{
    "docs": [
        {
            "location": "/", 
            "text": "Hecke\n\n\n\n\nAbout\n\n\nHecke is a software package for algebraic number theory maintained by Claus Fieker and Tommy Hofmann. It is written in \njulia\n and is based on the computer algebra package \nNemo\n.\n\n\n\n\nhttps://github.com/thofma/Hecke.jl\n (Source code)\n\n\nhttp://thofma.github.io/Hecke.jl/latest/\n (Online documentation)\n\n\n\n\nSo far, Hecke provides the following features:\n\n\n\n\nOrders (including element and ideal arithmetic) in number fields\n\n\nComputation of maximal orders\n\n\nVerified residue computations of Dedekind zeta functions\n\n\nClass and Unit group computation, S-units, PID testing\n\n\nLattice enumeration\n\n\nSparse linear algebra\n\n\nNormal forms for modules over maximal orders\n\n\nExtensions of number fields, non-simple extensions of number fields\n\n\nOrders and ideals in extensions of fields\n\n\nAbelian groups\n\n\nRay class groups, quotients of ray class groups\n\n\nInvariant subgroups\n\n\nDefining equations for class fields\n\n\n\n\n\n\nInstallation\n\n\nTo use Hecke, a julia version of 0.6 or higher is necessary (the latest stable julia version will do). Please see \nhttp://julialang.org/downloads\n for instructions on how to obtain julia for your system. Once a suitable julia version is installed, use the following steps at the julia prompt to install Hecke:\n\n\njulia\n \nPkg\n.\nadd\n(\nHecke\n)\n\n\n\n\n\n\n\n\nQuick start\n\n\nHere is a quick example of using Hecke:\n\n\njulia\n \nusing\n \nHecke\n\n\n...\n\n\n\nWelcome\n \nto\n \n\n  \n_\n    \n_\n           \n_\n        \n \n|\n \n|\n  \n|\n \n|\n         \n|\n \n|\n       \n \n|\n \n|\n__\n|\n \n|\n \n___\n  \n___\n|\n \n|\n \n_____\n \n \n|\n  \n__\n  \n|/\n \n_\n \n\\/\n \n__\n|\n \n|/\n \n/\n \n_\n \n\\\n\n \n|\n \n|\n  \n|\n \n|\n  \n__\n/\n \n(\n__\n|\n   \n  \n__\n/\n\n \n|\n_\n|\n  \n|\n_\n|\\\n___\n|\\\n___\n|\n_\n|\\\n_\n\\\n___\n|\n\n\n\nVersion\n \n0.4\n.\n0\n \n...\n \n \n...\n \nwhich\n \ncomes\n \nwith\n \nabsolutely\n \nno\n \nwarranty\n \nwhatsoever\n\n\n(\nc\n)\n \n2015\n,\n \n2016\n,\n \n2017\n \nby\n \nClaus\n \nFieker\n \nand\n \nTommy\n \nHofmann\n\n\n\njulia\n \nQx\n,\n \nx\n \n=\n \nPolynomialRing\n(\nFlintQQ\n,\n \nx\n);\n\n\njulia\n \nf\n \n=\n \nx\n^\n3\n \n+\n \n2\n;\n\n\njulia\n \nK\n,\n \na\n \n=\n \nNumberField\n(\nf\n,\n \na\n);\n\n\njulia\n \nO\n \n=\n \nmaximal_order\n(\nK\n);\n\n\njulia\n \nO\n\n\nMaximal\n \norder\n \nof\n \nNumber\n \nfield\n \nover\n \nRational\n \nField\n \nwith\n \ndefining\n \npolynomial\n \nx\n^\n3\n \n+\n \n2\n \n\nwith\n \nbasis\n \n[\n1\n,\na\n,\na\n^\n2\n]\n\n\n\n\n\n\n\n\nManual table of contents\n\n\n\n\nOrders of number fields\n\n\nIntroduction\n\n\nCreation and basic properties\n\n\nElements\n\n\nIdeals\n\n\nFractional ideals\n\n\n\n\n\n\n\n\nThe documentation of the single functions can also be accessed at the julia prompt. Here is an example:\n\n\nhelp?\n signature\nsearch: signature\n\n  ----------------------------------------------------------------------------\n\n  signature(O::NfMaximalOrder) -\n Tuple{Int, Int}\n\n  |  Returns the signature of the ambient number field of \\mathcal O.\n\n\n\n\n\n\n\nContents\n\n\n- [Table of contents](toc.md#Table-of-contents-1)", 
            "title": "Home"
        }, 
        {
            "location": "/#hecke", 
            "text": "", 
            "title": "Hecke"
        }, 
        {
            "location": "/#about", 
            "text": "Hecke is a software package for algebraic number theory maintained by Claus Fieker and Tommy Hofmann. It is written in  julia  and is based on the computer algebra package  Nemo .   https://github.com/thofma/Hecke.jl  (Source code)  http://thofma.github.io/Hecke.jl/latest/  (Online documentation)   So far, Hecke provides the following features:   Orders (including element and ideal arithmetic) in number fields  Computation of maximal orders  Verified residue computations of Dedekind zeta functions  Class and Unit group computation, S-units, PID testing  Lattice enumeration  Sparse linear algebra  Normal forms for modules over maximal orders  Extensions of number fields, non-simple extensions of number fields  Orders and ideals in extensions of fields  Abelian groups  Ray class groups, quotients of ray class groups  Invariant subgroups  Defining equations for class fields", 
            "title": "About"
        }, 
        {
            "location": "/#installation", 
            "text": "To use Hecke, a julia version of 0.6 or higher is necessary (the latest stable julia version will do). Please see  http://julialang.org/downloads  for instructions on how to obtain julia for your system. Once a suitable julia version is installed, use the following steps at the julia prompt to install Hecke:  julia   Pkg . add ( Hecke )", 
            "title": "Installation"
        }, 
        {
            "location": "/#quick-start", 
            "text": "Here is a quick example of using Hecke:  julia   using   Hecke  ...  Welcome   to  \n\n   _      _             _         \n  |   |    |   |           |   |        \n  |   | __ |   |   ___    ___ |   |   _____  \n  |    __    |/   _   \\/   __ |   |/   /   _   \\ \n  |   |    |   |    __ /   ( __ |        __ / \n  | _ |    | _ |\\ ___ |\\ ___ | _ |\\ _ \\ ___ |  Version   0.4 . 0   ...  \n  ...   which   comes   with   absolutely   no   warranty   whatsoever  ( c )   2015 ,   2016 ,   2017   by   Claus   Fieker   and   Tommy   Hofmann  julia   Qx ,   x   =   PolynomialRing ( FlintQQ ,   x );  julia   f   =   x ^ 3   +   2 ;  julia   K ,   a   =   NumberField ( f ,   a );  julia   O   =   maximal_order ( K );  julia   O  Maximal   order   of   Number   field   over   Rational   Field   with   defining   polynomial   x ^ 3   +   2   with   basis   [ 1 , a , a ^ 2 ]", 
            "title": "Quick start"
        }, 
        {
            "location": "/#manual-table-of-contents", 
            "text": "Orders of number fields  Introduction  Creation and basic properties  Elements  Ideals  Fractional ideals     The documentation of the single functions can also be accessed at the julia prompt. Here is an example:  help?  signature\nsearch: signature\n\n  ----------------------------------------------------------------------------\n\n  signature(O::NfMaximalOrder) -  Tuple{Int, Int}\n\n  |  Returns the signature of the ambient number field of \\mathcal O.", 
            "title": "Manual table of contents"
        }, 
        {
            "location": "/#contents", 
            "text": "- [Table of contents](toc.md#Table-of-contents-1)", 
            "title": "Contents"
        }, 
        {
            "location": "/toc/", 
            "text": "Table of contents\n\n\nbla\n\n\n\n\nOrders of number fields\n\n\nIntroduction\n\n\n\n\n\n\nIntroduction\n\n\nClass Field Theory\n\n\nIntroduction\n\n\nRay Class Groups\n\n\nRay Class Fields\n\n\nConversions\n\n\nInvariants\n\n\nOperations", 
            "title": "Table of contents"
        }, 
        {
            "location": "/toc/#table-of-contents", 
            "text": "bla   Orders of number fields  Introduction    Introduction  Class Field Theory  Introduction  Ray Class Groups  Ray Class Fields  Conversions  Invariants  Operations", 
            "title": "Table of contents"
        }, 
        {
            "location": "/orders/introduction/", 
            "text": "Orders of number fields\n\n\n\n\nIntroduction\n\n\nThis chapter deals with absolute number fields and orders there of. \n\n\n\n\nDefinitions and vocabulary\n\n\nWe begin by collecting the necessary definitions and vocabulary.  This is in particular important for everything related to embeddings of number fields into archimedean fields, since they are at least two (slighlty) different normalizations. \n\n\n\n\nNumber fields\n\n\nBy an absolute number field we mean finite extensions of \n\\mathbf Q\n, which is of type \nAnticNumberField\n and whose elements are of type \nnf_elem\n. Such an absolute number field \nK\n is always given in the form \nK = \\mathbf Q(\\alpha) = \\mathbf Q[X]/(f)\n, where \nf \\in \\mathbf Q[X]\n is an irreducible polynomial.  We call \n(1,\\alpha,\\alpha^2,\\dotsc,\\alpha^{d-1})\n, where \nd\n is the degree \n[K : \\mathbf Q]\n the \npower basis\n of \nK\n. If \n\\beta\n is any element of \nK\n, then the \nrepresentation matrix\n of \n\\beta\n is the matrix representing \nK \\to K, \\gamma \\mapsto \\beta \\gamma\n with respect to the power basis, that is,\n\n\n\n\n \\beta \\cdot (1,\\alpha,\\dotsc,\\alpha^{d-1}) = M_\\alpha (1, \\alpha, \\dotsc, \\alpha^{d-1}). \n\n\n\n\nLet \n(r,s)\n be the signature of \nK\n, that is, \nK\n has \nr\n real embeddings \n\\sigma_i \\colon K \\to \\mathbf{R}\n, \n1 \\leq i \\leq r\n, and \n2s\n complex embeddings \n\\sigma_i \\colon K \\to \\mathbf{C}\n, \n1 \\leq i \\leq 2s\n. In Hecke the complex embeddings are always ordered such that \n\\sigma_i = \\overline{\\sigma_{i+s}}\n for \nr + 1 \\leq i \\leq r + s\n. The \n\\mathbf{Q}\n-linear function \n K \\longrightarrow \\mathbf R^{d}, \\ \\alpha \\longmapsto (\\sigma_1(\\alpha),\\dotsc,\\sigma_r(\\alpha),\\sqrt{2}\\operatorname{Re}(\\sigma_{r+1}(\\alpha)),\\sqrt{2}\\operatorname{Im}(\\sigma_{r+1}(\\alpha)),\\dotsc,\\sqrt{2}\\operatorname{Re}(\\sigma_{r+s}(\\alpha)),\\sqrt{2}\\operatorname{Im}(\\sigma_{r+s}(\\alpha)) \n is called the \nMinkowski map\n (or \nMinkowski embedding\n).\n\n\n\n\nOrders\n\n\nIf \nK = \\mathbf Q(\\alpha)\n is an absolute number field, then an \norder\n \n\\mathcal O\n of \nK\n is a subring of the ring of integers \n\\mathcal O_K\n, which is free of rank \n[ K : \\mathbf Q]\n as a \n\\mathbf Z\n-module. The natural order \n\\mathbf Z[\\alpha]\n is called the \nequation order\n of \nK\n. In Hecke orders of absolute number fields are constructed (implicitely) by specifying a \n\\mathbf Z\n-basis, which is refered to as the \nbasis\n of \n\\mathcal O\n. If \n(\\omega_1,\\dotsc,\\omega_d)\n is the basis of \n\\mathcal O\n, then the matrix \nB \\in \\operatorname{Mat}_{d \\times d}(\\mathbf Q)\n with\n\n\n\n\n \\begin{pmatrix} \\omega_1 \\\\ \\vdots \\\\ \\omega_d \\end{pmatrix} = B \\begin{pmatrix} 1 \\\\ \\vdots \\\\ \\alpha^{d - 1} \\end{pmatrix} \n\n\n\n\nis called the \nbasis matrix\n of \n\\mathcal O\n. We call \n\\det(B)\n the \ngeneralized index\n of \n\\mathcal O\n.  In case \n\\mathbf Z[\\alpha] \\subseteq \\mathcal O\n, the determinant \n\\det(B)^{-1}\n is in fact equal to \n[ \\mathcal O : \\mathbf Z[\\alpha]]\n and is called the \nindex\n of \n\\mathcal O\n. The matrix \n \\begin{pmatrix}  \\sigma_1(\\omega_1) & \\dotsc & \\sigma_r(\\omega_1) & \\sqrt{2}\\operatorname{Re}(\\sigma_{r+1}(\\omega_1)) & \\sqrt{2}\\operatorname{Im}(\\sigma_{r+1}(\\omega_1)) & \\dotsc & \\sqrt{2}\\operatorname{Im}(\\sigma_{r+s}(\\omega_1)) \\\\\n\\sigma_1(\\omega_2) & \\dotsc & \\sigma_r(\\omega_2) & \\sqrt{2}\\operatorname{Re}(\\sigma_{r+1}(\\omega_2)) & \\sqrt{2}\\operatorname{Im}(\\sigma_{r+1}(\\omega_2)) & \\dotsc  & \\sqrt{2}\\operatorname{Im}(\\sigma_{r+s}(\\omega_2)) \\\\\n\\vdots & \\dotsc & \\vdots & \\vdots & \\dotsc & \\vdots & \\vdots\\\\\n\\sigma_1(\\omega_d) & \\dotsc & \\sigma_r(\\omega_d) & \\sqrt{2}\\operatorname{Re}(\\sigma_{r+1}(\\omega_d)) & \\sqrt{2}\\operatorname{Im}(\\sigma_{r+2}(\\omega_d)) & \\dotsc & \\sqrt{2}\\operatorname{Im}(\\sigma_{r+s}(\\omega_d)) \\end{pmatrix} \\in \\operatorname{Mat}_{d\\times d}(\\mathbf R). \n is called the \nMinkowski matrix\n of \n\\mathcal O\n.\n\n\n\n\nIdeals\n\n\n\n\nFractional ideals\n\n\n\n\nTypes", 
            "title": "Introduction"
        }, 
        {
            "location": "/orders/introduction/#orders-of-number-fields", 
            "text": "", 
            "title": "Orders of number fields"
        }, 
        {
            "location": "/orders/introduction/#introduction", 
            "text": "This chapter deals with absolute number fields and orders there of.", 
            "title": "Introduction"
        }, 
        {
            "location": "/orders/introduction/#definitions-and-vocabulary", 
            "text": "We begin by collecting the necessary definitions and vocabulary.  This is in particular important for everything related to embeddings of number fields into archimedean fields, since they are at least two (slighlty) different normalizations.", 
            "title": "Definitions and vocabulary"
        }, 
        {
            "location": "/orders/introduction/#number-fields", 
            "text": "By an absolute number field we mean finite extensions of  \\mathbf Q , which is of type  AnticNumberField  and whose elements are of type  nf_elem . Such an absolute number field  K  is always given in the form  K = \\mathbf Q(\\alpha) = \\mathbf Q[X]/(f) , where  f \\in \\mathbf Q[X]  is an irreducible polynomial.  We call  (1,\\alpha,\\alpha^2,\\dotsc,\\alpha^{d-1}) , where  d  is the degree  [K : \\mathbf Q]  the  power basis  of  K . If  \\beta  is any element of  K , then the  representation matrix  of  \\beta  is the matrix representing  K \\to K, \\gamma \\mapsto \\beta \\gamma  with respect to the power basis, that is,    \\beta \\cdot (1,\\alpha,\\dotsc,\\alpha^{d-1}) = M_\\alpha (1, \\alpha, \\dotsc, \\alpha^{d-1}).    Let  (r,s)  be the signature of  K , that is,  K  has  r  real embeddings  \\sigma_i \\colon K \\to \\mathbf{R} ,  1 \\leq i \\leq r , and  2s  complex embeddings  \\sigma_i \\colon K \\to \\mathbf{C} ,  1 \\leq i \\leq 2s . In Hecke the complex embeddings are always ordered such that  \\sigma_i = \\overline{\\sigma_{i+s}}  for  r + 1 \\leq i \\leq r + s . The  \\mathbf{Q} -linear function   K \\longrightarrow \\mathbf R^{d}, \\ \\alpha \\longmapsto (\\sigma_1(\\alpha),\\dotsc,\\sigma_r(\\alpha),\\sqrt{2}\\operatorname{Re}(\\sigma_{r+1}(\\alpha)),\\sqrt{2}\\operatorname{Im}(\\sigma_{r+1}(\\alpha)),\\dotsc,\\sqrt{2}\\operatorname{Re}(\\sigma_{r+s}(\\alpha)),\\sqrt{2}\\operatorname{Im}(\\sigma_{r+s}(\\alpha))   is called the  Minkowski map  (or  Minkowski embedding ).", 
            "title": "Number fields"
        }, 
        {
            "location": "/orders/introduction/#orders", 
            "text": "If  K = \\mathbf Q(\\alpha)  is an absolute number field, then an  order   \\mathcal O  of  K  is a subring of the ring of integers  \\mathcal O_K , which is free of rank  [ K : \\mathbf Q]  as a  \\mathbf Z -module. The natural order  \\mathbf Z[\\alpha]  is called the  equation order  of  K . In Hecke orders of absolute number fields are constructed (implicitely) by specifying a  \\mathbf Z -basis, which is refered to as the  basis  of  \\mathcal O . If  (\\omega_1,\\dotsc,\\omega_d)  is the basis of  \\mathcal O , then the matrix  B \\in \\operatorname{Mat}_{d \\times d}(\\mathbf Q)  with    \\begin{pmatrix} \\omega_1 \\\\ \\vdots \\\\ \\omega_d \\end{pmatrix} = B \\begin{pmatrix} 1 \\\\ \\vdots \\\\ \\alpha^{d - 1} \\end{pmatrix}    is called the  basis matrix  of  \\mathcal O . We call  \\det(B)  the  generalized index  of  \\mathcal O .  In case  \\mathbf Z[\\alpha] \\subseteq \\mathcal O , the determinant  \\det(B)^{-1}  is in fact equal to  [ \\mathcal O : \\mathbf Z[\\alpha]]  and is called the  index  of  \\mathcal O . The matrix   \\begin{pmatrix}  \\sigma_1(\\omega_1) & \\dotsc & \\sigma_r(\\omega_1) & \\sqrt{2}\\operatorname{Re}(\\sigma_{r+1}(\\omega_1)) & \\sqrt{2}\\operatorname{Im}(\\sigma_{r+1}(\\omega_1)) & \\dotsc & \\sqrt{2}\\operatorname{Im}(\\sigma_{r+s}(\\omega_1)) \\\\\n\\sigma_1(\\omega_2) & \\dotsc & \\sigma_r(\\omega_2) & \\sqrt{2}\\operatorname{Re}(\\sigma_{r+1}(\\omega_2)) & \\sqrt{2}\\operatorname{Im}(\\sigma_{r+1}(\\omega_2)) & \\dotsc  & \\sqrt{2}\\operatorname{Im}(\\sigma_{r+s}(\\omega_2)) \\\\\n\\vdots & \\dotsc & \\vdots & \\vdots & \\dotsc & \\vdots & \\vdots\\\\\n\\sigma_1(\\omega_d) & \\dotsc & \\sigma_r(\\omega_d) & \\sqrt{2}\\operatorname{Re}(\\sigma_{r+1}(\\omega_d)) & \\sqrt{2}\\operatorname{Im}(\\sigma_{r+2}(\\omega_d)) & \\dotsc & \\sqrt{2}\\operatorname{Im}(\\sigma_{r+s}(\\omega_d)) \\end{pmatrix} \\in \\operatorname{Mat}_{d\\times d}(\\mathbf R).   is called the  Minkowski matrix  of  \\mathcal O .", 
            "title": "Orders"
        }, 
        {
            "location": "/orders/introduction/#ideals", 
            "text": "", 
            "title": "Ideals"
        }, 
        {
            "location": "/orders/introduction/#fractional-ideals", 
            "text": "", 
            "title": "Fractional ideals"
        }, 
        {
            "location": "/orders/introduction/#types", 
            "text": "", 
            "title": "Types"
        }, 
        {
            "location": "/orders/basics/", 
            "text": "Creation and basic properties\n\n\nOrder(::AnticNumberField, ::Array{nf_elem, 1})\nOrder(::AnticNumberField, ::FakeFmpqMat)\nOrder(::NfOrdFracIdl)\nEquationOrder(::AnticNumberField)\nMaximalOrder(::AnticNumberField)\nMaximalOrder(::NfOrd)\nmaximal_order(::AnticNumberField)\nlll(::NfOrd)\n\n\n\n\n\nBy Chistov's fundamental theorem, the computation of the maximal order is basically as hard as the factorisation of the discriminant. In order to help the computer, Hecke also provides the following signatures:\n\n\n\n\nmaximal_order(K::AnticNumberField, primes::Array{fmpz, 1}) -\n NfOrd\nmaximal_order(K::AnticNumberField, primes::Array{Integer, 1}) -\n NfOrd\n\n\n\n\n\nAssuming that \nprimes\n contains all the prime numbers at which the equation order \n\\mathbf{Z}[\\alpha]\n of \nK = \\mathbf{Q}(\\alpha)\n is not maximal (e.g. \nprimes\n may contain all prime divisors of the discriminant of \n\\mathbf Z[\\alpha]\n), this function returns the maximal order of \nK\n.\n\n\n\n\nring_of_integers(K::AnticNumberField, primes::Array{fmpz, 1}) -\n NfOrd\nring_of_integers(K::AnticNumberField, primes::Array{Integer, 1}) -\n NfOrd\n\n\n\n\n\nAssuming that \nprimes\n contains all the prime numbers at which the equation order \n\\mathbf{Z}[\\alpha]\n of \nK = \\mathbf{Q}(\\alpha)\n is not maximal, this function returns the maximal order of \nK\n.\n\n\nIt is also possible the execute the steps individually:\n\n\n\n\npradical(O::NfOrd, p::fmpz) -\n NfAbsOrdIdl\n\n\n\n\n\n\n\nGiven a prime number \np\n, this function returns the \np\n-radical \n\\sqrt{p\\mathcal O}\n of \n\\mathcal O\n, which is just \n\\{ x \\in \\mathcal O \\mid \\exists k \\in \\mathbf Z_{\\geq 0} \\colon x^k \\in p\\mathcal O \\}\n. It is not checked that \np\n is prime.\n\n\n\n\n\n\nring_of_multipliers(I::NfAbsOrdIdl) -\n NfOrd\n\n\n\n\n\n\n\nComputes the order \n(I : I)\n, which is the set of all \nx \\in K\n with \nxI \\subseteq I\n.\n\n\n\n\n\n\nring_of_multipliers(a::NfRelOrdIdl) -\n NfRelOrd\n\n\n\n\n\n\n\nComputes the order \n(a : a)\n, which is the set of all \nx \\in K\n with \nxa \\subseteq a\n, where \nK\n is the ambient number field of \na\n.\n\n\n\n\n\n\nExample\n\n\njulia\n \nQx\n,\n \nx\n \n=\n \nPolynomialRing\n(\nFlintQQ\n,\n \nx\n);\n\n\n\njulia\n \nK\n,\n \na\n \n=\n \nNumberField\n(\nx\n^\n2\n \n-\n \n2\n,\n \na\n);\n\n\n\njulia\n \nO\n \n=\n \nEquationOrder\n(\nK\n)\n\n\nOrder\n \nof\n \nNumber\n \nfield\n \nover\n \nRational\n \nField\n \nwith\n \ndefining\n \npolynomial\n \nx\n^\n2\n-\n2\n\n\nwith\n \nZ\n-\nbasis\n \nHecke\n.\nNfAbsOrdElem\n{\nNemo\n.\nAnticNumberField\n,\nNemo\n.\nnf_elem\n}[\n1\n,\n \na\n]\n\n\n\n\n\n\nparent(::NfOrd)\nisequation_order(::NfOrd)\nsignature(::NfOrd)\nnf(::NfOrd)\ndegree(::NfOrd)\nbasis(::NfOrd)\nbasis(::NfOrd, ::AnticNumberField)\nbasis_mat(::NfOrd)\nbasis_mat_inv(::NfOrd)\ndiscriminant(::NfOrd)\ngen_index(::NfOrd)\nindex(::NfOrd)\nisindex_divisor(::NfOrd, ::fmpz)\nminkowski_mat(::NfOrd, ::Int)\nin(::nf_elem, ::NfOrd)\ndenominator(::nf_elem, ::NfOrd)\nnorm_change_const(::NfOrd)\ntrace_matrix(::NfOrd)\n+(::NfOrd, ::NfOrd)\npoverorder(::NfOrd, ::fmpz)\npmaximal_overorder(::NfOrd, ::fmpz)\nparent(::NfOrd)\ndeepcopy(::NfOrd)\n\n\n\n\n\n\n\nElements\n\n\n\n\nCreation\n\n\n\n\nBasic properties\n\n\n\n\nparent(a::NfAbsOrdElem) -\n NfOrd\n\n\n\n\n\nReturns the order of which \na\n is an element.\n\n\nparent(g::perm)\n\n\n\n\n\n\n\nReturn the parent of the permutation \ng\n.\n\n\n\n\njulia\n G = PermutationGroup(5); g = perm([3,4,5,2,1])\n(1,3,5)(2,4)\n\njulia\n parent(g) == G\ntrue\n\n\n\n\n\nparent(a::AbstractAlgebra.MatElem)\n\n\n\n\n\n\n\nReturn the parent object of the given matrix.\n\n\n\n\n\n\nelem_in_nf(a::NfAbsOrdElem) -\n nf_elem\n\n\n\n\n\n\n\nReturns the element \na\n considered as an element of the ambient number field.\n\n\n\n\n\n\nelem_in_basis(a::NfAbsOrdElem) -\n Array{fmpz, 1}\n\n\n\n\n\n\n\nReturns the coefficient vector of \na\n.\n\n\n\n\n\n\n  elem_in_basis(a::NfRelOrdElem{T}) -\n Vector{T}\n\n\n\n\n\n\n\nReturns the coefficient vector of \na\n.\n\n\n\n\n\n\ndiscriminant(B::Array{NfAbsOrdElem, 1}) -\n fmpz\n\n\n\n\n\n\n\nReturns the discriminant of the family \nB\n.\n\n\n\n\n\n\n==(x::NfAbsOrdElem, y::NfAbsOrdElem) -\n Bool\n\n\n\n\n\n\n\nReturns whether \nx\n and \ny\n are equal.\n\n\n\n\n\n\nzero(O::NfOrd) -\n NfAbsOrdElem\n\n\n\n\n\n\n\nReturns the zero element of \n\\mathcal O\n.\n\n\n\n\n\n\none(O::NfOrd) -\n NfAbsOrdElem\n\n\n\n\n\n\n\nReturns the one element of \n\\mathcal O\n.\n\n\n\n\n\n\niszero(a::NfOrd) -\n Bool\n\n\n\n\n\n\n\nTests if \na\n is zero.\n\n\n\n\n\n\nisone(a::NfOrd) -\n Bool\n\n\n\n\n\n\n\nTests if \na\n is one.\n\n\n\n\n\n\nArithmetic\n\n\n\n\n-(x::NfAbsOrdElem) -\n NfAbsOrdElem\n\n\n\n\n\n\n\nReturns the additive inverse of \nx\n.\n\n\n\n\n-{T \n: RingElement}(a::AbstractAlgebra.ResElem{T}, b::AbstractAlgebra.ResElem{T})\n\n\n\n\n\n\n\nReturn \na - b\n.\n\n\n\n\n-{T \n: RingElem}(a::AbstractAlgebra.ResElem{T}, b::T)\n\n\n\n\n\n\n\nReturn \na - b\n.\n\n\n\n\n-{T \n: RingElem}(a::T, b::AbstractAlgebra.ResElem{T})\n\n\n\n\n\n\n\nReturn \na - b\n.\n\n\n\n\n-{T \n: RingElement}(a::AbstractAlgebra.ResFieldElem{T}, b::AbstractAlgebra.ResFieldElem{T})\n\n\n\n\n\n\n\nReturn \na - b\n.\n\n\n\n\n-{T \n: RingElem}(a::AbstractAlgebra.ResFieldElem{T}, b::T)\n\n\n\n\n\n\n\nReturn \na - b\n.\n\n\n\n\n-{T \n: RingElem}(a::T, b::AbstractAlgebra.ResFieldElem{T})\n\n\n\n\n\n\n\nReturn \na - b\n.\n\n\n\n\n-{T \n: RingElement}(a::AbstractAlgebra.PolyElem{T}, b::AbstractAlgebra.PolyElem{T})\n\n\n\n\n\n\n\nReturn \na - b\n.\n\n\n\n\n-{T \n: RingElement}(a::AbstractAlgebra.RelSeriesElem{T}, b::AbstractAlgebra.RelSeriesElem{T})\n\n\n\n\n\n\n\nReturn \na - b\n.\n\n\n\n\n-{T \n: RingElement}(a::AbstractAlgebra.AbsSeriesElem{T}, b::AbstractAlgebra.AbsSeriesElem{T})\n\n\n\n\n\n\n\nReturn \na - b\n.\n\n\n\n\n-{T \n: RingElement}(a::LaurentSeriesElem{T}, b::LaurentSeriesElem{T})\n\n\n\n\n\n\n\nReturn \na - b\n.\n\n\n\n\n-{T \n: RingElement}(a::AbstractAlgebra.MatElem{T}, b::AbstractAlgebra.MatElem{T})\n\n\n\n\n\n\n\nReturn \na - b\n.\n\n\n\n\n-{T \n: RingElem}(x::T, y::AbstractAlgebra.MatElem{T})\n\n\n\n\n\n\n\nReturn \nS(x) - y\n where \nS\n is the parent of \ny\n.\n\n\n\n\n-{T \n: RingElem}(x::AbstractAlgebra.MatElem{T}, y::T)\n\n\n\n\n\n\n\nReturn \nx - S(y)\n, where \nS\n is the parent of \na\n.\n\n\n\n\n-{T \n: RingElem}(a::AbstractAlgebra.FracElem{T}, b::AbstractAlgebra.FracElem{T})\n\n\n\n\n\n\n\nReturn \na - b\n.\n\n\n\n\n-{T \n: RingElem}(a::AbstractAlgebra.FracElem{T}, b::T)\n\n\n\n\n\n\n\nReturn \na - b\n.\n\n\n\n\n-{T \n: RingElem}(a::T, b::AbstractAlgebra.FracElem{T})\n\n\n\n\n\n\n\nReturn \na - b\n.\n\n\n\n\n\n\n+(x::NfAbsOrdElem, y::NfAbsOrdElem) -\n NfAbsOrdElem\n\n\n\n\n\n\n\nReturns \nx + y\n.\n\n\n\n\n\n\n-(x::NfAbsOrdElem, y::NfAbsOrdElem) -\n NfAbsOrdElem\n\n\n\n\n\n\n\nReturns \nx - y\n.\n\n\n\n\n\n\n*(x::NfAbsOrdElem, y::NfAbsOrdElem) -\n NfAbsOrdElem\n\n\n\n\n\n\n\nReturns \nx \\cdot y\n.\n\n\n\n\n\n\n^(x::NfAbsOrdElem, y::Union{fmpz, Int})\n\n\n\n\n\n\n\nReturns \nx^y\n.\n\n\n\n\n\n\nmod(a::NfAbsOrdElem, m::Union{fmpz, Int}) -\n NfAbsOrdElem\n\n\n\n\n\n\n\nReduces the coefficient vector of \na\n modulo \nm\n and returns the corresponding element. The coefficient vector of the result will have entries \nx\n with \n0 \\leq x \\leq m\n.\n\n\n\n\n\n\npowermod(a::NfAbsOrdElem, i::fmpz, m::Integer) -\n NfAbsOrdElem\n\n\n\n\n\n\n\nReturns the element \na^i\n modulo \nm\n.\n\n\n\n\n\n\nMiscallenous\n\n\n\n\nrepresentation_matrix(a::NfAbsOrdElem) -\n fmpz_mat\n\n\n\n\n\n\n\nReturns the representation matrix of the element \na\n.\n\n\n\n\n\n\nrepresentation_matrix(a::NfAbsOrdElem, K::AnticNumberField) -\n FakeFmpqMat\n\n\n\n\n\n\n\nReturns the representation matrix of the element \na\n considered as an element of the ambient number field \nK\n. It is assumed that \nK\n is the ambient number field of the order of \na\n.\n\n\n\n\n\n\nrepresentation_matrix(a::NfAbsOrdElem, K::AnticNumberField) -\n FakeFmpqMat\n\n\n\n\n\n\n\nReturns the representation matrix of the element \na\n considered as an element of the ambient number field \nK\n. It is assumed that \nK\n is the ambient number field of the order of \na\n.\n\n\n\n\n\n\ntrace(a::NfAbsOrdElem) -\n fmpz\n\n\n\n\n\n\n\nReturns the trace of \na\n.\n\n\n\n\n\n\nnorm(a::NfAbsOrdElem) -\n fmpz\n\n\n\n\n\n\n\nReturns the norm of \na\n.\n\n\n\n\n\n\nnorm(A::NfAbsOrdIdl) -\n fmpz\n\n\n\n\n\n\n\nReturns the norm of \nA\n, that is, the cardinality of \n\\mathcal O/A\n, where \n\\mathcal O\n is the order of \nA\n.\n\n\n\n\n\n\nnorm(a::NfRelOrdIdl) -\n NfOrdIdl\n\n\n\n\n\n\n\nReturns the norm of \na\n.\n\n\n\n\n\n\nnorm(a::NfRelOrdFracIdl{T, S}) -\n S\n\n\n\n\n\n\n\nReturns the norm of \na\n\n\n\n\n\n\n\n\nrand(O::NfOrd, n::Union{Integer, fmpz}) -\n NfAbsOrdElem\n\n\n\n\n\n\n\nComputes a coefficient vector with entries uniformly distributed in \n\\{-n,\\dotsc,-1,0,1,\\dotsc,n\\}\n and returns the corresponding element of the order \n\\mathcal O\n.\n\n\n\n\n\n\nminkowski_map(a::NfAbsOrdElem, abs_tol::Int) -\n Array{arb, 1}\n\n\n\n\n\n\n\nReturns the image of \na\n under the Minkowski embedding. Every entry of the array returned is of type \narb\n with radius less then \n2^-abs_tol\n.\n\n\n\n\n\n\nconjugates_arb(x::NfAbsOrdElem, abs_tol::Int) -\n Array{acb, 1}\n\n\n\n\n\n\n\nCompute the the conjugates of \nx\n as elements of type \nacb\n. Recall that we order the complex conjugates \n\\sigma_{r+1}(x),...,\\sigma_{r+2s}(x)\n such that \n\\sigma_{i}(x) = \\overline{\\sigma_{i + s}(x)}\n for \nr + 2 \\leq i \\leq r + s\n.\n\n\nEvery entry \ny\n of the array returned satisfies \nradius(real(y)) \n 2^-abs_tol\n, \nradius(imag(y)) \n 2^-abs_tol\n respectively.\n\n\n\n\n\n\nconjugates_arb_log(x::NfAbsOrdElem, abs_tol::Int) -\n Array{arb, 1}\n\n\n\n\n\n\n\nReturns the elements \n(\\log(\\lvert \\sigma_1(x) \\rvert),\\dotsc,\\log(\\lvert\\sigma_r(x) \\rvert), \\dotsc,2\\log(\\lvert \\sigma_{r+1}(x) \\rvert),\\dotsc, 2\\log(\\lvert \\sigma_{r+s}(x)\\rvert))\n as elements of type \narb\n radius less then \n2^-abs_tol\n.\n\n\n\n\n\n\nt2(x::NfAbsOrdElem, abs_tol::Int = 32) -\n arb\n\n\n\n\n\n\n\nReturn the \nT_2\n-norm of \nx\n. The radius of the result will be less than \n2^-abs_tol\n.\n\n\n\n\nminpoly{T \n: RingElement}(S::Ring, M::AbstractAlgebra.MatElem{T}, charpoly_only = false)\n\n\n\n\n\n\n\nReturns the minimal polynomial \np\n of the matrix \nM\n. The polynomial ring \nR\n of the resulting polynomial must be supplied and the matrix must be square.\n\n\n\n\ncharpoly{T \n: RingElement}(V::Ring, Y::AbstractAlgebra.MatElem{T})\n\n\n\n\n\n\n\nReturns the characteristic polynomial \np\n of the matrix \nM\n. The polynomial ring \nR\n of the resulting polynomial must be supplied and the matrix is assumed to be square.\n\n\n\n\n\n\nIdeals\n\n\n\n\nCreation\n\n\nideal(::NfOrd, ::Int)\nideal(::NfOrd, ::Integer)\nideal(::NfOrd, ::fmpz)\nideal(::NfOrd, ::fmpz_mat)\nideal(::NfOrd, ::NfOrdElem)\nideal(::NfOrd, ::Integer, ::NfOrdElem)\nideal(::NfOrd, ::fmpz, ::NfOrdElem)\n*(::NfOrd, ::NfOrdElem)\nprime_decomposition(::NfOrd, ::Integer)\nprime_decomposition(::NfOrd, ::fmpz)\n\n\n\n\n\n\n\nArithmetic\n\n\n\n\n==(x::NfAbsOrdIdl, y::NfAbsOrdIdl)\n\n\n\n\n\n\n\nReturns whether \nx\n and \ny\n are equal.\n\n\n\n\n\n\n+(x::NfOrdIdl, y::NfOrdIdl)\n\n\n\n\n\n\n\nReturns \nx + y\n.\n\n\n\n\n*(x::NfOrdIdl, y::NfOrdIdl)\n\n\n\n\n\n\n\nReturns \nx \\cdot y\n.\n\n\n\n\nintersection(x::NfOrdIdl, y::NfOrdIdl) -\n NfOrdIdl\nlcm(x::NfOrdIdl, y::NfOrdIdl) -\n NfOrdIdl\n\n\n\n\n\n\n\nReturns \nx \\cap y\n.\n\n\n\n\n\n\nMiscaellenous\n\n\norder(::NfOrdIdl)\nbasis(::NfOrdIdl)\nbasis_mat(::NfOrdIdl)\nbasis_mat_inv(::NfOrdIdl)\nminimum(::NfOrdIdl)\nnorm(::NfOrdIdl)\nin(::NfOrdElem, ::NfOrdIdl)\nidempotents(::NfOrdIdl, ::NfOrdIdl)\nmod(::NfOrdElem, ::NfOrdIdl)\npradical(::NfOrd, p::fmpz)\nisprime(::NfOrdIdl)\nvaluation(::nf_elem, ::NfOrdIdl)\nvaluation(::NfOrdElem, ::NfOrdIdl)\nvaluation(::NfOrdIdl, ::NfOrdIdl)\nvaluation(::Integer, ::NfOrdIdl)\nvaluation(::fmpz, ::NfOrdIdl)\nvaluation(::NfOrdFracIdl, ::NfOrdIdl)\n\n\n\n\n\n\n\nFractional ideals\n\n\n\n\nCreation\n\n\nfrac_ideal(::NfOrd, ::fmpz_mat)\nfrac_ideal(::NfOrd, ::fmpz_mat, ::fmpz)\nfrac_ideal(::NfOrd, ::FakeFmpqMat)\nfrac_ideal(::NfOrd, ::NfOrdIdl)\nfrac_ideal(::NfOrd, ::NfOrdIdl, ::fmpz)\nfrac_ideal(::NfOrd, ::nf_elem)\nfrac_ideal(::NfOrd, ::NfOrdElem)\n\n\n\n\n\n\n\nArithmetic\n\n\n\n\n==(x::NfOrdFracIdl, y::NfOrdFracIdl) -\n Bool\n\n\n\n\n\n\n\nReturns whether \nx\n and \ny\n are equal.\n\n\n\n\n\n\ninv(A::NfOrdFracIdl) -\n NfOrdFracIdl\n\n\n\n\n\n\n\nReturns the fractional ideal \nB\n such that \nAB = \\mathcal O\n.\n\n\n\n\n\n\nintegral_split(A::NfOrdFracIdl) -\n NfOrdIdl, NfOrdIdl\n\n\n\n\n\n\n\nComputes the unique coprime integral ideals \nN\n and \nD\n s.th. \nA = ND^{-1}\n\n\n\n\n\n\n\n\nMiscaellenous\n\n\norder(::NfOrdFracIdl)\nbasis_mat(::NfOrdFracIdl)\nbasis_mat_inv(::NfOrdFracIdl)\nbasis(::NfOrdFracIdl)\nnorm(::NfOrdFracIdl)", 
            "title": "Basics"
        }, 
        {
            "location": "/orders/basics/#creation-and-basic-properties", 
            "text": "Order(::AnticNumberField, ::Array{nf_elem, 1})\nOrder(::AnticNumberField, ::FakeFmpqMat)\nOrder(::NfOrdFracIdl)\nEquationOrder(::AnticNumberField)\nMaximalOrder(::AnticNumberField)\nMaximalOrder(::NfOrd)\nmaximal_order(::AnticNumberField)\nlll(::NfOrd)  By Chistov's fundamental theorem, the computation of the maximal order is basically as hard as the factorisation of the discriminant. In order to help the computer, Hecke also provides the following signatures:   maximal_order(K::AnticNumberField, primes::Array{fmpz, 1}) -  NfOrd\nmaximal_order(K::AnticNumberField, primes::Array{Integer, 1}) -  NfOrd  Assuming that  primes  contains all the prime numbers at which the equation order  \\mathbf{Z}[\\alpha]  of  K = \\mathbf{Q}(\\alpha)  is not maximal (e.g.  primes  may contain all prime divisors of the discriminant of  \\mathbf Z[\\alpha] ), this function returns the maximal order of  K .   ring_of_integers(K::AnticNumberField, primes::Array{fmpz, 1}) -  NfOrd\nring_of_integers(K::AnticNumberField, primes::Array{Integer, 1}) -  NfOrd  Assuming that  primes  contains all the prime numbers at which the equation order  \\mathbf{Z}[\\alpha]  of  K = \\mathbf{Q}(\\alpha)  is not maximal, this function returns the maximal order of  K .  It is also possible the execute the steps individually:   pradical(O::NfOrd, p::fmpz) -  NfAbsOrdIdl   Given a prime number  p , this function returns the  p -radical  \\sqrt{p\\mathcal O}  of  \\mathcal O , which is just  \\{ x \\in \\mathcal O \\mid \\exists k \\in \\mathbf Z_{\\geq 0} \\colon x^k \\in p\\mathcal O \\} . It is not checked that  p  is prime.    ring_of_multipliers(I::NfAbsOrdIdl) -  NfOrd   Computes the order  (I : I) , which is the set of all  x \\in K  with  xI \\subseteq I .    ring_of_multipliers(a::NfRelOrdIdl) -  NfRelOrd   Computes the order  (a : a) , which is the set of all  x \\in K  with  xa \\subseteq a , where  K  is the ambient number field of  a .", 
            "title": "Creation and basic properties"
        }, 
        {
            "location": "/orders/basics/#example", 
            "text": "julia   Qx ,   x   =   PolynomialRing ( FlintQQ ,   x );  julia   K ,   a   =   NumberField ( x ^ 2   -   2 ,   a );  julia   O   =   EquationOrder ( K )  Order   of   Number   field   over   Rational   Field   with   defining   polynomial   x ^ 2 - 2  with   Z - basis   Hecke . NfAbsOrdElem { Nemo . AnticNumberField , Nemo . nf_elem }[ 1 ,   a ]   parent(::NfOrd)\nisequation_order(::NfOrd)\nsignature(::NfOrd)\nnf(::NfOrd)\ndegree(::NfOrd)\nbasis(::NfOrd)\nbasis(::NfOrd, ::AnticNumberField)\nbasis_mat(::NfOrd)\nbasis_mat_inv(::NfOrd)\ndiscriminant(::NfOrd)\ngen_index(::NfOrd)\nindex(::NfOrd)\nisindex_divisor(::NfOrd, ::fmpz)\nminkowski_mat(::NfOrd, ::Int)\nin(::nf_elem, ::NfOrd)\ndenominator(::nf_elem, ::NfOrd)\nnorm_change_const(::NfOrd)\ntrace_matrix(::NfOrd)\n+(::NfOrd, ::NfOrd)\npoverorder(::NfOrd, ::fmpz)\npmaximal_overorder(::NfOrd, ::fmpz)\nparent(::NfOrd)\ndeepcopy(::NfOrd)", 
            "title": "Example"
        }, 
        {
            "location": "/orders/basics/#elements", 
            "text": "", 
            "title": "Elements"
        }, 
        {
            "location": "/orders/basics/#creation", 
            "text": "", 
            "title": "Creation"
        }, 
        {
            "location": "/orders/basics/#basic-properties", 
            "text": "parent(a::NfAbsOrdElem) -  NfOrd  Returns the order of which  a  is an element.  parent(g::perm)   Return the parent of the permutation  g .   julia  G = PermutationGroup(5); g = perm([3,4,5,2,1])\n(1,3,5)(2,4)\n\njulia  parent(g) == G\ntrue  parent(a::AbstractAlgebra.MatElem)   Return the parent object of the given matrix.    elem_in_nf(a::NfAbsOrdElem) -  nf_elem   Returns the element  a  considered as an element of the ambient number field.    elem_in_basis(a::NfAbsOrdElem) -  Array{fmpz, 1}   Returns the coefficient vector of  a .      elem_in_basis(a::NfRelOrdElem{T}) -  Vector{T}   Returns the coefficient vector of  a .    discriminant(B::Array{NfAbsOrdElem, 1}) -  fmpz   Returns the discriminant of the family  B .    ==(x::NfAbsOrdElem, y::NfAbsOrdElem) -  Bool   Returns whether  x  and  y  are equal.    zero(O::NfOrd) -  NfAbsOrdElem   Returns the zero element of  \\mathcal O .    one(O::NfOrd) -  NfAbsOrdElem   Returns the one element of  \\mathcal O .    iszero(a::NfOrd) -  Bool   Tests if  a  is zero.    isone(a::NfOrd) -  Bool   Tests if  a  is one.", 
            "title": "Basic properties"
        }, 
        {
            "location": "/orders/basics/#arithmetic", 
            "text": "-(x::NfAbsOrdElem) -  NfAbsOrdElem   Returns the additive inverse of  x .   -{T  : RingElement}(a::AbstractAlgebra.ResElem{T}, b::AbstractAlgebra.ResElem{T})   Return  a - b .   -{T  : RingElem}(a::AbstractAlgebra.ResElem{T}, b::T)   Return  a - b .   -{T  : RingElem}(a::T, b::AbstractAlgebra.ResElem{T})   Return  a - b .   -{T  : RingElement}(a::AbstractAlgebra.ResFieldElem{T}, b::AbstractAlgebra.ResFieldElem{T})   Return  a - b .   -{T  : RingElem}(a::AbstractAlgebra.ResFieldElem{T}, b::T)   Return  a - b .   -{T  : RingElem}(a::T, b::AbstractAlgebra.ResFieldElem{T})   Return  a - b .   -{T  : RingElement}(a::AbstractAlgebra.PolyElem{T}, b::AbstractAlgebra.PolyElem{T})   Return  a - b .   -{T  : RingElement}(a::AbstractAlgebra.RelSeriesElem{T}, b::AbstractAlgebra.RelSeriesElem{T})   Return  a - b .   -{T  : RingElement}(a::AbstractAlgebra.AbsSeriesElem{T}, b::AbstractAlgebra.AbsSeriesElem{T})   Return  a - b .   -{T  : RingElement}(a::LaurentSeriesElem{T}, b::LaurentSeriesElem{T})   Return  a - b .   -{T  : RingElement}(a::AbstractAlgebra.MatElem{T}, b::AbstractAlgebra.MatElem{T})   Return  a - b .   -{T  : RingElem}(x::T, y::AbstractAlgebra.MatElem{T})   Return  S(x) - y  where  S  is the parent of  y .   -{T  : RingElem}(x::AbstractAlgebra.MatElem{T}, y::T)   Return  x - S(y) , where  S  is the parent of  a .   -{T  : RingElem}(a::AbstractAlgebra.FracElem{T}, b::AbstractAlgebra.FracElem{T})   Return  a - b .   -{T  : RingElem}(a::AbstractAlgebra.FracElem{T}, b::T)   Return  a - b .   -{T  : RingElem}(a::T, b::AbstractAlgebra.FracElem{T})   Return  a - b .    +(x::NfAbsOrdElem, y::NfAbsOrdElem) -  NfAbsOrdElem   Returns  x + y .    -(x::NfAbsOrdElem, y::NfAbsOrdElem) -  NfAbsOrdElem   Returns  x - y .    *(x::NfAbsOrdElem, y::NfAbsOrdElem) -  NfAbsOrdElem   Returns  x \\cdot y .    ^(x::NfAbsOrdElem, y::Union{fmpz, Int})   Returns  x^y .    mod(a::NfAbsOrdElem, m::Union{fmpz, Int}) -  NfAbsOrdElem   Reduces the coefficient vector of  a  modulo  m  and returns the corresponding element. The coefficient vector of the result will have entries  x  with  0 \\leq x \\leq m .    powermod(a::NfAbsOrdElem, i::fmpz, m::Integer) -  NfAbsOrdElem   Returns the element  a^i  modulo  m .", 
            "title": "Arithmetic"
        }, 
        {
            "location": "/orders/basics/#miscallenous", 
            "text": "representation_matrix(a::NfAbsOrdElem) -  fmpz_mat   Returns the representation matrix of the element  a .    representation_matrix(a::NfAbsOrdElem, K::AnticNumberField) -  FakeFmpqMat   Returns the representation matrix of the element  a  considered as an element of the ambient number field  K . It is assumed that  K  is the ambient number field of the order of  a .    representation_matrix(a::NfAbsOrdElem, K::AnticNumberField) -  FakeFmpqMat   Returns the representation matrix of the element  a  considered as an element of the ambient number field  K . It is assumed that  K  is the ambient number field of the order of  a .    trace(a::NfAbsOrdElem) -  fmpz   Returns the trace of  a .    norm(a::NfAbsOrdElem) -  fmpz   Returns the norm of  a .    norm(A::NfAbsOrdIdl) -  fmpz   Returns the norm of  A , that is, the cardinality of  \\mathcal O/A , where  \\mathcal O  is the order of  A .    norm(a::NfRelOrdIdl) -  NfOrdIdl   Returns the norm of  a .    norm(a::NfRelOrdFracIdl{T, S}) -  S   Returns the norm of  a     rand(O::NfOrd, n::Union{Integer, fmpz}) -  NfAbsOrdElem   Computes a coefficient vector with entries uniformly distributed in  \\{-n,\\dotsc,-1,0,1,\\dotsc,n\\}  and returns the corresponding element of the order  \\mathcal O .    minkowski_map(a::NfAbsOrdElem, abs_tol::Int) -  Array{arb, 1}   Returns the image of  a  under the Minkowski embedding. Every entry of the array returned is of type  arb  with radius less then  2^-abs_tol .    conjugates_arb(x::NfAbsOrdElem, abs_tol::Int) -  Array{acb, 1}   Compute the the conjugates of  x  as elements of type  acb . Recall that we order the complex conjugates  \\sigma_{r+1}(x),...,\\sigma_{r+2s}(x)  such that  \\sigma_{i}(x) = \\overline{\\sigma_{i + s}(x)}  for  r + 2 \\leq i \\leq r + s .  Every entry  y  of the array returned satisfies  radius(real(y))   2^-abs_tol ,  radius(imag(y))   2^-abs_tol  respectively.    conjugates_arb_log(x::NfAbsOrdElem, abs_tol::Int) -  Array{arb, 1}   Returns the elements  (\\log(\\lvert \\sigma_1(x) \\rvert),\\dotsc,\\log(\\lvert\\sigma_r(x) \\rvert), \\dotsc,2\\log(\\lvert \\sigma_{r+1}(x) \\rvert),\\dotsc, 2\\log(\\lvert \\sigma_{r+s}(x)\\rvert))  as elements of type  arb  radius less then  2^-abs_tol .    t2(x::NfAbsOrdElem, abs_tol::Int = 32) -  arb   Return the  T_2 -norm of  x . The radius of the result will be less than  2^-abs_tol .   minpoly{T  : RingElement}(S::Ring, M::AbstractAlgebra.MatElem{T}, charpoly_only = false)   Returns the minimal polynomial  p  of the matrix  M . The polynomial ring  R  of the resulting polynomial must be supplied and the matrix must be square.   charpoly{T  : RingElement}(V::Ring, Y::AbstractAlgebra.MatElem{T})   Returns the characteristic polynomial  p  of the matrix  M . The polynomial ring  R  of the resulting polynomial must be supplied and the matrix is assumed to be square.", 
            "title": "Miscallenous"
        }, 
        {
            "location": "/orders/basics/#ideals", 
            "text": "", 
            "title": "Ideals"
        }, 
        {
            "location": "/orders/basics/#creation_1", 
            "text": "ideal(::NfOrd, ::Int)\nideal(::NfOrd, ::Integer)\nideal(::NfOrd, ::fmpz)\nideal(::NfOrd, ::fmpz_mat)\nideal(::NfOrd, ::NfOrdElem)\nideal(::NfOrd, ::Integer, ::NfOrdElem)\nideal(::NfOrd, ::fmpz, ::NfOrdElem)\n*(::NfOrd, ::NfOrdElem)\nprime_decomposition(::NfOrd, ::Integer)\nprime_decomposition(::NfOrd, ::fmpz)", 
            "title": "Creation"
        }, 
        {
            "location": "/orders/basics/#arithmetic_1", 
            "text": "==(x::NfAbsOrdIdl, y::NfAbsOrdIdl)   Returns whether  x  and  y  are equal.    +(x::NfOrdIdl, y::NfOrdIdl)   Returns  x + y .   *(x::NfOrdIdl, y::NfOrdIdl)   Returns  x \\cdot y .   intersection(x::NfOrdIdl, y::NfOrdIdl) -  NfOrdIdl\nlcm(x::NfOrdIdl, y::NfOrdIdl) -  NfOrdIdl   Returns  x \\cap y .", 
            "title": "Arithmetic"
        }, 
        {
            "location": "/orders/basics/#miscaellenous", 
            "text": "order(::NfOrdIdl)\nbasis(::NfOrdIdl)\nbasis_mat(::NfOrdIdl)\nbasis_mat_inv(::NfOrdIdl)\nminimum(::NfOrdIdl)\nnorm(::NfOrdIdl)\nin(::NfOrdElem, ::NfOrdIdl)\nidempotents(::NfOrdIdl, ::NfOrdIdl)\nmod(::NfOrdElem, ::NfOrdIdl)\npradical(::NfOrd, p::fmpz)\nisprime(::NfOrdIdl)\nvaluation(::nf_elem, ::NfOrdIdl)\nvaluation(::NfOrdElem, ::NfOrdIdl)\nvaluation(::NfOrdIdl, ::NfOrdIdl)\nvaluation(::Integer, ::NfOrdIdl)\nvaluation(::fmpz, ::NfOrdIdl)\nvaluation(::NfOrdFracIdl, ::NfOrdIdl)", 
            "title": "Miscaellenous"
        }, 
        {
            "location": "/orders/basics/#fractional-ideals", 
            "text": "", 
            "title": "Fractional ideals"
        }, 
        {
            "location": "/orders/basics/#creation_2", 
            "text": "frac_ideal(::NfOrd, ::fmpz_mat)\nfrac_ideal(::NfOrd, ::fmpz_mat, ::fmpz)\nfrac_ideal(::NfOrd, ::FakeFmpqMat)\nfrac_ideal(::NfOrd, ::NfOrdIdl)\nfrac_ideal(::NfOrd, ::NfOrdIdl, ::fmpz)\nfrac_ideal(::NfOrd, ::nf_elem)\nfrac_ideal(::NfOrd, ::NfOrdElem)", 
            "title": "Creation"
        }, 
        {
            "location": "/orders/basics/#arithmetic_2", 
            "text": "==(x::NfOrdFracIdl, y::NfOrdFracIdl) -  Bool   Returns whether  x  and  y  are equal.    inv(A::NfOrdFracIdl) -  NfOrdFracIdl   Returns the fractional ideal  B  such that  AB = \\mathcal O .    integral_split(A::NfOrdFracIdl) -  NfOrdIdl, NfOrdIdl   Computes the unique coprime integral ideals  N  and  D  s.th.  A = ND^{-1}", 
            "title": "Arithmetic"
        }, 
        {
            "location": "/orders/basics/#miscaellenous_1", 
            "text": "order(::NfOrdFracIdl)\nbasis_mat(::NfOrdFracIdl)\nbasis_mat_inv(::NfOrdFracIdl)\nbasis(::NfOrdFracIdl)\nnorm(::NfOrdFracIdl)", 
            "title": "Miscaellenous"
        }, 
        {
            "location": "/orders/ideals/", 
            "text": "Ideals", 
            "title": "Ideals"
        }, 
        {
            "location": "/orders/ideals/#ideals", 
            "text": "", 
            "title": "Ideals"
        }, 
        {
            "location": "/abelian/introduction/", 
            "text": "Introduction", 
            "title": "Introduction"
        }, 
        {
            "location": "/abelian/introduction/#introduction", 
            "text": "", 
            "title": "Introduction"
        }, 
        {
            "location": "/class_fields/intro/", 
            "text": "Class Field Theory\n\n\n\n\nIntroduction\n\n\nThis chapter deals with abelian extensions of number fields and the rational numbers.\n\n\nClass Field Theory, here specifically, class field theory of global number fields, deals with abelian extension, ie. fields where the group of automorphisms is abelian. For extensions of {{{Q}}}, the famous Kronnecker-Weber theorem classifies all such fields: a field is abelian if and only if it is contained in some cyclotomic field. For general number fields this is more involved and even for extensions of {{{Q}}} is is not practical.\n\n\nIn Hecke, abelian extensions are parametrized by quotients of so called ray class groups. The language of ray class groups while dated is more applicable to algorithms than the modern language of idel class groups and quotients.\n\n\n\n\nRay Class Groups\n\n\nGiven an integral ideal \nm_0 \\le Z_K\n and a list of real places \nm_\\infty\n, the ray class group modulo \n(m_0, m_\\infty)\n, \nC(m)\n is defined as the group of ideals coprime to \nm_0\n modulo the elements \na\\in K^*\n s.th. \nv_p(a-1) \\ge v_p(m_0)\n and for all \nv\\in m_\\infty\n, \na^{(v)} >0\n. This is a finite abelian group. For \nm_0 = Z_K\n and \nm_\\infty = \\{\\}\n we get \nC()\n is the class group, if \nm_\\infty\n contains all real places, we obtain the narrow class group, or strict class group.\n\n\nray_class_group\n(\nm\n::\nHecke\n.\nNfAbsOrdIdl\n{\nNemo.AnticNumberField,Nemo.nf_elem\n}\n,\n \ninf_plc\n::\nArray\n{\nHecke.InfPlc,1\n}\n;\n \np_part\n,\n \nn_quo\n)\n\n\nray_class_group\n(\nm\n::\nHecke\n.\nNfAbsOrdIdl\n{\nNemo.AnticNumberField,Nemo.nf_elem\n}\n)\n\n\nclass_group\n(\nO\n::\nHecke\n.\nNfAbsOrd\n{\nNemo.AnticNumberField,Nemo.nf_elem\n}\n;\n \nbound\n,\n \nmethod\n,\n \nredo\n,\n \nunit_method\n,\n \nlarge\n)\n\n\nclass_group\n(\nK\n::\nNemo\n.\nAnticNumberField\n)\n\n\nclass_group\n(\nc\n::\nHecke\n.\nClassGrpCtx\n;\n \nredo\n)\n\n\n\n\n\n\n\n\nRay Class Fields\n\n\nIn general, the construction of a class field starts with a (ray) class group. Each quotient of a ray class group then defines a ray class field, the defining property is that the (relative) automorphism group is canonically isomorphic to the quotient of the ray class group where the isomorphism is given by the Artin (or Frobenius) map. Since, in Hecke, the (ray) class groups have no link to the field, actually this has to be specified using the maps.\n\n\nIt should be noted that this is a {\\em lazy} construction: nothing is computed at this point.\n\n\nray_class_field\n(\nm\n::\nUnion\n{\nHecke.MapClassGrp,\n \nHecke.MapRayClassGrp\n}\n)\n\n\nray_class_field\n(\nm\n::\nUnion\n{\nHecke.MapClassGrp,\n \nHecke.MapRayClassGrp\n}\n,\n \nquomap\n::\nHecke\n.\nGrpAbFinGenMap\n)\n\n\nray_class_field\n(\nI\n::\nHecke\n.\nNfAbsOrdIdl\n;\n \nn_quo\n,\n \np_part\n)\n\n\nhilbert_class_field\n(\nk\n::\nAnticNumberField\n)\n\n\n\n\n\n\n\n\nExample\n\n\njulia\n \n#Qx, x = PolynomialRing(FlintQQ, \nx\n);\n\n       \n#K, a = NumberField(x^2 - 10, \na\n);\n\n       \n#c, mc = class_group(K);\n\n       \n#A = ray_class_field(mc)\n\n\n\n\n\n\n\n\nConversions\n\n\nGiven a ray class field, it is possible to actually compute defining equation(s) for this field. In general, the number field constructed this way will be non-simple by type and is defined by a polynomial for each maximal cyclic quotient of prime power order in the defining group.\n\n\nThe algorithm employed is based on Kummer-theory and requires the addition of a suitable root of unity. Progress can be monitored by setting {{{set_verbose_level(:ClassField, n)}}} where \n0\\le n\\le 3\n\n\n\n\nnumber_field(CF::ClassField) -\n Hecke.NfRel_ns{Nemo.nf_elem}\n\n\n\n\n\n\n\nGiven a (formal) abelian extension, compute the class field by finding defining polynomials for all prime power cyclic subfields. Note, by type this is always a non-simple extension.\n\n\n\n\njulia\n \n#Qx, x = PolynomialRing(FlintQQ, \nx\n);\n\n       \n#k, a = NumberField(x^2 - 10, \na\n);\n\n       \n#c, mc = class_group(k);\n\n       \n#A = ray_class_field(mc)\n\n       \n#K = number_field(A)\n\n       \n#ZK = maximal_order(K)\n\n       \n#isone(discriminant(ZK))\n\n\n\n\n\n\nMissing:\n\n\nray_class_field(K::NfRel)\n\n\n\n\n\n\n\nInvariants\n\n\ndegree(C::ClassField)\nbase_ring(A::Hecke.ClassField) \nbase_field(A::Hecke.ClassField) \ndiscriminant(C::Hecke.ClassField)\nconductor(C::Hecke.ClassField) \nHecke.defining_modulus(C::ClassField)\n\n\n\n\n\n\n\nOperations\n\n\n*(a::Hecke.ClassField, b::Hecke.ClassField)\ncompositum(a::Hecke.ClassField, b::Hecke.ClassField)\n==(a::Hecke.ClassField, b::Hecke.ClassField)\nintersect(a::Hecke.ClassField, b::Hecke.ClassField)\nprime_decomposition_type(C::Hecke.ClassField, p::Hecke.NfAbsOrdIdl)\nisconductor(C::Hecke.ClassField, m::Hecke.NfAbsOrdIdl{Nemo.AnticNumberField,Nemo.nf_elem}, inf_plc::Array{Hecke.InfPlc,1}) \nisconductor(C::Hecke.ClassField, m::Hecke.NfAbsOrdIdl{Nemo.AnticNumberField,Nemo.nf_elem})\nHecke.issubfield(a::ClassField, b::ClassField)\nHecke.islocal_norm(r::Hecke.ClassField, a::Hecke.NfAbsOrdElem)\nHecke.islocal_norm(r::Hecke.ClassField, a::Hecke.NfAbsOrdElem, p::Hecke.NfAbsOrdIdl)", 
            "title": "Introduction"
        }, 
        {
            "location": "/class_fields/intro/#class-field-theory", 
            "text": "", 
            "title": "Class Field Theory"
        }, 
        {
            "location": "/class_fields/intro/#introduction", 
            "text": "This chapter deals with abelian extensions of number fields and the rational numbers.  Class Field Theory, here specifically, class field theory of global number fields, deals with abelian extension, ie. fields where the group of automorphisms is abelian. For extensions of {{{Q}}}, the famous Kronnecker-Weber theorem classifies all such fields: a field is abelian if and only if it is contained in some cyclotomic field. For general number fields this is more involved and even for extensions of {{{Q}}} is is not practical.  In Hecke, abelian extensions are parametrized by quotients of so called ray class groups. The language of ray class groups while dated is more applicable to algorithms than the modern language of idel class groups and quotients.", 
            "title": "Introduction"
        }, 
        {
            "location": "/class_fields/intro/#ray-class-groups", 
            "text": "Given an integral ideal  m_0 \\le Z_K  and a list of real places  m_\\infty , the ray class group modulo  (m_0, m_\\infty) ,  C(m)  is defined as the group of ideals coprime to  m_0  modulo the elements  a\\in K^*  s.th.  v_p(a-1) \\ge v_p(m_0)  and for all  v\\in m_\\infty ,  a^{(v)} >0 . This is a finite abelian group. For  m_0 = Z_K  and  m_\\infty = \\{\\}  we get  C()  is the class group, if  m_\\infty  contains all real places, we obtain the narrow class group, or strict class group.  ray_class_group ( m :: Hecke . NfAbsOrdIdl { Nemo.AnticNumberField,Nemo.nf_elem } ,   inf_plc :: Array { Hecke.InfPlc,1 } ;   p_part ,   n_quo )  ray_class_group ( m :: Hecke . NfAbsOrdIdl { Nemo.AnticNumberField,Nemo.nf_elem } )  class_group ( O :: Hecke . NfAbsOrd { Nemo.AnticNumberField,Nemo.nf_elem } ;   bound ,   method ,   redo ,   unit_method ,   large )  class_group ( K :: Nemo . AnticNumberField )  class_group ( c :: Hecke . ClassGrpCtx ;   redo )", 
            "title": "Ray Class Groups"
        }, 
        {
            "location": "/class_fields/intro/#ray-class-fields", 
            "text": "In general, the construction of a class field starts with a (ray) class group. Each quotient of a ray class group then defines a ray class field, the defining property is that the (relative) automorphism group is canonically isomorphic to the quotient of the ray class group where the isomorphism is given by the Artin (or Frobenius) map. Since, in Hecke, the (ray) class groups have no link to the field, actually this has to be specified using the maps.  It should be noted that this is a {\\em lazy} construction: nothing is computed at this point.  ray_class_field ( m :: Union { Hecke.MapClassGrp,   Hecke.MapRayClassGrp } )  ray_class_field ( m :: Union { Hecke.MapClassGrp,   Hecke.MapRayClassGrp } ,   quomap :: Hecke . GrpAbFinGenMap )  ray_class_field ( I :: Hecke . NfAbsOrdIdl ;   n_quo ,   p_part )  hilbert_class_field ( k :: AnticNumberField )", 
            "title": "Ray Class Fields"
        }, 
        {
            "location": "/class_fields/intro/#example", 
            "text": "julia   #Qx, x = PolynomialRing(FlintQQ,  x ); \n        #K, a = NumberField(x^2 - 10,  a ); \n        #c, mc = class_group(K); \n        #A = ray_class_field(mc)", 
            "title": "Example"
        }, 
        {
            "location": "/class_fields/intro/#conversions", 
            "text": "Given a ray class field, it is possible to actually compute defining equation(s) for this field. In general, the number field constructed this way will be non-simple by type and is defined by a polynomial for each maximal cyclic quotient of prime power order in the defining group.  The algorithm employed is based on Kummer-theory and requires the addition of a suitable root of unity. Progress can be monitored by setting {{{set_verbose_level(:ClassField, n)}}} where  0\\le n\\le 3   number_field(CF::ClassField) -  Hecke.NfRel_ns{Nemo.nf_elem}   Given a (formal) abelian extension, compute the class field by finding defining polynomials for all prime power cyclic subfields. Note, by type this is always a non-simple extension.   julia   #Qx, x = PolynomialRing(FlintQQ,  x ); \n        #k, a = NumberField(x^2 - 10,  a ); \n        #c, mc = class_group(k); \n        #A = ray_class_field(mc) \n        #K = number_field(A) \n        #ZK = maximal_order(K) \n        #isone(discriminant(ZK))   Missing:  ray_class_field(K::NfRel)", 
            "title": "Conversions"
        }, 
        {
            "location": "/class_fields/intro/#invariants", 
            "text": "degree(C::ClassField)\nbase_ring(A::Hecke.ClassField) \nbase_field(A::Hecke.ClassField) \ndiscriminant(C::Hecke.ClassField)\nconductor(C::Hecke.ClassField) \nHecke.defining_modulus(C::ClassField)", 
            "title": "Invariants"
        }, 
        {
            "location": "/class_fields/intro/#operations", 
            "text": "*(a::Hecke.ClassField, b::Hecke.ClassField)\ncompositum(a::Hecke.ClassField, b::Hecke.ClassField)\n==(a::Hecke.ClassField, b::Hecke.ClassField)\nintersect(a::Hecke.ClassField, b::Hecke.ClassField)\nprime_decomposition_type(C::Hecke.ClassField, p::Hecke.NfAbsOrdIdl)\nisconductor(C::Hecke.ClassField, m::Hecke.NfAbsOrdIdl{Nemo.AnticNumberField,Nemo.nf_elem}, inf_plc::Array{Hecke.InfPlc,1}) \nisconductor(C::Hecke.ClassField, m::Hecke.NfAbsOrdIdl{Nemo.AnticNumberField,Nemo.nf_elem})\nHecke.issubfield(a::ClassField, b::ClassField)\nHecke.islocal_norm(r::Hecke.ClassField, a::Hecke.NfAbsOrdElem)\nHecke.islocal_norm(r::Hecke.ClassField, a::Hecke.NfAbsOrdElem, p::Hecke.NfAbsOrdIdl)", 
            "title": "Operations"
        }
    ]
}