{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Hecke About Hecke is a software package for algebraic number theory maintained by Claus Fieker, Carlo Sircana and Tommy Hofmann. It is written in julia and is based on the computer algebra package Nemo . https://github.com/thofma/Hecke.jl (Source code) https://thofma.github.io/Hecke.jl/dev/ (Online documentation) So far, Hecke provides the following features: Orders (including element and ideal arithmetic) in number fields Computation of maximal orders Verified residue computations of Dedekind zeta functions Class and Unit group computation, S-units, PID testing Lattice enumeration Sparse linear algebra Normal forms for modules over maximal orders Extensions of number fields, non-simple extensions of number fields Orders and ideals in extensions of fields Abelian groups Ray class groups, quotients of ray class groups Invariant subgroups Class Field Theory Associative Algebras Installation To use Hecke, a julia version of 1.0 is necessary (the latest stable julia version will do). Please see https://julialang.org/downloads/ for instructions on how to obtain julia for your system. Once a suitable julia version is installed, use the following steps at the julia prompt to install Hecke: julia > using Pkg julia > Pkg . add ( \"Hecke\" ) Quick start Here is a quick example of using Hecke: julia > using Hecke ... Welcome to _ _ _ | | | | | | | | __ | | ___ ___ | | _____ | __ |/ _ \\/ __ | |/ / _ \\ | | | | __ / ( __ | < __ / | _ | | _ |\\ ___ |\\ ___ | _ |\\ _ \\ ___ | Version 0.9 . 0 ... ... which comes with absolutely no warranty whatsoever ( c ) 2015 - 2018 by Claus Fieker , Tommy Hofmann and Carlo Sircana julia > Qx , x = PolynomialRing ( FlintQQ , \"x\" ); julia > f = x ^ 3 + 2 ; julia > K , a = NumberField ( f , \"a\" ); julia > O = maximal_order ( K ); julia > O Maximal order of Number field over Rational Field with defining polynomial x ^ 3 + 2 with basis [ 1 , a , a ^ 2 ] The documentation of the single functions can also be accessed at the julia prompt. Here is an example: help?> signature search: signature ---------------------------------------------------------------------------- signature(O::NfMaximalOrder) -> Tuple{Int, Int} | Returns the signature of the ambient number field of \\mathcal O.","title":"About"},{"location":"#hecke","text":"","title":"Hecke"},{"location":"#about","text":"Hecke is a software package for algebraic number theory maintained by Claus Fieker, Carlo Sircana and Tommy Hofmann. It is written in julia and is based on the computer algebra package Nemo . https://github.com/thofma/Hecke.jl (Source code) https://thofma.github.io/Hecke.jl/dev/ (Online documentation) So far, Hecke provides the following features: Orders (including element and ideal arithmetic) in number fields Computation of maximal orders Verified residue computations of Dedekind zeta functions Class and Unit group computation, S-units, PID testing Lattice enumeration Sparse linear algebra Normal forms for modules over maximal orders Extensions of number fields, non-simple extensions of number fields Orders and ideals in extensions of fields Abelian groups Ray class groups, quotients of ray class groups Invariant subgroups Class Field Theory Associative Algebras","title":"About"},{"location":"#installation","text":"To use Hecke, a julia version of 1.0 is necessary (the latest stable julia version will do). Please see https://julialang.org/downloads/ for instructions on how to obtain julia for your system. Once a suitable julia version is installed, use the following steps at the julia prompt to install Hecke: julia > using Pkg julia > Pkg . add ( \"Hecke\" )","title":"Installation"},{"location":"#quick-start","text":"Here is a quick example of using Hecke: julia > using Hecke ... Welcome to _ _ _ | | | | | | | | __ | | ___ ___ | | _____ | __ |/ _ \\/ __ | |/ / _ \\ | | | | __ / ( __ | < __ / | _ | | _ |\\ ___ |\\ ___ | _ |\\ _ \\ ___ | Version 0.9 . 0 ... ... which comes with absolutely no warranty whatsoever ( c ) 2015 - 2018 by Claus Fieker , Tommy Hofmann and Carlo Sircana julia > Qx , x = PolynomialRing ( FlintQQ , \"x\" ); julia > f = x ^ 3 + 2 ; julia > K , a = NumberField ( f , \"a\" ); julia > O = maximal_order ( K ); julia > O Maximal order of Number field over Rational Field with defining polynomial x ^ 3 + 2 with basis [ 1 , a , a ^ 2 ] The documentation of the single functions can also be accessed at the julia prompt. Here is an example: help?> signature search: signature ---------------------------------------------------------------------------- signature(O::NfMaximalOrder) -> Tuple{Int, Int} | Returns the signature of the ambient number field of \\mathcal O.","title":"Quick start"},{"location":"FacElem/","text":"Factored Elements In many applications in number theory related to the multiplicative structure of number fields, interesting elements, e.g. units, are extremely large when written wrt. to a fxied basis for the field: for the fundamental unit in Q[\\sqrt d] it is known that the coefficients wrt. the canonical basis 1, \\sqrt d can have O(\\exp \\sqrt d) many digits. All currently known, fast methods construct those elements as power products of smaller elements, allowing the computer to handle them. Mathematically, one can think of factored elements to formally live in the ring Z[K] the group ring of the non-zero field elements. Thus elements are of the form \\prod a*i^{e*i} where a_i are elements in K , typically small and the e_i\\in Z are frequently large exponents. We refer to the a_i as the base and the e_i as the exponents of the factored element. Since K is, in general, no PID, this presentation is non-unique, elements in this form can easily be multiplied, raised to large powers, but in general not compared and not added. In Hecke, this is caputured more generally by the type FacElem , parametrized by the type of the elements in the base and the type of their parent. Important special cases are FacElem{fmpz, FlintIntegerRing} , factored integers FacElem{nf_elem, AnticNumberField} , factored algerbaic numbers FacElem{NfAbsOrdIdl, NfAbsOrdIdlSet} , factored ideals It should be noted that an object of type ` FacElem{fmpz, FlintIntegerRing} will, in general, not represent an integer as the exponents can be negative. Construction In general one can define factored elements by giving 2 arrays, the base and the exponent, or a dictionary containing the pairs: FacElem { B }( R , base :: Array { B , 1 }, exp :: Array { fmpz , 1 }) -> FacElem { B } Returns the element \\prod b_i^{e_i} , un-expanded. FacElem{B}(base::Array{B, 1}, exp::Array{fmpz, 1}) -> FacElem{B} Returns the element \\prod b_i^{e_i} , un-expanded. FacElem{B}(R, d::Dict{B, fmpz}) -> FacElem{B} FacElem{B}(R, d::Dict{B, Integer}) -> FacElem{B} Returns the element \\prod b^{d[p]} , un-expanded. FacElem{B}(d::Dict{B, fmpz}) -> FacElem{B} FacElem{B}(d::Dict{B, Integer}) -> FacElem{B} Returns the element \\prod b^{d[p]} , un-expanded. FacElem { B }( R , base :: Array { B , 1 }, exp :: Array { fmpz , 1 }) -> FacElem { B } Returns the element \\prod b_i^{e_i} , un-expanded. FacElem{B}(base::Array{B, 1}, exp::Array{fmpz, 1}) -> FacElem{B} Returns the element \\prod b_i^{e_i} , un-expanded. FacElem{B}(R, d::Dict{B, fmpz}) -> FacElem{B} FacElem{B}(R, d::Dict{B, Integer}) -> FacElem{B} Returns the element \\prod b^{d[p]} , un-expanded. FacElem{B}(d::Dict{B, fmpz}) -> FacElem{B} FacElem{B}(d::Dict{B, Integer}) -> FacElem{B} Returns the element \\prod b^{d[p]} , un-expanded. ideal ( O :: NfOrd , a :: FacElem { nf_elem , AnticNumberField ) The factored fractional ideal a*O . Conversion The process of computing the value defined by a factored element is available as evaluate . Depending on the types involved this can be very efficient. evaluate { T }( x :: FacElem { T }) -> T Expands or evaluates the factored element, i.e. actually computes the value. Does \"square-and-multiply\" on the exponent vectors. evaluate ( x :: FacElem { fmpq }) -> fmpq evaluate ( x :: FacElem { fmpz }) -> fmpz Expands or evaluates the factored element, i.e. actually computes the the element. Works by first obtaining a simplified version of the power product into coprime base elements. evaluate { T }( x :: FacElem { T }) -> T Expands or evaluates the factored element, i.e. actually computes the value. Does \"square-and-multiply\" on the exponent vectors. evaluate_naive { T }( x :: FacElem { T }) -> T Expands or evaluates the factored element, i.e. actually computes the value. Uses the obvious naive algorithm. Faster for input in finite rings. Special functions In the case where the parent of the base allows for efficient gcd computation, power products can be made unique: simplify ( x :: FacElem { NfOrdIdl , NfOrdIdlSet }) -> FacElem simplify ( x :: FacElem { NfOrdFracIdl , NfOrdFracIdlSet }) -> FacElem Uses coprime_base to obtain a simplified version of x , ie. in the simplified version all base ideals will be pariwise coprime but not neccessarily prime!. simplify ( x :: FacElem { fmpq }) -> FacElem { fmpq } simplify ( x :: FacElem { fmpz }) -> FacElem { fmpz } Simplfies the factored element, i.e. arranges for the base to be coprime. The simplified version can then be used further: isone ( x :: FacElem { fmpq }) -> Bool isone ( x :: FacElem { fmpz }) -> Bool Tests if x represents 1 without an evaluation. factor_coprime ( x :: FacElem { fmpz }) -> Fac { fmpz } Computed a partial factorisation of x , ie. writes x as a product of pariwise coprime integers. factor_coprime ( x :: FacElem { NfOrdIdl , NfOrdIdlSet }) -> Dict { NfOrdIdl , Int } Computed a partial factorisation of x , ie. writes x as a product of pariwise coprime integral ideals. factor_coprime ( Q :: FacElem { NfOrdFracIdl , NfOrdFracIdlSet }) -> Dict { NfOrdIdl , Int } A coprime factorisation of Q : each ideal in Q is split using \\code{integral_split} and then a coprime basis is computed. This does {\\bf not} use any factorisation. factor_coprime ( a :: FacElem { nf_elem , AnticNumberField }, I :: NfOrdIdlSet ) -> Dict { NfOrdIdl , fmpz } Factors the rincipal ideal generated by a into coprimes by computing a coprime basis from the principal ideals in the factorisation of a . factor ( Q :: FacElem { NfOrdFracIdl , NfOrdFracIdlSet }) -> Dict { NfOrdIdl , Int } The factorisation of Q , by refining a coprime factorisation. factor ( a :: FacElem { nf_elem , AnticNumberField }, I :: NfOrdIdlSet ) -> Dict { NfOrdIdl , fmpz } Factors the principal ideal generated by a by refinind a coprime factorisation. For factorised algebraic numbers a unique simplification is not possible, however, this allows still do obtain partial results: compact_presentation ( a :: FacElem { nf_elem , AnticNumberField }, n :: Int = 2 ; decom , arb_prec = 100 , short_prec = 1000 ) -> FacElem Computes a presentation a = \\prod a_i^{n_i} where all the exponents n_i are powers of n and, the elements a_i are \"small\", generically, they have a norm bounded by d^{n/2} where d is the discriminant of the maximal order. As the algorithm needs the factorisation of the principal ideal generated by a , it can be passed in in \\code{decom}. signs ( a :: nf_elem ) -> Dict { InfPlc , Int } signs ( a :: FacElem { nf_elem }) -> Dict { InfPlc , Int } This function returns a dictionary of the signs of a at all infinite places of the ambient number field. The keys are infinite places of the ambient number field. The value is 1 if the sign is positive and -1 if the sign is negative. signs ( a :: nf_elem , l :: Vector { InfPlc }) -> Dict { InfPlc , Int } signs ( a :: FacElem { nf_elem }, l :: Vector { InfPlc }) -> Dict { InfPlc , Int } This function returns a dictionary of the signs of a at places in l . The keys are the elements of l . The value is 1 if the sign is positive and -1 if the sign is negative. The result will contain as many signs as there are real places contained in l . sign ( a :: nf_elem , P :: InfPlc ) -> Int sign ( a :: FacElem { nf_elem }, P :: InfPlc ) -> Int This function returns the sign of a at the place P . The value is 1 if the sign is positive and -1 if the sign is negative. ispositive ( a :: nf_elem , P :: InfPlc ) -> Bool ispositive ( a :: FacElem { nf_elem }, P :: InfPlc ) -> Bool Returns whether the element a is positive at the embedding corresponding to P . The place P must be real. ispositive ( a :: nf_elem , l :: Vector { InfPlc }) -> Bool ispositive ( a :: FacElem { nf_elem }, l :: Vector { InfPlc }) -> Bool Returns whether the element a is positive at the embeddings corresponding to the real places of l . istotally_positive ( a :: nf_elem ) -> Bool istotally_positive ( a :: FacElem { nf_elem }) -> Bool Returns whether the element a is totally positive, that is, whether it is positive at all places of the ambient number field. valuation ( a :: FacElem { nf_elem , AnticNumberField }, P :: NfOrdIdl ) -> fmpz The valuation of a at P . valuation ( A :: FacElem { NfOrdFracIdl , NfOrdFracIdlSet }, p :: NfOrdIdl ) valuation ( A :: FacElem { NfOrdIdl , NfOrdIdlSet }, p :: NfOrdIdl ) The valuation of A at P . evaluate_mod ( a :: FacElem { nf_elem , AnticNumberField }, B :: NfOrdFracIdl ) -> nf_elem Evaluates a using CRT and small primes. Assumes that the ideal generated by a is in fact B . Useful in cases where a has huge exponents, but the evaluated element is actually \"small\". reduce_ideal ( A :: FacElem { NfOrdIdl }) -> NfOrdIdl , FacElem { nf_elem } Computes B and \\alpha in factored form, such that \\alpha B = A . modular_proj ( a :: FacElem { nf_elem , AnticNumberField }, me :: modular_env ) -> Array { fq_nmod , 1 } Given an algebraic number a in factored form and data \\code{me} as computed by \\code{modular_init}, project a onto the residue class fields. Miscellaneous max_exp ( a :: FacElem ) Finds the largest exponent in the factored element a . min_exp ( a :: FacElem ) Finds the smallest exponent in the factored element a . maxabs_exp ( a :: FacElem ) Finds the largest exponent by absolute value in the factored element a .","title":"Factored Elements"},{"location":"FacElem/#factored-elements","text":"In many applications in number theory related to the multiplicative structure of number fields, interesting elements, e.g. units, are extremely large when written wrt. to a fxied basis for the field: for the fundamental unit in Q[\\sqrt d] it is known that the coefficients wrt. the canonical basis 1, \\sqrt d can have O(\\exp \\sqrt d) many digits. All currently known, fast methods construct those elements as power products of smaller elements, allowing the computer to handle them. Mathematically, one can think of factored elements to formally live in the ring Z[K] the group ring of the non-zero field elements. Thus elements are of the form \\prod a*i^{e*i} where a_i are elements in K , typically small and the e_i\\in Z are frequently large exponents. We refer to the a_i as the base and the e_i as the exponents of the factored element. Since K is, in general, no PID, this presentation is non-unique, elements in this form can easily be multiplied, raised to large powers, but in general not compared and not added. In Hecke, this is caputured more generally by the type FacElem , parametrized by the type of the elements in the base and the type of their parent. Important special cases are FacElem{fmpz, FlintIntegerRing} , factored integers FacElem{nf_elem, AnticNumberField} , factored algerbaic numbers FacElem{NfAbsOrdIdl, NfAbsOrdIdlSet} , factored ideals It should be noted that an object of type ` FacElem{fmpz, FlintIntegerRing} will, in general, not represent an integer as the exponents can be negative.","title":"Factored Elements"},{"location":"FacElem/#construction","text":"In general one can define factored elements by giving 2 arrays, the base and the exponent, or a dictionary containing the pairs: FacElem { B }( R , base :: Array { B , 1 }, exp :: Array { fmpz , 1 }) -> FacElem { B } Returns the element \\prod b_i^{e_i} , un-expanded. FacElem{B}(base::Array{B, 1}, exp::Array{fmpz, 1}) -> FacElem{B} Returns the element \\prod b_i^{e_i} , un-expanded. FacElem{B}(R, d::Dict{B, fmpz}) -> FacElem{B} FacElem{B}(R, d::Dict{B, Integer}) -> FacElem{B} Returns the element \\prod b^{d[p]} , un-expanded. FacElem{B}(d::Dict{B, fmpz}) -> FacElem{B} FacElem{B}(d::Dict{B, Integer}) -> FacElem{B} Returns the element \\prod b^{d[p]} , un-expanded. FacElem { B }( R , base :: Array { B , 1 }, exp :: Array { fmpz , 1 }) -> FacElem { B } Returns the element \\prod b_i^{e_i} , un-expanded. FacElem{B}(base::Array{B, 1}, exp::Array{fmpz, 1}) -> FacElem{B} Returns the element \\prod b_i^{e_i} , un-expanded. FacElem{B}(R, d::Dict{B, fmpz}) -> FacElem{B} FacElem{B}(R, d::Dict{B, Integer}) -> FacElem{B} Returns the element \\prod b^{d[p]} , un-expanded. FacElem{B}(d::Dict{B, fmpz}) -> FacElem{B} FacElem{B}(d::Dict{B, Integer}) -> FacElem{B} Returns the element \\prod b^{d[p]} , un-expanded. ideal ( O :: NfOrd , a :: FacElem { nf_elem , AnticNumberField ) The factored fractional ideal a*O .","title":"Construction"},{"location":"FacElem/#conversion","text":"The process of computing the value defined by a factored element is available as evaluate . Depending on the types involved this can be very efficient. evaluate { T }( x :: FacElem { T }) -> T Expands or evaluates the factored element, i.e. actually computes the value. Does \"square-and-multiply\" on the exponent vectors. evaluate ( x :: FacElem { fmpq }) -> fmpq evaluate ( x :: FacElem { fmpz }) -> fmpz Expands or evaluates the factored element, i.e. actually computes the the element. Works by first obtaining a simplified version of the power product into coprime base elements. evaluate { T }( x :: FacElem { T }) -> T Expands or evaluates the factored element, i.e. actually computes the value. Does \"square-and-multiply\" on the exponent vectors. evaluate_naive { T }( x :: FacElem { T }) -> T Expands or evaluates the factored element, i.e. actually computes the value. Uses the obvious naive algorithm. Faster for input in finite rings.","title":"Conversion"},{"location":"FacElem/#special-functions","text":"In the case where the parent of the base allows for efficient gcd computation, power products can be made unique: simplify ( x :: FacElem { NfOrdIdl , NfOrdIdlSet }) -> FacElem simplify ( x :: FacElem { NfOrdFracIdl , NfOrdFracIdlSet }) -> FacElem Uses coprime_base to obtain a simplified version of x , ie. in the simplified version all base ideals will be pariwise coprime but not neccessarily prime!. simplify ( x :: FacElem { fmpq }) -> FacElem { fmpq } simplify ( x :: FacElem { fmpz }) -> FacElem { fmpz } Simplfies the factored element, i.e. arranges for the base to be coprime. The simplified version can then be used further: isone ( x :: FacElem { fmpq }) -> Bool isone ( x :: FacElem { fmpz }) -> Bool Tests if x represents 1 without an evaluation. factor_coprime ( x :: FacElem { fmpz }) -> Fac { fmpz } Computed a partial factorisation of x , ie. writes x as a product of pariwise coprime integers. factor_coprime ( x :: FacElem { NfOrdIdl , NfOrdIdlSet }) -> Dict { NfOrdIdl , Int } Computed a partial factorisation of x , ie. writes x as a product of pariwise coprime integral ideals. factor_coprime ( Q :: FacElem { NfOrdFracIdl , NfOrdFracIdlSet }) -> Dict { NfOrdIdl , Int } A coprime factorisation of Q : each ideal in Q is split using \\code{integral_split} and then a coprime basis is computed. This does {\\bf not} use any factorisation. factor_coprime ( a :: FacElem { nf_elem , AnticNumberField }, I :: NfOrdIdlSet ) -> Dict { NfOrdIdl , fmpz } Factors the rincipal ideal generated by a into coprimes by computing a coprime basis from the principal ideals in the factorisation of a . factor ( Q :: FacElem { NfOrdFracIdl , NfOrdFracIdlSet }) -> Dict { NfOrdIdl , Int } The factorisation of Q , by refining a coprime factorisation. factor ( a :: FacElem { nf_elem , AnticNumberField }, I :: NfOrdIdlSet ) -> Dict { NfOrdIdl , fmpz } Factors the principal ideal generated by a by refinind a coprime factorisation. For factorised algebraic numbers a unique simplification is not possible, however, this allows still do obtain partial results: compact_presentation ( a :: FacElem { nf_elem , AnticNumberField }, n :: Int = 2 ; decom , arb_prec = 100 , short_prec = 1000 ) -> FacElem Computes a presentation a = \\prod a_i^{n_i} where all the exponents n_i are powers of n and, the elements a_i are \"small\", generically, they have a norm bounded by d^{n/2} where d is the discriminant of the maximal order. As the algorithm needs the factorisation of the principal ideal generated by a , it can be passed in in \\code{decom}. signs ( a :: nf_elem ) -> Dict { InfPlc , Int } signs ( a :: FacElem { nf_elem }) -> Dict { InfPlc , Int } This function returns a dictionary of the signs of a at all infinite places of the ambient number field. The keys are infinite places of the ambient number field. The value is 1 if the sign is positive and -1 if the sign is negative. signs ( a :: nf_elem , l :: Vector { InfPlc }) -> Dict { InfPlc , Int } signs ( a :: FacElem { nf_elem }, l :: Vector { InfPlc }) -> Dict { InfPlc , Int } This function returns a dictionary of the signs of a at places in l . The keys are the elements of l . The value is 1 if the sign is positive and -1 if the sign is negative. The result will contain as many signs as there are real places contained in l . sign ( a :: nf_elem , P :: InfPlc ) -> Int sign ( a :: FacElem { nf_elem }, P :: InfPlc ) -> Int This function returns the sign of a at the place P . The value is 1 if the sign is positive and -1 if the sign is negative. ispositive ( a :: nf_elem , P :: InfPlc ) -> Bool ispositive ( a :: FacElem { nf_elem }, P :: InfPlc ) -> Bool Returns whether the element a is positive at the embedding corresponding to P . The place P must be real. ispositive ( a :: nf_elem , l :: Vector { InfPlc }) -> Bool ispositive ( a :: FacElem { nf_elem }, l :: Vector { InfPlc }) -> Bool Returns whether the element a is positive at the embeddings corresponding to the real places of l . istotally_positive ( a :: nf_elem ) -> Bool istotally_positive ( a :: FacElem { nf_elem }) -> Bool Returns whether the element a is totally positive, that is, whether it is positive at all places of the ambient number field. valuation ( a :: FacElem { nf_elem , AnticNumberField }, P :: NfOrdIdl ) -> fmpz The valuation of a at P . valuation ( A :: FacElem { NfOrdFracIdl , NfOrdFracIdlSet }, p :: NfOrdIdl ) valuation ( A :: FacElem { NfOrdIdl , NfOrdIdlSet }, p :: NfOrdIdl ) The valuation of A at P . evaluate_mod ( a :: FacElem { nf_elem , AnticNumberField }, B :: NfOrdFracIdl ) -> nf_elem Evaluates a using CRT and small primes. Assumes that the ideal generated by a is in fact B . Useful in cases where a has huge exponents, but the evaluated element is actually \"small\". reduce_ideal ( A :: FacElem { NfOrdIdl }) -> NfOrdIdl , FacElem { nf_elem } Computes B and \\alpha in factored form, such that \\alpha B = A . modular_proj ( a :: FacElem { nf_elem , AnticNumberField }, me :: modular_env ) -> Array { fq_nmod , 1 } Given an algebraic number a in factored form and data \\code{me} as computed by \\code{modular_init}, project a onto the residue class fields.","title":"Special functions"},{"location":"FacElem/#miscellaneous","text":"max_exp ( a :: FacElem ) Finds the largest exponent in the factored element a . min_exp ( a :: FacElem ) Finds the smallest exponent in the factored element a . maxabs_exp ( a :: FacElem ) Finds the largest exponent by absolute value in the factored element a .","title":"Miscellaneous"},{"location":"toc/","text":"Table of contents Number Fields Introduction Introduction Definitions and vocabulary Examples Ideals Creation Arithmetic Class Group Miscaellenous Quotient Rings Maximal Order Introduction Orders Creation Basic invariants Elements Creation Basic invariants Binary and unary operations Representation matrices Trace and norm Random elements Conjugates Ideals Abelian Groups Introduction Class Field Theory Introduction Ray Class Groups Ray Class Fields Conversions Invariants Operations","title":"Toc"},{"location":"toc/#table-of-contents","text":"Number Fields Introduction Introduction Definitions and vocabulary Examples Ideals Creation Arithmetic Class Group Miscaellenous Quotient Rings Maximal Order Introduction Orders Creation Basic invariants Elements Creation Basic invariants Binary and unary operations Representation matrices Trace and norm Random elements Conjugates Ideals Abelian Groups Introduction Class Field Theory Introduction Ray Class Groups Ray Class Fields Conversions Invariants Operations","title":"Table of contents"},{"location":"MaximalOrders/Creation/","text":"@module{Hecke} Orders Creation @{MaximalOrder(::AnticNumberField)} @{MaximalOrder(::AnticNumberField, ::Array{fmpz, 1})} Basic invariants @{nf(::NfMaximalOrder)} @{degree(::NfMaximalOrder)} @{basis(::NfMaximalOrder)} @{basis(::NfMaximalOrder, ::AnticNumberField)} @{basis matrix(::NfMaximalOrder)} @{basis mat inv(::NfMaximalOrder)} @{index(::NfMaximalOrder)} @{signature(::NfMaximalOrder)} @{isindex divisor(::NfMaximalOrder, ::fmpz)} @{minkowski_matrix(::NfMaximalOrder, ::Int)}","title":"Creation"},{"location":"MaximalOrders/Creation/#orders","text":"","title":"Orders"},{"location":"MaximalOrders/Creation/#creation","text":"@{MaximalOrder(::AnticNumberField)} @{MaximalOrder(::AnticNumberField, ::Array{fmpz, 1})}","title":"Creation"},{"location":"MaximalOrders/Creation/#basic-invariants","text":"@{nf(::NfMaximalOrder)} @{degree(::NfMaximalOrder)} @{basis(::NfMaximalOrder)} @{basis(::NfMaximalOrder, ::AnticNumberField)} @{basis matrix(::NfMaximalOrder)} @{basis mat inv(::NfMaximalOrder)} @{index(::NfMaximalOrder)} @{signature(::NfMaximalOrder)} @{isindex divisor(::NfMaximalOrder, ::fmpz)} @{minkowski_matrix(::NfMaximalOrder, ::Int)}","title":"Basic invariants"},{"location":"MaximalOrders/Elements/","text":"@module{Hecke} Elements Creation @{call(::NfMaximalOrder, ::nf elem, ::Bool)} @{call(::NfMaximalOrder, ::fmpz)} @{call(::NfMaximalOrder, ::Array{fmpz, 1})} @{call(::NfMaximalOrder, ::Array{Int, 1})} @{call(::NfMaximalOrder, ::nf elem, ::Array{fmpz, 1})} @{call(::NfMaximalOrder)} @{zero(::NfMaximalOrder)} @{one(::NfMaximalOrder)} Basic invariants @{parent(::NfOrderElem)} @{elem in nf(::NfOrderElem)} @{coordinates(::NfOrderElem)} @{==(::NfOrderElem, ::NfOrderElem)} @{deepcopy(::NfOrderElem)} @{in(::nf elem, ::NfMaximalOrder)} @{denominator(::nf elem, ::NfMaximalOrder)} Binary and unary operations @{-(::NfOrderElem)} @{ (::NfOrderElem, ::NfOrderElem)} @{+(::NfOrderElem, ::NfOrderElem)} @{-(::NfOrderElem, ::NfOrderElem)} @{ (::NfOrderElem, ::fmpz)} @{+(::NfOrderElem, ::fmpz)} @{-(::NfOrderElem, ::fmpz)} @{^(::NfOrderElem, ::Int)} @{mod(::NfOrderElem, ::Int)} @{powermod(::NfOrderElem, ::Int, ::fmpz)} Representation matrices @{representation matrix(::NfOrderElem)} @{representation matrix(::NfOrderElem, ::AnticNumberField)} Trace and norm @{tr(::NfOrderElem)} @{norm(::NfOrderElem)} Random elements @{rand(::NfMaximalOrder, ::UnitRange{Int})} @{rand(::NfMaximalOrder, ::Int)} Conjugates @{conjugates arb(::NfOrderElem, ::Int)} @{minkowski map(::NfOrderElem, ::Int)} @{conjugates_log(::NfOrderElem)}","title":"Elements"},{"location":"MaximalOrders/Elements/#elements","text":"","title":"Elements"},{"location":"MaximalOrders/Elements/#creation","text":"@{call(::NfMaximalOrder, ::nf elem, ::Bool)} @{call(::NfMaximalOrder, ::fmpz)} @{call(::NfMaximalOrder, ::Array{fmpz, 1})} @{call(::NfMaximalOrder, ::Array{Int, 1})} @{call(::NfMaximalOrder, ::nf elem, ::Array{fmpz, 1})} @{call(::NfMaximalOrder)} @{zero(::NfMaximalOrder)} @{one(::NfMaximalOrder)}","title":"Creation"},{"location":"MaximalOrders/Elements/#basic-invariants","text":"@{parent(::NfOrderElem)} @{elem in nf(::NfOrderElem)} @{coordinates(::NfOrderElem)} @{==(::NfOrderElem, ::NfOrderElem)} @{deepcopy(::NfOrderElem)} @{in(::nf elem, ::NfMaximalOrder)} @{denominator(::nf elem, ::NfMaximalOrder)}","title":"Basic invariants"},{"location":"MaximalOrders/Elements/#binary-and-unary-operations","text":"@{-(::NfOrderElem)} @{ (::NfOrderElem, ::NfOrderElem)} @{+(::NfOrderElem, ::NfOrderElem)} @{-(::NfOrderElem, ::NfOrderElem)} @{ (::NfOrderElem, ::fmpz)} @{+(::NfOrderElem, ::fmpz)} @{-(::NfOrderElem, ::fmpz)} @{^(::NfOrderElem, ::Int)} @{mod(::NfOrderElem, ::Int)} @{powermod(::NfOrderElem, ::Int, ::fmpz)}","title":"Binary and unary operations"},{"location":"MaximalOrders/Elements/#representation-matrices","text":"@{representation matrix(::NfOrderElem)} @{representation matrix(::NfOrderElem, ::AnticNumberField)}","title":"Representation matrices"},{"location":"MaximalOrders/Elements/#trace-and-norm","text":"@{tr(::NfOrderElem)} @{norm(::NfOrderElem)}","title":"Trace and norm"},{"location":"MaximalOrders/Elements/#random-elements","text":"@{rand(::NfMaximalOrder, ::UnitRange{Int})} @{rand(::NfMaximalOrder, ::Int)}","title":"Random elements"},{"location":"MaximalOrders/Elements/#conjugates","text":"@{conjugates arb(::NfOrderElem, ::Int)} @{minkowski map(::NfOrderElem, ::Int)} @{conjugates_log(::NfOrderElem)}","title":"Conjugates"},{"location":"MaximalOrders/Ideals/","text":"Ideals @module{Hecke} @{nf(::NfMaximalOrderIdeal)}","title":"Ideals"},{"location":"MaximalOrders/Ideals/#ideals","text":"@module{Hecke} @{nf(::NfMaximalOrderIdeal)}","title":"Ideals"},{"location":"MaximalOrders/Introduction/","text":"Maximal Order Introduction In Hecke, maximal orders (aka ring of integers), due to their special properties normal orders don't share, come with their own type NfMaximalOrder . While the elements have type NfOrderElem , the ideals and fractional ideals have types NfMaximalOrderIdeal and NfMaximalOrderFracIdeal respectively. While theoretically a number field contains a unique maximal order (the set of all integral elements), for technical reasons in Hecke a number field admits multiple maximal orders, which are uniquely determined by the number field and a chosen integral basis. Let K be a number field of degree d with primitive element \\alpha and \\mathcal O a maximal order K with \\mathbf{Z} -basis (\\omega_1,\\dotsc,\\omega_d) . The basis matrix of \\mathcal O is the unique matrix M_{\\mathcal O} \\in \\operatorname{Mat}_{d \\times d}(\\mathbf{Q}) such that \\begin{align} \\begin{pmatrix} \\omega*1 \\\\ \\omega*2 \\\\ \\vdots \\\\ \\omega*d \\end{pmatrix} = M*{\\mathcal O} \\begin{pmatrix} 1 \\\\ \\alpha \\\\ \\vdots \\\\ \\alpha^{d - 1} \\end{pmatrix}. \\end{align} If \\beta is an element of \\mathcal O , we call the unique integers (x_1,\\dotsc,x_d) \\in \\mathbf Z^d with \\begin{align} \\beta = \\sum*{i=1}^d x*i \\omega_i \\end{align} the coefficients of \\beta with respect to \\mathcal O or just the coefficient vector . For an ideal I of \\mathcal O , a basis matrix of I is a matrix M \\in \\operatorname{Mat}_{d \\times d}(\\mathbf{Z}) , such that the elements (\\alpha_1,\\dotsc,\\alpha_d) definied by \\begin{align} \\begin{pmatrix} \\alpha*1 \\\\ \\alpha*2 \\\\ \\vdots \\\\ \\alpha*d \\end{pmatrix} = M*{\\mathcal O} \\begin{pmatrix} \\omega*1 \\\\ \\omega*2 \\\\ \\vdots \\\\ \\omega_d \\end{pmatrix} \\end{align} form a \\mathbf{Z} -basis of I .","title":"Introduction"},{"location":"MaximalOrders/Introduction/#maximal-order","text":"","title":"Maximal Order"},{"location":"MaximalOrders/Introduction/#introduction","text":"In Hecke, maximal orders (aka ring of integers), due to their special properties normal orders don't share, come with their own type NfMaximalOrder . While the elements have type NfOrderElem , the ideals and fractional ideals have types NfMaximalOrderIdeal and NfMaximalOrderFracIdeal respectively. While theoretically a number field contains a unique maximal order (the set of all integral elements), for technical reasons in Hecke a number field admits multiple maximal orders, which are uniquely determined by the number field and a chosen integral basis. Let K be a number field of degree d with primitive element \\alpha and \\mathcal O a maximal order K with \\mathbf{Z} -basis (\\omega_1,\\dotsc,\\omega_d) . The basis matrix of \\mathcal O is the unique matrix M_{\\mathcal O} \\in \\operatorname{Mat}_{d \\times d}(\\mathbf{Q}) such that \\begin{align} \\begin{pmatrix} \\omega*1 \\\\ \\omega*2 \\\\ \\vdots \\\\ \\omega*d \\end{pmatrix} = M*{\\mathcal O} \\begin{pmatrix} 1 \\\\ \\alpha \\\\ \\vdots \\\\ \\alpha^{d - 1} \\end{pmatrix}. \\end{align} If \\beta is an element of \\mathcal O , we call the unique integers (x_1,\\dotsc,x_d) \\in \\mathbf Z^d with \\begin{align} \\beta = \\sum*{i=1}^d x*i \\omega_i \\end{align} the coefficients of \\beta with respect to \\mathcal O or just the coefficient vector . For an ideal I of \\mathcal O , a basis matrix of I is a matrix M \\in \\operatorname{Mat}_{d \\times d}(\\mathbf{Z}) , such that the elements (\\alpha_1,\\dotsc,\\alpha_d) definied by \\begin{align} \\begin{pmatrix} \\alpha*1 \\\\ \\alpha*2 \\\\ \\vdots \\\\ \\alpha*d \\end{pmatrix} = M*{\\mathcal O} \\begin{pmatrix} \\omega*1 \\\\ \\omega*2 \\\\ \\vdots \\\\ \\omega_d \\end{pmatrix} \\end{align} form a \\mathbf{Z} -basis of I .","title":"Introduction"},{"location":"abelian/introduction/","text":"Abelian Groups Introduction","title":"Introduction"},{"location":"abelian/introduction/#abelian-groups","text":"","title":"Abelian Groups"},{"location":"abelian/introduction/#introduction","text":"","title":"Introduction"},{"location":"class_fields/intro/","text":"Class Field Theory Introduction This chapter deals with abelian extensions of number fields and the rational numbers. Class Field Theory, here specifically, class field theory of global number fields, deals with abelian extension, ie. fields where the group of automorphisms is abelian. For extensions of {\\Q}, the famous Kronnecker-Weber theorem classifies all such fields: a field is abelian if and only if it is contained in some cyclotomic field. For general number fields this is more involved and even for extensions of {\\Q} is is not practical. In Hecke, abelian extensions are parametrized by quotients of so called ray class groups. The language of ray class groups while dated is more applicable to algorithms than the modern language of idel class groups and quotients. Ray Class Groups Given an integral ideal m_0 \\le Z_K and a list of real places m_\\infty , the ray class group modulo (m_0, m_\\infty) , C(m) is defined as the group of ideals coprime to m_0 modulo the elements a\\in K^* s.th. v_p(a-1) \\ge v_p(m_0) and for all v\\in m_\\infty , a^{(v)} >0 . This is a finite abelian group. For m_0 = Z_K and m_\\infty = \\{\\} we get C() is the class group, if m_\\infty contains all real places, we obtain the narrow class group, or strict class group. ray_class_group ( m :: NfOrdIdl , inf_plc :: Array { InfPlc , 1 }; n_quo :: Int , lp :: Dict { NfOrdIdl , Int }) -> GrpAbFinGen , MapRayClassGrp Given an ideal m and a set of infinite places of K , this function returns the corresponding ray class group as an abstract group \\mathcal {Cl}_m and a map going from the group into the group of ideals of K that are coprime to m . If n_quo is set, it will return the group modulo n_quo . The factorization of m can be given with the keyword argument lp . class_group ( O :: NfOrd ; bound = - 1 , method = 3 , redo = false , large = 1000 ) -> GrpAbFinGen , Map Returns a group A and a map f from A to the set of ideals of O . The inverse of the map is the projection onto the group of ideals modulo the group of principal ideals. redo allows to trigger a re-computation, thus avoiding the cache. bound , when given, is the bound for the factor base. class_group ( K :: AnticNumberField ) -> GrpAbFinGen , Map Shortcut for class_group(maximal_order(K)) : returns the class group as an abelian group and a map from this group to the set of ideals of the maximal order. norm_group ( f :: Nemo . PolyElem , mR :: Hecke . MapRayClassGrp , isabelian :: Bool = true ; of_closure :: Bool = false ) -> Hecke . FinGenGrpAb , Hecke . FinGenGrpAbMap norm_group ( f :: Array { PolyElem { nf_elem }}, mR :: Hecke . MapRayClassGrp , isabelian :: Bool = true ; of_closure :: Bool = false ) -> Hecke . FinGenGrpAb , Hecke . FinGenGrpAbMap Computes the subgroup of the Ray Class Group R given by the norm of the extension generated by a/the roots of f . If isabelian is set to true, then the code assumes the field to be abelian, hence the algorithm stops when the quotient by the norm group has the correct order. Even though the algorithm is probabilistic by nature, in this case the result is guaranteed. If of_closure is given, then the norm group of the splitting field of the polynomial(s) is computed. It is the callers responsibility to ensure that the ray class group passed in is large enough. norm_group ( K :: NfRel { nf_elem }, mR :: Hecke . MapRayClassGrp ) -> Hecke . FinGenGrpAb , Hecke . FinGenGrpAbMap norm_group ( K :: NfRelNS { nf_elem }, mR :: Hecke . MapRayClassGrp ) -> Hecke . FinGenGrpAb , Hecke . FinGenGrpAbMap Computes the subgroup of the Ray Class Group R given by the norm of the extension. Ray Class Fields In general, the construction of a class field starts with a (ray) class group. Each quotient of a ray class group then defines a ray class field, the defining property is that the (relative) automorphism group is canonically isomorphic to the quotient of the ray class group where the isomorphism is given by the Artin (or Frobenius) map. Since, in Hecke, the (ray) class groups have no link to the field, actually this has to be specified using the maps. It should be noted that this is a {\\em lazy} construction: nothing is computed at this point. ray_class_field ( m :: MapClassGrp ) -> ClassField ray_class_field ( m :: MapRayClassGrp ) -> ClassField Creates the (formal) abelian extension defined by the map m: A \\to I where I is the set of ideals coprime to the modulus defining m and A is a quotient of the ray class group (or class group). The map m must be the map returned from a call to {class group} or {ray class_group}. ray_class_field ( m :: Union { MapClassGrp , MapRayClassGrp }, quomap :: GrpAbFinGenMap ) -> ClassField For m a map computed by either {ray class group} or {class_group} and q a canonical projection (quotient map) as returned by {quo} for q quotient of the domain of m and a subgroup of m , create the (formal) abelian extension where the (relative) automorphism group is canonically isomorphic to the codomain of q . ray_class_field ( I :: NfAbsOrdIdl ; n_quo = 0 ) -> ClassField The ray class field modulo I . If n_quo is given, then the largest subfield of exponent n is computed. ray_class_field ( I :: NfAbsOrdIdl , inf :: Array { InfPlc , 1 }; n_quo = 0 ) -> ClassField The ray class field modulo I and the infinite places given. If n_quo is given, then the largest subfield of exponent n is computed. hilbert_class_field ( k :: AnticNumberField ) -> ClassField The Hilbert class field of k as a formal (ray-) class field. ring_class_field ( O :: NfAbsOrd ) -> ClassField The ring class field of O , i.e. the maximal abelian extension ramified only at primes dividing the conductor with the automorphism group isomorphic to the Picard group. Example julia> Qx, x = PolynomialRing(FlintQQ, \"x\"); julia> K, a = NumberField(x^2 - 10, \"a\"); julia> c, mc = class_group(K) (GrpAb: Z/2, ClassGroup map of Set of ideals of Maximal order of Number field over Rational Field with defining polynomial x^2 - 10 with basis nf_elem[1, a] ) julia> A = ray_class_field(mc) Class field defined mod (<1, 1>, InfPlc[]) of structure Abelian group with structure: Z/2 Conversions Given a ray class field, it is possible to actually compute defining equation(s) for this field. In general, the number field constructed this way will be non-simple by type and is defined by a polynomial for each maximal cyclic quotient of prime power order in the defining group. The algorithm employed is based on Kummer-theory and requires the addition of a suitable root of unity. Progress can be monitored by setting {{{set verbose level(:ClassField, n)}}} where 0\\le n\\le 3 NumberField ( CF :: ClassField ) -> NfRelNS { nf_elem } Given a (formal) abelian extension, compute the class field by finding defining polynomials for all prime power cyclic subfields. Note, the return type is always a non-simple extension. julia> Qx, x = PolynomialRing(FlintQQ, \"x\"); julia> k, a = NumberField(x^2 - 10, \"a\"); julia> c, mc = class_group(k); julia> A = ray_class_field(mc) Class field defined mod (<1, 1>, InfPlc[]) of structure Abelian group with structure: Z/2 julia> K = number_field(A) non-simple Relative number field with defining polynomials AbstractAlgebra.Generic.MPoly{nf_elem}[_$1^2 - 2] over Number field over Rational Field with defining polynomial x^2 - 10 julia> ZK = maximal_order(K) Relative maximal order of non-simple Relative number field with defining polynomials AbstractAlgebra.Generic.MPoly{nf_elem}[_$1^2 - 2] over Number field over Rational Field with defining polynomial x^2 - 10 with pseudo-basis (1, 1//1 * <1, 1>) (_$1 + a, 1//4 * <2, 3*a>) julia> isone(discriminant(ZK)) true ray_class_field ( K :: NfRel { nf_elem }) -> ClassField For a (relative) abelian extension, compute an abstract representation as a class field. genus_field ( A :: ClassField , k :: AnticNumberField ) -> ClassField The maximal extension contained in A that is the compositum of K with an abelian extension of k . maximal_abelian_subfield ( A :: ClassField , k :: AnticNumberField ) -> ClassField The maximal abelian extension of k contained in A . k must be a subfield of the base field of A . maximal_abelian_subfield ( K :: NfRel { nf_elem }; of_closure :: Bool = false ) -> ClassField Using a probabilistic algorithm for the norm group computation, determine the maximal abelian subfield in K over its base field. If of_closure is set to true, then the algorithm is applied to the normal closure of K (without computing it). Invariants degree ( A :: ClassField ) The degree of A over its base field, i.e. the size of the defining ideal group. base_ring ( A :: ClassField ) The maximal order of the field that A is defined over. base_field ( A :: ClassField ) The number field that A is defined over. discriminant ( C :: ClassField ) -> NfOrdIdl Using the conductor-discriminant formula, compute the (relative) discriminant of C . This does not use the defining equations. conductor ( C :: ClassField ) -> NfOrdIdl , Array { InfPlc , 1 } Return the conductor of the abelian extension corresponding to C . defining_modulus ( CF :: ClassField ) The modulus, i.e. an ideal of the set of real places, used to create the class field. iscyclic ( C :: ClassField ) Tests if the (relative) automorphism group of C is cyclic (by checking the defining ideal group). isconductor ( C :: Hecke . ClassField , m :: NfOrdIdl , inf_plc :: Array { InfPlc , 1 } = InfPlc []; check ) -> NfOrdIdl , Array { InfPlc , 1 } Checks if (m, inf_plc) is the conductor of the abelian extension corresponding to C . If check is false , it assumes that the given modulus is a multiple of the conductor. This is usually faster than computing the conductor. isnormal ( C :: ClassField ) -> Bool For a class field C defined over a normal base field k , decide if C is normal over Q . iscentral ( C :: ClassField ) -> Bool For a class field C defined over a normal base field k , decide if C is central over Q . Operations * ( A :: ClassField , B :: ClassField ) -> ClassField The compositum of a and b as a (formal) class field. compositum ( a :: ClassField , b :: ClassField ) -> ClassField The compositum of a and b as a (formal) class field. == ( a :: ClassField , b :: ClassField ) Tests if a and b are equal. intersect ( a :: ClassField , b :: ClassField ) -> ClassField The intersection of a and b as a class field. prime_decomposition_type ( C :: ClassField , p :: NfAbsOrdIdl ) -> ( Int , Int , Int ) For a prime p in the base ring of r , determine the splitting type of p in r . ie. the tuple (e, f, g) giving the ramification degree, the inertia and the number of primes above p . issubfield ( a :: ClassField , b :: ClassField ) -> Bool Determines if a is a subfield of b . islocal_norm ( r :: ClassField , a :: NfAbsOrdElem ) -> Bool Tests if a is a local norm at all finite places in the extension implictly given by r . islocal_norm ( r :: ClassField , a :: NfAbsOrdElem , p :: NfAbsOrdIdl ) -> Bool Tests if a is a local norm at p in the extension implictly given by r . Currently the conductor cannot have infinite places. normal_closure ( C :: ClassField ) -> ClassField For a ray class field C extending a normal base field k , compute the normal closure over Q . subfields ( C :: ClassField ) -> Array { ClassField , 1 } Find all subfields of C as class fields. Note: this will not find all subfields over Q , but only the ones sharing the same base field. subfields ( C :: ClassField , d :: Int ) -> Array { ClassField , 1 } Find all subfields of C of degree d as class fields. Note: this will not find all subfields over Q , but only the ones sharing the same base field.","title":"Introduction"},{"location":"class_fields/intro/#class-field-theory","text":"","title":"Class Field Theory"},{"location":"class_fields/intro/#introduction","text":"This chapter deals with abelian extensions of number fields and the rational numbers. Class Field Theory, here specifically, class field theory of global number fields, deals with abelian extension, ie. fields where the group of automorphisms is abelian. For extensions of {\\Q}, the famous Kronnecker-Weber theorem classifies all such fields: a field is abelian if and only if it is contained in some cyclotomic field. For general number fields this is more involved and even for extensions of {\\Q} is is not practical. In Hecke, abelian extensions are parametrized by quotients of so called ray class groups. The language of ray class groups while dated is more applicable to algorithms than the modern language of idel class groups and quotients.","title":"Introduction"},{"location":"class_fields/intro/#ray-class-groups","text":"Given an integral ideal m_0 \\le Z_K and a list of real places m_\\infty , the ray class group modulo (m_0, m_\\infty) , C(m) is defined as the group of ideals coprime to m_0 modulo the elements a\\in K^* s.th. v_p(a-1) \\ge v_p(m_0) and for all v\\in m_\\infty , a^{(v)} >0 . This is a finite abelian group. For m_0 = Z_K and m_\\infty = \\{\\} we get C() is the class group, if m_\\infty contains all real places, we obtain the narrow class group, or strict class group. ray_class_group ( m :: NfOrdIdl , inf_plc :: Array { InfPlc , 1 }; n_quo :: Int , lp :: Dict { NfOrdIdl , Int }) -> GrpAbFinGen , MapRayClassGrp Given an ideal m and a set of infinite places of K , this function returns the corresponding ray class group as an abstract group \\mathcal {Cl}_m and a map going from the group into the group of ideals of K that are coprime to m . If n_quo is set, it will return the group modulo n_quo . The factorization of m can be given with the keyword argument lp . class_group ( O :: NfOrd ; bound = - 1 , method = 3 , redo = false , large = 1000 ) -> GrpAbFinGen , Map Returns a group A and a map f from A to the set of ideals of O . The inverse of the map is the projection onto the group of ideals modulo the group of principal ideals. redo allows to trigger a re-computation, thus avoiding the cache. bound , when given, is the bound for the factor base. class_group ( K :: AnticNumberField ) -> GrpAbFinGen , Map Shortcut for class_group(maximal_order(K)) : returns the class group as an abelian group and a map from this group to the set of ideals of the maximal order. norm_group ( f :: Nemo . PolyElem , mR :: Hecke . MapRayClassGrp , isabelian :: Bool = true ; of_closure :: Bool = false ) -> Hecke . FinGenGrpAb , Hecke . FinGenGrpAbMap norm_group ( f :: Array { PolyElem { nf_elem }}, mR :: Hecke . MapRayClassGrp , isabelian :: Bool = true ; of_closure :: Bool = false ) -> Hecke . FinGenGrpAb , Hecke . FinGenGrpAbMap Computes the subgroup of the Ray Class Group R given by the norm of the extension generated by a/the roots of f . If isabelian is set to true, then the code assumes the field to be abelian, hence the algorithm stops when the quotient by the norm group has the correct order. Even though the algorithm is probabilistic by nature, in this case the result is guaranteed. If of_closure is given, then the norm group of the splitting field of the polynomial(s) is computed. It is the callers responsibility to ensure that the ray class group passed in is large enough. norm_group ( K :: NfRel { nf_elem }, mR :: Hecke . MapRayClassGrp ) -> Hecke . FinGenGrpAb , Hecke . FinGenGrpAbMap norm_group ( K :: NfRelNS { nf_elem }, mR :: Hecke . MapRayClassGrp ) -> Hecke . FinGenGrpAb , Hecke . FinGenGrpAbMap Computes the subgroup of the Ray Class Group R given by the norm of the extension.","title":"Ray Class Groups"},{"location":"class_fields/intro/#ray-class-fields","text":"In general, the construction of a class field starts with a (ray) class group. Each quotient of a ray class group then defines a ray class field, the defining property is that the (relative) automorphism group is canonically isomorphic to the quotient of the ray class group where the isomorphism is given by the Artin (or Frobenius) map. Since, in Hecke, the (ray) class groups have no link to the field, actually this has to be specified using the maps. It should be noted that this is a {\\em lazy} construction: nothing is computed at this point. ray_class_field ( m :: MapClassGrp ) -> ClassField ray_class_field ( m :: MapRayClassGrp ) -> ClassField Creates the (formal) abelian extension defined by the map m: A \\to I where I is the set of ideals coprime to the modulus defining m and A is a quotient of the ray class group (or class group). The map m must be the map returned from a call to {class group} or {ray class_group}. ray_class_field ( m :: Union { MapClassGrp , MapRayClassGrp }, quomap :: GrpAbFinGenMap ) -> ClassField For m a map computed by either {ray class group} or {class_group} and q a canonical projection (quotient map) as returned by {quo} for q quotient of the domain of m and a subgroup of m , create the (formal) abelian extension where the (relative) automorphism group is canonically isomorphic to the codomain of q . ray_class_field ( I :: NfAbsOrdIdl ; n_quo = 0 ) -> ClassField The ray class field modulo I . If n_quo is given, then the largest subfield of exponent n is computed. ray_class_field ( I :: NfAbsOrdIdl , inf :: Array { InfPlc , 1 }; n_quo = 0 ) -> ClassField The ray class field modulo I and the infinite places given. If n_quo is given, then the largest subfield of exponent n is computed. hilbert_class_field ( k :: AnticNumberField ) -> ClassField The Hilbert class field of k as a formal (ray-) class field. ring_class_field ( O :: NfAbsOrd ) -> ClassField The ring class field of O , i.e. the maximal abelian extension ramified only at primes dividing the conductor with the automorphism group isomorphic to the Picard group.","title":"Ray Class Fields"},{"location":"class_fields/intro/#example","text":"julia> Qx, x = PolynomialRing(FlintQQ, \"x\"); julia> K, a = NumberField(x^2 - 10, \"a\"); julia> c, mc = class_group(K) (GrpAb: Z/2, ClassGroup map of Set of ideals of Maximal order of Number field over Rational Field with defining polynomial x^2 - 10 with basis nf_elem[1, a] ) julia> A = ray_class_field(mc) Class field defined mod (<1, 1>, InfPlc[]) of structure Abelian group with structure: Z/2","title":"Example"},{"location":"class_fields/intro/#conversions","text":"Given a ray class field, it is possible to actually compute defining equation(s) for this field. In general, the number field constructed this way will be non-simple by type and is defined by a polynomial for each maximal cyclic quotient of prime power order in the defining group. The algorithm employed is based on Kummer-theory and requires the addition of a suitable root of unity. Progress can be monitored by setting {{{set verbose level(:ClassField, n)}}} where 0\\le n\\le 3 NumberField ( CF :: ClassField ) -> NfRelNS { nf_elem } Given a (formal) abelian extension, compute the class field by finding defining polynomials for all prime power cyclic subfields. Note, the return type is always a non-simple extension. julia> Qx, x = PolynomialRing(FlintQQ, \"x\"); julia> k, a = NumberField(x^2 - 10, \"a\"); julia> c, mc = class_group(k); julia> A = ray_class_field(mc) Class field defined mod (<1, 1>, InfPlc[]) of structure Abelian group with structure: Z/2 julia> K = number_field(A) non-simple Relative number field with defining polynomials AbstractAlgebra.Generic.MPoly{nf_elem}[_$1^2 - 2] over Number field over Rational Field with defining polynomial x^2 - 10 julia> ZK = maximal_order(K) Relative maximal order of non-simple Relative number field with defining polynomials AbstractAlgebra.Generic.MPoly{nf_elem}[_$1^2 - 2] over Number field over Rational Field with defining polynomial x^2 - 10 with pseudo-basis (1, 1//1 * <1, 1>) (_$1 + a, 1//4 * <2, 3*a>) julia> isone(discriminant(ZK)) true ray_class_field ( K :: NfRel { nf_elem }) -> ClassField For a (relative) abelian extension, compute an abstract representation as a class field. genus_field ( A :: ClassField , k :: AnticNumberField ) -> ClassField The maximal extension contained in A that is the compositum of K with an abelian extension of k . maximal_abelian_subfield ( A :: ClassField , k :: AnticNumberField ) -> ClassField The maximal abelian extension of k contained in A . k must be a subfield of the base field of A . maximal_abelian_subfield ( K :: NfRel { nf_elem }; of_closure :: Bool = false ) -> ClassField Using a probabilistic algorithm for the norm group computation, determine the maximal abelian subfield in K over its base field. If of_closure is set to true, then the algorithm is applied to the normal closure of K (without computing it).","title":"Conversions"},{"location":"class_fields/intro/#invariants","text":"degree ( A :: ClassField ) The degree of A over its base field, i.e. the size of the defining ideal group. base_ring ( A :: ClassField ) The maximal order of the field that A is defined over. base_field ( A :: ClassField ) The number field that A is defined over. discriminant ( C :: ClassField ) -> NfOrdIdl Using the conductor-discriminant formula, compute the (relative) discriminant of C . This does not use the defining equations. conductor ( C :: ClassField ) -> NfOrdIdl , Array { InfPlc , 1 } Return the conductor of the abelian extension corresponding to C . defining_modulus ( CF :: ClassField ) The modulus, i.e. an ideal of the set of real places, used to create the class field. iscyclic ( C :: ClassField ) Tests if the (relative) automorphism group of C is cyclic (by checking the defining ideal group). isconductor ( C :: Hecke . ClassField , m :: NfOrdIdl , inf_plc :: Array { InfPlc , 1 } = InfPlc []; check ) -> NfOrdIdl , Array { InfPlc , 1 } Checks if (m, inf_plc) is the conductor of the abelian extension corresponding to C . If check is false , it assumes that the given modulus is a multiple of the conductor. This is usually faster than computing the conductor. isnormal ( C :: ClassField ) -> Bool For a class field C defined over a normal base field k , decide if C is normal over Q . iscentral ( C :: ClassField ) -> Bool For a class field C defined over a normal base field k , decide if C is central over Q .","title":"Invariants"},{"location":"class_fields/intro/#operations","text":"* ( A :: ClassField , B :: ClassField ) -> ClassField The compositum of a and b as a (formal) class field. compositum ( a :: ClassField , b :: ClassField ) -> ClassField The compositum of a and b as a (formal) class field. == ( a :: ClassField , b :: ClassField ) Tests if a and b are equal. intersect ( a :: ClassField , b :: ClassField ) -> ClassField The intersection of a and b as a class field. prime_decomposition_type ( C :: ClassField , p :: NfAbsOrdIdl ) -> ( Int , Int , Int ) For a prime p in the base ring of r , determine the splitting type of p in r . ie. the tuple (e, f, g) giving the ramification degree, the inertia and the number of primes above p . issubfield ( a :: ClassField , b :: ClassField ) -> Bool Determines if a is a subfield of b . islocal_norm ( r :: ClassField , a :: NfAbsOrdElem ) -> Bool Tests if a is a local norm at all finite places in the extension implictly given by r . islocal_norm ( r :: ClassField , a :: NfAbsOrdElem , p :: NfAbsOrdIdl ) -> Bool Tests if a is a local norm at p in the extension implictly given by r . Currently the conductor cannot have infinite places. normal_closure ( C :: ClassField ) -> ClassField For a ray class field C extending a normal base field k , compute the normal closure over Q . subfields ( C :: ClassField ) -> Array { ClassField , 1 } Find all subfields of C as class fields. Note: this will not find all subfields over Q , but only the ones sharing the same base field. subfields ( C :: ClassField , d :: Int ) -> Array { ClassField , 1 } Find all subfields of C of degree d as class fields. Note: this will not find all subfields over Q , but only the ones sharing the same base field.","title":"Operations"},{"location":"number_fields/basics/","text":"Creation of number fields Creation of simple number fields Number fields are mostly created using the function NumberField , of which number_field is an alias. To create a simple number field, the following functions can be used. NumberField ( f :: Poly { NumFieldElem }, s :: String ; cached :: Bool = false , check :: Bool = false ) -> NumField , NumFieldElem Given an irreducible polynomial f \\in K[x] over some number field K , this function creates the simple number field L = K[x]/(x) and returns (L, b) , where b is the class of x in L . The string s is used only for printing the primitive element b . Testing that f is irreducible can be disabled by setting the keyword argument check to false . cyclotomic_field ( n :: Int ) -> AnticNumberField , nf_elem The n -th cyclotomic field defined by the n -th cyclotomic polynomial. wildanger_field ( n :: Int , B :: fmpz ) -> AnticNumberField , nf_elem Returns the field with defining polynomial x^n + \\sum_{i=0}^{n-1} (-1)^{n-i}Bx^i . These fields tend to have non-trivial class groups. radical_extension ( n :: Int , a :: NumFieldElem ; s = \"_$\" , check = true , cached = true ) -> NumField , NumFieldElem Given an element a of a number field K and an integer n , create the simple extension of K with the defining polynomial x^n - a . Many of the constructors have arguments of type Symbol or AbstractString , if used, they define the appearance in printing, and printing only. The named parameter check can be true or false , the default being true . This parameter controlls is the polynomial defining the number field is tested for irreducibility or not. Given that this can be potentially very time consuming if the degree if large, one can disable this test. Note however, that the behaviour of Hecke is undefined if a reducible polynomial is used to define a field . The named boolean parameter cached is inherited from the underlying Nemo system. Two number fields defined using the same polynomial from the identical polynomial ring and the same (identical) symbol/ string will be identical if cached == true and different if cached == false . Example julia > Qx , x = PolynomialRing ( FlintQQ , \"x\" ); julia > K , a = NumberField ( x ^ 2 - 10 , \"a\" ) ( Number field over Rational Field with defining polynomial x ^ 2 - 10 , a ) Creation of non-simple number fields NumberField ( f :: Vector { PolyElem { <: NumFieldElem }}, s :: String = \"_ \\$ \" , check = true ) -> NumField , Vector { NumFieldElem } Given a list f_1, \\ldots, f_n of univariate polynomials in K[x] over some number field K , constructs the extension K[x_1, \\ldots, x_n]/(f_1(x_1), \\ldots, f_n(x_n)) . Example julia > Qx , x = PolynomialRing ( FlintQQ , \"x\" ); julia > K , g = number_field ([ x ^ 2 - 2 , x ^ 2 - 3 , x ^ 2 - 5 ]) ( Non - simple number field with defining polynomials fmpq_mpoly [ x1 ^ 2 - 2 , x2 ^ 2 - 3 , x3 ^ 2 - 5 ], NfAbsNSElem [ _ $ 1 , _ $ 2 , _ $ 3 ]) julia > g [ 1 ] ^ 2 2 julia > minpoly ( g [ 1 ] + g [ 2 ]) x ^ 4 - 10 * x ^ 2 + 1 Conversion absolute_simple_field ( L :: NumField ) -> NumField , Map Given a number field L , this function returns an absolute simple number field M/\\mathbf{Q} together with a \\mathbf{Q} -linear isomorphism M \\to K . simple_extension ( L :: NonSimpleNumField ) -> SimpleNumField , Map Given a non-simple extension L/K , this function computes a simple extension M/K and a K -linear isomorphism M \\to L . Invariants basis ( L :: SimpleNumField ) -> Vector { NumFieldElem } Returns the canonical basis of a simple extension L/K , that is, the elements 1,a,\\dotsc,a^{d - 1} , where d is the degree of K and a the primitive element. basis ( L :: NonSimpleNumField ) -> Vector { NumFieldElem } Returns the canonical basis of a non-simple extension L/K . If L = K(a_1,\\dotsc,a_n) where each a_i has degree d_i , then the basis will be a_1^{i_1}\\dotsm a_d^{i_d} with 0 \\leq i_j d_j - 1 for 1 \\leq j \\leq n . issimple ( L :: NumField ) -> Bool Given a number field L/K this function returns whether L is simple, that is, whether L/K is defined by a univariate polynomial$. isabsolute ( L :: NumField ) -> Bool Returns whether L is an absolute extension, that is, whether the base field of L is \\mathbf{Q} . degree ( L :: NumField ) -> Int Given a number field L/K , this function returns the degree of L over K . discriminant ( L :: SimpleNumField ) -> NumFieldElem The discriminant of the defining polynomial of L , not the discriminant of the maximal order of L . absolute_discriminant ( L :: SimpleNumField , QQ ) -> fmpq The absolute discriminant of the defining polynomial of L , not the discriminant of the maximal order of L . This is the norm of the discriminant times the d -th power of the discriminant of the base field, where d is the degree of L . defining_polynomial ( L :: SimpleNumField ) -> PolyElem Given a simple number field L/K , constructed as L = K[x]/(f) , this function returns f . Subfields issubfield ( K :: SimpleNumField , L :: SimpleNumField ) -> Bool , Map Returns true and an injection from K to L if K is a subfield of L . Otherwise the function returns false and a morphism mapping everything to 0 . isisomorphic ( K :: SimpleNumField , L :: SimpleNumField ) -> Bool , Map Returns true and an isomorphism from K to L if K and L are isomorphic. Otherwise the function returns false and a morphism mapping everything to 0 .","title":"Creation and basics"},{"location":"number_fields/basics/#creation-of-number-fields","text":"","title":"Creation of number fields"},{"location":"number_fields/basics/#creation-of-simple-number-fields","text":"Number fields are mostly created using the function NumberField , of which number_field is an alias. To create a simple number field, the following functions can be used. NumberField ( f :: Poly { NumFieldElem }, s :: String ; cached :: Bool = false , check :: Bool = false ) -> NumField , NumFieldElem Given an irreducible polynomial f \\in K[x] over some number field K , this function creates the simple number field L = K[x]/(x) and returns (L, b) , where b is the class of x in L . The string s is used only for printing the primitive element b . Testing that f is irreducible can be disabled by setting the keyword argument check to false . cyclotomic_field ( n :: Int ) -> AnticNumberField , nf_elem The n -th cyclotomic field defined by the n -th cyclotomic polynomial. wildanger_field ( n :: Int , B :: fmpz ) -> AnticNumberField , nf_elem Returns the field with defining polynomial x^n + \\sum_{i=0}^{n-1} (-1)^{n-i}Bx^i . These fields tend to have non-trivial class groups. radical_extension ( n :: Int , a :: NumFieldElem ; s = \"_$\" , check = true , cached = true ) -> NumField , NumFieldElem Given an element a of a number field K and an integer n , create the simple extension of K with the defining polynomial x^n - a . Many of the constructors have arguments of type Symbol or AbstractString , if used, they define the appearance in printing, and printing only. The named parameter check can be true or false , the default being true . This parameter controlls is the polynomial defining the number field is tested for irreducibility or not. Given that this can be potentially very time consuming if the degree if large, one can disable this test. Note however, that the behaviour of Hecke is undefined if a reducible polynomial is used to define a field . The named boolean parameter cached is inherited from the underlying Nemo system. Two number fields defined using the same polynomial from the identical polynomial ring and the same (identical) symbol/ string will be identical if cached == true and different if cached == false . Example julia > Qx , x = PolynomialRing ( FlintQQ , \"x\" ); julia > K , a = NumberField ( x ^ 2 - 10 , \"a\" ) ( Number field over Rational Field with defining polynomial x ^ 2 - 10 , a )","title":"Creation of simple number fields"},{"location":"number_fields/basics/#creation-of-non-simple-number-fields","text":"NumberField ( f :: Vector { PolyElem { <: NumFieldElem }}, s :: String = \"_ \\$ \" , check = true ) -> NumField , Vector { NumFieldElem } Given a list f_1, \\ldots, f_n of univariate polynomials in K[x] over some number field K , constructs the extension K[x_1, \\ldots, x_n]/(f_1(x_1), \\ldots, f_n(x_n)) . Example julia > Qx , x = PolynomialRing ( FlintQQ , \"x\" ); julia > K , g = number_field ([ x ^ 2 - 2 , x ^ 2 - 3 , x ^ 2 - 5 ]) ( Non - simple number field with defining polynomials fmpq_mpoly [ x1 ^ 2 - 2 , x2 ^ 2 - 3 , x3 ^ 2 - 5 ], NfAbsNSElem [ _ $ 1 , _ $ 2 , _ $ 3 ]) julia > g [ 1 ] ^ 2 2 julia > minpoly ( g [ 1 ] + g [ 2 ]) x ^ 4 - 10 * x ^ 2 + 1","title":"Creation of non-simple number fields"},{"location":"number_fields/basics/#conversion","text":"absolute_simple_field ( L :: NumField ) -> NumField , Map Given a number field L , this function returns an absolute simple number field M/\\mathbf{Q} together with a \\mathbf{Q} -linear isomorphism M \\to K . simple_extension ( L :: NonSimpleNumField ) -> SimpleNumField , Map Given a non-simple extension L/K , this function computes a simple extension M/K and a K -linear isomorphism M \\to L .","title":"Conversion"},{"location":"number_fields/basics/#invariants","text":"basis ( L :: SimpleNumField ) -> Vector { NumFieldElem } Returns the canonical basis of a simple extension L/K , that is, the elements 1,a,\\dotsc,a^{d - 1} , where d is the degree of K and a the primitive element. basis ( L :: NonSimpleNumField ) -> Vector { NumFieldElem } Returns the canonical basis of a non-simple extension L/K . If L = K(a_1,\\dotsc,a_n) where each a_i has degree d_i , then the basis will be a_1^{i_1}\\dotsm a_d^{i_d} with 0 \\leq i_j d_j - 1 for 1 \\leq j \\leq n . issimple ( L :: NumField ) -> Bool Given a number field L/K this function returns whether L is simple, that is, whether L/K is defined by a univariate polynomial$. isabsolute ( L :: NumField ) -> Bool Returns whether L is an absolute extension, that is, whether the base field of L is \\mathbf{Q} . degree ( L :: NumField ) -> Int Given a number field L/K , this function returns the degree of L over K . discriminant ( L :: SimpleNumField ) -> NumFieldElem The discriminant of the defining polynomial of L , not the discriminant of the maximal order of L . absolute_discriminant ( L :: SimpleNumField , QQ ) -> fmpq The absolute discriminant of the defining polynomial of L , not the discriminant of the maximal order of L . This is the norm of the discriminant times the d -th power of the discriminant of the base field, where d is the degree of L . defining_polynomial ( L :: SimpleNumField ) -> PolyElem Given a simple number field L/K , constructed as L = K[x]/(f) , this function returns f .","title":"Invariants"},{"location":"number_fields/basics/#subfields","text":"issubfield ( K :: SimpleNumField , L :: SimpleNumField ) -> Bool , Map Returns true and an injection from K to L if K is a subfield of L . Otherwise the function returns false and a morphism mapping everything to 0 . isisomorphic ( K :: SimpleNumField , L :: SimpleNumField ) -> Bool , Map Returns true and an isomorphism from K to L if K and L are isomorphic. Otherwise the function returns false and a morphism mapping everything to 0 .","title":"Subfields"},{"location":"number_fields/elements/","text":"Elements Creation gen ( L :: SimpleNumField ) -> NumFieldElem Given a simple number field L = K[x]/(x) over K , this functions returns the class of x , which is the canonical primitive element of L over K . gens ( L :: NonSimpleNumField ) -> Vector { NumFieldElem } Given a non-simple number field L = K[x_1,\\dotsc,x_n]/(f_1,\\dotsc,f_n) over K , this functions returns the list \\bar x_1,\\dotsc,\\bar x_n . Predicates isintegral ( a :: NumFieldElem ) -> Bool Returns whether a is integral, that is, whether the minimal polynomial of a has integral coefficients. Invariants norm ( a :: NumFieldElem ) -> NumFieldElem Returns the norm of an element a of a number field extension L/K . This will be an element of K . minpoly ( a :: NumFieldElem ) -> PolyElem Given a number field element a of a number field K , this function returns the minimal polynomial of a over the base field of K . absolute_minpoly ( a :: NumFieldElem ) -> PolyElem Given a number field element a of a number field K , this function returns the minimal polynomial of a over the rationals \\mathbf{Q} . charpoly ( a :: NumFieldElem ) -> PolyElem Given a number field element a of a number field K , this function returns the characteristic polynomial of a over the base field of K . absolute_charpoly ( a :: NumFieldElem ) -> PolyElem Given a number field element a of a number field K , this function returns the characteristic polynomial of a over the rationals \\mathbf{Q} . Implicit Relative Extensions Given two absolute fields K and k as well as an embedding \\phi:k \\to K we can regard K as an extension on k , hence invariante of K can be investigated relative to k rathern than over Q . Here we list functions achieving this without actually computing K as an extension of k . minimum ( m :: T , I :: NfOrdIdl ) where T <: Map { AnticNumberField , AnticNumberField } -> NfOrdIdl Given an embedding m:k\\to K of number fields and an integral ideal in K , find the intersect I \\cap \\mathbf{Z}_k . norm ( m :: T , I :: NfOrdIdl ) where T <: Map { AnticNumberField , AnticNumberField } -> NfOrdIdl Given an embedding m:k\\to K of number fields and an integral ideal in K , find the norm N_{K/k}(I) . norm ( m :: T , a :: nf_elem ) where T <: Map { AnticNumberField , AnticNumberField } -> nf_elem Given an embedding m:k\\to K of number fields and an element in K , find the norm N_{K/k}(a) . discriminant ( m :: Map , R :: NfOrd ) -> NfOrdIdl The discriminant ideal of R over the maximal order of the domain of the map m , that is, the ideal generated by all norms of differents of elements in R .","title":"Elements"},{"location":"number_fields/elements/#elements","text":"","title":"Elements"},{"location":"number_fields/elements/#creation","text":"gen ( L :: SimpleNumField ) -> NumFieldElem Given a simple number field L = K[x]/(x) over K , this functions returns the class of x , which is the canonical primitive element of L over K . gens ( L :: NonSimpleNumField ) -> Vector { NumFieldElem } Given a non-simple number field L = K[x_1,\\dotsc,x_n]/(f_1,\\dotsc,f_n) over K , this functions returns the list \\bar x_1,\\dotsc,\\bar x_n .","title":"Creation"},{"location":"number_fields/elements/#predicates","text":"isintegral ( a :: NumFieldElem ) -> Bool Returns whether a is integral, that is, whether the minimal polynomial of a has integral coefficients.","title":"Predicates"},{"location":"number_fields/elements/#invariants","text":"norm ( a :: NumFieldElem ) -> NumFieldElem Returns the norm of an element a of a number field extension L/K . This will be an element of K . minpoly ( a :: NumFieldElem ) -> PolyElem Given a number field element a of a number field K , this function returns the minimal polynomial of a over the base field of K . absolute_minpoly ( a :: NumFieldElem ) -> PolyElem Given a number field element a of a number field K , this function returns the minimal polynomial of a over the rationals \\mathbf{Q} . charpoly ( a :: NumFieldElem ) -> PolyElem Given a number field element a of a number field K , this function returns the characteristic polynomial of a over the base field of K . absolute_charpoly ( a :: NumFieldElem ) -> PolyElem Given a number field element a of a number field K , this function returns the characteristic polynomial of a over the rationals \\mathbf{Q} .","title":"Invariants"},{"location":"number_fields/elements/#implicit-relative-extensions","text":"Given two absolute fields K and k as well as an embedding \\phi:k \\to K we can regard K as an extension on k , hence invariante of K can be investigated relative to k rathern than over Q . Here we list functions achieving this without actually computing K as an extension of k . minimum ( m :: T , I :: NfOrdIdl ) where T <: Map { AnticNumberField , AnticNumberField } -> NfOrdIdl Given an embedding m:k\\to K of number fields and an integral ideal in K , find the intersect I \\cap \\mathbf{Z}_k . norm ( m :: T , I :: NfOrdIdl ) where T <: Map { AnticNumberField , AnticNumberField } -> NfOrdIdl Given an embedding m:k\\to K of number fields and an integral ideal in K , find the norm N_{K/k}(I) . norm ( m :: T , a :: nf_elem ) where T <: Map { AnticNumberField , AnticNumberField } -> nf_elem Given an embedding m:k\\to K of number fields and an element in K , find the norm N_{K/k}(a) . discriminant ( m :: Map , R :: NfOrd ) -> NfOrdIdl The discriminant ideal of R over the maximal order of the domain of the map m , that is, the ideal generated by all norms of differents of elements in R .","title":"Implicit Relative Extensions"},{"location":"number_fields/internal/","text":"Number fields, in Hecke, come in several different types: AnticNumberField : a finite simple extension of the rational numbers Q NfAbsNS : a finite extension of Q given by several polynomials. We will refer to this as a non-simple field - even though mathematically we can find a primitive elements. NfRel : a finite simple extension of a number field. This is actually parametried by the (element) type of the coefficient field. The complete type of an extension of an absolute field ( AnticNumberField ) is NfRel{nf_elem} . The next extension thus will be NfRel{NfRelElem{nf_elem}} . NfRelNS : extensions of number fields given by several polynomials. This too will be refered to as a non-simple field. The simple types AnticNumberField and NfRel are also calle simple fields in the rest of this document, NfRel and NfRelNS are referred to as relative extensions while AnticNumberField and NfAbsNS are called absolute. Internally, simple fields are essentially just (univariate) polynomial quotients in a dense representation, while non-simple fields are multivariate quotient rings, thus have a sparse presentation. In general, simple fields allow much faster arithmetic, while the non-simple fields give easy access to large degree fields. Absolute Simple Fields The most basic number field type is that of AnticNumberField . Internally this is essentially represented as a unvariate quotient with the arithmetic provided by the antic-c-library and implemented in Nemo.","title":"Internals"},{"location":"number_fields/internal/#absolute-simple-fields","text":"The most basic number field type is that of AnticNumberField . Internally this is essentially represented as a unvariate quotient with the arithmetic provided by the antic-c-library and implemented in Nemo.","title":"Absolute Simple Fields"},{"location":"number_fields/intro/","text":"Number Fields Introduction By definition, mathematically a number field is just a finite extension of the rational \\mathbf{Q} . In Hecke, a number field L is recursively defined as being the field of rational numbers \\mathbf{Q} or a finite extension of a number field K . In the second case, the extension can be defined in the one of the following two ways: We have L = K[x]/(f) , where f \\in K[x] is an irreducible polynomial ( simple extension ), or We have L = K[x_1,\\dotsc,x_n]/(f_1(x_1),\\dotsc,f_n(x_n)) , where f_1,\\dotsc,f_n \\in K[x] are univariate polynomials ( non-simple extension ). In both cases we refer to K as the base field of the number field L . Another useful dichotomy comes from the type of the base field. We call L an absolute number field, if the base field is equal to the rational numbers \\mathbf{Q} . Types The abstract type for number fields is NumField . For simple number fields the type is SimpleNumField , where as for non-simple number fields the type is NonSimpleNumField .","title":"Introduction"},{"location":"number_fields/intro/#number-fields","text":"","title":"Number Fields"},{"location":"number_fields/intro/#introduction","text":"By definition, mathematically a number field is just a finite extension of the rational \\mathbf{Q} . In Hecke, a number field L is recursively defined as being the field of rational numbers \\mathbf{Q} or a finite extension of a number field K . In the second case, the extension can be defined in the one of the following two ways: We have L = K[x]/(f) , where f \\in K[x] is an irreducible polynomial ( simple extension ), or We have L = K[x_1,\\dotsc,x_n]/(f_1(x_1),\\dotsc,f_n(x_n)) , where f_1,\\dotsc,f_n \\in K[x] are univariate polynomials ( non-simple extension ). In both cases we refer to K as the base field of the number field L . Another useful dichotomy comes from the type of the base field. We call L an absolute number field, if the base field is equal to the rational numbers \\mathbf{Q} .","title":"Introduction"},{"location":"number_fields/intro/#types","text":"The abstract type for number fields is NumField . For simple number fields the type is SimpleNumField , where as for non-simple number fields the type is NonSimpleNumField .","title":"Types"},{"location":"orders/elements/","text":"Elements Elements in orders have two representations: they can be viewed as elements in the Z^n giving the coefficients wrt to the order basis where they are elements in. On the other hand, as every order is in a field, they also have a representation as number field elements. Since, asymptotically, operations are more efficient in the field (due to fast polynomial arithmetic) than in the order, the primary representation is that as a field element. Creation Elements are constructed either as linear combinations of basis elements or via explicit coercion. Elements will be of type NfOrdElem , the type if actually parametrized by the type of the surrounding field and the type of the field elements. E.g. the type of any element in any order of an absolute simple field will be NfAbsOrdElem{AnticNumberField,nf_elem} ( O :: NfOrd )( a :: Union { fmpz , Integer }) -> NfAbsOrdElem Given an element a of type fmpz or Integer , this function coerces the element into \\mathcal O . It will be checked that a is contained in \\mathcal O if and only if check is true . (O::NfOrd)(arr::Array{fmpz, 1}) Returns the element of \\mathcal O with coefficient vector arr . (O::NfOrd)() -> NfAbsOrdElem This function constructs a new element of \\mathcal O which is set to 0 . Basic properties parent ( g :: Perm ) Return the parent of the permutation g . julia> G = SymmetricGroup(5); g = Perm([3,4,5,2,1]) (1,3,5)(2,4) julia> parent(g) == G true parent(a::AbstractAlgebra.MatElem{T}, cached::Bool = true) where T <: RingElement Return the parent object of the given matrix. parent(a::AbstractAlgebra.MatAlgElem{T}, cached::Bool = true) where T <: RingElement Return the parent object of the given matrix. parent(a::NfAbsOrdElem) -> NfOrd Returns the order of which a is an element. elem_in_nf ( a :: NfAbsOrdElem ) -> nf_elem Returns the element a considered as an element of the ambient number field. coordinates ( a :: NfAbsOrdElem ) -> Array { fmpz , 1 } Returns the coefficient vector of a . discriminant ( B :: Array { NfAbsOrdElem , 1 }) -> fmpz Returns the discriminant of the family B . discriminant(E::EllCrv{T}) -> T Computes the discriminant of E . discriminant(O::AlgssRelOrd) Returns the discriminant of O . == ( x :: NfAbsOrdElem , y :: NfAbsOrdElem ) -> Bool Returns whether x and y are equal. zero ( O :: NfOrd ) -> NfAbsOrdElem Returns the zero element of \\mathcal O . one ( O :: NfOrd ) -> NfAbsOrdElem Returns the one element of \\mathcal O . iszero ( v :: AbstractAlgebra . FPModuleElem { T }) where T <: RingElement Return true if v is the zero element of the module M . iszero(a::NfOrd) -> Bool Tests if a is zero. isone ( a :: NfOrd ) -> Bool Tests if a is one. Arithmetic - ( x :: T , y :: Generic . MatrixElem { T }) where { T <: RingElem } Return S(x) - y where S is the parent of y . -(x::Generic.MatrixElem{T}, y::T) where {T <: RingElem} Return x - S(y) , where S is the parent of a . -(x::NfAbsOrdElem) -> NfAbsOrdElem Returns the additive inverse of x . - ( A :: SMat , B :: SMat ) -> SMat Return the difference A - B . -(A::SRow, B::SRow) -> SRow Returns the difference of A and B . -(A::SRow) -> SRow Returns the negative of A . -(a::AbsAlgAssElem) -> AbsAlgAssElem Returns -a . -(a::AbsAlgAssElem, b::AbsAlgAssElem) -> AbsAlgAssElem Return a - b . -(a::AlgMatElem, b::AlgMatElem) -> AlgMatElem Return a - b . + ( x :: NfAbsOrdElem , y :: NfAbsOrdElem ) -> NfAbsOrdElem Returns x + y . - ( x :: NfAbsOrdElem , y :: NfAbsOrdElem ) -> NfAbsOrdElem Returns x - y . * ( x :: NfAbsOrdElem , y :: NfAbsOrdElem ) -> NfAbsOrdElem Returns x \\cdot y . ^ ( x :: NfAbsOrdElem , y :: Int ) Returns x^y . mod ( a :: NfAbsOrdElem , m :: Union { fmpz , Int }) -> NfAbsOrdElem Reduces the coefficient vector of a modulo m and returns the corresponding element. The coefficient vector of the result will have entries x with 0 \\leq x \\leq m . powermod ( a :: NfAbsOrdElem , i :: fmpz , m :: Integer ) -> NfAbsOrdElem Returns the element a^i modulo m . Miscellaneous representation_matrix ( a :: NfAbsOrdElem ) -> fmpz_mat Returns the representation matrix of the element a . representation_matrix ( a :: NfAbsOrdElem , K :: AnticNumberField ) -> FakeFmpqMat Returns the representation matrix of the element a considered as an element of the ambient number field K . It is assumed that K is the ambient number field of the order of a . representation_matrix ( a :: NfAbsOrdElem , K :: AnticNumberField ) -> FakeFmpqMat Returns the representation matrix of the element a considered as an element of the ambient number field K . It is assumed that K is the ambient number field of the order of a . tr ( a :: NfAbsOrdElem ) -> fmpz Returns the trace of a . tr(x::AbsAlgAssElem{T}) where T -> T Returns the trace of x . norm ( a :: NfRelOrdIdl ) -> NfOrdIdl Returns the norm of a . norm(a::NfRelOrdFracIdl{T, S}) -> S Returns the norm of a . norm(a::NfAbsOrdElem) -> fmpz Returns the norm of a . norm(a::AlgAssAbsOrdIdl, O::AlgAssAbsOrd; copy::Bool = true) -> fmpq Returns the norm of a considered as an (possibly fractional) ideal of O . norm(a::AlgAssRelOrdIdl{S, T, U}, O::AlgAssRelOrd{S, T, U}; copy::Bool = true) where { S, T, U } -> T Returns the norm of a considered as an (possibly fractional) ideal of O . rand ( O :: NfOrd , n :: Union { Integer , fmpz }) -> NfAbsOrdElem Computes a coefficient vector with entries uniformly distributed in \\{-n,\\dotsc,-1,0,1,\\dotsc,n\\} and returns the corresponding element of the order \\mathcal O . minkowski_map ( a :: NfAbsOrdElem , abs_tol :: Int ) -> Array { arb , 1 } Returns the image of a under the Minkowski embedding. Every entry of the array returned is of type arb with radius less then 2^-abs_tol . conjugates_arb ( x :: NfAbsOrdElem , abs_tol :: Int ) -> Array { acb , 1 } Compute the conjugates of x as elements of type acb . Recall that we order the complex conjugates \\sigma_{r+1}(x),...,\\sigma_{r+2s}(x) such that \\sigma_{i}(x) = \\overline{\\sigma_{i + s}(x)} for r + 2 \\leq i \\leq r + s . Every entry y of the array returned satisfies radius(real(y)) < 2^-abs_tol , radius(imag(y)) < 2^-abs_tol respectively. conjugates_arb_log ( x :: NfAbsOrdElem , abs_tol :: Int ) -> Array { arb , 1 } Returns the elements (\\log(\\lvert \\sigma_1(x) \\rvert),\\dotsc,\\log(\\lvert\\sigma_r(x) \\rvert), \\dotsc,2\\log(\\lvert \\sigma_{r+1}(x) \\rvert),\\dotsc, 2\\log(\\lvert \\sigma_{r+s}(x)\\rvert)) as elements of type arb radius less then 2^-abs_tol . t2 ( x :: NfAbsOrdElem , abs_tol :: Int = 32 ) -> arb Return the T_2 -norm of x . The radius of the result will be less than 2^-abs_tol . minpoly ( S :: Ring , M :: MatElem { T }, charpoly_only :: Bool = false ) where { T <: RingElement } Return the minimal polynomial p of the matrix M . The polynomial ring S of the resulting polynomial must be supplied and the matrix must be square. minpoly(S::Ring, M::MatAlgElem{T}, charpoly_only::Bool = false) where {T <: RingElement} Return the minimal polynomial p of the matrix M . The polynomial ring S of the resulting polynomial must be supplied and the matrix must be square. minpoly(a::NfRelElem) -> PolyElem Given an element a in an extension L/K , this function returns the minimal polynomial of a over K . minpoly(a::NfAbsOrdElem) -> fmpz_poly The minimal polynomial of a . charpoly ( V :: Ring , Y :: Generic . MatrixElem { T }) where { T <: RingElement } Return the characteristic polynomial p of the matrix M . The polynomial ring R of the resulting polynomial must be supplied and the matrix is assumed to be square. charpoly(a::NfAbsOrdElem) -> fmpz_poly charpoly(a::NfAbsOrdElem, FlintZZ) -> fmpz_poly The characteristic polynomial of a . factor ( a :: NfOrdElem ) -> Fac { NfOrdElem } Computes a factorization of a into irreducible elements. The return value is a factorization fac , which satisfies a = unit(fac) * prod(p^e for (p, e) in fac) . The function requires that a is non-zero and that all prime ideals containing a are principal, which is for example satisfied if class group of the order of a is trivial.","title":"Elements"},{"location":"orders/elements/#elements","text":"Elements in orders have two representations: they can be viewed as elements in the Z^n giving the coefficients wrt to the order basis where they are elements in. On the other hand, as every order is in a field, they also have a representation as number field elements. Since, asymptotically, operations are more efficient in the field (due to fast polynomial arithmetic) than in the order, the primary representation is that as a field element.","title":"Elements"},{"location":"orders/elements/#creation","text":"Elements are constructed either as linear combinations of basis elements or via explicit coercion. Elements will be of type NfOrdElem , the type if actually parametrized by the type of the surrounding field and the type of the field elements. E.g. the type of any element in any order of an absolute simple field will be NfAbsOrdElem{AnticNumberField,nf_elem} ( O :: NfOrd )( a :: Union { fmpz , Integer }) -> NfAbsOrdElem Given an element a of type fmpz or Integer , this function coerces the element into \\mathcal O . It will be checked that a is contained in \\mathcal O if and only if check is true . (O::NfOrd)(arr::Array{fmpz, 1}) Returns the element of \\mathcal O with coefficient vector arr . (O::NfOrd)() -> NfAbsOrdElem This function constructs a new element of \\mathcal O which is set to 0 .","title":"Creation"},{"location":"orders/elements/#basic-properties","text":"parent ( g :: Perm ) Return the parent of the permutation g . julia> G = SymmetricGroup(5); g = Perm([3,4,5,2,1]) (1,3,5)(2,4) julia> parent(g) == G true parent(a::AbstractAlgebra.MatElem{T}, cached::Bool = true) where T <: RingElement Return the parent object of the given matrix. parent(a::AbstractAlgebra.MatAlgElem{T}, cached::Bool = true) where T <: RingElement Return the parent object of the given matrix. parent(a::NfAbsOrdElem) -> NfOrd Returns the order of which a is an element. elem_in_nf ( a :: NfAbsOrdElem ) -> nf_elem Returns the element a considered as an element of the ambient number field. coordinates ( a :: NfAbsOrdElem ) -> Array { fmpz , 1 } Returns the coefficient vector of a . discriminant ( B :: Array { NfAbsOrdElem , 1 }) -> fmpz Returns the discriminant of the family B . discriminant(E::EllCrv{T}) -> T Computes the discriminant of E . discriminant(O::AlgssRelOrd) Returns the discriminant of O . == ( x :: NfAbsOrdElem , y :: NfAbsOrdElem ) -> Bool Returns whether x and y are equal. zero ( O :: NfOrd ) -> NfAbsOrdElem Returns the zero element of \\mathcal O . one ( O :: NfOrd ) -> NfAbsOrdElem Returns the one element of \\mathcal O . iszero ( v :: AbstractAlgebra . FPModuleElem { T }) where T <: RingElement Return true if v is the zero element of the module M . iszero(a::NfOrd) -> Bool Tests if a is zero. isone ( a :: NfOrd ) -> Bool Tests if a is one.","title":"Basic properties"},{"location":"orders/elements/#arithmetic","text":"- ( x :: T , y :: Generic . MatrixElem { T }) where { T <: RingElem } Return S(x) - y where S is the parent of y . -(x::Generic.MatrixElem{T}, y::T) where {T <: RingElem} Return x - S(y) , where S is the parent of a . -(x::NfAbsOrdElem) -> NfAbsOrdElem Returns the additive inverse of x . - ( A :: SMat , B :: SMat ) -> SMat Return the difference A - B . -(A::SRow, B::SRow) -> SRow Returns the difference of A and B . -(A::SRow) -> SRow Returns the negative of A . -(a::AbsAlgAssElem) -> AbsAlgAssElem Returns -a . -(a::AbsAlgAssElem, b::AbsAlgAssElem) -> AbsAlgAssElem Return a - b . -(a::AlgMatElem, b::AlgMatElem) -> AlgMatElem Return a - b . + ( x :: NfAbsOrdElem , y :: NfAbsOrdElem ) -> NfAbsOrdElem Returns x + y . - ( x :: NfAbsOrdElem , y :: NfAbsOrdElem ) -> NfAbsOrdElem Returns x - y . * ( x :: NfAbsOrdElem , y :: NfAbsOrdElem ) -> NfAbsOrdElem Returns x \\cdot y . ^ ( x :: NfAbsOrdElem , y :: Int ) Returns x^y . mod ( a :: NfAbsOrdElem , m :: Union { fmpz , Int }) -> NfAbsOrdElem Reduces the coefficient vector of a modulo m and returns the corresponding element. The coefficient vector of the result will have entries x with 0 \\leq x \\leq m . powermod ( a :: NfAbsOrdElem , i :: fmpz , m :: Integer ) -> NfAbsOrdElem Returns the element a^i modulo m .","title":"Arithmetic"},{"location":"orders/elements/#miscellaneous","text":"representation_matrix ( a :: NfAbsOrdElem ) -> fmpz_mat Returns the representation matrix of the element a . representation_matrix ( a :: NfAbsOrdElem , K :: AnticNumberField ) -> FakeFmpqMat Returns the representation matrix of the element a considered as an element of the ambient number field K . It is assumed that K is the ambient number field of the order of a . representation_matrix ( a :: NfAbsOrdElem , K :: AnticNumberField ) -> FakeFmpqMat Returns the representation matrix of the element a considered as an element of the ambient number field K . It is assumed that K is the ambient number field of the order of a . tr ( a :: NfAbsOrdElem ) -> fmpz Returns the trace of a . tr(x::AbsAlgAssElem{T}) where T -> T Returns the trace of x . norm ( a :: NfRelOrdIdl ) -> NfOrdIdl Returns the norm of a . norm(a::NfRelOrdFracIdl{T, S}) -> S Returns the norm of a . norm(a::NfAbsOrdElem) -> fmpz Returns the norm of a . norm(a::AlgAssAbsOrdIdl, O::AlgAssAbsOrd; copy::Bool = true) -> fmpq Returns the norm of a considered as an (possibly fractional) ideal of O . norm(a::AlgAssRelOrdIdl{S, T, U}, O::AlgAssRelOrd{S, T, U}; copy::Bool = true) where { S, T, U } -> T Returns the norm of a considered as an (possibly fractional) ideal of O . rand ( O :: NfOrd , n :: Union { Integer , fmpz }) -> NfAbsOrdElem Computes a coefficient vector with entries uniformly distributed in \\{-n,\\dotsc,-1,0,1,\\dotsc,n\\} and returns the corresponding element of the order \\mathcal O . minkowski_map ( a :: NfAbsOrdElem , abs_tol :: Int ) -> Array { arb , 1 } Returns the image of a under the Minkowski embedding. Every entry of the array returned is of type arb with radius less then 2^-abs_tol . conjugates_arb ( x :: NfAbsOrdElem , abs_tol :: Int ) -> Array { acb , 1 } Compute the conjugates of x as elements of type acb . Recall that we order the complex conjugates \\sigma_{r+1}(x),...,\\sigma_{r+2s}(x) such that \\sigma_{i}(x) = \\overline{\\sigma_{i + s}(x)} for r + 2 \\leq i \\leq r + s . Every entry y of the array returned satisfies radius(real(y)) < 2^-abs_tol , radius(imag(y)) < 2^-abs_tol respectively. conjugates_arb_log ( x :: NfAbsOrdElem , abs_tol :: Int ) -> Array { arb , 1 } Returns the elements (\\log(\\lvert \\sigma_1(x) \\rvert),\\dotsc,\\log(\\lvert\\sigma_r(x) \\rvert), \\dotsc,2\\log(\\lvert \\sigma_{r+1}(x) \\rvert),\\dotsc, 2\\log(\\lvert \\sigma_{r+s}(x)\\rvert)) as elements of type arb radius less then 2^-abs_tol . t2 ( x :: NfAbsOrdElem , abs_tol :: Int = 32 ) -> arb Return the T_2 -norm of x . The radius of the result will be less than 2^-abs_tol . minpoly ( S :: Ring , M :: MatElem { T }, charpoly_only :: Bool = false ) where { T <: RingElement } Return the minimal polynomial p of the matrix M . The polynomial ring S of the resulting polynomial must be supplied and the matrix must be square. minpoly(S::Ring, M::MatAlgElem{T}, charpoly_only::Bool = false) where {T <: RingElement} Return the minimal polynomial p of the matrix M . The polynomial ring S of the resulting polynomial must be supplied and the matrix must be square. minpoly(a::NfRelElem) -> PolyElem Given an element a in an extension L/K , this function returns the minimal polynomial of a over K . minpoly(a::NfAbsOrdElem) -> fmpz_poly The minimal polynomial of a . charpoly ( V :: Ring , Y :: Generic . MatrixElem { T }) where { T <: RingElement } Return the characteristic polynomial p of the matrix M . The polynomial ring R of the resulting polynomial must be supplied and the matrix is assumed to be square. charpoly(a::NfAbsOrdElem) -> fmpz_poly charpoly(a::NfAbsOrdElem, FlintZZ) -> fmpz_poly The characteristic polynomial of a . factor ( a :: NfOrdElem ) -> Fac { NfOrdElem } Computes a factorization of a into irreducible elements. The return value is a factorization fac , which satisfies a = unit(fac) * prod(p^e for (p, e) in fac) . The function requires that a is non-zero and that all prime ideals containing a are principal, which is for example satisfied if class group of the order of a is trivial.","title":"Miscellaneous"},{"location":"orders/frac_ideals/","text":"Fractional ideals A fractional ideal in the number field K is a Z_K -module A such that there exists an integer d>0 wich dA is an (integral) ideal in Z_K . Due to the Dedekind property of Z_K , the ideals for a multiplicative group. Fractional ideals are represented as an integral ideal and an additional denominator. They are of type NfOrdFracIdl . Creation fractional_ideal ( O :: NfAbsOrd , A :: fmpz_mat , b :: fmpz , A_in_hnf :: Bool = false ) -> NfAbsOrdFracIdl Creates the fractional ideal of \\mathcal O with basis matrix A/b . If A_in_hnf is set, then it is assumed that A is already in lower left HNF. fractional_ideal ( O :: NfAbsOrd , A :: fmpz_mat , b :: fmpz , A_in_hnf :: Bool = false ) -> NfAbsOrdFracIdl Creates the fractional ideal of \\mathcal O with basis matrix A/b . If A_in_hnf is set, then it is assumed that A is already in lower left HNF. fractional_ideal ( O :: NfAbsOrd , A :: FakeFmpqMat , A_in_hnf :: Bool = false ) -> NfAbsOrdFracIdl Creates the fractional ideal of \\mathcal O with basis matrix A . If A_in_hnf is set, then it is assumed that the numerator of A is already in lower left HNF. fractional_ideal ( O :: NfOrd , I :: NfAbsOrdIdl ) -> NfOrdFracIdl The fractional ideal of O generated by a Z -basis of I . fractional_ideal(O::NfAbsOrd, I::NfAbsOrdIdl) -> NfAbsOrdFracIdl Turns the ideal I into a fractional ideal of \\mathcal O . fractional_ideal ( O :: NfAbsOrd , I :: NfAbsOrdIdl , b :: fmpz ) -> NfAbsOrdFracIdl Creates the fractional ideal I/b of \\mathcal O . fractional_ideal ( O :: NfAbsOrd , a :: nf_elem ) -> NfAbsOrdFracIdl Creates the principal fractional ideal (a) of \\mathcal O . fractional_ideal ( O :: NfAbsOrd , a :: NfAbsOrdElem ) -> NfAbsOrdFracIdl Creates the principal fractional ideal (a) of \\mathcal O . inv ( a :: LocElem { T }, checked :: Bool = true ) where { T <: RingElem } Returns the inverse element of a if a is a unit. If 'checked = false' the invertibility of a is not checked and the corresponding inverse element of the Fraction Field is returned. inv(a::NfRelOrdIdl) -> NfRelOrdFracIdl inv(a::NfRelOrdFracIdl) -> NfRelOrdFracIdl Computes the inverse of a , that is, the fractional ideal b such that ab = O , where O is the ambient order of a . O must be maximal. inv(A::NfAbsOrdIdl) -> NfOrdFracIdl Computes the inverse of A , that is, the fractional ideal B such that AB = \\mathcal O_K . Arithmetic == ( x :: NfAbsOrdFracIdl , y :: NfAbsOrdFracIdl ) -> Bool Returns whether x and y are equal. inv ( a :: LocElem { T }, checked :: Bool = true ) where { T <: RingElem } Returns the inverse element of a if a is a unit. If 'checked = false' the invertibility of a is not checked and the corresponding inverse element of the Fraction Field is returned. inv(a::NfRelOrdIdl) -> NfRelOrdFracIdl inv(a::NfRelOrdFracIdl) -> NfRelOrdFracIdl Computes the inverse of a , that is, the fractional ideal b such that ab = O , where O is the ambient order of a . O must be maximal. inv(A::NfAbsOrdFracIdl) -> NfAbsOrdFracIdl Returns the fractional ideal B such that AB = \\mathcal O . integral_split ( A :: NfAbsOrdFracIdl ) -> NfAbsOrdIdl , NfAbsOrdIdl Computes the unique coprime integral ideals N and D s.th. A = ND^{-1} Miscaellenous order ( a :: NfAbsOrdFracIdl ) -> NfAbsOrd The order that was used to define the ideal a . basis_matrix ( I :: NfAbsOrdFracIdl ) -> FakeFmpqMat Returns the basis matrix of I with respect to the basis of the order. basis_mat_inv ( O :: NfOrd ) -> FakeFmpqMat Returns the inverse of the basis matrix of \\mathcal O . basis_mat_inv(A::NfAbsOrdIdl) -> fmpz_mat Returns the inverse basis matrix of A . basis_mat_inv(I::NfAbsOrdFracIdl) -> FakeFmpqMat Returns the inverse of the basis matrix of I . basis ( I :: NfAbsOrdFracIdl ) -> Array { nf_elem , 1 } Returns the \\mathbf Z -basis of I . norm ( a :: NfRelOrdIdl ) -> NfOrdIdl Returns the norm of a . norm(a::NfRelOrdFracIdl{T, S}) -> S Returns the norm of a . norm(I::NfAbsOrdFracIdl) -> fmpq Returns the norm of I . norm(a::AlgAssAbsOrdIdl, O::AlgAssAbsOrd; copy::Bool = true) -> fmpq Returns the norm of a considered as an (possibly fractional) ideal of O . norm(a::AlgAssRelOrdIdl{S, T, U}, O::AlgAssRelOrd{S, T, U}; copy::Bool = true) where { S, T, U } -> T Returns the norm of a considered as an (possibly fractional) ideal of O .","title":"Fractional Ideals"},{"location":"orders/frac_ideals/#fractional-ideals","text":"A fractional ideal in the number field K is a Z_K -module A such that there exists an integer d>0 wich dA is an (integral) ideal in Z_K . Due to the Dedekind property of Z_K , the ideals for a multiplicative group. Fractional ideals are represented as an integral ideal and an additional denominator. They are of type NfOrdFracIdl .","title":"Fractional ideals"},{"location":"orders/frac_ideals/#creation","text":"fractional_ideal ( O :: NfAbsOrd , A :: fmpz_mat , b :: fmpz , A_in_hnf :: Bool = false ) -> NfAbsOrdFracIdl Creates the fractional ideal of \\mathcal O with basis matrix A/b . If A_in_hnf is set, then it is assumed that A is already in lower left HNF. fractional_ideal ( O :: NfAbsOrd , A :: fmpz_mat , b :: fmpz , A_in_hnf :: Bool = false ) -> NfAbsOrdFracIdl Creates the fractional ideal of \\mathcal O with basis matrix A/b . If A_in_hnf is set, then it is assumed that A is already in lower left HNF. fractional_ideal ( O :: NfAbsOrd , A :: FakeFmpqMat , A_in_hnf :: Bool = false ) -> NfAbsOrdFracIdl Creates the fractional ideal of \\mathcal O with basis matrix A . If A_in_hnf is set, then it is assumed that the numerator of A is already in lower left HNF. fractional_ideal ( O :: NfOrd , I :: NfAbsOrdIdl ) -> NfOrdFracIdl The fractional ideal of O generated by a Z -basis of I . fractional_ideal(O::NfAbsOrd, I::NfAbsOrdIdl) -> NfAbsOrdFracIdl Turns the ideal I into a fractional ideal of \\mathcal O . fractional_ideal ( O :: NfAbsOrd , I :: NfAbsOrdIdl , b :: fmpz ) -> NfAbsOrdFracIdl Creates the fractional ideal I/b of \\mathcal O . fractional_ideal ( O :: NfAbsOrd , a :: nf_elem ) -> NfAbsOrdFracIdl Creates the principal fractional ideal (a) of \\mathcal O . fractional_ideal ( O :: NfAbsOrd , a :: NfAbsOrdElem ) -> NfAbsOrdFracIdl Creates the principal fractional ideal (a) of \\mathcal O . inv ( a :: LocElem { T }, checked :: Bool = true ) where { T <: RingElem } Returns the inverse element of a if a is a unit. If 'checked = false' the invertibility of a is not checked and the corresponding inverse element of the Fraction Field is returned. inv(a::NfRelOrdIdl) -> NfRelOrdFracIdl inv(a::NfRelOrdFracIdl) -> NfRelOrdFracIdl Computes the inverse of a , that is, the fractional ideal b such that ab = O , where O is the ambient order of a . O must be maximal. inv(A::NfAbsOrdIdl) -> NfOrdFracIdl Computes the inverse of A , that is, the fractional ideal B such that AB = \\mathcal O_K .","title":"Creation"},{"location":"orders/frac_ideals/#arithmetic","text":"== ( x :: NfAbsOrdFracIdl , y :: NfAbsOrdFracIdl ) -> Bool Returns whether x and y are equal. inv ( a :: LocElem { T }, checked :: Bool = true ) where { T <: RingElem } Returns the inverse element of a if a is a unit. If 'checked = false' the invertibility of a is not checked and the corresponding inverse element of the Fraction Field is returned. inv(a::NfRelOrdIdl) -> NfRelOrdFracIdl inv(a::NfRelOrdFracIdl) -> NfRelOrdFracIdl Computes the inverse of a , that is, the fractional ideal b such that ab = O , where O is the ambient order of a . O must be maximal. inv(A::NfAbsOrdFracIdl) -> NfAbsOrdFracIdl Returns the fractional ideal B such that AB = \\mathcal O . integral_split ( A :: NfAbsOrdFracIdl ) -> NfAbsOrdIdl , NfAbsOrdIdl Computes the unique coprime integral ideals N and D s.th. A = ND^{-1}","title":"Arithmetic"},{"location":"orders/frac_ideals/#miscaellenous","text":"order ( a :: NfAbsOrdFracIdl ) -> NfAbsOrd The order that was used to define the ideal a . basis_matrix ( I :: NfAbsOrdFracIdl ) -> FakeFmpqMat Returns the basis matrix of I with respect to the basis of the order. basis_mat_inv ( O :: NfOrd ) -> FakeFmpqMat Returns the inverse of the basis matrix of \\mathcal O . basis_mat_inv(A::NfAbsOrdIdl) -> fmpz_mat Returns the inverse basis matrix of A . basis_mat_inv(I::NfAbsOrdFracIdl) -> FakeFmpqMat Returns the inverse of the basis matrix of I . basis ( I :: NfAbsOrdFracIdl ) -> Array { nf_elem , 1 } Returns the \\mathbf Z -basis of I . norm ( a :: NfRelOrdIdl ) -> NfOrdIdl Returns the norm of a . norm(a::NfRelOrdFracIdl{T, S}) -> S Returns the norm of a . norm(I::NfAbsOrdFracIdl) -> fmpq Returns the norm of I . norm(a::AlgAssAbsOrdIdl, O::AlgAssAbsOrd; copy::Bool = true) -> fmpq Returns the norm of a considered as an (possibly fractional) ideal of O . norm(a::AlgAssRelOrdIdl{S, T, U}, O::AlgAssRelOrd{S, T, U}; copy::Bool = true) where { S, T, U } -> T Returns the norm of a considered as an (possibly fractional) ideal of O .","title":"Miscaellenous"},{"location":"orders/ideals/","text":"Ideals (Integral) ideals in orders are always free Z -module of the same rank as the order, hence have a representation via a Z -basis. This can be made unique by normalising the corresponding matrix to be in reduced row echelon form (HNF). For ideals in maximal orders Z_K , we also have a second presentation coming from the Z_K module structure and the fact that Z_K is a Dedekind ring: ideals can be generated by 2 elements, one of which can be any non-zero element in the ideal. For efficiency, we will choose the 1st generator to be an integer. Ideals here are of type NfAbsOrdIdl , which is, similar to the elements above, also indexed by the type of the field and their elements: NfAbsOrdIdl{AnticNumberField,nf_elem} for ideals in simple absolute fields. Different to elements, the parent of an ideal is teh set of all ideals in the ring, of type NfAbsOrdIdlSet . Creation ideal ( O :: NfOrd , a :: fmpz ) -> NfAbsOrdIdl ideal ( O :: NfOrd , a :: Integer ) -> NfAbsOrdIdl Returns the ideal of \\mathcal O which is generated by a . ideal ( O :: NfOrd , x :: fmpz_mat , check :: Bool = false , x_in_hnf :: Bool = false ) -> NfAbsOrdIdl Creates the ideal of \\mathcal O with basis matrix x . If check is set, then it is checked whether x defines an ideal (expensive). If x_in_hnf is set, then it is assumed that x is already in lower left HNF. ideal ( O :: NfOrd , x :: NfOrdElem ) -> NfAbsOrdIdl Creates the principal ideal (x) of \\mathcal O . ideal ( O :: NfOrd , x :: fmpz , y :: NfOrdElem ) -> NfAbsOrdIdl ideal ( O :: NfOrd , x :: Integer , y :: NfOrdElem ) -> NfAbsOrdIdl Creates the ideal (x, y) of \\mathcal O . Missing docstring. Missing docstring for ideal(::NfOrd, ::NfAbsOrdIdl) . Check Documenter's build log for details. * ( O :: NfOrd , x :: NfOrdElem ) -> NfAbsOrdIdl * ( x :: NfAbsOrdElem , O :: NfAbsOrd ) -> NfAbsOrdIdl Returns the principal ideal (x) of \\mathcal O . Missing docstring. Missing docstring for prime_decomposition(::NfOrd, ::Integer) . Check Documenter's build log for details. Missing docstring. Missing docstring for prime_decomposition(::NfOrd, ::fmpz) . Check Documenter's build log for details. factor ( A :: NfOrdIdl ) -> Dict { NfOrdIdl , Int } Computes the prime ideal factorization A as a dictionary, the keys being the prime ideal divisors: If lp = factor_dict(A) , then keys(lp) are the prime ideal divisors of A and lp[P] is the P -adic valuation of A for all P in keys(lp) . factor ( a :: nf_elem , I :: NfOrdIdlSet ) -> Dict { NfOrdIdl , fmpz } Factors the principal ideal generated by a . Arithmetic == ( x :: NfAbsOrdIdl , y :: NfAbsOrdIdl ) Returns whether x and y are equal. + ( x :: NfOrdIdl , y :: NfOrdIdl ) Returns x + y . * ( x :: NfOrdIdl , y :: NfOrdIdl ) Returns x \\cdot y . divexact ( A :: NfOrdIdl , B :: NfOrdIdl ) -> NfOrdIdl Returns AB^{-1} assuming that AB^{-1} is again an integral ideal. divides ( A :: NfOrdIdl , B :: NfOrdIdl ) Checks if B divides A . intersect ( x :: NfOrdIdl , y :: NfOrdIdl ) -> NfOrdIdl lcm ( x :: NfOrdIdl , y :: NfOrdIdl ) -> NfOrdIdl Returns x \\cap y . gcd ( A :: NfOrdIdl , B :: NfOrdIdl ) -> NfOrdIdl The gcd or sum (A+B). gcd ( A :: NfOrdIdl , p :: fmpz ) -> NfOrdIdl The gcd or sum (A + pO). intersect ( x :: NfOrdIdl , y :: NfOrdIdl ) -> NfOrdIdl lcm ( x :: NfOrdIdl , y :: NfOrdIdl ) -> NfOrdIdl Returns x \\cap y . colon ( a :: NfAbsOrdIdl , b :: NfAbsOrdIdl ) -> NfOrdFracIdl The ideal (a:b) = \\{x \\in K | xb \\subseteq a\\} = \\hom(b, a) where K is the number field. in ( x :: NfOrdElem , y :: NfAbsOrdIdl ) in ( x :: nf_elem , y :: NfAbsOrdIdl ) in ( x :: fmpz , y :: NfAbsOrdIdl ) Returns whether x is contained in y . ispower ( A :: NfAbsOrdIdl , n :: Int ) -> Bool , NfAbsOrdIdl ispower ( A :: NfOrdFracIdl , n :: Int ) -> Bool , NfOrdFracIdl Computes, if possible, an ideal B s.th. B^n==A holds. In this case, true and B are returned. ispower ( I :: NfAbsOrdIdl ) -> Int , NfAbsOrdIdl ispower ( a :: NfOrdFracIdl ) -> Int , NfOrdFracIdl Writes a = r^e with e maximal. Note: 1 = 1^0 . isinvertible ( A :: NfAbsOrdIdl ) -> Bool , NfOrdFracIdl Returns true and an inverse of A or false and an ideal B such that A*B \\subsetneq order(A) , if A is not invertible. isone ( A :: NfAbsOrdIdl ) -> Bool isunit ( A :: NfAbsOrdIdl ) -> Bool Tests if A is the trivial ideal generated by 1 . Class Group The group of invertable ideals in any order forms a group and the principal ideals a subgroup. The finite quotient is called class group for maximal orders and Picard group or ring class group in general. Missing docstring. Missing docstring for class_group(::NfOrd) . Check Documenter's build log for details. Missing docstring. Missing docstring for class_group(::AnticNumberField) . Check Documenter's build log for details. picard_group ( O :: NfOrd ) -> GrpAbFinGen , MapClassGrp Returns the Picard group of O and a map from the group in the set of (invertible) ideals of O . ring_class_group ( O :: NfAbsOrd ) The ring class group (Picard group) of O . julia> k, a = wildanger_field(3, 13); julia> zk = maximal_order(k); julia> c, mc = class_group(zk) (GrpAb: Z/9, ClassGroup map of Set of ideals of Maximal order of Number field over Rational Field with defining polynomial x^3 - 13*x^2 + 13*x - 13 with basis nf_elem[1, _$, 1//2*_$^2 + 1//2] ) julia> lp = prime_ideals_up_to(zk, 20); julia> [ mc \\ I for I = lp] 10-element Array{GrpAbFinGenElem,1}: Element of GrpAb: Z/9 with components [1] Element of GrpAb: Z/9 with components [7] Element of GrpAb: Z/9 with components [1] Element of GrpAb: Z/9 with components [8] Element of GrpAb: Z/9 with components [3] Element of GrpAb: Z/9 with components [5] Element of GrpAb: Z/9 with components [4] Element of GrpAb: Z/9 with components [7] Element of GrpAb: Z/9 with components [0] Element of GrpAb: Z/9 with components [5] julia> mc(c[1]) <2, 3//2*_$^2 + 7//2> Norm: 2 Minimum: 2 two normal wrt: 2 julia> order(c[1]) 9 julia> mc(c[1])^Int(order(c[1])) <512, 17938012485062321973//2*_$^2 - 8901657589938385545*_$ + 19420694289946120507//2> Norm: 512 two normal wrt: 2 julia> mc \\ ans Element of GrpAb: Z/9 with components [0] The class group, or more precisely the information used to compute it also allows for principal ideal testing and related tasks. In general, due to the size of the objetcs, the fac_elem versions are more effcient. isprincipal ( A :: NfOrdIdl ) -> Bool , NfOrdElem isprincipal ( A :: NfOrdFracIdl ) -> Bool , NfOrdElem Tests if A is principal and returns (\\mathtt{true}, \\alpha) if A = \\langle \\alpha\\rangle or (\\mathtt{false}, 1) otherwise. isprincipal_fac_elem ( A :: NfOrdIdl ) -> Bool , FacElem { nf_elem , NumberField } Tests if A is principal and returns (\\mathtt{true}, \\alpha) if A = \\langle \\alpha\\rangle or (\\mathtt{false}, 1) otherwise. The generator will be in factored form. power_class ( A :: NfOrdIdl , e :: fmpz ) -> NfOrdIdl Computes a (small) ideal in the same class as A^e . power_product_class ( A :: Array { NfOrdIdl , 1 }, e :: Array { fmpz , 1 }) -> NfOrdIdl Computes a (small) ideal in the same class as \\prod A_i^{e_i} . power_reduce ( A :: NfOrdIdl , e :: fmpz ) -> NfOrdIdl , FacElem { nf_elem } Computes B and \\alpha in factored form, such that \\alpha B = A^e B has small norm. class_group_ideal_relation ( I :: NfOrdIdl , c :: ClassGrpCtx ) -> nf_elem , SRow { fmpz } Finds a number field element \\alpha such that \\alpha I factors over the factor base in c . julia> I = mc(c[1]) <2, 3//2*_$^2 + 7//2> Norm: 2 Minimum: 2 two normal wrt: 2 julia> Hecke.isprincipal(I) (false, 1) julia> I = I^Int(order(c[1])) <512, 17938012485062321973//2*_$^2 - 8901657589938385545*_$ + 19420694289946120507//2> Norm: 512 two normal wrt: 2 julia> Hecke.isprincipal(I) (true, 1//2*_$^2 - 5*_$ - 17//2) julia> Hecke.isprincipal_fac_elem(I) (true, Factored element with data Dict{nf_elem,fmpz}(1//2*_$^2 - 5*_$ - 17//2 => 1)) The computation of S -units is also tied to the class group: unit_group ( O :: NfOrd ) -> GrpAbFinGen , Map Returns a group U and an isomorphism map f \\colon U \\to \\mathcal O^\\times . A set of fundamental units of \\mathcal O can be obtained via [ f(U[1+i]) for i in 1:unit_rank(O) ] . f(U[1]) will give a generator for the torsion subgroup. unit_group_fac_elem ( O :: NfOrd ) -> GrpAbFinGen , Map Returns a group U and an isomorphism map f \\colon U \\to \\mathcal O^\\times . A set of fundamental units of \\mathcal O can be obtained via [ f(U[1+i]) for i in 1:unit_rank(O) ] . f(U[1]) will give a generator for the torsion subgroup. All elements will be returned in factored form. sunit_group ( I :: Array { NfOrdIdl , 1 }) -> GrpAb , Map For an array I of (coprime prime) ideals, find the S -unit group defined by I , ie. the group of non-zero field elements which are only divisible by ideals in I . sunit_group_fac_elem ( I :: Array { NfOrdIdl , 1 }) -> GrpAb , Map For an array I of (coprime prime) ideals, find the S -unit group defined by I , ie. the group of non-zero field elements which are only divisible by ideals in I . The map will return elements in factored form. sunit_mod_units_group_fac_elem ( I :: Array { NfOrdIdl , 1 }) -> GrpAb , Map For an array I of (coprime prime) ideals, find the S -unit group defined by I , ie. the group of non-zero field elements which are only divisible by ideals in I modulo the units of the field. The map will return elements in factored form. julia> u, mu = unit_group(zk) (GrpAb: Z/2 x Z, UnitGroup map of Maximal order of Number field over Rational Field with defining polynomial x^3 - 13*x^2 + 13*x - 13 with basis nf_elem[1, _$, 1//2*_$^2 + 1//2] ) julia> mu(u[2]) _$^2 - _$ + 1 julia> u, mu = unit_group_fac_elem(zk) (GrpAb: Z/2 x Z, UnitGroup map of Factored elements over Number field over Rational Field with defining polynomial x^3 - 13*x^2 + 13*x - 13 ) julia> mu(u[2]) Factored element with data Dict{nf_elem,fmpz}(-_$^2 + 99*_$ - 26 => 1,-25//2*_$^2 + 113*_$ + 975//2 => -1,_$ - 1 => 1,2 => -1) julia> evaluate(ans) _$^2 - _$ + 1 julia> lp = factor(6*zk) Dict{NfAbsOrdIdl{AnticNumberField,nf_elem},Int64} with 4 entries: <3, _$^2 + 1> => 1 <2, 7//2*_$^2 + 5//2> => 1 <2, 7//2*_$^2 + 3//2> => 2 <3, _$ - 1> => 1 julia> s, ms = Hecke.sunit_group(collect(keys(lp))) (GrpAb: Z/2 x Z^(5), SUnits map of Number field over Rational Field with defining polynomial x^3 - 13*x^2 + 13*x - 13 for NfAbsOrdIdl{AnticNumberField,nf_elem}[<3, _$^2 + 1> Norm: 9 Minimum: 3 basis_matrix [3 0 0; 0 3 0; 0 0 1] two normal wrt: 3, <2, 7//2*_$^2 + 5//2> Norm: 2 Minimum: 2 basis_matrix [2 0 0; 1 1 0; 1 0 1] two normal wrt: 2, <2, 7//2*_$^2 + 3//2> Norm: 2 Minimum: 2 basis_matrix [2 0 0; 1 1 0; 0 0 1] two normal wrt: 2, <3, _$ - 1> Norm: 3 Minimum: 3 basis_matrix [3 0 0; 2 1 0; 2 0 1] two normal wrt: 3] ) julia> ms(s[4]) -1//2*_$^2 + 6*_$ + 1//2 julia> norm(ans) 18 julia> factor(numerator(ans)) 1 * 2 * 3^2 Miscaellenous order ( I :: NfAbsOrdIdl ) -> NfOrd Returns the order of I . nf ( x :: NfAbsOrdIdl ) -> AnticNumberField Returns the number field, of which x is an integral ideal. basis ( A :: NfAbsOrdIdl ) -> Array { NfOrdElem , 1 } Returns the basis of A . basis ( I :: NfAbsOrdFracIdl ) -> Array { nf_elem , 1 } Returns the \\mathbf Z -basis of I . basis_matrix ( A :: NfAbsOrdIdl ) -> fmpz_mat Returns the basis matrix of A . basis_mat_inv ( O :: NfOrd ) -> FakeFmpqMat Returns the inverse of the basis matrix of \\mathcal O . basis_mat_inv(A::NfAbsOrdIdl) -> fmpz_mat Returns the inverse basis matrix of A . basis_mat_inv ( A :: NfAbsOrdIdl ) -> FakeFmpqMat Returns the inverse of the basis matrix of A . has_basis ( A :: NfAbsOrdIdl ) -> Bool Returns whether A has a basis already computed. has_basis_matrix ( A :: NfAbsOrdIdl ) -> Bool Returns whether A knows its basis matrix. has_2_elem ( A :: NfAbsOrdIdl ) -> Bool Returns whether A is generated by two elements. has_2_elem_normal ( A :: NfAbsOrdIdl ) -> Bool Returns whether A has normal two element generators. has_weakly_normal ( A :: NfAbsOrdIdl ) -> Bool Returns whether A has weakly normal two element generators. has_princ_gen_special ( A :: NfAbsOrdIdl ) -> Bool Returns whether A knows if it is generated by a rational integer. principal_generator ( A :: NfOrdIdl ) -> NfOrdElem For a principal ideal A , find a generator. principal_generator_fac_elem ( A :: NfOrdIdl ) -> FacElem { nf_elem , NumberField } For a principal ideal A , find a generator in factored form. minimum ( A :: NfRelOrdIdl ) -> NfOrdIdl minimum ( A :: NfRelOrdIdl ) -> NfRelOrdIdl Returns the ideal A \\cap O where O is the maximal order of the coefficient ideals of A . minimum(A::NfAbsOrdIdl) -> fmpz Returns the smallest nonnegative element in A \\cap \\mathbf Z . has_minimum ( A :: NfAbsOrdIdl ) -> Bool Returns whether A knows its mininum. norm ( a :: NfRelOrdIdl ) -> NfOrdIdl Returns the norm of a . norm(a::NfRelOrdFracIdl{T, S}) -> S Returns the norm of a . norm(A::NfAbsOrdIdl) -> fmpz Returns the norm of A , that is, the cardinality of \\mathcal O/A , where \\mathcal O is the order of A . norm(a::AlgAssAbsOrdIdl, O::AlgAssAbsOrd; copy::Bool = true) -> fmpq Returns the norm of a considered as an (possibly fractional) ideal of O . norm(a::AlgAssRelOrdIdl{S, T, U}, O::AlgAssRelOrd{S, T, U}; copy::Bool = true) where { S, T, U } -> T Returns the norm of a considered as an (possibly fractional) ideal of O . has_norm ( A :: NfAbsOrdIdl ) -> Bool Returns whether A knows its norm. idempotents ( x :: NfOrdIdl , y :: NfOrdIdl ) -> NfOrdElem , NfOrdElem Returns a tuple (e, f) consisting of elements e in x , f in y such that 1 = e + f . If the ideals are not coprime, an error is raised. isprime ( A :: NfOrdIdl ) -> Bool Returns whether A is a prime ideal. isprime_known ( A :: NfOrdIdl ) -> Bool Returns whether A knows if it is prime. isramified ( O :: NfOrd , p :: Int ) -> Bool Returns whether the integer p is ramified in \\mathcal O . It is assumed that p is prime. ramification_index ( P :: NfOrdIdl ) -> Int The ramification index of the prime-ideal P . degree ( P :: NfOrdIdl ) -> Int The inertia degree of the prime-ideal P . valuation ( a :: nf_elem , p :: NfOrdIdl ) -> fmpz valuation ( a :: NfOrdElem , p :: NfOrdIdl ) -> fmpz valuation ( a :: fmpz , p :: NfOrdIdl ) -> fmpz Computes the \\mathfrak p -adic valuation of a , that is, the largest i such that a is contained in \\mathfrak p^i . valuation ( a :: nf_elem , p :: NfOrdIdl ) -> fmpz valuation ( a :: NfOrdElem , p :: NfOrdIdl ) -> fmpz valuation ( a :: fmpz , p :: NfOrdIdl ) -> fmpz Computes the \\mathfrak p -adic valuation of a , that is, the largest i such that a is contained in \\mathfrak p^i . valuation ( A :: NfOrdIdl , p :: NfOrdIdl ) -> fmpz Computes the \\mathfrak p -adic valuation of A , that is, the largest i such that A is contained in \\mathfrak p^i . valuation ( a :: Integer , p :: NfOrdIdl ) -> fmpz Computes the \\mathfrak p -adic valuation of a , that is, the largest i such that a is contained in \\mathfrak p^i . valuation ( a :: nf_elem , p :: NfOrdIdl ) -> fmpz valuation ( a :: NfOrdElem , p :: NfOrdIdl ) -> fmpz valuation ( a :: fmpz , p :: NfOrdIdl ) -> fmpz Computes the \\mathfrak p -adic valuation of a , that is, the largest i such that a is contained in \\mathfrak p^i . valuation ( A :: NfAbsOrdFracIdl , p :: NfAbsOrdIdl ) The valuation of A at p . Quotient Rings quo ( O :: NfOrd , I :: NfOrdIdl ) -> NfOrdQuoRing , Map quo ( O :: AlgAssAbsOrd , I :: AlgAssAbsOrdIdl ) -> AbsOrdQuoRing , Map The quotient ring O/I as a ring together with the section M: O/I \\to O . The pointwise inverse of M is the canonical projection O\\to O/I . ResidueRing ( O :: NfOrd , I :: NfOrdIdl ) -> NfOrdQuoRing ResidueRing ( O :: AlgAssAbsOrd , I :: AlgAssAbsOrdIdl ) -> AbsOrdQuoRing The quotient ring O modulo I as a new ring. ResidueField ( O :: NfOrd , P :: NfOrdIdl , check :: Bool = true ) -> Field , Map Returns the residue field of the prime ideal P together with the projection map. If check is true, the ideal is checked for being prime. mod ( x :: NfOrdElem , I :: NfAbsOrdIdl ) Returns the unique element y of the ambient order of x with x \\equiv y \\bmod I and the following property: If a_1,\\dotsc,a_d \\in \\mathbf{Z}_{\\geq 1} are the diagonal entries of the unique HNF basis matrix of I and (b_1,\\dotsc,b_d) is the coefficient vector of y , then 0 \\leq b_i < a_i for 1 \\leq i \\leq d . crt ( r1 :: NfOrdElem , i1 :: NfOrdIdl , r2 :: NfOrdElem , i2 :: NfOrdIdl ) -> NfOrdElem Find x such that x \\equiv r_1 \\bmod i_1 and x \\equiv r_2 \\bmod i_2 using idempotents .","title":"Ideals"},{"location":"orders/ideals/#ideals","text":"(Integral) ideals in orders are always free Z -module of the same rank as the order, hence have a representation via a Z -basis. This can be made unique by normalising the corresponding matrix to be in reduced row echelon form (HNF). For ideals in maximal orders Z_K , we also have a second presentation coming from the Z_K module structure and the fact that Z_K is a Dedekind ring: ideals can be generated by 2 elements, one of which can be any non-zero element in the ideal. For efficiency, we will choose the 1st generator to be an integer. Ideals here are of type NfAbsOrdIdl , which is, similar to the elements above, also indexed by the type of the field and their elements: NfAbsOrdIdl{AnticNumberField,nf_elem} for ideals in simple absolute fields. Different to elements, the parent of an ideal is teh set of all ideals in the ring, of type NfAbsOrdIdlSet .","title":"Ideals"},{"location":"orders/ideals/#creation","text":"ideal ( O :: NfOrd , a :: fmpz ) -> NfAbsOrdIdl ideal ( O :: NfOrd , a :: Integer ) -> NfAbsOrdIdl Returns the ideal of \\mathcal O which is generated by a . ideal ( O :: NfOrd , x :: fmpz_mat , check :: Bool = false , x_in_hnf :: Bool = false ) -> NfAbsOrdIdl Creates the ideal of \\mathcal O with basis matrix x . If check is set, then it is checked whether x defines an ideal (expensive). If x_in_hnf is set, then it is assumed that x is already in lower left HNF. ideal ( O :: NfOrd , x :: NfOrdElem ) -> NfAbsOrdIdl Creates the principal ideal (x) of \\mathcal O . ideal ( O :: NfOrd , x :: fmpz , y :: NfOrdElem ) -> NfAbsOrdIdl ideal ( O :: NfOrd , x :: Integer , y :: NfOrdElem ) -> NfAbsOrdIdl Creates the ideal (x, y) of \\mathcal O . Missing docstring. Missing docstring for ideal(::NfOrd, ::NfAbsOrdIdl) . Check Documenter's build log for details. * ( O :: NfOrd , x :: NfOrdElem ) -> NfAbsOrdIdl * ( x :: NfAbsOrdElem , O :: NfAbsOrd ) -> NfAbsOrdIdl Returns the principal ideal (x) of \\mathcal O . Missing docstring. Missing docstring for prime_decomposition(::NfOrd, ::Integer) . Check Documenter's build log for details. Missing docstring. Missing docstring for prime_decomposition(::NfOrd, ::fmpz) . Check Documenter's build log for details. factor ( A :: NfOrdIdl ) -> Dict { NfOrdIdl , Int } Computes the prime ideal factorization A as a dictionary, the keys being the prime ideal divisors: If lp = factor_dict(A) , then keys(lp) are the prime ideal divisors of A and lp[P] is the P -adic valuation of A for all P in keys(lp) . factor ( a :: nf_elem , I :: NfOrdIdlSet ) -> Dict { NfOrdIdl , fmpz } Factors the principal ideal generated by a .","title":"Creation"},{"location":"orders/ideals/#arithmetic","text":"== ( x :: NfAbsOrdIdl , y :: NfAbsOrdIdl ) Returns whether x and y are equal. + ( x :: NfOrdIdl , y :: NfOrdIdl ) Returns x + y . * ( x :: NfOrdIdl , y :: NfOrdIdl ) Returns x \\cdot y . divexact ( A :: NfOrdIdl , B :: NfOrdIdl ) -> NfOrdIdl Returns AB^{-1} assuming that AB^{-1} is again an integral ideal. divides ( A :: NfOrdIdl , B :: NfOrdIdl ) Checks if B divides A . intersect ( x :: NfOrdIdl , y :: NfOrdIdl ) -> NfOrdIdl lcm ( x :: NfOrdIdl , y :: NfOrdIdl ) -> NfOrdIdl Returns x \\cap y . gcd ( A :: NfOrdIdl , B :: NfOrdIdl ) -> NfOrdIdl The gcd or sum (A+B). gcd ( A :: NfOrdIdl , p :: fmpz ) -> NfOrdIdl The gcd or sum (A + pO). intersect ( x :: NfOrdIdl , y :: NfOrdIdl ) -> NfOrdIdl lcm ( x :: NfOrdIdl , y :: NfOrdIdl ) -> NfOrdIdl Returns x \\cap y . colon ( a :: NfAbsOrdIdl , b :: NfAbsOrdIdl ) -> NfOrdFracIdl The ideal (a:b) = \\{x \\in K | xb \\subseteq a\\} = \\hom(b, a) where K is the number field. in ( x :: NfOrdElem , y :: NfAbsOrdIdl ) in ( x :: nf_elem , y :: NfAbsOrdIdl ) in ( x :: fmpz , y :: NfAbsOrdIdl ) Returns whether x is contained in y . ispower ( A :: NfAbsOrdIdl , n :: Int ) -> Bool , NfAbsOrdIdl ispower ( A :: NfOrdFracIdl , n :: Int ) -> Bool , NfOrdFracIdl Computes, if possible, an ideal B s.th. B^n==A holds. In this case, true and B are returned. ispower ( I :: NfAbsOrdIdl ) -> Int , NfAbsOrdIdl ispower ( a :: NfOrdFracIdl ) -> Int , NfOrdFracIdl Writes a = r^e with e maximal. Note: 1 = 1^0 . isinvertible ( A :: NfAbsOrdIdl ) -> Bool , NfOrdFracIdl Returns true and an inverse of A or false and an ideal B such that A*B \\subsetneq order(A) , if A is not invertible. isone ( A :: NfAbsOrdIdl ) -> Bool isunit ( A :: NfAbsOrdIdl ) -> Bool Tests if A is the trivial ideal generated by 1 .","title":"Arithmetic"},{"location":"orders/ideals/#class-group","text":"The group of invertable ideals in any order forms a group and the principal ideals a subgroup. The finite quotient is called class group for maximal orders and Picard group or ring class group in general. Missing docstring. Missing docstring for class_group(::NfOrd) . Check Documenter's build log for details. Missing docstring. Missing docstring for class_group(::AnticNumberField) . Check Documenter's build log for details. picard_group ( O :: NfOrd ) -> GrpAbFinGen , MapClassGrp Returns the Picard group of O and a map from the group in the set of (invertible) ideals of O . ring_class_group ( O :: NfAbsOrd ) The ring class group (Picard group) of O . julia> k, a = wildanger_field(3, 13); julia> zk = maximal_order(k); julia> c, mc = class_group(zk) (GrpAb: Z/9, ClassGroup map of Set of ideals of Maximal order of Number field over Rational Field with defining polynomial x^3 - 13*x^2 + 13*x - 13 with basis nf_elem[1, _$, 1//2*_$^2 + 1//2] ) julia> lp = prime_ideals_up_to(zk, 20); julia> [ mc \\ I for I = lp] 10-element Array{GrpAbFinGenElem,1}: Element of GrpAb: Z/9 with components [1] Element of GrpAb: Z/9 with components [7] Element of GrpAb: Z/9 with components [1] Element of GrpAb: Z/9 with components [8] Element of GrpAb: Z/9 with components [3] Element of GrpAb: Z/9 with components [5] Element of GrpAb: Z/9 with components [4] Element of GrpAb: Z/9 with components [7] Element of GrpAb: Z/9 with components [0] Element of GrpAb: Z/9 with components [5] julia> mc(c[1]) <2, 3//2*_$^2 + 7//2> Norm: 2 Minimum: 2 two normal wrt: 2 julia> order(c[1]) 9 julia> mc(c[1])^Int(order(c[1])) <512, 17938012485062321973//2*_$^2 - 8901657589938385545*_$ + 19420694289946120507//2> Norm: 512 two normal wrt: 2 julia> mc \\ ans Element of GrpAb: Z/9 with components [0] The class group, or more precisely the information used to compute it also allows for principal ideal testing and related tasks. In general, due to the size of the objetcs, the fac_elem versions are more effcient. isprincipal ( A :: NfOrdIdl ) -> Bool , NfOrdElem isprincipal ( A :: NfOrdFracIdl ) -> Bool , NfOrdElem Tests if A is principal and returns (\\mathtt{true}, \\alpha) if A = \\langle \\alpha\\rangle or (\\mathtt{false}, 1) otherwise. isprincipal_fac_elem ( A :: NfOrdIdl ) -> Bool , FacElem { nf_elem , NumberField } Tests if A is principal and returns (\\mathtt{true}, \\alpha) if A = \\langle \\alpha\\rangle or (\\mathtt{false}, 1) otherwise. The generator will be in factored form. power_class ( A :: NfOrdIdl , e :: fmpz ) -> NfOrdIdl Computes a (small) ideal in the same class as A^e . power_product_class ( A :: Array { NfOrdIdl , 1 }, e :: Array { fmpz , 1 }) -> NfOrdIdl Computes a (small) ideal in the same class as \\prod A_i^{e_i} . power_reduce ( A :: NfOrdIdl , e :: fmpz ) -> NfOrdIdl , FacElem { nf_elem } Computes B and \\alpha in factored form, such that \\alpha B = A^e B has small norm. class_group_ideal_relation ( I :: NfOrdIdl , c :: ClassGrpCtx ) -> nf_elem , SRow { fmpz } Finds a number field element \\alpha such that \\alpha I factors over the factor base in c . julia> I = mc(c[1]) <2, 3//2*_$^2 + 7//2> Norm: 2 Minimum: 2 two normal wrt: 2 julia> Hecke.isprincipal(I) (false, 1) julia> I = I^Int(order(c[1])) <512, 17938012485062321973//2*_$^2 - 8901657589938385545*_$ + 19420694289946120507//2> Norm: 512 two normal wrt: 2 julia> Hecke.isprincipal(I) (true, 1//2*_$^2 - 5*_$ - 17//2) julia> Hecke.isprincipal_fac_elem(I) (true, Factored element with data Dict{nf_elem,fmpz}(1//2*_$^2 - 5*_$ - 17//2 => 1)) The computation of S -units is also tied to the class group: unit_group ( O :: NfOrd ) -> GrpAbFinGen , Map Returns a group U and an isomorphism map f \\colon U \\to \\mathcal O^\\times . A set of fundamental units of \\mathcal O can be obtained via [ f(U[1+i]) for i in 1:unit_rank(O) ] . f(U[1]) will give a generator for the torsion subgroup. unit_group_fac_elem ( O :: NfOrd ) -> GrpAbFinGen , Map Returns a group U and an isomorphism map f \\colon U \\to \\mathcal O^\\times . A set of fundamental units of \\mathcal O can be obtained via [ f(U[1+i]) for i in 1:unit_rank(O) ] . f(U[1]) will give a generator for the torsion subgroup. All elements will be returned in factored form. sunit_group ( I :: Array { NfOrdIdl , 1 }) -> GrpAb , Map For an array I of (coprime prime) ideals, find the S -unit group defined by I , ie. the group of non-zero field elements which are only divisible by ideals in I . sunit_group_fac_elem ( I :: Array { NfOrdIdl , 1 }) -> GrpAb , Map For an array I of (coprime prime) ideals, find the S -unit group defined by I , ie. the group of non-zero field elements which are only divisible by ideals in I . The map will return elements in factored form. sunit_mod_units_group_fac_elem ( I :: Array { NfOrdIdl , 1 }) -> GrpAb , Map For an array I of (coprime prime) ideals, find the S -unit group defined by I , ie. the group of non-zero field elements which are only divisible by ideals in I modulo the units of the field. The map will return elements in factored form. julia> u, mu = unit_group(zk) (GrpAb: Z/2 x Z, UnitGroup map of Maximal order of Number field over Rational Field with defining polynomial x^3 - 13*x^2 + 13*x - 13 with basis nf_elem[1, _$, 1//2*_$^2 + 1//2] ) julia> mu(u[2]) _$^2 - _$ + 1 julia> u, mu = unit_group_fac_elem(zk) (GrpAb: Z/2 x Z, UnitGroup map of Factored elements over Number field over Rational Field with defining polynomial x^3 - 13*x^2 + 13*x - 13 ) julia> mu(u[2]) Factored element with data Dict{nf_elem,fmpz}(-_$^2 + 99*_$ - 26 => 1,-25//2*_$^2 + 113*_$ + 975//2 => -1,_$ - 1 => 1,2 => -1) julia> evaluate(ans) _$^2 - _$ + 1 julia> lp = factor(6*zk) Dict{NfAbsOrdIdl{AnticNumberField,nf_elem},Int64} with 4 entries: <3, _$^2 + 1> => 1 <2, 7//2*_$^2 + 5//2> => 1 <2, 7//2*_$^2 + 3//2> => 2 <3, _$ - 1> => 1 julia> s, ms = Hecke.sunit_group(collect(keys(lp))) (GrpAb: Z/2 x Z^(5), SUnits map of Number field over Rational Field with defining polynomial x^3 - 13*x^2 + 13*x - 13 for NfAbsOrdIdl{AnticNumberField,nf_elem}[<3, _$^2 + 1> Norm: 9 Minimum: 3 basis_matrix [3 0 0; 0 3 0; 0 0 1] two normal wrt: 3, <2, 7//2*_$^2 + 5//2> Norm: 2 Minimum: 2 basis_matrix [2 0 0; 1 1 0; 1 0 1] two normal wrt: 2, <2, 7//2*_$^2 + 3//2> Norm: 2 Minimum: 2 basis_matrix [2 0 0; 1 1 0; 0 0 1] two normal wrt: 2, <3, _$ - 1> Norm: 3 Minimum: 3 basis_matrix [3 0 0; 2 1 0; 2 0 1] two normal wrt: 3] ) julia> ms(s[4]) -1//2*_$^2 + 6*_$ + 1//2 julia> norm(ans) 18 julia> factor(numerator(ans)) 1 * 2 * 3^2","title":"Class Group"},{"location":"orders/ideals/#miscaellenous","text":"order ( I :: NfAbsOrdIdl ) -> NfOrd Returns the order of I . nf ( x :: NfAbsOrdIdl ) -> AnticNumberField Returns the number field, of which x is an integral ideal. basis ( A :: NfAbsOrdIdl ) -> Array { NfOrdElem , 1 } Returns the basis of A . basis ( I :: NfAbsOrdFracIdl ) -> Array { nf_elem , 1 } Returns the \\mathbf Z -basis of I . basis_matrix ( A :: NfAbsOrdIdl ) -> fmpz_mat Returns the basis matrix of A . basis_mat_inv ( O :: NfOrd ) -> FakeFmpqMat Returns the inverse of the basis matrix of \\mathcal O . basis_mat_inv(A::NfAbsOrdIdl) -> fmpz_mat Returns the inverse basis matrix of A . basis_mat_inv ( A :: NfAbsOrdIdl ) -> FakeFmpqMat Returns the inverse of the basis matrix of A . has_basis ( A :: NfAbsOrdIdl ) -> Bool Returns whether A has a basis already computed. has_basis_matrix ( A :: NfAbsOrdIdl ) -> Bool Returns whether A knows its basis matrix. has_2_elem ( A :: NfAbsOrdIdl ) -> Bool Returns whether A is generated by two elements. has_2_elem_normal ( A :: NfAbsOrdIdl ) -> Bool Returns whether A has normal two element generators. has_weakly_normal ( A :: NfAbsOrdIdl ) -> Bool Returns whether A has weakly normal two element generators. has_princ_gen_special ( A :: NfAbsOrdIdl ) -> Bool Returns whether A knows if it is generated by a rational integer. principal_generator ( A :: NfOrdIdl ) -> NfOrdElem For a principal ideal A , find a generator. principal_generator_fac_elem ( A :: NfOrdIdl ) -> FacElem { nf_elem , NumberField } For a principal ideal A , find a generator in factored form. minimum ( A :: NfRelOrdIdl ) -> NfOrdIdl minimum ( A :: NfRelOrdIdl ) -> NfRelOrdIdl Returns the ideal A \\cap O where O is the maximal order of the coefficient ideals of A . minimum(A::NfAbsOrdIdl) -> fmpz Returns the smallest nonnegative element in A \\cap \\mathbf Z . has_minimum ( A :: NfAbsOrdIdl ) -> Bool Returns whether A knows its mininum. norm ( a :: NfRelOrdIdl ) -> NfOrdIdl Returns the norm of a . norm(a::NfRelOrdFracIdl{T, S}) -> S Returns the norm of a . norm(A::NfAbsOrdIdl) -> fmpz Returns the norm of A , that is, the cardinality of \\mathcal O/A , where \\mathcal O is the order of A . norm(a::AlgAssAbsOrdIdl, O::AlgAssAbsOrd; copy::Bool = true) -> fmpq Returns the norm of a considered as an (possibly fractional) ideal of O . norm(a::AlgAssRelOrdIdl{S, T, U}, O::AlgAssRelOrd{S, T, U}; copy::Bool = true) where { S, T, U } -> T Returns the norm of a considered as an (possibly fractional) ideal of O . has_norm ( A :: NfAbsOrdIdl ) -> Bool Returns whether A knows its norm. idempotents ( x :: NfOrdIdl , y :: NfOrdIdl ) -> NfOrdElem , NfOrdElem Returns a tuple (e, f) consisting of elements e in x , f in y such that 1 = e + f . If the ideals are not coprime, an error is raised. isprime ( A :: NfOrdIdl ) -> Bool Returns whether A is a prime ideal. isprime_known ( A :: NfOrdIdl ) -> Bool Returns whether A knows if it is prime. isramified ( O :: NfOrd , p :: Int ) -> Bool Returns whether the integer p is ramified in \\mathcal O . It is assumed that p is prime. ramification_index ( P :: NfOrdIdl ) -> Int The ramification index of the prime-ideal P . degree ( P :: NfOrdIdl ) -> Int The inertia degree of the prime-ideal P . valuation ( a :: nf_elem , p :: NfOrdIdl ) -> fmpz valuation ( a :: NfOrdElem , p :: NfOrdIdl ) -> fmpz valuation ( a :: fmpz , p :: NfOrdIdl ) -> fmpz Computes the \\mathfrak p -adic valuation of a , that is, the largest i such that a is contained in \\mathfrak p^i . valuation ( a :: nf_elem , p :: NfOrdIdl ) -> fmpz valuation ( a :: NfOrdElem , p :: NfOrdIdl ) -> fmpz valuation ( a :: fmpz , p :: NfOrdIdl ) -> fmpz Computes the \\mathfrak p -adic valuation of a , that is, the largest i such that a is contained in \\mathfrak p^i . valuation ( A :: NfOrdIdl , p :: NfOrdIdl ) -> fmpz Computes the \\mathfrak p -adic valuation of A , that is, the largest i such that A is contained in \\mathfrak p^i . valuation ( a :: Integer , p :: NfOrdIdl ) -> fmpz Computes the \\mathfrak p -adic valuation of a , that is, the largest i such that a is contained in \\mathfrak p^i . valuation ( a :: nf_elem , p :: NfOrdIdl ) -> fmpz valuation ( a :: NfOrdElem , p :: NfOrdIdl ) -> fmpz valuation ( a :: fmpz , p :: NfOrdIdl ) -> fmpz Computes the \\mathfrak p -adic valuation of a , that is, the largest i such that a is contained in \\mathfrak p^i . valuation ( A :: NfAbsOrdFracIdl , p :: NfAbsOrdIdl ) The valuation of A at p .","title":"Miscaellenous"},{"location":"orders/ideals/#quotient-rings","text":"quo ( O :: NfOrd , I :: NfOrdIdl ) -> NfOrdQuoRing , Map quo ( O :: AlgAssAbsOrd , I :: AlgAssAbsOrdIdl ) -> AbsOrdQuoRing , Map The quotient ring O/I as a ring together with the section M: O/I \\to O . The pointwise inverse of M is the canonical projection O\\to O/I . ResidueRing ( O :: NfOrd , I :: NfOrdIdl ) -> NfOrdQuoRing ResidueRing ( O :: AlgAssAbsOrd , I :: AlgAssAbsOrdIdl ) -> AbsOrdQuoRing The quotient ring O modulo I as a new ring. ResidueField ( O :: NfOrd , P :: NfOrdIdl , check :: Bool = true ) -> Field , Map Returns the residue field of the prime ideal P together with the projection map. If check is true, the ideal is checked for being prime. mod ( x :: NfOrdElem , I :: NfAbsOrdIdl ) Returns the unique element y of the ambient order of x with x \\equiv y \\bmod I and the following property: If a_1,\\dotsc,a_d \\in \\mathbf{Z}_{\\geq 1} are the diagonal entries of the unique HNF basis matrix of I and (b_1,\\dotsc,b_d) is the coefficient vector of y , then 0 \\leq b_i < a_i for 1 \\leq i \\leq d . crt ( r1 :: NfOrdElem , i1 :: NfOrdIdl , r2 :: NfOrdElem , i2 :: NfOrdIdl ) -> NfOrdElem Find x such that x \\equiv r_1 \\bmod i_1 and x \\equiv r_2 \\bmod i_2 using idempotents .","title":"Quotient Rings"},{"location":"orders/introduction/","text":"Introduction This chapter deals with absolute number fields and orders there of. Definitions and vocabulary We begin by collecting the necessary definitions and vocabulary. This is in particular important for everything related to embeddings of number fields into archimedean fields, since they are at least two (slighlty) different normalizations. Number fields By an absolute number field we mean finite extensions of \\mathbf Q , which is of type AnticNumberField and whose elements are of type nf_elem . Such an absolute number field K is always given in the form K = \\mathbf Q(\\alpha) = \\mathbf Q[X]/(f) , where f \\in \\mathbf Q[X] is an irreducible polynomial. See here for more information on the different types of fields supported. We call (1,\\alpha,\\alpha^2,\\dotsc,\\alpha^{d-1}) , where d is the degree [K : \\mathbf Q] the power basis of K . If \\beta is any element of K , then the representation matrix of \\beta is the matrix representing K \\to K, \\gamma \\mapsto \\beta \\gamma with respect to the power basis, that is, \\beta \\cdot (1,\\alpha,\\dotsc,\\alpha^{d-1}) = M_\\alpha (1, \\alpha, \\dotsc, \\alpha^{d-1}). Let (r,s) be the signature of K , that is, K has r real embeddings \\sigma_i \\colon K \\to \\mathbf{R} , 1 \\leq i \\leq r , and 2s complex embeddings \\sigma_i \\colon K \\to \\mathbf{C} , 1 \\leq i \\leq 2s . In Hecke the complex embeddings are always ordered such that \\sigma_i = \\overline{\\sigma_{i+s}} for r + 1 \\leq i \\leq r + s . The \\mathbf{Q} -linear function \\begin{gather*} K \\longrightarrow \\mathbf R^{d} \\\\ \\alpha \\longmapsto \\Bigl( \\sigma_1(\\alpha), \\dotsc, \\sigma_r(\\alpha), \\sqrt{2}\\operatorname{Re}\\bigl(\\sigma_{r+1}(\\alpha)\\bigr), \\sqrt{2}\\operatorname{Im}\\bigl(\\sigma_{r+1}(\\alpha)\\bigr), \\dotsc, \\sqrt{2}\\operatorname{Re}\\bigl(\\sigma_{r+s}(\\alpha)\\bigr), \\sqrt{2}\\operatorname{Im}\\bigl(\\sigma_{r+s}(\\alpha)\\bigr) \\Bigr) \\end{gather*} is called the Minkowski map (or Minkowski embedding ). Orders If K = \\mathbf Q(\\alpha) is an absolute number field, then an order \\mathcal O of K is a subring of the ring of integers \\mathcal O_K , which is free of rank [ K : \\mathbf Q] as a \\mathbf Z -module. The natural order \\mathbf Z[\\alpha] is called the equation order of K . In Hecke orders of absolute number fields are constructed (implicitely) by specifying a \\mathbf Z -basis, which is refered to as the basis of \\mathcal O . If (\\omega_1,\\dotsc,\\omega_d) is the basis of \\mathcal O , then the matrix B \\in \\operatorname{Mat}_{d \\times d}(\\mathbf Q) with \\begin{pmatrix} \\omega_1 \\\\ \\vdots \\\\ \\omega_d \\end{pmatrix} = B \\begin{pmatrix} 1 \\\\ \\vdots \\\\ \\alpha^{d - 1} \\end{pmatrix} is called the basis matrix of \\mathcal O . We call \\det(B) the generalized index of \\mathcal O . In case \\mathbf Z[\\alpha] \\subseteq \\mathcal O , the determinant \\det(B)^{-1} is in fact equal to [ \\mathcal O : \\mathbf Z[\\alpha]] and is called the index of \\mathcal O . The matrix \\begin{pmatrix} \\sigma_1(\\omega_1) & \\dotsc & \\sigma_r(\\omega_1) & \\sqrt{2}\\operatorname{Re}(\\sigma_{r+1}(\\omega_1)) & \\sqrt{2}\\operatorname{Im}(\\sigma_{r+1}(\\omega_1)) & \\dotsc & \\sqrt{2}\\operatorname{Im}(\\sigma_{r+s}(\\omega_1)) \\\\\\\\ \\sigma_1(\\omega_2) & \\dotsc & \\sigma_r(\\omega_2) & \\sqrt{2}\\operatorname{Re}(\\sigma_{r+1}(\\omega_2)) & \\sqrt{2}\\operatorname{Im}(\\sigma_{r+1}(\\omega_2)) & \\dotsc & \\sqrt{2}\\operatorname{Im}(\\sigma_{r+s}(\\omega_2)) \\\\\\\\ \\vdots & \\ddots & \\vdots & \\vdots & \\vdots & \\ddots & \\vdots\\\\\\\\ \\sigma_1(\\omega_d) & \\dotsc & \\sigma_r(\\omega_d) & \\sqrt{2}\\operatorname{Re}(\\sigma_{r+1}(\\omega_d)) & \\sqrt{2}\\operatorname{Im}(\\sigma_{r+2}(\\omega_d)) & \\dotsc & \\sqrt{2}\\operatorname{Im}(\\sigma_{r+s}(\\omega_d)) \\end{pmatrix} \\in \\operatorname{Mat}_{d\\times d}(\\mathbf R). is called the Minkowski matrix of \\mathcal O . Examples Usually, to create an order, one starts with a field (or a polynomial): julia> Qx, x = PolynomialRing(FlintQQ, \"x\"); julia> K, a = NumberField(x^2 - 10, \"a\"); julia> E = EquationOrder(K) Maximal order of Number field over Rational Field with defining polynomial x^2 - 10 with basis nf_elem[1, a] julia> Z_K = MaximalOrder(K) Maximal order of Number field over Rational Field with defining polynomial x^2 - 10 with basis nf_elem[1, a] julia> conductor(E) <no 2-elts present> basis_matrix [1 0; 0 1] julia> E == Z_K true Once orders are created, we can play with elements and ideals: julia> lp = prime_decomposition(Z_K, 2) 1-element Array{Tuple{NfAbsOrdIdl{AnticNumberField,nf_elem},Int64},1}: (<2, a> Norm: 2 Minimum: 2 two normal wrt: 2, 2) julia> p = lp[1][1] <2, a> Norm: 2 Minimum: 2 two normal wrt: 2 julia> isprincipal(p) (false, 1) julia> fl, alpha = isprincipal(p^2) (true, -2) julia> norm(alpha) 4 It is possible to work with residue fields as well: julia> Fp, mFp = ResidueField(Z_K, p) (Finite field of degree 1 over F_2, Map with following data Domain: ======= Maximal order of Number field over Rational Field with defining polynomial x^2 - 10 with basis nf_elem[1, a] Codomain: ========= Finite field of degree 1 over F_2 ) julia> [ mFp(x) for x = basis(Z_K)] 2-element Array{fq,1}: 1 0","title":"Introduction"},{"location":"orders/introduction/#introduction","text":"This chapter deals with absolute number fields and orders there of.","title":"Introduction"},{"location":"orders/introduction/#definitions-and-vocabulary","text":"We begin by collecting the necessary definitions and vocabulary. This is in particular important for everything related to embeddings of number fields into archimedean fields, since they are at least two (slighlty) different normalizations.","title":"Definitions and vocabulary"},{"location":"orders/introduction/#number-fields","text":"By an absolute number field we mean finite extensions of \\mathbf Q , which is of type AnticNumberField and whose elements are of type nf_elem . Such an absolute number field K is always given in the form K = \\mathbf Q(\\alpha) = \\mathbf Q[X]/(f) , where f \\in \\mathbf Q[X] is an irreducible polynomial. See here for more information on the different types of fields supported. We call (1,\\alpha,\\alpha^2,\\dotsc,\\alpha^{d-1}) , where d is the degree [K : \\mathbf Q] the power basis of K . If \\beta is any element of K , then the representation matrix of \\beta is the matrix representing K \\to K, \\gamma \\mapsto \\beta \\gamma with respect to the power basis, that is, \\beta \\cdot (1,\\alpha,\\dotsc,\\alpha^{d-1}) = M_\\alpha (1, \\alpha, \\dotsc, \\alpha^{d-1}). Let (r,s) be the signature of K , that is, K has r real embeddings \\sigma_i \\colon K \\to \\mathbf{R} , 1 \\leq i \\leq r , and 2s complex embeddings \\sigma_i \\colon K \\to \\mathbf{C} , 1 \\leq i \\leq 2s . In Hecke the complex embeddings are always ordered such that \\sigma_i = \\overline{\\sigma_{i+s}} for r + 1 \\leq i \\leq r + s . The \\mathbf{Q} -linear function \\begin{gather*} K \\longrightarrow \\mathbf R^{d} \\\\ \\alpha \\longmapsto \\Bigl( \\sigma_1(\\alpha), \\dotsc, \\sigma_r(\\alpha), \\sqrt{2}\\operatorname{Re}\\bigl(\\sigma_{r+1}(\\alpha)\\bigr), \\sqrt{2}\\operatorname{Im}\\bigl(\\sigma_{r+1}(\\alpha)\\bigr), \\dotsc, \\sqrt{2}\\operatorname{Re}\\bigl(\\sigma_{r+s}(\\alpha)\\bigr), \\sqrt{2}\\operatorname{Im}\\bigl(\\sigma_{r+s}(\\alpha)\\bigr) \\Bigr) \\end{gather*} is called the Minkowski map (or Minkowski embedding ).","title":"Number fields"},{"location":"orders/introduction/#orders","text":"If K = \\mathbf Q(\\alpha) is an absolute number field, then an order \\mathcal O of K is a subring of the ring of integers \\mathcal O_K , which is free of rank [ K : \\mathbf Q] as a \\mathbf Z -module. The natural order \\mathbf Z[\\alpha] is called the equation order of K . In Hecke orders of absolute number fields are constructed (implicitely) by specifying a \\mathbf Z -basis, which is refered to as the basis of \\mathcal O . If (\\omega_1,\\dotsc,\\omega_d) is the basis of \\mathcal O , then the matrix B \\in \\operatorname{Mat}_{d \\times d}(\\mathbf Q) with \\begin{pmatrix} \\omega_1 \\\\ \\vdots \\\\ \\omega_d \\end{pmatrix} = B \\begin{pmatrix} 1 \\\\ \\vdots \\\\ \\alpha^{d - 1} \\end{pmatrix} is called the basis matrix of \\mathcal O . We call \\det(B) the generalized index of \\mathcal O . In case \\mathbf Z[\\alpha] \\subseteq \\mathcal O , the determinant \\det(B)^{-1} is in fact equal to [ \\mathcal O : \\mathbf Z[\\alpha]] and is called the index of \\mathcal O . The matrix \\begin{pmatrix} \\sigma_1(\\omega_1) & \\dotsc & \\sigma_r(\\omega_1) & \\sqrt{2}\\operatorname{Re}(\\sigma_{r+1}(\\omega_1)) & \\sqrt{2}\\operatorname{Im}(\\sigma_{r+1}(\\omega_1)) & \\dotsc & \\sqrt{2}\\operatorname{Im}(\\sigma_{r+s}(\\omega_1)) \\\\\\\\ \\sigma_1(\\omega_2) & \\dotsc & \\sigma_r(\\omega_2) & \\sqrt{2}\\operatorname{Re}(\\sigma_{r+1}(\\omega_2)) & \\sqrt{2}\\operatorname{Im}(\\sigma_{r+1}(\\omega_2)) & \\dotsc & \\sqrt{2}\\operatorname{Im}(\\sigma_{r+s}(\\omega_2)) \\\\\\\\ \\vdots & \\ddots & \\vdots & \\vdots & \\vdots & \\ddots & \\vdots\\\\\\\\ \\sigma_1(\\omega_d) & \\dotsc & \\sigma_r(\\omega_d) & \\sqrt{2}\\operatorname{Re}(\\sigma_{r+1}(\\omega_d)) & \\sqrt{2}\\operatorname{Im}(\\sigma_{r+2}(\\omega_d)) & \\dotsc & \\sqrt{2}\\operatorname{Im}(\\sigma_{r+s}(\\omega_d)) \\end{pmatrix} \\in \\operatorname{Mat}_{d\\times d}(\\mathbf R). is called the Minkowski matrix of \\mathcal O .","title":"Orders"},{"location":"orders/introduction/#examples","text":"Usually, to create an order, one starts with a field (or a polynomial): julia> Qx, x = PolynomialRing(FlintQQ, \"x\"); julia> K, a = NumberField(x^2 - 10, \"a\"); julia> E = EquationOrder(K) Maximal order of Number field over Rational Field with defining polynomial x^2 - 10 with basis nf_elem[1, a] julia> Z_K = MaximalOrder(K) Maximal order of Number field over Rational Field with defining polynomial x^2 - 10 with basis nf_elem[1, a] julia> conductor(E) <no 2-elts present> basis_matrix [1 0; 0 1] julia> E == Z_K true Once orders are created, we can play with elements and ideals: julia> lp = prime_decomposition(Z_K, 2) 1-element Array{Tuple{NfAbsOrdIdl{AnticNumberField,nf_elem},Int64},1}: (<2, a> Norm: 2 Minimum: 2 two normal wrt: 2, 2) julia> p = lp[1][1] <2, a> Norm: 2 Minimum: 2 two normal wrt: 2 julia> isprincipal(p) (false, 1) julia> fl, alpha = isprincipal(p^2) (true, -2) julia> norm(alpha) 4 It is possible to work with residue fields as well: julia> Fp, mFp = ResidueField(Z_K, p) (Finite field of degree 1 over F_2, Map with following data Domain: ======= Maximal order of Number field over Rational Field with defining polynomial x^2 - 10 with basis nf_elem[1, a] Codomain: ========= Finite field of degree 1 over F_2 ) julia> [ mFp(x) for x = basis(Z_K)] 2-element Array{fq,1}: 1 0","title":"Examples"},{"location":"orders/orders/","text":"Orders Orders, ie. unitary subrings that are free Z -modules of rank equal to the degree of the number field, are at the core of the arithmetic of number fields. In Hecke, orders are always represented using the module structure, be it the Z -module structure for orders in absolute fields, of the structure as a module over the maximal order of the base field in the case of relative extensions. In this chapter we only deal with orders in absolute fields. There are more general definitions of orders in number fields available, but those are (currently) not implemented in Hecke. Among all orders in a fixed field, there is a unique maximal one, called the maximal order, or ring of integers of the field. It is well known that this is the only order that is a Dedekind domain, hence has a rich ideal structure as well. The maximal order is also the integral closure of Z in the number field and can also be interpreted as a normalisation of any other order. Creation and basic properties Order ( B :: Array { nf_elem , 1 }; check :: Bool = true , cached :: Bool = true ) -> NfOrd Returns the order generated by B . If check is set, it is checked whether B defines an order. If isbasis is set, then elements are assumed to form a \\mathbf{Z} -basis. Order ( K :: AnticNumberField , A :: FakeFmpqMat ; check :: Bool = true ) -> NfOrd Returns the order which has basis matrix A with respect to the power basis of K . If check is set, it is checked whether A defines an order. Order ( K :: NumField , M :: PMat ) -> NfRelOrd Returns the order which has basis pseudo-matrix M with respect to the power basis of K . Order(K::AnticNumberField, A::fmpz_mat, check::Bool = true) -> NfOrd Returns the order which has basis matrix A with respect to the power basis of K . If check is set, it is checked whether A defines an order. Order(A::AbsAlgAss{<: NumFieldElem}, M::PMat{<: NumFieldElem, T}) -> AlgAssRelOrd Returns the order of A with basis pseudo-matrix M . EquationOrder ( L :: NumField ) -> NfRelOrd equation_order ( L :: NumField ) -> NfRelOrd Returns the equation order of the number field L . EquationOrder(K::NfAbs) -> NfAbsOrd Returns the equation order of the absolute number field K . MaximalOrder ( K :: NumField { fmpq }; discriminant :: fmpz , ramified_primes :: Vector { fmpz }) -> NfAbsOrd Returns the maximal order of K . Additional information can be supplied if they are already known, as the ramified primes or the discriminant of the maximal order. Example julia> Qx, x = FlintQQ[\"x\"]; julia> K, a = NumberField(x^3 + 2, \"a\"); julia> O = MaximalOrder(K); MaximalOrder ( O :: NfAbsOrd ; index_divisors :: Vector { fmpz }, discriminant :: fmpz , ramified_primes :: Vector { fmpz }) -> NfAbsOrd Returns the maximal order of the number field that contains O . Additional information can be supplied if they are already known, as the ramified primes, the discriminant of the maximal order or a set of integers dividing the index of O in the maximal order. MaximalOrder(O::AlgAssAbsOrd) Given an order O , this function returns a maximal order containing O . MaximalOrder(A::AbsAlgAss{fmpq}) -> AlgAssAbsOrd Returns a maximal order of A . maximal_order ( O :: AlgAssRelOrd ) -> AlgAssRelOrd Returns a maximal order of the algebra of O containing itself. lll ( M :: NfAbsOrd ) -> NfAbsOrd The same order, but with the basis now being LLL reduced wrt. the Minkowski metric. By Chistov's fundamental theorem, the computation of the maximal order is basically as hard as the factorisation of the discriminant. In order to help the computer, Hecke also provides the following signatures: Missing docstring. Missing docstring for maximal_order(::AnticNumberField, ::Array{fmpz, 1}) . Check Documenter's build log for details. It is also possible the execute the steps individually: pradical ( O :: NfOrd , p :: { fmpz | Integer }) -> NfAbsOrdIdl Given a prime number p , this function returns the p -radical \\sqrt{p\\mathcal O} of \\mathcal O , which is just \\{ x \\in \\mathcal O \\mid \\exists k \\in \\mathbf Z_{\\geq 0} \\colon x^k \\in p\\mathcal O \\} . It is not checked that p is prime. ring_of_multipliers ( a :: NfRelOrdIdl ) -> NfRelOrd Computes the order (a : a) , which is the set of all x \\in K with xa \\subseteq a , where K is the ambient number field of a . ring_of_multipliers(I::NfAbsOrdIdl) -> NfAbsOrd Computes the order (I : I) , which is the set of all x \\in K with xI \\subseteq I . Example julia> Qx, x = PolynomialRing(FlintQQ, \"x\"); julia> K, a = NumberField(x^2 - 2, \"a\"); julia> O = EquationOrder(K) Order of Number field over Rational Field with defining polynomial x^2 - 2 with Z-basis NfAbsOrdElem{AnticNumberField,nf_elem}[1, a] parent ( O :: NfAbsOrd ) -> NfOrdSet Returns the parent of \\mathcal O , that is, the set of orders of the ambient number field. isequation_order ( O :: NfAbsOrd ) -> Bool Returns whether \\mathcal O is the equation order of the ambient number field K . signature ( O :: NfOrd ) -> Tuple { Int , Int } Returns the signature of the ambient number field of \\mathcal O . nf ( O :: NfRelOrd ) -> NumField Returns the ambient number field of \\mathcal O . nf(O::NfAbsOrd) -> AnticNumberField Returns the ambient number field of \\mathcal O . degree ( O :: NfOrd ) -> Int Returns the degree of \\mathcal O . basis ( O :: NfOrd ) -> Array { NfOrdElem , 1 } Returns the \\mathbf Z -basis of \\mathcal O . basis ( I :: NfAbsOrdFracIdl ) -> Array { nf_elem , 1 } Returns the \\mathbf Z -basis of I . basis ( O :: NfOrd , K :: AnticNumberField ) -> Array { nf_elem , 1 } Returns the \\mathbf Z -basis elements of \\mathcal O as elements of the ambient number field. basis_matrix ( O :: NfOrd ) -> FakeFmpqMat Returns the basis matrix of \\mathcal O with respect to the power basis of the ambient number field. basis_mat_inv ( O :: NfOrd ) -> FakeFmpqMat Returns the inverse of the basis matrix of \\mathcal O . basis_mat_inv(A::NfAbsOrdIdl) -> fmpz_mat Returns the inverse basis matrix of A . discriminant ( O :: NfOrd ) -> fmpz Returns the discriminant of \\mathcal O . discriminant ( B :: Array { NfAbsOrdElem , 1 }) -> fmpz Returns the discriminant of the family B . discriminant(E::EllCrv{T}) -> T Computes the discriminant of E . discriminant(O::AlgssRelOrd) Returns the discriminant of O . gen_index ( O :: NfOrd ) -> fmpq Returns the generalized index of \\mathcal O with respect to the equation order of the ambient number field. index ( O :: NfOrd ) -> fmpz Assuming that the order \\mathcal O contains the equation order \\mathbf Z[\\alpha] of the ambient number field, this function returns the index [ \\mathcal O : \\mathbf Z] . isindex_divisor ( O :: NfOrd , d :: fmpz ) -> Bool isindex_divisor ( O :: NfOrd , d :: Int ) -> Bool Returns whether d is a divisor of the index of \\mathcal O . It is assumed that \\mathcal O contains the equation order of the ambient number field. minkowski_matrix ( O :: NfOrd , abs_tol :: Int = 64 ) -> arb_mat Returns the Minkowski matrix of \\mathcal O . Thus if \\mathcal O has degree d , then the result is a matrix in \\operatorname{Mat}_{d\\times d}(\\mathbf R) . The entries of the matrix are real balls of type arb with radius less then 2^-abs_tol . in ( a :: nf_elem , O :: NfOrd ) -> Bool Checks whether a lies in \\mathcal O . Missing docstring. Missing docstring for denominator(::nf_elem, ::NfOrd) . Check Documenter's build log for details. norm_change_const ( O :: NfOrd ) -> ( Float64 , Float64 ) Returns (c_1, c_2) \\in \\mathbf R_{>0}^2 such that for all x = \\sum_{i=1}^d x_i \\omega_i \\in \\mathcal O we have T_2(x) \\leq c_1 \\cdot \\sum_i^d x_i^2 and \\sum_i^d x_i^2 \\leq c_2 \\cdot T_2(x) , where (\\omega_i)_i is the \\mathbf Z -basis of \\mathcal O . trace_matrix ( O :: NfOrd ) -> fmpz_mat Returns the trace matrix of \\mathcal O , that is, the matrix (\\operatorname{tr}_{K/\\mathbf Q}(b_i \\cdot b_j))_{1 \\leq i, j \\leq d} . + ( R :: NfOrd , S :: NfOrd ) -> NfOrd Given two orders R , S of K , this function returns the smallest order containing both R and S . It is assumed that R , S contain the ambient equation order and have coprime index. poverorder ( O :: NfOrd , p :: fmpz ) -> NfOrd poverorder ( O :: NfOrd , p :: Integer ) -> NfOrd This function tries to find an order that is locally larger than \\mathcal O at the prime p : If p divides the index [ \\mathcal O_K : \\mathcal O] , this function will return an order R such that v_p([ \\mathcal O_K : R]) < v_p([ \\mathcal O_K : \\mathcal O]) . Otherwise \\mathcal O is returned. pmaximal_overorder ( O :: NfOrd , p :: fmpz ) -> NfOrd pmaximal_overorder ( O :: NfOrd , p :: Integer ) -> NfOrd This function finds a p -maximal order R containing \\mathcal O . That is, the index [ \\mathcal O_K : R] is not divisible by p .","title":"Basics"},{"location":"orders/orders/#orders","text":"Orders, ie. unitary subrings that are free Z -modules of rank equal to the degree of the number field, are at the core of the arithmetic of number fields. In Hecke, orders are always represented using the module structure, be it the Z -module structure for orders in absolute fields, of the structure as a module over the maximal order of the base field in the case of relative extensions. In this chapter we only deal with orders in absolute fields. There are more general definitions of orders in number fields available, but those are (currently) not implemented in Hecke. Among all orders in a fixed field, there is a unique maximal one, called the maximal order, or ring of integers of the field. It is well known that this is the only order that is a Dedekind domain, hence has a rich ideal structure as well. The maximal order is also the integral closure of Z in the number field and can also be interpreted as a normalisation of any other order.","title":"Orders"},{"location":"orders/orders/#creation-and-basic-properties","text":"Order ( B :: Array { nf_elem , 1 }; check :: Bool = true , cached :: Bool = true ) -> NfOrd Returns the order generated by B . If check is set, it is checked whether B defines an order. If isbasis is set, then elements are assumed to form a \\mathbf{Z} -basis. Order ( K :: AnticNumberField , A :: FakeFmpqMat ; check :: Bool = true ) -> NfOrd Returns the order which has basis matrix A with respect to the power basis of K . If check is set, it is checked whether A defines an order. Order ( K :: NumField , M :: PMat ) -> NfRelOrd Returns the order which has basis pseudo-matrix M with respect to the power basis of K . Order(K::AnticNumberField, A::fmpz_mat, check::Bool = true) -> NfOrd Returns the order which has basis matrix A with respect to the power basis of K . If check is set, it is checked whether A defines an order. Order(A::AbsAlgAss{<: NumFieldElem}, M::PMat{<: NumFieldElem, T}) -> AlgAssRelOrd Returns the order of A with basis pseudo-matrix M . EquationOrder ( L :: NumField ) -> NfRelOrd equation_order ( L :: NumField ) -> NfRelOrd Returns the equation order of the number field L . EquationOrder(K::NfAbs) -> NfAbsOrd Returns the equation order of the absolute number field K . MaximalOrder ( K :: NumField { fmpq }; discriminant :: fmpz , ramified_primes :: Vector { fmpz }) -> NfAbsOrd Returns the maximal order of K . Additional information can be supplied if they are already known, as the ramified primes or the discriminant of the maximal order. Example julia> Qx, x = FlintQQ[\"x\"]; julia> K, a = NumberField(x^3 + 2, \"a\"); julia> O = MaximalOrder(K); MaximalOrder ( O :: NfAbsOrd ; index_divisors :: Vector { fmpz }, discriminant :: fmpz , ramified_primes :: Vector { fmpz }) -> NfAbsOrd Returns the maximal order of the number field that contains O . Additional information can be supplied if they are already known, as the ramified primes, the discriminant of the maximal order or a set of integers dividing the index of O in the maximal order. MaximalOrder(O::AlgAssAbsOrd) Given an order O , this function returns a maximal order containing O . MaximalOrder(A::AbsAlgAss{fmpq}) -> AlgAssAbsOrd Returns a maximal order of A . maximal_order ( O :: AlgAssRelOrd ) -> AlgAssRelOrd Returns a maximal order of the algebra of O containing itself. lll ( M :: NfAbsOrd ) -> NfAbsOrd The same order, but with the basis now being LLL reduced wrt. the Minkowski metric. By Chistov's fundamental theorem, the computation of the maximal order is basically as hard as the factorisation of the discriminant. In order to help the computer, Hecke also provides the following signatures: Missing docstring. Missing docstring for maximal_order(::AnticNumberField, ::Array{fmpz, 1}) . Check Documenter's build log for details. It is also possible the execute the steps individually: pradical ( O :: NfOrd , p :: { fmpz | Integer }) -> NfAbsOrdIdl Given a prime number p , this function returns the p -radical \\sqrt{p\\mathcal O} of \\mathcal O , which is just \\{ x \\in \\mathcal O \\mid \\exists k \\in \\mathbf Z_{\\geq 0} \\colon x^k \\in p\\mathcal O \\} . It is not checked that p is prime. ring_of_multipliers ( a :: NfRelOrdIdl ) -> NfRelOrd Computes the order (a : a) , which is the set of all x \\in K with xa \\subseteq a , where K is the ambient number field of a . ring_of_multipliers(I::NfAbsOrdIdl) -> NfAbsOrd Computes the order (I : I) , which is the set of all x \\in K with xI \\subseteq I .","title":"Creation and basic properties"},{"location":"orders/orders/#example","text":"julia> Qx, x = PolynomialRing(FlintQQ, \"x\"); julia> K, a = NumberField(x^2 - 2, \"a\"); julia> O = EquationOrder(K) Order of Number field over Rational Field with defining polynomial x^2 - 2 with Z-basis NfAbsOrdElem{AnticNumberField,nf_elem}[1, a] parent ( O :: NfAbsOrd ) -> NfOrdSet Returns the parent of \\mathcal O , that is, the set of orders of the ambient number field. isequation_order ( O :: NfAbsOrd ) -> Bool Returns whether \\mathcal O is the equation order of the ambient number field K . signature ( O :: NfOrd ) -> Tuple { Int , Int } Returns the signature of the ambient number field of \\mathcal O . nf ( O :: NfRelOrd ) -> NumField Returns the ambient number field of \\mathcal O . nf(O::NfAbsOrd) -> AnticNumberField Returns the ambient number field of \\mathcal O . degree ( O :: NfOrd ) -> Int Returns the degree of \\mathcal O . basis ( O :: NfOrd ) -> Array { NfOrdElem , 1 } Returns the \\mathbf Z -basis of \\mathcal O . basis ( I :: NfAbsOrdFracIdl ) -> Array { nf_elem , 1 } Returns the \\mathbf Z -basis of I . basis ( O :: NfOrd , K :: AnticNumberField ) -> Array { nf_elem , 1 } Returns the \\mathbf Z -basis elements of \\mathcal O as elements of the ambient number field. basis_matrix ( O :: NfOrd ) -> FakeFmpqMat Returns the basis matrix of \\mathcal O with respect to the power basis of the ambient number field. basis_mat_inv ( O :: NfOrd ) -> FakeFmpqMat Returns the inverse of the basis matrix of \\mathcal O . basis_mat_inv(A::NfAbsOrdIdl) -> fmpz_mat Returns the inverse basis matrix of A . discriminant ( O :: NfOrd ) -> fmpz Returns the discriminant of \\mathcal O . discriminant ( B :: Array { NfAbsOrdElem , 1 }) -> fmpz Returns the discriminant of the family B . discriminant(E::EllCrv{T}) -> T Computes the discriminant of E . discriminant(O::AlgssRelOrd) Returns the discriminant of O . gen_index ( O :: NfOrd ) -> fmpq Returns the generalized index of \\mathcal O with respect to the equation order of the ambient number field. index ( O :: NfOrd ) -> fmpz Assuming that the order \\mathcal O contains the equation order \\mathbf Z[\\alpha] of the ambient number field, this function returns the index [ \\mathcal O : \\mathbf Z] . isindex_divisor ( O :: NfOrd , d :: fmpz ) -> Bool isindex_divisor ( O :: NfOrd , d :: Int ) -> Bool Returns whether d is a divisor of the index of \\mathcal O . It is assumed that \\mathcal O contains the equation order of the ambient number field. minkowski_matrix ( O :: NfOrd , abs_tol :: Int = 64 ) -> arb_mat Returns the Minkowski matrix of \\mathcal O . Thus if \\mathcal O has degree d , then the result is a matrix in \\operatorname{Mat}_{d\\times d}(\\mathbf R) . The entries of the matrix are real balls of type arb with radius less then 2^-abs_tol . in ( a :: nf_elem , O :: NfOrd ) -> Bool Checks whether a lies in \\mathcal O . Missing docstring. Missing docstring for denominator(::nf_elem, ::NfOrd) . Check Documenter's build log for details. norm_change_const ( O :: NfOrd ) -> ( Float64 , Float64 ) Returns (c_1, c_2) \\in \\mathbf R_{>0}^2 such that for all x = \\sum_{i=1}^d x_i \\omega_i \\in \\mathcal O we have T_2(x) \\leq c_1 \\cdot \\sum_i^d x_i^2 and \\sum_i^d x_i^2 \\leq c_2 \\cdot T_2(x) , where (\\omega_i)_i is the \\mathbf Z -basis of \\mathcal O . trace_matrix ( O :: NfOrd ) -> fmpz_mat Returns the trace matrix of \\mathcal O , that is, the matrix (\\operatorname{tr}_{K/\\mathbf Q}(b_i \\cdot b_j))_{1 \\leq i, j \\leq d} . + ( R :: NfOrd , S :: NfOrd ) -> NfOrd Given two orders R , S of K , this function returns the smallest order containing both R and S . It is assumed that R , S contain the ambient equation order and have coprime index. poverorder ( O :: NfOrd , p :: fmpz ) -> NfOrd poverorder ( O :: NfOrd , p :: Integer ) -> NfOrd This function tries to find an order that is locally larger than \\mathcal O at the prime p : If p divides the index [ \\mathcal O_K : \\mathcal O] , this function will return an order R such that v_p([ \\mathcal O_K : R]) < v_p([ \\mathcal O_K : \\mathcal O]) . Otherwise \\mathcal O is returned. pmaximal_overorder ( O :: NfOrd , p :: fmpz ) -> NfOrd pmaximal_overorder ( O :: NfOrd , p :: Integer ) -> NfOrd This function finds a p -maximal order R containing \\mathcal O . That is, the index [ \\mathcal O_K : R] is not divisible by p .","title":"Example"},{"location":"quad_forms/basics/","text":"Basics Creation of spaces quadratic_space ( K :: NumField , n :: Int ) -> QuadSpace Create the quadratic space over K with dimension n and Gram matrix equal to the identity matrix. quadratic_space ( K :: NumField , G :: Int ) -> QuadSpace Create the quadratic space over K with Gram matrix G . The matrix G must be square and symmetric. Attributes rank ( V :: AbsSpace ) -> Int Return the rank of the quadratic space V . dim ( V :: AbsSpace ) -> Int Return the dimension of the space V . gram_matrix ( V :: AbsSpace ) -> MatElem Return the Gram matrix of V . Missing docstring. Missing docstring for base_field(::AbsSpace) . Check Documenter's build log for details. involution ( V :: AbsSpace ) -> NumField Return the involution of V . isregular ( V :: AbsSpace ) -> Bool Return whether V is regular, that is, if the Gram matrix has full rank. det ( V :: AbsSpace ) -> FieldElem Returns the determinant of the space V as an element of the fixed field. discriminant ( V :: AbsSpace ) -> FieldElem Returns the discriminant of the space V as an element of the fixed field. Inner products and diagonalization gram_matrix ( V :: AbsSpace , M :: MatElem ) -> MatElem Returns the gram matrix of the rows of M . gram_matrix ( V :: AbsSpace , S :: Vector { Vector }) -> MatElem Returns the gram matrix of the sequence S . inner_product ( V :: AbsSpace , v :: Vector , w :: Vector ) -> FieldElem Returns the inner product of v and w with respect to V . orthogonal_basis ( V :: AbsSpace ) -> MatElem Returns a matrix M , such that the rows of M form an orthgonal basis of V . diagonal ( V :: AbsSpace ) -> Vector { FieldElem } Returns a vector of elements a_1,\\dotsc,a_n such that V is isometric to the diagonal space \\langle a_1,\\dotsc,a_n \\rangle . The elements will be contained in the fixed field of V . Equivalence hasse_invariant ( V :: QuadSpace , p :: Union { InfPlc , NfOrdIdl }) -> Int Returns the Hasse invariant of the quadratic space V at p . This is equal to the product of local Hilbert symbols (a_i, a_j)_p , i < j , where V is isometric to \\langle a_1,\\dotsc,a_n\\rangle . witt_invariant ( V :: QuadSpace , p :: Union { InfPlc , NfOrdIdl }) -> Int Returns the Witt invariant of the quadratic space V at p . See [Definition 3.2.1, Kir16]. isequivalent ( L :: AbsSpace , M :: AbsSpace , p :: Union { InfPlc , NfOrdIdl }) -> Bool Returns whether L and M are equivalent over the completion at p . invariants ( M :: QuadSpace ) -> FieldElem , Dict { NfOrdIdl , Int }, Vector { Tuple { InfPlc , Int }} Returns a tuple (n, k, d, H, I) of invariants of M , which determine the equivalence class completely. Here n is the dimension. The dimension of the kernel is k . The element d is the determinant of a Gram matrix of the non-degenerate part, H contains the non-trivial Hasse invariants and I contains for each real place the negative index of inertia. Note that d is determined only modulo squares. isequivalent ( M :: QuadSpace , L :: QuadSpace ) -> Bool Tests if M and L are equivalent.","title":"Basics"},{"location":"quad_forms/basics/#basics","text":"","title":"Basics"},{"location":"quad_forms/basics/#creation-of-spaces","text":"quadratic_space ( K :: NumField , n :: Int ) -> QuadSpace Create the quadratic space over K with dimension n and Gram matrix equal to the identity matrix. quadratic_space ( K :: NumField , G :: Int ) -> QuadSpace Create the quadratic space over K with Gram matrix G . The matrix G must be square and symmetric.","title":"Creation of spaces"},{"location":"quad_forms/basics/#attributes","text":"rank ( V :: AbsSpace ) -> Int Return the rank of the quadratic space V . dim ( V :: AbsSpace ) -> Int Return the dimension of the space V . gram_matrix ( V :: AbsSpace ) -> MatElem Return the Gram matrix of V . Missing docstring. Missing docstring for base_field(::AbsSpace) . Check Documenter's build log for details. involution ( V :: AbsSpace ) -> NumField Return the involution of V . isregular ( V :: AbsSpace ) -> Bool Return whether V is regular, that is, if the Gram matrix has full rank. det ( V :: AbsSpace ) -> FieldElem Returns the determinant of the space V as an element of the fixed field. discriminant ( V :: AbsSpace ) -> FieldElem Returns the discriminant of the space V as an element of the fixed field.","title":"Attributes"},{"location":"quad_forms/basics/#inner-products-and-diagonalization","text":"gram_matrix ( V :: AbsSpace , M :: MatElem ) -> MatElem Returns the gram matrix of the rows of M . gram_matrix ( V :: AbsSpace , S :: Vector { Vector }) -> MatElem Returns the gram matrix of the sequence S . inner_product ( V :: AbsSpace , v :: Vector , w :: Vector ) -> FieldElem Returns the inner product of v and w with respect to V . orthogonal_basis ( V :: AbsSpace ) -> MatElem Returns a matrix M , such that the rows of M form an orthgonal basis of V . diagonal ( V :: AbsSpace ) -> Vector { FieldElem } Returns a vector of elements a_1,\\dotsc,a_n such that V is isometric to the diagonal space \\langle a_1,\\dotsc,a_n \\rangle . The elements will be contained in the fixed field of V .","title":"Inner products and diagonalization"},{"location":"quad_forms/basics/#equivalence","text":"hasse_invariant ( V :: QuadSpace , p :: Union { InfPlc , NfOrdIdl }) -> Int Returns the Hasse invariant of the quadratic space V at p . This is equal to the product of local Hilbert symbols (a_i, a_j)_p , i < j , where V is isometric to \\langle a_1,\\dotsc,a_n\\rangle . witt_invariant ( V :: QuadSpace , p :: Union { InfPlc , NfOrdIdl }) -> Int Returns the Witt invariant of the quadratic space V at p . See [Definition 3.2.1, Kir16]. isequivalent ( L :: AbsSpace , M :: AbsSpace , p :: Union { InfPlc , NfOrdIdl }) -> Bool Returns whether L and M are equivalent over the completion at p . invariants ( M :: QuadSpace ) -> FieldElem , Dict { NfOrdIdl , Int }, Vector { Tuple { InfPlc , Int }} Returns a tuple (n, k, d, H, I) of invariants of M , which determine the equivalence class completely. Here n is the dimension. The dimension of the kernel is k . The element d is the determinant of a Gram matrix of the non-degenerate part, H contains the non-trivial Hasse invariants and I contains for each real place the negative index of inertia. Note that d is determined only modulo squares. isequivalent ( M :: QuadSpace , L :: QuadSpace ) -> Bool Tests if M and L are equivalent.","title":"Equivalence"},{"location":"quad_forms/introduction/","text":"Introduction This chapter deals with quadratic and Hermitian spaces and lattices there of. Definitions and vocabulary We begin by collecting the necessary definitions and vocabulary. The terminology follows mainly [Kir16] Quadratic and Hermitian spaces Let E be a number field. A quadratic space is a finite-dimensional vector space V over E together with a bilinear morphism \\Phi \\colon V \\times V \\to E . We will always work with an implicit canonical basis e_1,\\dotsc,e_n of V . In view of this, quadratic spaces are in bijection with symmetric matrices over E . If V is a quadratic space, we call the matrix G = (\\Phi(e_i, e_j))_{1 \\leq i, j \\leq n} \\in E^{n \\times n} the Gram matrix of V . Let E/K be an extension of number fields of degree two with non-trivial automorphism \\overline{\\phantom{x}} E \\to E . A Hermitian space is a finite-dimensional vector space V over E together with a sesquilinear (with respect to the involution \\overline{\\phantom{x}} ) morphism \\Phi \\colon V \\times V \\to K . We will always work with an implicit canonical basis e_1,\\dotsc,e_n of V . In view of this, Hermitian spaces are in bijection with Hermitian matrices over E . If V is a Hermitian space, we call the matrix G = (\\Phi(e_i, e_j))_{1 \\leq i, j \\leq n} \\in E^{n \\times n} the Gram matrix of V . We call \\overline{\\phantom{x}} the involution of V . In both cases we refer to the field E as the base ring V . In this chapter we will refer to quadratic and Hermitian spaces also just as spaces . For Hermitian lattices, the field K will be refered to as the fixed field of V . Quadratic and Hermitian lattices Let V be a space (either quadratic or Hermitian) with base field E . A finitely generated \\mathcal O_E -submodule L of V is called a quadratic lattice or Hermitian lattice respectively. We call V the ambient space of L and L\\otimes_{\\mathcal O_E} E the rational span of L . The ring \\mathcal O_E will be referred to as the base ring of L . References Many of the implemented algorithms for computing with quadratic and hermitian lattices over number fields are based on the Magma implementation of Markus Kirschmer, which can be found here . [Kir16] : Definite quadratic and hermitian forms with small class number. Habilitationsschrift. RWTH Aachen University, 2016, pdf","title":"Introduction"},{"location":"quad_forms/introduction/#introduction","text":"This chapter deals with quadratic and Hermitian spaces and lattices there of.","title":"Introduction"},{"location":"quad_forms/introduction/#definitions-and-vocabulary","text":"We begin by collecting the necessary definitions and vocabulary. The terminology follows mainly [Kir16]","title":"Definitions and vocabulary"},{"location":"quad_forms/introduction/#quadratic-and-hermitian-spaces","text":"Let E be a number field. A quadratic space is a finite-dimensional vector space V over E together with a bilinear morphism \\Phi \\colon V \\times V \\to E . We will always work with an implicit canonical basis e_1,\\dotsc,e_n of V . In view of this, quadratic spaces are in bijection with symmetric matrices over E . If V is a quadratic space, we call the matrix G = (\\Phi(e_i, e_j))_{1 \\leq i, j \\leq n} \\in E^{n \\times n} the Gram matrix of V . Let E/K be an extension of number fields of degree two with non-trivial automorphism \\overline{\\phantom{x}} E \\to E . A Hermitian space is a finite-dimensional vector space V over E together with a sesquilinear (with respect to the involution \\overline{\\phantom{x}} ) morphism \\Phi \\colon V \\times V \\to K . We will always work with an implicit canonical basis e_1,\\dotsc,e_n of V . In view of this, Hermitian spaces are in bijection with Hermitian matrices over E . If V is a Hermitian space, we call the matrix G = (\\Phi(e_i, e_j))_{1 \\leq i, j \\leq n} \\in E^{n \\times n} the Gram matrix of V . We call \\overline{\\phantom{x}} the involution of V . In both cases we refer to the field E as the base ring V . In this chapter we will refer to quadratic and Hermitian spaces also just as spaces . For Hermitian lattices, the field K will be refered to as the fixed field of V .","title":"Quadratic and Hermitian spaces"},{"location":"quad_forms/introduction/#quadratic-and-hermitian-lattices","text":"Let V be a space (either quadratic or Hermitian) with base field E . A finitely generated \\mathcal O_E -submodule L of V is called a quadratic lattice or Hermitian lattice respectively. We call V the ambient space of L and L\\otimes_{\\mathcal O_E} E the rational span of L . The ring \\mathcal O_E will be referred to as the base ring of L .","title":"Quadratic and Hermitian lattices"},{"location":"quad_forms/introduction/#references","text":"Many of the implemented algorithms for computing with quadratic and hermitian lattices over number fields are based on the Magma implementation of Markus Kirschmer, which can be found here . [Kir16] : Definite quadratic and hermitian forms with small class number. Habilitationsschrift. RWTH Aachen University, 2016, pdf","title":"References"},{"location":"quad_forms/lattices/","text":"Quadratic and hermitian lattices Creation of lattices quadratic_lattice ( K :: NumField , B :: MatElem ; gram_ambient_space = F ) -> QuadLat Given a number field K and a matrix B , returns the quadratic lattice spanned by the rows of B inside the quadratic space over K with gram matrix F . If F is not supplied, the gram matrix of the ambient space will be the identity matrix. quadratic_lattice ( K :: NumField , B :: PMat ; gram_ambient_space = F ) -> QuadLat Given a number field K and a pseudo-matrix B , returns the quadratic lattice spanned by the pseudo-matrix B inside the quadratic space over K with gram matrix F . If F is not supplied, the gram matrix of the ambient space will be the identity matrix. hermitian_lattice ( K :: NumField , B :: MatElem ; gram_ambient_space = F ) -> HermLat Given a number field K and a matrix B , returns the hermitian lattice spanned by the rows of B inside the hermitian space over K with gram matrix F . If F is not supplied, the gram matrix of the ambient space will be the identity matrix. hermitian_lattice ( K :: NumField , B :: PMat ; gram_ambient_space = F ) -> HermLat Given a number field K and a pseudo-matrix B , returns the hermitian lattice spanned by the pseudo-matrix B inside the hermitian space over K with gram matrix F . If F is not supplied, the gram matrix of the ambient space will be the identity matrix. Basic invariants ambient_space ( L :: AbsLat ) -> AbsSpace Returns the ambient space of L . If the ambient space is not known, an error is raised. rational_span ( L :: AbsLat ) -> AbsSpace Returns the rational span of L . diagonal ( A :: Mat { T }) -> Vector { T } Returns the diagonal of A as an array. fixed_field ( L :: AbsLat ) -> NumField Returns the fixed field of the involution of L . involution ( L :: AbsLat ) -> Map Returns the involution of the rational span of L . rank ( L :: AbsLat ) -> Int Returns the rank of L , that is the dimension of the rational span of L . degree ( L :: AbsLat ) -> Int Returns the dimension of the ambient space of L . Missing docstring. Missing docstring for gram_matrix_of_basis(L::AbsLat) . Check Documenter's build log for details. generators ( L :: AbsLat ; minimal = false ) -> Vector { Vector } Returns a set of generators of L over the base ring of L . If minimal == true , the number of generators is minimal. Note that computing minimal generators is expensive. discriminant ( L :: AbsLat ) -> NfOrdFracIdl Returns the discriminant of L , that is, the generalized index ideal [L^\\# : L] . pseudo_matrix ( L :: AbsLat ) -> PMat Returns the basis pseudo-matrix of L . coefficient_ideals ( L :: Abs ) -> Vector { NfOrdIdl } Returns the coefficient ideals of the pseudo-basis of L . Missing docstring. Missing docstring for basis_matrix(L::AbsLat) . Check Documenter's build log for details. absolute_basis ( L :: AbsLat ) -> Vector Returns a \\mathbf{Z} -basis of L . absolute_basis_matrix ( L :: AbsLat ) -> MatElem Returns a \\mathbf{Z} -basis matrix of L . Rational invariants hasse_invariant ( L :: AbsLat , p :: Union { InfPlc , NfOrdIdl }) -> Int Returns the Hasse invariant of the rational span of L at p . The lattice must be quadratic. witt_invariant ( L :: AbsLat , p :: Union { InfPlc , NfOrdIdl }) -> Int Returns the Witt invariant of the rational span of L at p . The lattice must be quadratic. isrationally_equivalent ( L :: AbsLat , M :: AbsLat , p :: Union { InfPlc , NfOrdIdl }) -> Bool Returns whether the rational spans of L and M are equivalent over the completion at \\mathfrak p . isrationally_equivalent ( L :: AbsLat , M :: AbsLat ) -> Bool Returns whether the rational spans of L and M are equivalent. Definiteness ispositive_definite ( L :: AbsLat ) -> Bool Returns whether the rational span of L is positive definite. isnegative_definite ( L :: AbsLat ) -> Bool Returns whether the rational span of L is negative definite. isdefinite ( L :: AbsLat ) -> Bool Returns whether the rational span of L is definite. can_scale_totally_positive ( L :: AbsLat ) -> Bool , NumFieldElem Returns whether there is a totally positive rescaled lattice of L . If so, the second return value is an element a such that L^a is totally positive. Module operations Missing docstring. Missing docstring for Base.:(+)(::AbsLat, M::AbsLat) . Check Documenter's build log for details. Missing docstring. Missing docstring for intersect(L::AbsLat, M::AbsLat) . Check Documenter's build log for details. * ( a :: NumFieldElem , M :: AbsLat ) -> AbsLat Returns the lattice aM inside the ambient space of M . * ( a :: NfOrdIdl , M :: AbsLat ) -> AbsLat Returns the lattice aM inside the ambient space of M . * ( a :: NfOrdFracIdl , M :: AbsLat ) -> AbsLat Returns the lattice aM inside the ambient space of M . rescale ( L :: AbsLat , a :: NumFieldElem ) -> AbsLat Returns the rescaled lattice L^a . Note that this has a different ambient space than L . dual ( L :: AbsLat ) -> AbsLat Returns the dual lattice of L . Invariants norm ( L :: AbsLat ) -> NfOrdFracIdl Returns the norm of L . This is a fractional ideal of the fixed field of L . scale ( L :: AbsLat ) -> NfOrdFracIdl Returns the scale of L . isintegral ( L :: AbsLat ) -> Bool Returns whether the lattice L is integral. volume ( L :: AbsLat ) -> NfOrdFracIdl Returns the volume of L . ismodular ( L :: AbsLat ) -> Bool , NfOrdFracIdl Returns whether L is modular. In this case, the second return value is a fractional ideal \\mathfrak a such that \\mathfrak a L^\\# = L , where L^\\# is the dual of L . Local properties local_basis_matrix ( L :: AbsLat , p :: NfOrdIdl ; type = : any ) -> MatElem Given a prime ideal \\mathfrak p and a lattice L , this function returns a basis matrix of lattice M such that M_{\\mathfrak{p}} = L_{\\mathfrak{p}} . If type == :submodule , the lattice L will be a sublattice of M . If type == :supermodule , the lattice L will be a superlattice of M . If type == :any , there may not be any containment relation between M and L . Missing docstring. Missing docstring for ismodular(L::AbsLat, p) . Check Documenter's build log for details. Missing docstring. Missing docstring for bad_primes(L::AbsLat; even::Bool = false) . Check Documenter's build log for details. jordan_decomposition ( L :: AbsLat , p :: NfOrdIdl ) -> Vector { MatElem }, Vector { MatElem }, Vector { Int } Returns a Jordan decomposition of the completion of L at \\mathfrak p . The return value consists of three lists (M_i)_i , (G_i)_i and (s_i)_i of the same length r . The completions of the row spans of the matrices M_i yield a Jordan decomposition of L_{\\mathfrak{p}} into modular sublattices L_i with gram matrices G_i and scale of \\mathfrak{p} -adic valuation s_i . islocally_isometric ( L :: AbsLat , M :: AbsLat , p :: NfOrdIdl ) -> Bool Returns whether the completions of L and M at the prime ideal \\mathfrak{p} are locally isometric. Genera Creation of genera from lattices genus ( L :: HermLat , p :: NfOrdIdl ) -> LocalGenusHerm Returns the genus of L at the prime ideal \\mathfrak p . See [Kir16, Definition 8.3.1]. genus ( L :: HermLat ) -> GenusHerm Given a Hermitian lattice, return the genus it belongs to. Properties of genera rank ( G :: LocalGenusHerm ) -> Int Given a genus symbol G , return the rank of a lattice in G . rank ( G :: LocalGenusHerm , i :: Int ) Given a genus symbol for Hermitian lattices over E/K , return the rank of the i th Jordan block of G . ranks ( G :: LocalGenusHerm ) Given a genus symbol for Hermitian lattices over E/K , return the ranks of the Jordan blocks of G . det ( G :: LocalGenusHerm ) -> Int Given a genus symbol G , return the determinant of a lattice in G . This will be 1 or -1 depending on whether the determinant is a local norm or not. det_representative ( G :: LocalGenusHerm ) -> NumFieldElem Return a representative for the norm class of the determinant of G . gram_matrix ( G :: LocalGenusHerm ) Return a matrix M , such that a lattice with Gram matrix M is an element of the given genus. primes ( G :: GenusHerm ) -> Vector { NfOrdIdl } Return the primes of a global genus symbol. Check if lattice is contained in genus in ( L :: HermLat , G :: LocalGenusHerm ) -> Bool Test if the lattice L is contained in the local genus G . in ( L :: HermLat , G :: GenusHerm ) -> Bool Test if the lattice L is contained in the genus G . Creating representatives representative ( G :: LocalGenusHerm ) -> HermLat Given a local genus, return a Hermitian lattice contained in this genus.","title":"Lattices"},{"location":"quad_forms/lattices/#quadratic-and-hermitian-lattices","text":"","title":"Quadratic and hermitian lattices"},{"location":"quad_forms/lattices/#creation-of-lattices","text":"quadratic_lattice ( K :: NumField , B :: MatElem ; gram_ambient_space = F ) -> QuadLat Given a number field K and a matrix B , returns the quadratic lattice spanned by the rows of B inside the quadratic space over K with gram matrix F . If F is not supplied, the gram matrix of the ambient space will be the identity matrix. quadratic_lattice ( K :: NumField , B :: PMat ; gram_ambient_space = F ) -> QuadLat Given a number field K and a pseudo-matrix B , returns the quadratic lattice spanned by the pseudo-matrix B inside the quadratic space over K with gram matrix F . If F is not supplied, the gram matrix of the ambient space will be the identity matrix. hermitian_lattice ( K :: NumField , B :: MatElem ; gram_ambient_space = F ) -> HermLat Given a number field K and a matrix B , returns the hermitian lattice spanned by the rows of B inside the hermitian space over K with gram matrix F . If F is not supplied, the gram matrix of the ambient space will be the identity matrix. hermitian_lattice ( K :: NumField , B :: PMat ; gram_ambient_space = F ) -> HermLat Given a number field K and a pseudo-matrix B , returns the hermitian lattice spanned by the pseudo-matrix B inside the hermitian space over K with gram matrix F . If F is not supplied, the gram matrix of the ambient space will be the identity matrix.","title":"Creation of lattices"},{"location":"quad_forms/lattices/#basic-invariants","text":"ambient_space ( L :: AbsLat ) -> AbsSpace Returns the ambient space of L . If the ambient space is not known, an error is raised. rational_span ( L :: AbsLat ) -> AbsSpace Returns the rational span of L . diagonal ( A :: Mat { T }) -> Vector { T } Returns the diagonal of A as an array. fixed_field ( L :: AbsLat ) -> NumField Returns the fixed field of the involution of L . involution ( L :: AbsLat ) -> Map Returns the involution of the rational span of L . rank ( L :: AbsLat ) -> Int Returns the rank of L , that is the dimension of the rational span of L . degree ( L :: AbsLat ) -> Int Returns the dimension of the ambient space of L . Missing docstring. Missing docstring for gram_matrix_of_basis(L::AbsLat) . Check Documenter's build log for details. generators ( L :: AbsLat ; minimal = false ) -> Vector { Vector } Returns a set of generators of L over the base ring of L . If minimal == true , the number of generators is minimal. Note that computing minimal generators is expensive. discriminant ( L :: AbsLat ) -> NfOrdFracIdl Returns the discriminant of L , that is, the generalized index ideal [L^\\# : L] . pseudo_matrix ( L :: AbsLat ) -> PMat Returns the basis pseudo-matrix of L . coefficient_ideals ( L :: Abs ) -> Vector { NfOrdIdl } Returns the coefficient ideals of the pseudo-basis of L . Missing docstring. Missing docstring for basis_matrix(L::AbsLat) . Check Documenter's build log for details. absolute_basis ( L :: AbsLat ) -> Vector Returns a \\mathbf{Z} -basis of L . absolute_basis_matrix ( L :: AbsLat ) -> MatElem Returns a \\mathbf{Z} -basis matrix of L .","title":"Basic invariants"},{"location":"quad_forms/lattices/#rational-invariants","text":"hasse_invariant ( L :: AbsLat , p :: Union { InfPlc , NfOrdIdl }) -> Int Returns the Hasse invariant of the rational span of L at p . The lattice must be quadratic. witt_invariant ( L :: AbsLat , p :: Union { InfPlc , NfOrdIdl }) -> Int Returns the Witt invariant of the rational span of L at p . The lattice must be quadratic. isrationally_equivalent ( L :: AbsLat , M :: AbsLat , p :: Union { InfPlc , NfOrdIdl }) -> Bool Returns whether the rational spans of L and M are equivalent over the completion at \\mathfrak p . isrationally_equivalent ( L :: AbsLat , M :: AbsLat ) -> Bool Returns whether the rational spans of L and M are equivalent.","title":"Rational invariants"},{"location":"quad_forms/lattices/#definiteness","text":"ispositive_definite ( L :: AbsLat ) -> Bool Returns whether the rational span of L is positive definite. isnegative_definite ( L :: AbsLat ) -> Bool Returns whether the rational span of L is negative definite. isdefinite ( L :: AbsLat ) -> Bool Returns whether the rational span of L is definite. can_scale_totally_positive ( L :: AbsLat ) -> Bool , NumFieldElem Returns whether there is a totally positive rescaled lattice of L . If so, the second return value is an element a such that L^a is totally positive.","title":"Definiteness"},{"location":"quad_forms/lattices/#module-operations","text":"Missing docstring. Missing docstring for Base.:(+)(::AbsLat, M::AbsLat) . Check Documenter's build log for details. Missing docstring. Missing docstring for intersect(L::AbsLat, M::AbsLat) . Check Documenter's build log for details. * ( a :: NumFieldElem , M :: AbsLat ) -> AbsLat Returns the lattice aM inside the ambient space of M . * ( a :: NfOrdIdl , M :: AbsLat ) -> AbsLat Returns the lattice aM inside the ambient space of M . * ( a :: NfOrdFracIdl , M :: AbsLat ) -> AbsLat Returns the lattice aM inside the ambient space of M . rescale ( L :: AbsLat , a :: NumFieldElem ) -> AbsLat Returns the rescaled lattice L^a . Note that this has a different ambient space than L . dual ( L :: AbsLat ) -> AbsLat Returns the dual lattice of L .","title":"Module operations"},{"location":"quad_forms/lattices/#invariants","text":"norm ( L :: AbsLat ) -> NfOrdFracIdl Returns the norm of L . This is a fractional ideal of the fixed field of L . scale ( L :: AbsLat ) -> NfOrdFracIdl Returns the scale of L . isintegral ( L :: AbsLat ) -> Bool Returns whether the lattice L is integral. volume ( L :: AbsLat ) -> NfOrdFracIdl Returns the volume of L . ismodular ( L :: AbsLat ) -> Bool , NfOrdFracIdl Returns whether L is modular. In this case, the second return value is a fractional ideal \\mathfrak a such that \\mathfrak a L^\\# = L , where L^\\# is the dual of L .","title":"Invariants"},{"location":"quad_forms/lattices/#local-properties","text":"local_basis_matrix ( L :: AbsLat , p :: NfOrdIdl ; type = : any ) -> MatElem Given a prime ideal \\mathfrak p and a lattice L , this function returns a basis matrix of lattice M such that M_{\\mathfrak{p}} = L_{\\mathfrak{p}} . If type == :submodule , the lattice L will be a sublattice of M . If type == :supermodule , the lattice L will be a superlattice of M . If type == :any , there may not be any containment relation between M and L . Missing docstring. Missing docstring for ismodular(L::AbsLat, p) . Check Documenter's build log for details. Missing docstring. Missing docstring for bad_primes(L::AbsLat; even::Bool = false) . Check Documenter's build log for details. jordan_decomposition ( L :: AbsLat , p :: NfOrdIdl ) -> Vector { MatElem }, Vector { MatElem }, Vector { Int } Returns a Jordan decomposition of the completion of L at \\mathfrak p . The return value consists of three lists (M_i)_i , (G_i)_i and (s_i)_i of the same length r . The completions of the row spans of the matrices M_i yield a Jordan decomposition of L_{\\mathfrak{p}} into modular sublattices L_i with gram matrices G_i and scale of \\mathfrak{p} -adic valuation s_i . islocally_isometric ( L :: AbsLat , M :: AbsLat , p :: NfOrdIdl ) -> Bool Returns whether the completions of L and M at the prime ideal \\mathfrak{p} are locally isometric.","title":"Local properties"},{"location":"quad_forms/lattices/#genera","text":"","title":"Genera"},{"location":"quad_forms/lattices/#creation-of-genera-from-lattices","text":"genus ( L :: HermLat , p :: NfOrdIdl ) -> LocalGenusHerm Returns the genus of L at the prime ideal \\mathfrak p . See [Kir16, Definition 8.3.1]. genus ( L :: HermLat ) -> GenusHerm Given a Hermitian lattice, return the genus it belongs to.","title":"Creation of genera from lattices"},{"location":"quad_forms/lattices/#properties-of-genera","text":"rank ( G :: LocalGenusHerm ) -> Int Given a genus symbol G , return the rank of a lattice in G . rank ( G :: LocalGenusHerm , i :: Int ) Given a genus symbol for Hermitian lattices over E/K , return the rank of the i th Jordan block of G . ranks ( G :: LocalGenusHerm ) Given a genus symbol for Hermitian lattices over E/K , return the ranks of the Jordan blocks of G . det ( G :: LocalGenusHerm ) -> Int Given a genus symbol G , return the determinant of a lattice in G . This will be 1 or -1 depending on whether the determinant is a local norm or not. det_representative ( G :: LocalGenusHerm ) -> NumFieldElem Return a representative for the norm class of the determinant of G . gram_matrix ( G :: LocalGenusHerm ) Return a matrix M , such that a lattice with Gram matrix M is an element of the given genus. primes ( G :: GenusHerm ) -> Vector { NfOrdIdl } Return the primes of a global genus symbol.","title":"Properties of genera"},{"location":"quad_forms/lattices/#check-if-lattice-is-contained-in-genus","text":"in ( L :: HermLat , G :: LocalGenusHerm ) -> Bool Test if the lattice L is contained in the local genus G . in ( L :: HermLat , G :: GenusHerm ) -> Bool Test if the lattice L is contained in the genus G .","title":"Check if lattice is contained in genus"},{"location":"quad_forms/lattices/#creating-representatives","text":"representative ( G :: LocalGenusHerm ) -> HermLat Given a local genus, return a Hermitian lattice contained in this genus.","title":"Creating representatives"},{"location":"sparse/intro/","text":"Sparse linear algebra Introduction This chapter deals with sparse linear algebra over commutative rings and fields. Sparse linear algebra, that is, linear algebra with sparse matrices, plays an important role in various algorithms in algebraic number theory. For example, it is one of the key ingredients in the computation of class groups and discrete logarithms using index calculus methods. Sparse rows Building blocks for sparse matrices are sparse rows, which are modelled by objects of type \\texttt{SRow}. More precisely, the type is of parametrized form objects of type SRow . More precisely, the type is of parametrized form SRow{T} , where T is the element type of the base ring R . For example, SRow{fmpz} is the type for sparse rows over the integers. It is important to note that sparse rows do not have a fixed number of columns, that is, they represent elements of \\{ (x_i)_i \\in R^{\\mathbb{N}} \\mid x_i = 0 \\text{ for almost all }i\\} . In particular any two sparse rows over the same base ring can be added. Creation sparse_row ( R :: Ring , J :: Vector { Tuple { Int , T }}) -> SRow { T } Constructs the sparse row (a_i)_i with a_{i_j} = x_j , where J = (i_j, x_j)_j . The elements x_i must belong to the ring R . sparse_row ( R :: Ring , J :: Vector { Tuple { Int , T }}) -> SRow { T } Constructs the sparse row (a_i)_i with a_{i_j} = x_j , where J = (i_j, x_j)_j . The elements x_i must belong to the ring R . sparse_row(R::Ring, J::Vector{Tuple{Int, Int}}) -> SRow Constructs the sparse row (a_i)_i over R with a_{i_j} = x_j , where J = (i_j, x_j)_j . sparse_row ( R :: Ring , J :: Vector { Int }, V :: Vector { T }) -> SRow { T } Constructs the sparse row (a_i)_i over R with a_{i_j} = x_j , where J = (i_j)_j and V = (x_j)_j . Basic operations == ( x :: SRow , y :: SRow ) Checks whether x and y are the same sparse row, that is, whether x and y have the same non-zero entries. + ( A :: SRow , B :: SRow ) -> SRow Returns the sum of A and B . getindex ( A :: SRow , j :: Int ) -> RingElem Given a sparse row (a_i)_{i} and an index j return a_j . * ( b :: T , A :: SRow { T }) -> SRow Return the sparse row obtained by multiplying all elements of A by b . div ( A :: SRow { T }, b :: T ) -> SRow Return the sparse row obtained by dividing all elements of A by b using div . divexact ( A :: SRow { T }, b :: T ) -> SRow Return the sparse row obtained by dividing all elements of A by b using divexact . add_scaled_row ( A :: SRow { T }, B :: SRow { T }, c :: T ) -> SRow { T } Returns the row c A + B . Change of base ring change_base_ring ( R :: Ring , A :: SRow ) -> SRow Create a new sparse row by coercing all elements into the ring R . Maximum, minimum and 2-norm maximum ( A :: SRow { T }) -> T Returns the largest entry of A . minimum ( A :: NfRelOrdIdl ) -> NfOrdIdl minimum ( A :: NfRelOrdIdl ) -> NfRelOrdIdl Returns the ideal A \\cap O where O is the maximal order of the coefficient ideals of A . minimum(A::SRow{T}) -> T Returns the smallest entry of A . norm2 ( A :: SRow { T } -> T Returns A \\cdot A^t . Functionality for integral sparse rows lift ( A :: SRow { nmod }) -> SRow { fmpz } Return the sparse row obtained by lifting all entries in A . mod! ( A :: SRow { fmpz }, n :: fmpz ) -> SRow { fmpz } Inplace reduction of all entries of A modulo n to the positive residue system. mod_sym! ( A :: SRow { fmpz }, n :: fmpz ) -> SRow { fmpz } Inplace reduction of all entries of A modulo n to the symmetric residue system. maximum ( abs , A :: SRow { fmpz }) -> fmpz Returns the largest, in absolute value, entry of A . Sparse matrices Let R be a commutative ring. Sparse matrices with base ring R are modelled by objects of type SMat . More precisely, the type is of parametrized form SRow{T} , where T is the element type of the base ring. For example, SMat{fmpz} is the type for sparse matrices over the integers. In constrast to sparse rows, sparse matrices have a fixed number of rows and columns, that is, they represent elements of the matrices space \\mathrm{Mat}_{n\\times m}(R) . Internally, sparse matrices are implemented as an array of sparse rows. As a consequence, unlike their dense counterparts, sparse matrices have a mutable number of rows and it is very performant to add additional rows. Construction sparse_matrix ( R :: Ring ) -> SMat Return an empty sparse matrix with base ring R . Sparse matrices can also be created from dense matrices as well as from julia arrays: sparse_matrix ( A :: MatElem ; keepzrows :: Bool = true ) Constructs the sparse matrix corresponding to the dense matrix A . If keepzrows is false, then the constructor will drop any zero row of A . sparse_matrix ( R :: Ring , A :: Array { T , 2 }) -> SMat Constructs the sparse matrix over R corresponding to A . sparse_matrix ( R :: Ring , A :: Array { T , 2 }) -> SMat Constructs the sparse matrix over R corresponding to A . The normal way however, is to add rows: push! ( A :: SMat { T }, B :: SRow { T }) where T Appends the sparse row B to A . Sparse matrices can also be concatenated to form larger ones: vcat! ( A :: SMat , B :: SMat ) -> SMat Vertically joins A and B inplace, that is, the rows of B are appended to A . vcat ( A :: SMat , B :: SMat ) -> SMat Vertically joins A and B . hcat! ( A :: SMat , B :: SMat ) -> SMat Horizontally concatenates A and B , inplace, changing A . hcat ( A :: SMat , B :: SMat ) -> SMat Horizontally concatenates A and B . (Normal julia cat is also supported) There are special constructors: identity_matrix ( :: Type { SMat }, R :: Ring , n :: Int ) Return a sparse n times n identity matrix over R . zero_matrix ( :: Type { SMat }, R :: Ring , n :: Int ) Return a sparse n times n zero matrix over R . zero_matrix ( :: Type { SMat }, R :: Ring , n :: Int , m :: Int ) Return a sparse n times m zero matrix over R . Slices: sub ( A :: SMat , r :: UnitRange , c :: UnitRange ) -> SMat Return the submatrix of A , where the rows correspond to r and the columns correspond to c . Transpose: transpose ( A :: SMat ) -> SMat Returns the transpose of A . Elementary Properties sparsity ( A :: SMat ) -> Float64 Return the sparsity of A , that is, the number of zero-valued elements divided by the number of all elements. density ( A :: SMat ) -> Float64 Return the density of A , that is, the number of nonzero-valued elements divided by the number of all elements. nnz ( A :: SMat ) -> Int Return the number of non-zero entries of A . nrows ( A :: SMat ) -> Int Return the number of rows of A . ncols ( A :: SMat ) -> Int Return the number of columns of A . isone ( A :: SMat ) Tests if A is an identity matrix. iszero ( A :: SMat ) Tests if A is a zero matrix. Manipulation/ Access getindex ( A :: SMat , i :: Int , j :: Int ) Given a sparse matrix A = (a_{ij})_{i, j} , return the entry a_{ij} . getindex ( A :: SMat , i :: Int ) -> SRow Given a sparse matrix A and an index i , return the i -th row of A . setindex! ( A :: SMat , b :: SRow , i :: Int ) Given a sparse matrix A , a sparse row b and an index i , set the i -th row of A equal to b . Changing of the ring: map_entries ( f , A :: SMat ) -> SMat Given a sparse matrix A and a callable object f , this function will construct a new sparse matrix by applying f to all elements of A . change_base_ring ( R :: Ring , A :: SMat ) Create a new sparse matrix by coercing all elements into the ring R . Arithmetic Various products: mul ( A :: SMat { T }, b :: AbstractVector { T }) -> Vector { T } Return the product A \\cdot b as a dense vector. mul ( A :: SMat { T }, b :: AbstractArray { T , 2 }) -> Array { T , 2 } Return the product A \\cdot b as a dense array. mul ( A :: SMat { T }, b :: MatElem { T }) -> MatElem Return the product A \\cdot b as a dense matrix. mul ( A :: SRow , B :: SMat ) -> SRow Return the product A\\cdot B as a sparse row. * ( b :: T , A :: SMat { T }) -> SMat { T } Return the product b \\cdot A . * ( b :: Integer , A :: SMat { T }) -> SMat { T } Return the product b \\cdot A . * ( b :: fmpz , A :: SMat { T }) -> SMat { T } Return the product b \\cdot A . Other: + ( A :: SMat , B :: SMat ) -> SMat Return the sum A + B . - ( A :: SMat , B :: SMat ) -> SMat Return the difference A - B . == ( A :: SMat , B :: SMat ) -> Bool Return whether A is equal to B .","title":"Sparse Linear Algebra"},{"location":"sparse/intro/#sparse-linear-algebra","text":"","title":"Sparse linear algebra"},{"location":"sparse/intro/#introduction","text":"This chapter deals with sparse linear algebra over commutative rings and fields. Sparse linear algebra, that is, linear algebra with sparse matrices, plays an important role in various algorithms in algebraic number theory. For example, it is one of the key ingredients in the computation of class groups and discrete logarithms using index calculus methods.","title":"Introduction"},{"location":"sparse/intro/#sparse-rows","text":"Building blocks for sparse matrices are sparse rows, which are modelled by objects of type \\texttt{SRow}. More precisely, the type is of parametrized form objects of type SRow . More precisely, the type is of parametrized form SRow{T} , where T is the element type of the base ring R . For example, SRow{fmpz} is the type for sparse rows over the integers. It is important to note that sparse rows do not have a fixed number of columns, that is, they represent elements of \\{ (x_i)_i \\in R^{\\mathbb{N}} \\mid x_i = 0 \\text{ for almost all }i\\} . In particular any two sparse rows over the same base ring can be added.","title":"Sparse rows"},{"location":"sparse/intro/#creation","text":"sparse_row ( R :: Ring , J :: Vector { Tuple { Int , T }}) -> SRow { T } Constructs the sparse row (a_i)_i with a_{i_j} = x_j , where J = (i_j, x_j)_j . The elements x_i must belong to the ring R . sparse_row ( R :: Ring , J :: Vector { Tuple { Int , T }}) -> SRow { T } Constructs the sparse row (a_i)_i with a_{i_j} = x_j , where J = (i_j, x_j)_j . The elements x_i must belong to the ring R . sparse_row(R::Ring, J::Vector{Tuple{Int, Int}}) -> SRow Constructs the sparse row (a_i)_i over R with a_{i_j} = x_j , where J = (i_j, x_j)_j . sparse_row ( R :: Ring , J :: Vector { Int }, V :: Vector { T }) -> SRow { T } Constructs the sparse row (a_i)_i over R with a_{i_j} = x_j , where J = (i_j)_j and V = (x_j)_j .","title":"Creation"},{"location":"sparse/intro/#basic-operations","text":"== ( x :: SRow , y :: SRow ) Checks whether x and y are the same sparse row, that is, whether x and y have the same non-zero entries. + ( A :: SRow , B :: SRow ) -> SRow Returns the sum of A and B . getindex ( A :: SRow , j :: Int ) -> RingElem Given a sparse row (a_i)_{i} and an index j return a_j . * ( b :: T , A :: SRow { T }) -> SRow Return the sparse row obtained by multiplying all elements of A by b . div ( A :: SRow { T }, b :: T ) -> SRow Return the sparse row obtained by dividing all elements of A by b using div . divexact ( A :: SRow { T }, b :: T ) -> SRow Return the sparse row obtained by dividing all elements of A by b using divexact . add_scaled_row ( A :: SRow { T }, B :: SRow { T }, c :: T ) -> SRow { T } Returns the row c A + B .","title":"Basic operations"},{"location":"sparse/intro/#change-of-base-ring","text":"change_base_ring ( R :: Ring , A :: SRow ) -> SRow Create a new sparse row by coercing all elements into the ring R .","title":"Change of base ring"},{"location":"sparse/intro/#maximum-minimum-and-2-norm","text":"maximum ( A :: SRow { T }) -> T Returns the largest entry of A . minimum ( A :: NfRelOrdIdl ) -> NfOrdIdl minimum ( A :: NfRelOrdIdl ) -> NfRelOrdIdl Returns the ideal A \\cap O where O is the maximal order of the coefficient ideals of A . minimum(A::SRow{T}) -> T Returns the smallest entry of A . norm2 ( A :: SRow { T } -> T Returns A \\cdot A^t .","title":"Maximum, minimum and 2-norm"},{"location":"sparse/intro/#functionality-for-integral-sparse-rows","text":"lift ( A :: SRow { nmod }) -> SRow { fmpz } Return the sparse row obtained by lifting all entries in A . mod! ( A :: SRow { fmpz }, n :: fmpz ) -> SRow { fmpz } Inplace reduction of all entries of A modulo n to the positive residue system. mod_sym! ( A :: SRow { fmpz }, n :: fmpz ) -> SRow { fmpz } Inplace reduction of all entries of A modulo n to the symmetric residue system. maximum ( abs , A :: SRow { fmpz }) -> fmpz Returns the largest, in absolute value, entry of A .","title":"Functionality for integral sparse rows"},{"location":"sparse/intro/#sparse-matrices","text":"Let R be a commutative ring. Sparse matrices with base ring R are modelled by objects of type SMat . More precisely, the type is of parametrized form SRow{T} , where T is the element type of the base ring. For example, SMat{fmpz} is the type for sparse matrices over the integers. In constrast to sparse rows, sparse matrices have a fixed number of rows and columns, that is, they represent elements of the matrices space \\mathrm{Mat}_{n\\times m}(R) . Internally, sparse matrices are implemented as an array of sparse rows. As a consequence, unlike their dense counterparts, sparse matrices have a mutable number of rows and it is very performant to add additional rows.","title":"Sparse matrices"},{"location":"sparse/intro/#construction","text":"sparse_matrix ( R :: Ring ) -> SMat Return an empty sparse matrix with base ring R . Sparse matrices can also be created from dense matrices as well as from julia arrays: sparse_matrix ( A :: MatElem ; keepzrows :: Bool = true ) Constructs the sparse matrix corresponding to the dense matrix A . If keepzrows is false, then the constructor will drop any zero row of A . sparse_matrix ( R :: Ring , A :: Array { T , 2 }) -> SMat Constructs the sparse matrix over R corresponding to A . sparse_matrix ( R :: Ring , A :: Array { T , 2 }) -> SMat Constructs the sparse matrix over R corresponding to A . The normal way however, is to add rows: push! ( A :: SMat { T }, B :: SRow { T }) where T Appends the sparse row B to A . Sparse matrices can also be concatenated to form larger ones: vcat! ( A :: SMat , B :: SMat ) -> SMat Vertically joins A and B inplace, that is, the rows of B are appended to A . vcat ( A :: SMat , B :: SMat ) -> SMat Vertically joins A and B . hcat! ( A :: SMat , B :: SMat ) -> SMat Horizontally concatenates A and B , inplace, changing A . hcat ( A :: SMat , B :: SMat ) -> SMat Horizontally concatenates A and B . (Normal julia cat is also supported) There are special constructors: identity_matrix ( :: Type { SMat }, R :: Ring , n :: Int ) Return a sparse n times n identity matrix over R . zero_matrix ( :: Type { SMat }, R :: Ring , n :: Int ) Return a sparse n times n zero matrix over R . zero_matrix ( :: Type { SMat }, R :: Ring , n :: Int , m :: Int ) Return a sparse n times m zero matrix over R . Slices: sub ( A :: SMat , r :: UnitRange , c :: UnitRange ) -> SMat Return the submatrix of A , where the rows correspond to r and the columns correspond to c . Transpose: transpose ( A :: SMat ) -> SMat Returns the transpose of A .","title":"Construction"},{"location":"sparse/intro/#elementary-properties","text":"sparsity ( A :: SMat ) -> Float64 Return the sparsity of A , that is, the number of zero-valued elements divided by the number of all elements. density ( A :: SMat ) -> Float64 Return the density of A , that is, the number of nonzero-valued elements divided by the number of all elements. nnz ( A :: SMat ) -> Int Return the number of non-zero entries of A . nrows ( A :: SMat ) -> Int Return the number of rows of A . ncols ( A :: SMat ) -> Int Return the number of columns of A . isone ( A :: SMat ) Tests if A is an identity matrix. iszero ( A :: SMat ) Tests if A is a zero matrix.","title":"Elementary Properties"},{"location":"sparse/intro/#manipulation-access","text":"getindex ( A :: SMat , i :: Int , j :: Int ) Given a sparse matrix A = (a_{ij})_{i, j} , return the entry a_{ij} . getindex ( A :: SMat , i :: Int ) -> SRow Given a sparse matrix A and an index i , return the i -th row of A . setindex! ( A :: SMat , b :: SRow , i :: Int ) Given a sparse matrix A , a sparse row b and an index i , set the i -th row of A equal to b . Changing of the ring: map_entries ( f , A :: SMat ) -> SMat Given a sparse matrix A and a callable object f , this function will construct a new sparse matrix by applying f to all elements of A . change_base_ring ( R :: Ring , A :: SMat ) Create a new sparse matrix by coercing all elements into the ring R .","title":"Manipulation/ Access"},{"location":"sparse/intro/#arithmetic","text":"Various products: mul ( A :: SMat { T }, b :: AbstractVector { T }) -> Vector { T } Return the product A \\cdot b as a dense vector. mul ( A :: SMat { T }, b :: AbstractArray { T , 2 }) -> Array { T , 2 } Return the product A \\cdot b as a dense array. mul ( A :: SMat { T }, b :: MatElem { T }) -> MatElem Return the product A \\cdot b as a dense matrix. mul ( A :: SRow , B :: SMat ) -> SRow Return the product A\\cdot B as a sparse row. * ( b :: T , A :: SMat { T }) -> SMat { T } Return the product b \\cdot A . * ( b :: Integer , A :: SMat { T }) -> SMat { T } Return the product b \\cdot A . * ( b :: fmpz , A :: SMat { T }) -> SMat { T } Return the product b \\cdot A . Other: + ( A :: SMat , B :: SMat ) -> SMat Return the sum A + B . - ( A :: SMat , B :: SMat ) -> SMat Return the difference A - B . == ( A :: SMat , B :: SMat ) -> Bool Return whether A is equal to B .","title":"Arithmetic"}]}