################################################################################
#
#  Auto- and isomorphism computation of lattices
#
################################################################################

# This is a port of the program ISOM and AUTO by Bernd Souvignier
# which implemented an algorithm published in
# W. PLESKEN, B. SOUVIGNIER, Computing Isometries of Lattices,
# Journal of Symbolic Computation, Volume 24, Issues 3-4, September 1997,
# Pages 327-334, ISSN 0747-7171, 10.1006/jsco.1996.0130.
# (http://www.sciencedirect.com/science/article/pii/S0747717196901303)

mutable struct SCPComb
	rank::Int
	trans::fmpz_mat
	coef::fmpz_mat
  F::Vector{fmpz_mat}

  SCPComb() = new()
end

mutable struct ZLatAutoCtx
  G::Vector{fmpz_mat}
  Gtr::Vector{fmpz_mat}
  dim::Int
  V::Vector{fmpz_mat}
  V_length::Vector{Vector{fmpz}}
  v::Vector{fmpz_mat}
  per::Vector{Int}
  fp::Matrix{Int}
  fp_diagonal::Vector{Int}
  std_basis::Vector{Int}
  scpcomb::SCPComb

  orders::Vector{Int}
  ng::Vector{Int}
  nsg::Vector{Int}
  g::Vector{Vector{fmpz_mat}}

  ZLatAutoCtx() = new()

  function ZLatAutoCtx(G::Vector{fmpz_mat})
    z = new()
    z.G = G
    z.Gtr = fmpz_mat[transpose(g) for g in G]
    z.dim = nrows(G[1])
    return z
  end
end

function Base.show(io::IO, C::ZLatAutoCtx)
  return C.G
end

dim(C::ZLatAutoCtx) = C.dim

function init(C::ZLatAutoCtx)
  # Compute the necessary short vectors
  compute_short_vectors(C)

  # Compute the fingerprint
  fingerprint(C)

  # Find the standard basis vectors
  C.std_basis = Vector{Int}(undef, dim(C))
  z = zero_matrix(FlintZZ, 1, dim(C))
  for i in 1:dim(C)
    z[1, C.per[i]] = 1
    k = findfirst(isequal(z), C.V)
    if k === nothing
      z[1, C.per[i]] = -1
      k = findfirst(isequal(z), C.V)
      @assert k !== nothing
      C.V[k] = -z
      C.std_basis[i] = k
    else
      C.std_basis[i] = k  
    end
    z[1, C.per[i]] = 0
  end

  # 
  
  C.v = Vector{fmpz_mat}(undef, length(C.G))

  for i in 1:length(C.G)
    A = zero_matrix(FlintZZ, length(C.V), dim(C))
    for j in 1:length(C.V)
      for k in 1:dim(C)
        A[j, k] = _dot_product(C.V[j], C.G[i], k)
      end
    end
    C.v[i] = A
  end

  if false
    for i in 1:length(C.G)
      for j in 1:length(C.V)
        for k in 1:length(C.V)
          @assert _dot_product(C.V[j], C.v[i], k) == (C.V[j] * C.G[i] * transpose(C.V[k]))[1, 1]
        end
      end
    end
  end

  C.g = Vector{Vector{fmpz_mat}}(undef, dim(C))
  for i in 1:dim(C)
    C.g[i] = fmpz_mat[]
  end
  C.ng = zeros(Int, dim(C))
  C.nsg = zeros(Int, dim(C))
  C.orders = Vector{Int}(undef, dim(C))

  # -Id is always an automorphism
  C.g[1] = fmpz_mat[-identity_matrix(FlintZZ, dim(C))]
  C.ng[1] = 1

  # Calculate orbit lengths
  
  nH = 0

  for i in 1:dim(C)
    nH += C.ng[i]
  end

  H = Vector{fmpz_mat}(undef, nH)

  for i in 1:dim(C)
    if C.ng[i] > 0
      nH = 0
      for j in i:dim(C)
        for k in 1:C.ng[j]
          nH += 1
          H[nH] = C.g[j][k]
        end
      end
      @assert _orbitlen_naive(C.std_basis[i], C.fp_diagonal[i], H, nH, C.V) == _orbitlen(C.std_basis[i], C.fp_diagonal[i], H, nH, C.V)
			C.orders[i] = _orbitlen(C.std_basis[i], C.fp_diagonal[i], H, nH, C.V)
		else
			C.orders[i] = 1
    end
  end

  return C
end

#function compute_scpcomb(C::ZAutLatCtx, depth::Int)
#  comb = Vector{SCPComp}(undef, dim(C))
#  for i in 1:dim(C)
#  end
#end


#	if (flags.DEPTH > 0)
#	{
#		if ((comb = (scpcomb*)malloc(dim * sizeof(scpcomb))) == 0)
#			exit (1);
#		for (i = 0; i < dim; ++i)
#		{
#/* compute the list of scalar product combinations and the corresponding
#   vector sums */
#			scpvecs(&comb[i].list, &sumveclist, i, fp.e, flags.DEPTH, V, F);
#/* compute a basis for the lattice that is generated by the vector sums and
#   a transformation matrix that expresses the basis in terms of the 
#   vector sums */
#			base(&comb[i], &sumvecbase, sumveclist, F.A[0], dim);
#			if (flags.PRINT == 1)
#/* if the -P option is given, print the rank of the lattice generated by the
#   vector sums on level i on AUTO.tmp */
#			{
#				outfile = fopen("AUTO.tmp", "a");
#				fprintf(outfile, "comb[%d].rank = %d\n", i, comb[i].rank);
#				fclose(outfile);
#			}
#/* compute the coefficients of the vector sums in terms of the basis */
#			coef(&comb[i], sumvecbase, sumveclist, F.A[0], dim);
#			for (j = 0; j <= comb[i].list.n; ++j)
#				free(sumveclist[j]);
#			free(sumveclist);
#/* compute the scalar products of the base-vectors */
#			scpforms(&comb[i], sumvecbase, F);
#			for (j = 0; j < comb[i].rank; ++j)
#				free(sumvecbase[j]);
#			free(sumvecbase);
#		}
#	}


# This is currently broken, since the enumeration is not working
function _compute_short_vectors(C::ZLatAutoCtx)
  E = enum_ctx_from_gram(C.G[1])
  max = maximum(C.G[1][i, i] for i in 1:dim(C))
  enum_ctx_start(E, max)
  V = fmpz_mat[]
  V_length = Vector{fmpz}[]
  while enum_ctx_next(E)
    push!(V, deepcopy(E.x))
    z = Vector{fmpz}(undef, length(C.G))
    for k in 1:length(z)
      z[k] = (E.x * C.G[k] * transpose(E.x))[1, 1]
    end
    push!(V_length, z)
  end
  return V, V_length
end

function __compute_short_vectors(C::ZLatAutoCtx)
  max = maximum(C.G[1][i, i] for i in 1:dim(C))
  R = ArbField(256)
  G = change_base_ring(R, C.G[1])
  V = enumerate_using_gram(G, R(max))
  C.V = fmpz_mat[]
  C.V_length = Vector{fmpz}[]
  for v in V
    positive = false
    for k in 1:length(v)
      if iszero(v[k])
        continue
      end
      if v[k] > 0
        positive = true
      end
      break
    end
    if !positive
      continue
    end
    @assert v[findfirst(!iszero, v)] > 0
    m = matrix(FlintZZ, 1, dim(C), v)
    z = Vector{fmpz}(undef, length(C.G))
    for k in 1:length(z)
      z[k] = (m * C.G[k] * transpose(m))[1, 1]
    end
    if z[1] > max
      continue
    end
    push!(C.V, m)
    push!(C.V_length, z)
  end
  W, Wl = _compute_short_vectors(C)
  @show Set(W) == Set(C.V)
  @show length(W), length(Wl)
  @show length(C.V), length(C.V_length)
end

function compute_short_vectors(C::ZLatAutoCtx)
  #V = enumerate_using_gram(G, R(max))
  C.V = fmpz_mat[]
  C.V_length = Vector{fmpz}[]
  max = maximum(C.G[1][i, i] for i in 1:dim(C))
  E = enum_ctx_from_gram(C.G[1])
  enum_ctx_start(E, max)
  n = ncols(C.G[1])
  while enum_ctx_next(E)
    positive = false
    for k in 1:n
      if iszero(E.x[1, k])
        continue
      end
      if E.x[1, k] > 0
        positive = true
      end
      break
    end
    if !positive
      m = -deepcopy(E.x)
    else
      m = deepcopy(E.x)#matrix(FlintZZ, 1, dim(C), v)
    end
    z = Vector{fmpz}(undef, length(C.G))
    for k in 1:length(z)
      z[k] = (m * C.G[k] * transpose(m))[1, 1]
    end
    if z[1] > max
      continue
    end
    push!(C.V, m)
    push!(C.V_length, z)
  end
  return C
end

function _get_vectors_of_length(G::Union{fmpz_mat, FakeFmpqMat}, max::fmpz)
  C = enum_ctx_from_gram(G)
  enum_ctx_start(C, max)
  res = Tuple{fmpz_mat, fmpz}[]
  while enum_ctx_next(C)
    push!(res, (deepcopy(C.x), (C.x * G * transpose(C.x))[1, 1]))
    push!(res, (-deepcopy(C.x), (C.x * G * transpose(C.x))[1, 1]))
  end
  return res
end

function _get_vectors_of_length(G::ZLattice, max::fmpz)
  return _get_vectors_of_length(FakeFmpqMat(gram_matrix(G)), max)
end

mutable struct auto_group
  ord
  ng
  nsg
  g
end

mutable struct fingerprint
  diag
  per
  e
end

mutable struct qfauto
  dim
  F
  U
  V
  W
  v 
  p
end

mutable struct qfcand
  cdep
  comb
  bacher_pol
end

function possible2(C::ZLatAutoCtx, per, I, J)
  V = C.V
  W = C.V_length
  n = length(C.V)
  F = C.G
  count = 0
  for j in 1:n
    v = V[j]
    w = W[j]
    good = true
    for k in 1:length(F)
      if w[k] != F[k][J, J]
        good = false
        break
      end
    end
    if !good
      continue
    end
    for k in 1:length(F)
      for i in 1:I
        z = zero_matrix(FlintZZ, dim(C), 1)
        z[per[i], 1] = 1
        if (v * F[k] * z)[1, 1] != F[k][per[i], J]
          good = false
          break
        end
      end
      if !good
        break
      end
    end

    if good
      count += 1
    end

    good = true
    for k in 1:length(F)
      for i in 1:I
        z = zero_matrix(FlintZZ, dim(C), 1)
        z[per[i], 1] = 1
        if (v * F[k] * z)[1, 1] != -F[k][per[i], J]
          good = false
          break
        end
      end
    end

    if good
      count += 1
    end

  end
  return count
end

function possible(C::ZLatAutoCtx, per, I, J)
  V = C.V
  W = C.V_length
  F = C.G
  Ftr = C.Gtr
  n = length(W)
  f = length(F)
  count = 0
  for j in 1:n
    Wj = W[j]
    Vj = V[j]
    good_scalar = true
    good_length = true
    i = I + 1
    for k in 1:f
      if Wj[k] != F[k][J, J]
        good_length = false
        break
      end
      for i in 1:I
        if _dot_product(Vj, Ftr[k], per[i]) != F[k][J, per[i]]
          good_scalar = false
          break
        end
      end

      if !good_scalar
        break
      end
    end

    if good_length && good_scalar
      count = count + 1
    end

    if !good_length
      continue
    end

    # length is correct
    
    good_scalar = true

    for k in 1:f
      for i in 1:I
        if _dot_product(Vj, Ftr[k], per[i]) != -F[k][J, per[i]]
          good_scalar = false
          break
        end
      end

      if !good_scalar
        break
      end
    end

    if good_scalar
      count = count + 1
    end
  end
  return count
end

function _dot_product(V::Vector, M, i)
  z = zero(base_ring(V))
  for j in 1:length(V)
    z = z + V[j] * M[i, j]
  end
  return z
end

function _dot_product(V::fmpz_mat, M, i)
  z = zero(base_ring(V))
  for j in 1:length(V)
    z = z + V[1, j] * M[i, j]
  end
  return z
end

# a permutation per for the
#	order of the basis-vectors is chosen
#	such that in every step the number of
#	possible continuations is minimal,
#	for j from per[i] to per[dim-1] the
#	value f[i][j] in the fingerprint f is
#	the number of vectors, which have the
#	same scalar product with the 
#	basis-vectors per[0]...per[i-1] as the 
#	basis-vector j and the same length as 
#	this vector with respect to all 
#	invariant forms

function fingerprint(C::ZLatAutoCtx)
  n = dim(C)
  k = length(C.G)
  per = Vector{Int}(undef, n)
  for i in 1:n
    per[i] = i
  end

  fp = zeros(Int, n, n)

  # fp[1, i] = # vectors v such that v has same length as b_i for all forms
  for i in 1:n
    for j in 1:length(C.V)
      good = true
      for l in 1:k
        if C.V_length[j][l] != C.G[l][i, i]
          good = false
          break
        end
      end

      if good
        fp[1, i] += 2 # the negative vector also has the correct length
      end
    end
  end

  for i in 1:(n - 1)
    # Find the minimal non-zero entry in the i-th row
    mini = i
    for j in (i+1):n
      if fp[i, per[j]] < fp[i, per[mini]]
        mini = j
      end
    end

    per[mini], per[i] = per[i], per[mini]

    # Set entries below the minimal entry to zero 
    for j in (i + 1):n
      fp[j, per[i]] = 0
    end

    # Now compute row i + 1

    for j in (i + 1):n
      fp[i + 1, per[j]] = possible(C, per, i, per[j])
    end
  end

  # Extract the diagonal

  res = Vector{Int}(undef, n)

  for i in 1:n
    res[i] = fp[i, per[i]]
  end

  C.fp = fp

  C.fp_diagonal = res

  C.per = per

  return per, fp, res
end

# computes min(#O, orblen), where O is the orbit of pt under the first nG matrices in G
function _orbitlen(point::Int, orblen::Int, G::Vector{fmpz_mat}, nG::Int, V)
  n = length(V)
  orb = ones(Int, orblen)
  orb[1] = point
  flag = zeros(Bool, 2*n + 1)
  flag[point + n + 1] = true
  # if flag[i + n+1] = 1, -n <= i <= n, then the point i is already in the orbit
  #flag = zero_Flv(2*n + 1)+n+1;
  #orb  = zero_Flv(orblen);
  #orb[1] = pt;
  #flag[pt] = 1;
  len = 1
  cnd = 1
  #@show G, nG
  while cnd <= len && len < orblen
    i = 1
    while i <= nG && len < orblen
      imag = _operate(orb[cnd], G[i], V)
      if !flag[imag + n + 1]
        # the image is a new point in the orbit
        len += 1
        orb[len] = imag
        flag[imag + n + 1] = true
      end
      i += 1
    end
    cnd += 1
  end
  return len
end

function _operate(point, A, V)
# 	V.v is a sorted list of length V.n of vectors
#				of dimension V.dim, the number of V.v[nr]*A in
#				the list is returned, where a negative number 
#				indicates the negative of a vector
  w = V[abs(point)] * A
  if point < 0
    w = -w
  end
  k = _find_point(w, V)
  return k
end

function _find_point(w, V)
  positive = false
  for k in 1:length(w)
    if !iszero(w[1, k])
      positive = w[1, k] > 0
      break
    end
  end
  if positive
    k = findfirst(isequal(w), V)
    @assert k !== nothing
    return k
  else
    mw = -w
    k = findfirst(isequal(mw), V)
    @assert k !== nothing
    return -k
  end
end
#
#{
#	int	i, im, *w;
#
#	if ((w = (int*)malloc(V.dim * sizeof(int))) == 0)
#		exit (1);
#	vecmatmul(V.v[abs(nr)], A, V.dim, w);
#	if (nr < 0)
#	{
#		for (i = 0; i < V.dim; ++i)
#			w[i] *= -1;
#	}
#	im = numberof(w, V);
#	if (abs(im) > V.n)
#/* the vector is not in the list */
#	{
#		fprintf(stderr, "Error: image of vector %d not found\n", nr);
#		exit (2);
#	}
#	free(w);
#	return(im);
#}

function _orbitlen_naive(point::Int, orblen::Int, G::Vector{fmpz_mat}, nG::Int, V)
  working_list = Int[point]
  orbit = Int[point]
  while !isempty(working_list)
    current_point = pop!(working_list)
    for i in 1:nG
      if current_point < 0 
        new_point_coord = -V[abs(current_point)] * G[i]
      else
        new_point_coord = V[current_point] * G[i]
      end
      new_point = _find_point(new_point_coord, V)
      if !(new_point in orbit)
        push!(orbit, new_point)
        push!(working_list, new_point)
      end
    end
  end
  #@show length(orbit)
  return min(orblen, length(orbit))
end

function auto(C)
  dim = Hecke.dim(C)

  candidates = Vector{Vector{Int}}(undef, dim) # candidate list for the image of the i-th basis vector

  for i in 1:dim
    candidates[i] = zeros(Int, C.fp_diagonal[i])
  end

  x = Vector{Int}(undef, dim)
  bad = Vector{Int}(undef, 2 * length(C.V))

  sta = 1
  for step in sta:dim
    #@show step
    nH = 0
    for i in step:dim
      nH += C.ng[i]
    end
    #@show nH
    H = Vector{fmpz_mat}(undef, nH)
    nH = 0
    for i in step:dim
      for j in 1:C.ng[i]
        nH += 1
        #@show C.g[i]
        H[nH] = C.g[i][j]
      end
    end
    for i in 1:2*length(C.V)
      bad[i] = 0
    end
    nbad = 0
    for i in 1:step
      x[i] = C.std_basis[i]
    end
    #@show C.fp_diagonal[step]
    #@show x
    #@show candidates
    if C.fp_diagonal[step] > 1
      nC = cand(candidates[step], step, x, C, 0)#comb)
    else # there is only one candidates
      candidates[step] = [C.std_basis[step]]
      nC = 1
    end
    #@show nC
    #@show candidates
    orb = orbit(C.std_basis[step], 1, H, nH, C.V)
    C.orders[step] = length(orb)
    # delete the orbit of the step-th basis vector from the candidates
    #nC = delete(candidates[step], nC, orb, C.orders[step])
    setdiff!(candidates[step], orb)
    nC = length(candidates[step])
    #@show step, nC
    while nC > 0 && ((im = candidates[step][1]) != 0)
      #@show im
      found = 0
      # try C.V[im] as the image of the step-th basis vector
      x[step] = im
      if step < dim
        #@show candidates
        if cand(candidates[step + 1], step + 1, x, C, 0) == C.fp_diagonal[step + 1]
          #@show candidates
          #@show "right before aut"
          #@show step + 1, x
          found = aut(step + 1, x, candidates, C, 0)#comb)
        else
          found = 0
        end
      else
        found = 1
      end

      #@show found

      if found == 0
        # x[1],...,x[step] cannot be continued
        oc = orbit(im, 1, H, nH, C.V)
        # delete the orbit of im from the candidates for x[step]
        candidates[step] = setdiff!(candidates[step], oc)
        nC = length(candidates[step])
        #nC = delete(candidates[step], nC, oc, noc)
        #empty!(oc)
        nbad += 1
        bad[nbad] = im
      else
        #@show x, step
        # a new generator has been found
        C.ng[step] += 1
        # append the new generator to C.>g[step]
        #@show "================================"
        ##@show C.g, step
        Gstep = resize!(C.g[step], C.ng[step])
        ##@show C.g, step
        Gstep[C.ng[step]] = matgen(x, dim, C.per, C.V)
        C.g[step] = Gstep
        nH += 1
        H = Vector{fmpz_mat}(undef, nH)
        nH = 0
        for i in step:dim
          for j in 1:C.ng[i]
            nH += 1
            H[nH] = C.g[i][j]
          end
        end
        # compute the new orbit of std_basis[step]
        orb = orbit(C.std_basis[step], 1, H, nH, C.V)
        C.orders[step] = length(orb)
        # delete the orbit from the candidates for x[step]
        setdiff!(candidates[step], orb)
        nC = length(candidates[step])
        #nC = delete(candidates[step], nC, orb, C.orders[step])
        # compute the new orbit of the vectors, which could be continued to an automorphism
        oc = orbit(bad, nbad, H, nH, C.V)
        # delete the orbit from the candidates
        setdiff!(candidates[step], oc)
        nC = length(candidates[step])
        #nC = delete(candidates[step], nC, oc, noc)
        #empty!(oc)
      end
    end
    if step == sta
      # test, whether on step flags.STAB some generators may be omitted 
      tries = C.nsg[step]
      while tries <= C.ng[step]
      #for tries in C.nsg[step]:C.ng[step]
        nH = 0
        for j in 1:(tries-1)
          nH += 1
          H[nH] = C.g[step][j]
        end
        for j in (tries + 1):(C.ng[step]-1)
          nH += 1
          H[nH] = C.g[step][j]
        end
        for i in (step + 1):dim
          for j in 1:C.ng[i]
            nH += 1
            H[nH] = C.g[i][j]
            if _orbitlen(C.std_basis[step], C.orders[step], H, nH, C) == C.orders[step]
              # /* the generator g[step][tries] can be omitted */
              C.ng[step] -= 1
              for i in tries:(C.ng[step] - 1)
                C.g[step][i] = C.g[step][i + 1]
              end
              tries -= 1
            end
          end
        end
        tries += 1
      end
    end
    if step < dim && C.orders[step] > 1
     # /* calculate stabilizer elements fixing the basis-vectors
     #    C.std_basis[1]...fp.e[step] */
      stab(step, C)
    end
  end
  return _get_generators(C)
end

function _get_generators(C)
  # Extract generators
  
  gens = fmpz_mat[]

  orde = prod(C.orders)

  for i in 1:dim(C)
    for j in (C.nsg[i] + 1):C.ng[i]
      push!(gens, C.g[i][j])
    end
  end

  return gens, orde
end

function aut(step, x, candidates, C, comb)
  dim = Hecke.dim(C)
  found = 0
  #@show step, x, candidates, C
  while candidates[step][1] != 0 && found == 0
    if step < dim
      x[step] = candidates[step][1]
      #/* check, whether x[1]...x[step] is a partial automorphism and compute the candidates for x[step + 1]
			if (cand(candidates[step + 1], step + 1, x, C, comb) == C.fp_diagonal[step + 1])
        found = aut(step + 1, x, candidates, C, comb)
      end
      if found == 1
        return found
      end
      orb = Int[x[step]]
      # delete the chosen vector from the list of candidates
      #delete(candidates[step], C.fp_diagonal[step], orb, 1)
      k = findfirst(isequal(x[step]), candidates[step])
      #setdiff!(candidates[step], orb)
      # This should be made faster to not always go to the end
      # Actually I should copy the delete function
      #@show candidates[step], k
      for i in (k + 1):length(candidates[step])
        candidates[step][i - 1] = candidates[step][i]
      end
      candidates[step][end] = 0
      #@show candidates[step]
    else
      x[dim] = candidates[dim][1]
      found = 1
    end
  end
  return found
end

function cand(candidates, I, x, C, comb)
  #@show candidates, I, x, C, comb
  DEP = 0 # this is bs
  dim = Hecke.dim(C)
  len = length(C.G) * DEP
  vec = Vector{Int}(undef, dim)
  scpvec = Vector{Int}(undef, len)
  if I >= 2 && DEP > 0
    com = comb[I - 1]
    rank = com.rank
    n = com.list.n
    # xvec is the list of vector sums which are computed with respect to the partial basis in x
    xvec = Vector{Vector{fmpz}}(undef, n + 1)
    for i in 1:(n + 1)
      xvec[i] = Vector{fmpz}(undef, dim)
      for j in 1:dim
        xvec[i][j] = zero(fmpz)
      end
    end
#/* xbase should be a basis for the lattice generated by the vectors in xvec,
#   it is obtained via the transformation matrix comb[I-1].trans */
    xbase = zero_matrix(FlintZZ, rank, dim)
    Fxbase = zero_matrix(FlintZZ, rank, dim)
  end
  # candidates is the list for the candidates
  #@show C.fp_diagonal[I], length(candidates)
  for i in 1:C.fp_diagonal[I]
    candidates[i] = 0
  end
  nr = 0
  fail = 0
  for j in 1:length(C.V)
    if fail != 0
      break
    end
    Vvj = C.V[j]
    okp = 0
    okm = 0
    for k in 1:len
      scpvek[k] = 0
    end
    #@show C.V[j]
    for i in 1:length(C.G)
      CAiI = C.G[i][C.per[I]] 
      Cvi = C.v[i]
      #@show Cvi
    
    # vec is the vector of scalar products of V.v[j] with the first I base vectors
    #   x[1]...x[I] 
      
      for k in 1:(I - 1)
        #@show x[k]
        xk = x[k]
        if xk > 0
          vec[k] = (Vvj * C.G[i] * C.V[xk]')[1, 1]
          #vec[k] = _dot_product(Vvj, C.v[i], xk)
        else
          vec[k] = -(Vvj * C.G[i] * C.V[-xk]')[1, 1]
          #vec[k] = -_dot_product(VVj, C.v[i], -xk)
        end
      end

      good = true
      for k in 1:(I - 1)
        if vec[k] != C.G[i][C.per[I], C.per[k]]
          good = false
          break
        end
      end

      #@show "pos", Vvj, good

      if good && C.V_length[j][i] == C.G[i][C.per[I], C.per[I]]
        # C.V[j] is a candidate for x[I] with respec to the form C.G[i]
        okp += 1
      end

      good = true
      for k in 1:(I - 1)
        if vec[k] != -C.G[i][C.per[I], C.per[k]]
          good = false
          break
        end
      end

      #@show "neg", Vvj, good

      if good && C.V_length[j][i] == C.G[i][C.per[I], C.per[I]]
        # C.V[j] is a candidate for x[I] with respec to the form C.G[i]
        #@show "here"
        okm += 1
      end


      if I >= 2 && DEP > 0
        for k in I-1:-1:1
          if k <= I - 1 - DEP
            continue
          end
          scpvec[(i - 1) * DEP + I - k] = vec[k]
        end
      end
    end

    if I >= 2 && DEP > 0
      # check whether the scalar product combination scpvec is contained in the list comb[I - 1].list
      if all(iszero, scpvec)
        num = 0
      else
        num = find_vector(scpvec, com.list)
        sign = num > 0 ? 1 : -1
        num = sign * num
      end

      if num > n
        # scpvec is not found, hence x[1],...,x[I - 1] is not a partial automorphism
        fail = 1
      elseif num > 0
        # scpvec is found and the vector is added to the corresponding vector sum
        xnum = xvec[num]
        for k in 1:dim
          xnum[k] += sign * Vvj[k]
        end
      end
    end

    if okp == length(C.G)
      # V.v[j] is a candidate for x[I]
      if nr < C.fp_diagonal[I]
        nr += 1
        candidates[nr] = j
      else
        # there are too many candidates
        fail = 1
      end
    end

    #@show nr

    #@show okm == length(C.G)

    if okm == length(C.G)
      # -V.v[j] is a candidate for x[I]
      if nr < C.fp_diagonal[I]
        nr += 1
        candidates[nr] = -j
      else
        # there are too many candidates
        fail = 1
      end
    end

    #@show nr
  end

  #@show fail

  if fail == 1
    nr = 0
  end

  if nr == C.fp_diagonal[I] && I >= 2 && DEP > 0
    # compute the basis of the lattice generated by the vectors in xvec via the transformation matrix comb[I - 1].trans
    for i in 1:rank
      comtri = com.trans[i]
      for j in 1:dim
        xbij = FlintZZ(0)
        for k in 1:(n+1)
          xbij += comtri[k] * xvec[k][j]
        end
        xbase[i, j] = xbij
      end
    end
  end

  if nr == C.fp_diagonal[I] && I >= 2 && DEP > 0
    for i in 1:length(C.G)
      if !(nr > 0)
        break
      end
      for j in 1:rank
        for k in 1:dim
          Fxbase[j, k] = _dot_product(xbase[j], C.A[i], k)
        end
      end
      for j in 1:rank
        if !(nr > 0)
          break
        end
        for k in 1:j
          if !(nr > 0)
            break
          end
          if _dot_product(xbase[j], Fxbase[k]) != com.F[i][j][k]
            # scalar product is wrong
            nr = 0
          end
        end
      end
    end
  end

  if nr == C.fp_diagonal[I] && I >= 2 && DEP > 0
    for i in 1:(n + 1)
      if !(nr > 0)
        break
      end
    end
    comcoi = com.coeff[i]
    for j in 1:dim
      vj = zero(fmpz)
      for k in 1:rank
        vj += comcoi[k] * xbase[k][j]
      end
      if vj != xvec[i][j]
        # entry wrong
        nr = 0
        break
      end
    end
  end
  #@show candidates
  return nr
end

function orbit(pt, npt, G, nG, V)
  orb = Vector{Int}(undef, npt)
  n = length(V)
  flag = zeros(Bool, 2*n + 1)
  #/* if flag[i + length(V)] is true, then the point i is already in the orbit */
  for i in 1:npt
    orb[i] = pt[i]
    flag[pt[i] + n + 1] = true
  end
  norb = npt
  cnd = 1
  while cnd <= norb
    for i in 1:nG
      im = _operate(orb[cnd], G[i], V)
      if !flag[im + n + 1]
        # this is a new point
        norb += 1
        push!(orb, im)
        flag[im + n + 1] = true
      end
    end
    cnd += 1
  end
  return orb
end

function stab(I, C)
  V = C.V
#     	computes the orbit of fp.e[I] under the 
#				generators in G->g[I]...G->g[n-1] and elements 
#				stabilizing fp.e[I],
#				has some heuristic break conditions,
#				the generators in G->g[i] stabilize 
#				fp.e[0]...fp.e[i-1] but not fp.e[i], 
#				G->ng[i] is the number of generators in G->g[i],
#				the first G->nsg[i] of which are elements which
#				are obtained as stabilizer elements in 
#				<G->g[0],...,G->g[i-1]>, G->ord[i] is the orbit
#				length of fp.e[i] under 
#				<G->g[i],...,G->g[n-1]>	*****/
#group	*G;
#fpstruct fp;
#veclist	V;
#{
#	int	*orb, len, cnd, tmplen;
#	int	**w, *flag, ***H, ***Hj, **S, **tmp, ***Ggj;
#	int	i, j, k, l, dim, im, nH, nHj, fail;
#	int	Maxfail, Rest;
#
#/* some heuristic break conditions for the computation of stabilizer elements:
#   it would be too expensive to calculate all the stabilizer generators, which
#   are obtained from the orbit, since this is highly redundant, 
#   on the other hand every new generator which enlarges the group is much 
#   cheaper than one obtained from the backtrack,
#   after Maxfail subsequent stabilizer elements, that do not enlarge the group,
#   Rest more elements are calculated even if they leave the group unchanged,
#   since it turned out that this is often useful in the following steps,
#   increasing the parameters will possibly decrease the number of generators
#   for the group, but will increase the running time,
#   there is no magic behind this heuristic, tuning might be appropriate */
  dim = Hecke.dim(C)
  n = length(V)
  Rest = 0
  for i in I:dim
    if C.fp_diagonal[i] > 1 && C.orders[i] < C.fp_diagonal[i]
      Rest += 1
    end
  end

  Maxfail = Rest

  for i in 1:dim
    if C.fp_diagonal[i] > 1
      Maxfail += 1
    end
  end
  
  nH = 0
  for i in I:dim
    nH += C.ng[i]
  end

  Hj = Vector{fmpz_mat}(undef, nH + 1)
  H = Vector{fmpz_mat}(undef, nH)

#/* H are the generators of the group in which the stabilizer is computed */

  k = 0
  for i in I:dim
    for j in 1:C.ng[i]
      k += 1
      H[k] = C.g[i][j]
    end
  end

  w = Vector{Vector{Int}}(undef, 2 * n + 1)
  orb = zeros(Int, 2 * n)
  flag = zeros(Bool, 2 * n + 1)


#/* in w[V.n+i] an element is stored that maps fp.e[I] on v[i] */
#/* orb contains the orbit of fp.e[I] */
#/* if flag[i + V.n] = 1, then the point i is already in the orbit */
#/* S is a matrix to hold a stabilizer element temporarily */

  S = zero_matrix(FlintZZ, dim, dim)
  #@show I
  orb[1] = C.std_basis[I]
  flag[orb[1] + n + 1] = true
  #@show orb[1] + n + 1
  w[orb[1] + n + 1] = Int[ C.std_basis[i] for i in 1:dim]
  cnd = 1
  len = 1
  fail = 0

  while cnd <= len && fail < Maxfail + Rest
    for i in 1:nH
      if fail > Maxfail + Rest
        break
      end

      if fail >= Maxfail
      #/* there have already been Maxfail successive failures, now a random generator
      #   is applied to a random point of the orbit to get Rest more stabilizer 
      #   elements */
        cnd = rand(1:len)
        i = rand(1:nH)
      end
      #@show orb, flag
      #@show cnd
      im = _operate(orb[cnd], H[i], V)
      #@show im
      #@show w
      if !flag[im + n + 1]
#/* a new element is found, appended to the orbit and an element mapping
#   fp.e[I] to im is stored in w[im+V.n] */
        len += 1
        #@show orb, len
        orb[len] = im
        flag[im + n + 1] = true
        #@show w[orb[cnd] + n + 1]
        #@show H[i]
        #@show Int[_operate(w[orb[cnd] + n + 1][j], H[i], V) for j in 1:dim]
        w[im + n + 1] = Int[_operate(w[orb[cnd] + n + 1][j], H[i], V) for j in 1:dim]
      else
#/* the image was already in the orbit */
        j = I
        while j <= dim
          if _operate(w[orb[cnd] + n + 1][j], H[i], V) == w[im + n + 1][j]
            break
          end
          j += 1
        end
#/* j is the first index where the images of the old and the new element
#   mapping e[I] on im differ */
        if j <= dim && (C.orders[j] < C.fp_diagonal[j]  || fail >= Maxfail)
#/* new stabilizer element S = w[orb[cnd]+V.n] * H[i] * (w[im+V.n])^-1 */
          S = stabil(w[orb[cnd] + n + 1], w[im + n + 1], C.per, H[i], V)
          #@show S
          Hj[1] = S
          nHj = 1
          for k in j:dim
            for l in 1:C.ng[k]
              nHj += 1
              Hj[nHj] = C.g[k][l]
            end
          end
          tmplen = _orbitlen(C.std_basis[j], C.fp_diagonal[j], Hj, nHj, V)
          if tmplen > C.orders[j] || fail >= Maxfail
#/* the new stabilizer element S either enlarges the orbit of e[j]
#   or it is one of the additional elements after MAXFAIL failures */
            C.orders[j] = tmplen
            C.ng[j] = C.ng[j] + 1
            C.nsg[j] = C.nsg[j] + 1
            #@show C.g[j]
            #@show C.nsg[j]
            insert!(C.g[j], C.nsg[j], S)
#/* the new generator is inserted as stabilizer element nr. nsg[j]-1 */
            nH += 1
            push!(H, S)
            if fail < Maxfail
              fail = 0
            else
              fail += 1
            end
            resize!(Hj, nH + 1)
#/* the new generator is appended to H */
#/* the number of failures is reset to 0 */ 
          else
#/* the new stabilizer element S does not enlarge the orbit of e[j] */
            fail += 1
          end
        else
          if j <= dim && fail < Maxfail || (j == dim && fail >= Maxfail)
            fail += 1
          end
        end
      #/* if S is the identity and fail < Maxfail, nothing is done */
      end
    end
    if fail < Maxfail
      cnd += 1
    end
  end
end

#void stabil(S, x1, x2, per, G, V)	/*****	x1 corresponds to an element X1
#						mapping some vector e on p1,
#						x2 to an element X2 mapping e on
#						p2 and G is a generator mapping
#						p1 on p2, then S = X1*G*X2^-1
#						stabilizes e	*****/
function stabil(x1, x2, per, G, V)
  #@show x1, x2
  dim = length(x1)
  XG = zero_matrix(FlintZZ, dim, dim)
  X2 = zero_matrix(FlintZZ, dim, dim)
  x = Vector{Int}(undef, dim)
  for i in 1:dim
    x[i] = _operate(x1[i], G, V)
  end
  #@show x
  #@show x2
  XG = matgen(x, dim, per, V)
  X2 = matgen(x2, dim, per, V)
  #@show XG, X2
  #X2i, d = pseudo_inv(X2)
  #@show XG * X2i, d
  #S = divexact(XG * X2i, d)
# /* S = XG * X2^-1 */
  b, S = can_solve(X2, XG, side = :left)
  @assert b
  @assert S * X2 == XG
  #@show S
  return S
end

function matgen(x, dim, per, v)
#/*****	generates the matrix X which has as row
#					per[i] the vector nr. x[i] from the 
#					list v	*****/
  X = zero_matrix(FlintZZ, dim, dim)
  #@show x
  for i in 1:dim
    xi = x[i]
    if x[i] > 0
      for j in 1:dim
        X[per[i], j] = v[xi][j]
      end
    else
      for j in 1:dim
        X[per[i], j] = -v[-xi][j]
      end
    end
  end
  return X
end

function assert_auto(C, order)
  G, o = _get_generators(C)
  if o != order
    throw(error("Order $o. Expected $order"))
  end

  for g in G
    for U in C.G
      if g * U * g' != U
        throw(error("Not an isometry.\nElement:\n $g\nGram matrix:\n$U"))
      end
    end
  end
  return true
end


#orbit(pt, npt, G, nG, V, orb)	/*****	computes the orbit of npt points in pt 
#					under the nG matrices in G and puts the
#					orbit in orb, allocates the memory for 
#					orb, returns the length of the orbit, 
#					the points are the indices in the
#					list V.v	*****/

#cand(CI, I, x, V, F, fp, comb, bach, flags)
#			/*****	tests, whether x[0],...,x[I-1] is a partial 
#				automorphism, using scalar product combinations
#				and Bacher-polynomials depending on the chosen 
#				options, puts the candidates for x[I] (i.e. the
#				vectors vec such that the scalar products of 
#				x[0],...,x[I-1],vec are correct) on CI, returns
#				their number (should be fp.diag[I])	*****/
#veclist	V;
#invar	F;
#fpstruct fp;
#scpcomb	*comb;
#bachpol	*bach;
#flagstruct flags;
#int	*CI, I, *x;
#{
#	int	i, j, k, dim, okp, okm, sign, nr, fail, num;
#	int	*vec, *scpvec, **xvec, **xbase, **Fxbase, DEP, len, rank, n;
#	int	*Vvj, *FAiI, **Fvi, *xnum, xk, *comtri, *comcoi, xbij, vj;
#	scpcomb	com;
#

# Some tests that I need to add:
#
# G = matrix(FlintZZ, 8, 8, [4, -2, 0, 0, 0, 0, 0, 1, -2, 2, -1, 0, 0, 0, 0, 0, 0, -1, 2, -1, 0, 0, 0, 0, 0, 0, -1, 2, -1, 0, 0, 0, 0, 0, 0, -1, 2, -1, 0, 0, 0, 0, 0, 0, -1, 2, -1, 0, 0, 0, 0, 0, 0, -1, 2, 0, 1, 0, 0, 0, 0, 0, 0, 2])
#
# C = Hecke.ZLatAutoCtx([G]); Hecke.compute_short_vectors(C);
#
# Hecke.fingerprint(C)
# reduce(hcat, [C.fp[:, i] for i in 1:8][C.per]) == [240 240 2160 240 240 240 240 240; 0 56 126 126 126 126 126 126; 0 0 27 27 72 72 72 72; 0 0 0 10 40 16 40 40; 0 0 0 0 8 8 24 24; 0 0 0 0 0 4 6 12; 0 0 0 0 0 0 3 6; 0 0 0 0 0 0 0 2]

const lattices = [
(([[2]]), 2), 
# 2
(([[1, 0], [0, 2]]), 4),
(([[2, -1], [-1, 2]]), 12),
# 3
(([[2, 1, 0], [1, 2, 0], [0, 0, 26]]), 24),
# 4
(([[1, 0, 0, 0], [0, 2, -1, 1], [0, -1, 3, -1], [0, 1, -1, 3]]), 16),
# 5
(([[2, 1, 1, 1, -1], [1, 2, 1, 1, 0], [1, 1, 2, 1, -1], [1, 1, 1, 2, -1], [-1, 0, -1, -1, 2]]), 3840),
(([[1, 0, 0, 0, 0], [0, 1, 0, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 2, 1], [0, 0, 0, 1, 3]]), 192),
# 6
(([[2, -1, 0, 0, 0, 0], [-1, 2, -1, 0, 0, 0], [0, -1, 2, -1, 0, -1], [0, 0, -1, 2, -1, 0], [0, 0, 0, -1, 2, 0], [0, 0, -1, 0, 0, 2]]), 103680),
(([[1, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0], [0, 0, 2, 1, 0, 1], [0, 0, 1, 3, 1, 1], [0, 0, 0, 1, 2, 1], [0, 0, 1, 1, 1, 3]]), 512),
#(([[8, 4, 4, 4, 4, 4, 4, 2, 4, 4, 4, 2, 4, 2, 2, 2, 4, 2, 2, 2, 0, 0, 0, -3],
#   [4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 2, 1, 1, 2, 1, 0, 0, -1],
#   [4, 2, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 1, 2, 2, 1, 1, 1, 0, 0, -1],
#   [4, 2, 2, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 2, 2, 1, 2, 1, 1, 0, 0, -1],
#   [4, 2, 2, 2, 4, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 1, 0, 0, -1],
#   [4, 2, 2, 2, 2, 4, 2, 2, 2, 2, 2, 1, 2, 2, 1, 1, 2, 1, 2, 1, 0, 0, 0, -1],
#   [4, 2, 2, 2, 2, 2, 4, 2, 2, 2, 2, 1, 2, 1, 2, 1, 2, 1, 1, 2, 0, 0, 0, -1],
#   [2, 2, 2, 2, 2, 2, 2, 4, 1, 1, 1, 2, 1, 2, 2, 2, 1, 2, 2, 2, 2, 0, 0, 1],
#   [4, 2, 2, 2, 2, 2, 2, 1, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, -1],
#   [4, 2, 2, 2, 2, 2, 2, 1, 2, 4, 2, 2, 2, 2, 1, 1, 2, 2, 1, 1, 0, 1, 0, -1],
#   [4, 2, 2, 2, 2, 2, 2, 1, 2, 2, 4, 2, 2, 1, 2, 1, 2, 1, 2, 1, 0, 0, 1, -1],
#   [2, 2, 2, 2, 1, 1, 1, 2, 2, 2, 2, 4, 1, 2, 2, 2, 1, 2, 2, 2, 2, 1, 1, 1],
#   [4, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 1, 4, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, -1],
#   [2, 2, 1, 1, 2, 2, 1, 2, 2, 2, 1, 2, 2, 4, 2, 2, 1, 2, 2, 2, 2, 2, 1, 1],
#   [2, 1, 2, 1, 2, 1, 2, 2, 2, 1, 2, 2, 2, 2, 4, 2, 1, 2, 2, 2, 2, 1, 2, 1],
#   [2, 1, 1, 2, 2, 1, 1, 2, 2, 1, 1, 2, 2, 2, 2, 4, 1, 2, 2, 2, 2, 1, 1, 1],
#   [4, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 1, 2, 1, 1, 1, 4, 2, 2, 2, 1, 1, 1, -1],
#   [2, 1, 2, 1, 2, 1, 1, 2, 2, 2, 1, 2, 1, 2, 2, 2, 2, 4, 2, 2, 2, 2, 1, 1],
#   [2, 1, 1, 2, 2, 2, 1, 2, 2, 1, 2, 2, 1, 2, 2, 2, 2, 2, 4, 2, 2, 1, 2, 1],
#   [2, 2, 1, 1, 2, 1, 2, 2, 2, 1, 1, 2, 1, 2, 2, 2, 2, 2, 2, 4, 2, 1, 1, 1],
#   [0, 1, 1, 1, 1, 0, 0, 2, 1, 0, 0, 2, 1, 2, 2, 2, 1, 2, 2, 2, 4, 2, 2, 2],
#   [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 2, 1, 1, 1, 2, 1, 1, 2, 4, 2, 2],
#   [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 2, 1, 1, 1, 2, 1, 2, 2, 4, 2],
#   [-3, -1, -1, -1, -1, -1, -1, 1, -1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 2,
#    2, 2, 4]]), 8315553613086720000)]
(([[2, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [-1, 2, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, -1, 2, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, -1, 2, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, -1, 2, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, -1, 2, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, -1, 2, -1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, -1, 2, -1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, -1, 2, -1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, -1, 2, -1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 2, -1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 2, -1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 2, -1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 2, -1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 2, -1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 2]]), 711374856192000)]

function test_auto()
  for (m, o) in lattices
    n = length(m[1])
    G = matrix(FlintZZ, n, n, reduce(vcat, m))
    C = Hecke.ZLatAutoCtx([G]);
    init(C)
    auto(C)
    assert_auto(C, o)
  end
end
