export cyclotomic_units_totally_real
# Some functionality for cyclotomic fields

@doc Markdown.doc"""
    cyclotomic_units_totally_real(K::NumField)

Given the maximal totally real subfield $K$ of a cyclotomic field of prime
conductor, return a generating set for the cyclotomic units of $K$.

# Examples

```jldoctest
julia> K, a = CyclotomicRealSubfield(7);

julia> cyclotomic_units_totally_real(K)
3-element Vector{nf_elem}:
 -1
 (z_7 + 1/z_7)^2 - 1
 -(z_7 + 1/z_7)^2 - (z_7 + 1/z_7) + 2
```
"""
function cyclotomic_units_totally_real(K::NumField)
 
  # K must be Q(zeta + zeta^-1)
  d = degree(K)
  @req is_prime(2*d + 1) "Conductor must be prime"
  p = 2 * d + 1
  Zx = Globals.Zx
  @assert is_zero(cos_minpoly(p, gen(Zx))(gen(K)))

  L, zeta = cyclotomic_field(p, cached = false)

  m = hom(K, L, gen(L) + gen(L)^-1)

  xi = gen(K)

  # Washington, Lemma 1
  res = elem_type(K)[K(-1)]

  Qx = parent(defining_polynomial(K))
  x = gen(parent(defining_polynomial(K)))

  inv2 = invmod(2, p)
  a = 2

  U, mU = unit_group(ResidueRing(ZZ, p, cached = false))
  @assert ngens(U) == 1
  g = Int(lift(mU(U[1])))

  # Schoof, "Class numbers of real cyclotomic fields of prime conductor", Section 2
  # gives the following formula:
  # eta = zeta^(g) - zeta^(-g)/zeta - zeta^-1 = sin(2pi g/n)/sin(2p/n) = U_{g - 1}(cos(2pi/n))
  # then Cyc is generated by the G-orbit of eta,
  # where G = Gal(K/Q).
  # so if eta_a = zeta^(ga) - zeta^(-ga)/zeta^a - zeta^-a
  # I just sneak in zeta - zeta^-1 and use the above formula twice
  p1 = numerator(chebyshev_u(g - 1, x)(x//2))
  eta = p1(xi)
  push!(res, eta)
  # now apply all automorphisms
  # we can leave out one (because the product is +/- 1)
  while a < p//2 - 1
    if !is_coprime(a, p)
      continue
    end
    neta = numerator(chebyshev_u(g * a- 1, x)(x//2))(xi)
    neta *= inv(numerator(chebyshev_u(a - 1, x)(x//2))(xi))
    push!(res, neta)
    a += 1
  end

  # The following might be useful for the prime power case
  #
  # Washtingon, "Introduction to cyclotomic fields", Lemma 8.1
  #
  #while a < p//2
  #  if !is_coprime(a, p)
  #    continue
  #  end
  #  b = zeta^((1 - a) * inv2)
  #  #fl, bb =  is_square_with_sqrt(zeta^(1 - a))
  #  @assert b^2 == zeta^(1 - a)
  #  xia = b * divexact(1 - zeta^a, 1 - zeta)
  #  fl, c = haspreimage(m, xia)
  #  @assert fl
  #  push!(res, c)
  #  a += 1
  #end
  return res
end
