# Compute basis for the subfield of K that is generated by the elements of as.
function _subfield_basis(K::S, as::Vector{T}) where {
    S <: Union{AbsSimpleNumField, Hecke.RelSimpleNumField},
    T <: Union{AbsSimpleNumFieldElem, Hecke.RelSimpleNumFieldElem}
   }
  if isempty(as)
    return elem_type(K)[gen(K)]
  end

  # Notation: k base field, K the ambient field, F the field generated by as

  k = base_field(K)

  d = degree(K)
  Kvs = vector_space(k, d)
  # We transition the coefficients of a in reverse order, so that the
  # first vector in the row reduced echelon form yields the highest
  # degree among all elements of Fas.
  (Fvs,phivs) = sub(Kvs, [Kvs([coeff(a,n) for n in d-1:-1:0])
                          for a in as])
  dF = length(Fvs.gens) # dim(Fvs)
  bs = as
  while !isempty(bs)
    nbs = elem_type(K)[]
    for b in bs
      abs = elem_type(K)[a*b for a in as]
      abvs,_ = sub(Kvs, [Kvs([coeff(ab,n) for n in d-1:-1:0])
                         for ab in abs])
      (Fvs,phivs) = sub(Kvs, typeof(Fvs)[Fvs, abvs])
      if dF != length(Fvs.gens) # dim(Fvs)
        dF = length(Fvs.gens) # dim(Fvs)
        append!(nbs, abs)
      end
    end
    bs = nbs
  end

  kx = parent(K.pol)
  b = elem_type(K)[
        let Kv = phivs(v)
          K(kx([Kv[n] for n in d:-1:1]))
        end
       for v in gens(Fvs)]::Vector{elem_type(K)}

  if K isa AbsSimpleNumField
    return [x*denominator(x) for x in b]
  else
    return b
  end
end

function _improve_subfield_basis(K, bas)
  # First compute the maximal order of <bas> by intersecting and saturating
  # Then B_Ok = N * B_LLL_OK
  # Then B' defined as lllN * B_LLL_OK will hopefully be small
  OK = maximal_order(K)
  OKbmatinv = basis_mat_inv(FakeFmpqMat, OK, copy = false)
  basinOK = bas * QQMatrix(OKbmatinv.num) * QQFieldElem(1, OKbmatinv.den)
  deno = ZZRingElem(1)
  for i in 1:nrows(basinOK)
    for j in 1:ncols(basinOK)
      deno = lcm(deno, denominator(basinOK[i, j]))
    end
  end
   S = saturate(map_entries(ZZ, basinOK * deno))
  SS = S * basis_matrix(FakeFmpqMat, OK, copy = false)
  lllOK = lll(OK)
  N = (SS * basis_mat_inv(FakeFmpqMat, lllOK)).num
  lllN = lll(N)
  maybesmaller = lllN * basis_matrix(FakeFmpqMat, lllOK)
  return maybesmaller
end

function _improve_subfield_basis_no_lll(K, bas)
  OK = maximal_order(K)
  OKbmatinv = basis_mat_inv(OK, copy = false)
  basinOK = bas * QQMatrix(OKbmatinv.num) * QQFieldElem(1, OKbmatinv.den)
  deno = ZZRingElem(1)
  for i in 1:nrows(basinOK)
    for j in 1:ncols(basinOK)
      deno = lcm(deno, denominator(basinOK[i, j]))
    end
  end
  S = saturate(map_entries(ZZ, basinOK * deno))
  SS = S * basis_matrix(FakeFmpqMat, OK, copy = false)
  return SS
end

# Compute a primitive element given a basis of a subfield
function _subfield_primitive_element_from_basis(K::S, as::Vector{T}) where {
    S <: Union{AbsSimpleNumField, Hecke.RelSimpleNumField},
    T <: Union{AbsSimpleNumFieldElem, Hecke.RelSimpleNumFieldElem}
   }
  if isempty(as)
    return gen(K)
  end

  d = length(as)

  # First check basis elements
  i = findfirst(a -> degree(minpoly(a)) == d, as)
  if i <= d
    return as[i]
  end

  k = base_field(K)

  # Notation: cs the coefficients in a linear combination of the as, ca the dot
  # product of these vectors.
  cs = ZZRingElem[zero(ZZ) for n in 1:d]
  cs[1] = one(ZZ)
  while true
    ca = sum(c*a for (c,a) in zip(cs,as))
    if degree(minpoly(ca)) == d
      return ca
    end

    # increment the components of cs
    cs[1] += 1
    let i = 2
      while i <= d && cs[i-1] > cs[i]+1
        cs[i-1] = zero(ZZ)
        cs[i] += 1
        i += 1
      end
    end
  end
end

function block_system(t::AbsSimpleNumFieldElem, C#=::qAdicConj=#)
  @assert C isa qAdicConj
  pr = 1
  while true
    c = conjugates(t, C, pr)::Vector{QadicFieldElem}
    D = Dict{QadicFieldElem, Vector{Int}}()
    for i = 1:length(c)
      if haskey(D, c[i])
        push!(D[c[i]], i)
      else
        D[c[i]] = [i]
      end
    end
    bs = sort(collect(values(D)), lt = (a,b) -> isless(a[1], b[1]))
    if length(bs) * length(bs[1]) == length(c) &&
        all(x->length(x) == length(bs[1]), bs)
      return bs
    end
    pr *= 2
    if pr > 100
      error("probably bad")
    end
  end
end

# As above, but for AbsSimpleNumField type
# In this case, we can use a block system to find if an element is
# primitive (and find a primitive element) Input does not need to be
# a basis, generators are sufficient
function _subfield_primitive_element_from_basis(K::AbsSimpleNumField, as::Vector{AbsSimpleNumFieldElem}, lincomb = false)
  if isempty(as) || degree(K) == 1
    return gen(K)
  end

  as = AbsSimpleNumFieldElem[x for x in as if !iszero(x)]

  dsubfield = length(as)

  @vprintln :Subfields 1 "Sieving for primitive elements"
  # First check basis elements
  Zx, = polynomial_ring(ZZ, "x", cached = false)
  f = Zx(K.pol*denominator(K.pol))
  _C = get_attribute(K, :subfield_data)
  if _C === nothing
    p, d = _find_prime(ZZPolyRingElem[f])
    _C = qAdicConj(K, p; splitting_field = true)
    set_attribute!(K, :subfield_data => _C)
  end
  C = _C::qAdicConj
  # First, we search for elements that are primitive using block systems
  # TODO: use p-adic roots ala Oscar/experimental/Galois.../src/Subfield.jl
  # prob: get bounds without SLP and GaloisCtx
  b = Vector{Int}[collect(1:degree(f))] #block system for QQ
  all_b = Vector{Vector{Int}}[]
  for i = 1:length(as)
    _b = block_system(as[i], C)
    push!(all_b, _b)
    b = Vector{Int}[intersect(x, y) for x in b for y in _b]
    b = Vector{Int}[x for x in b if length(x) > 0]
  end
  @vprintln :Subfields 1 "Have block systems, degree of subfield is $(length(b))"
  sort!(b, lt = (a,b) -> isless(a[1], b[1]))
  # b is the block of the subfield (with respect to the embeddings in C)

  if lincomb
    return _subfield_primitive_element_from_basis_lincomb(K, b, all_b, C, as)
  else
    return _subfield_primitive_element_from_block(K, C, b)
  end
end

function _subfield_primitive_element_from_basis_lincomb(K::AbsSimpleNumField, b, all_b, C, as::Vector{AbsSimpleNumFieldElem})
  indices = findall(x->length(x) == length(b), all_b)

  @vprintln :Subfields 1 "Found $(length(indices)) primitive elements in the basis"
  # Now, we select the one of smallest T2 norm
  if !isempty(indices)
    a = as[indices[1]]
    I = t2(a)
    for i = 2:length(indices)
      t2n = t2(as[indices[i]])
      if t2n < I
        a = as[indices[i]]
        I = t2n
      end
    end
    @vprintln :Subfields 1 "Primitive element found"
    return a
  end

  @vprintln :Subfields 1 "Finding combination of elements"

  pe = as[1]
  cur_b = all_b[1]
  for i=2:length(as)
    if issubset(all_b[i][1], cur_b[1])
      continue
    end
    cur_b = Vector{Int}[intersect(x, y) for x in cur_b for y in all_b[i]]
    cur_b = Vector{Int}[x for x in cur_b if length(x) > 0]
    sort!(cur_b, lt = (a,b) -> isless(a[1], b[1]))
    j = 1
    while block_system(pe + j*as[i], C) != cur_b
      j += 1
      if j > 10
        error("dnw")
      end
    end
    pe += j*as[i]
    if cur_b == b
      @vprintln :Subfields 1 "Primitive element found"
      return pe
    end
  end
  error("should be hard...")
end

function _subfield_primitive_element_from_block(K::AbsSimpleNumField, C#=::qAdicConj=#, b::Vector{Vector{Int}})
  @assert C isa qAdicConj
  if length(b) == 1
    return one(K)
  end
  # Klueners:
  # - try sum of conj. in block
  # - then prod
  # - then prod (x+i) for i this will enventually be OK
  #
  # trivial precision: double until it works
  #
  # So we have/ want to have K/k where k is given via block system
  # Klueners: at least one of
  #      Tr_K/k(gen(K)), N_K/k(gen(K)) or N_K/k(gen(K)+i)
  # is primitive (for suitable i)
  # so try in this order as Tr is expected to be smaller than Norm.
  # Size:
  # T_2(gen(k)) <= [K:k] T_2(gen(K)) via Trace
  #             <= T_2(gen(K))^[K:k] via Norm
  #             <= (sqrt(T_2) + sqrt([K:k])i)^2)^[K:k] in the last case
  #(using that sqrt(T_2) is a euclidean norm, so 
  #  sqrt(T_2(a+b)) <= sqrt(T_2(a)) + sqrt(T_2(b))
  #
  # if gen(K) is integral, then so is gen(k), however, gen(k)
  # won't be in the equation order
  # So we'll recover in the Kronnecker rep, in the dual basis
  # gen(k) = sum a_i omega_i
  # for Tr(omega_i gen(K)^j) = delta_i,j
  # so a_i = Tr(gen(k) * omega_i), using Cauchy-Schwarz
  # a_i^2 <= T_2(gen(k)) * T_2(omega_i)
  # omega_i can be obtained from coeff of def_poly(K)/(t-gen(K))
  # [K:k] = length(b[i]) for all i, [k:Q] = length(b) 

  pr = 5
  @assert is_monic(defining_polynomial(K))
  c = conjugates(gen(K), C, pr) #the roots...
  pe = c -> [sum(c[x]) for x = b]
  Bpe = length(b[1]) * length(gen(K)) 
  if length(Set(pe(c))) != length(b)
    #trace is not primitive!
    pe = c -> [prod(c[x]) for x in b]
    Bpe = length(gen(K))^length(b[1])
    if length(Set(pe(c))) != length(b)
      i = 1
      while true
        pe = c -> let i= i; [prod(y+i for y in c[x]) for x = b] end
        if length(Set(pe(c))) == length(b)
          break
        end
        i += 1
      end
      Bpe = (length(gen(K))+i*degree(K))^length(b[1]) #not quite correct?
    end
  end

  #Bpe should now be an upper bound on T_2 of gen(k)
  #from there we need
  # - bound on minpoly(gen(k))
  # - bound on coeffs (via dual basis, see above)
  #   dual[i]*den is actually dual to gen(K)^(i-1)
  #   and gen(k)//den is in ZZ[gen(K)]
  #   so tr(gen(k)//den * dual[i]*den) = tr(gen(k)*dual[i])
  #   is integral (and bounded)...
  #
  # minpoly: 
  #  T_2 is upper bound on conjugates (squared)
  #  coeffs of min_poly are elementary symmetric,
  #   so bounded by max(binom([k:Q], i), T_2(gen(k))^i : i)
  #  max binum is in the middle..
  B_f = binomial(ZZ(length(b)), div(ZZ(length(b)), 2))*Bpe^length(b)
  # the coeffs of minpoly are in Z, so need prec <= log_p(2 B_f)
  Kt, t = polynomial_ring(K; cached = false)
  den = inv(derivative(defining_polynomial(K))(gen(K)))
  dual = collect(coefficients(div(defining_polynomial(K)(t), t-gen(K)))) 
  B_pe = maximum(ceil(ZZRingElem, length(x)) for x = dual) * ceil(ZZRingElem, Bpe)
  #so pr needs to cover 2*max(B_pe, B_f)
  Qp = parent(c[1])
  pr_max = ceil(Int, log(2*max(B_pe, B_f), BigFloat(prime(Qp))))
    
  pr *= 2
  Qpt, t = polynomial_ring(Qp, cached = false)
  p = ZZ(C.C.p)
  local ff::ZZPolyRingElem
  while true
    p_pow = p^pr
    c = conjugates(gen(K), C, pr) #the roots...
    v = pe(c)
    setprecision!(t, pr)
    f = prod(elem_type(Qpt)[t-x for x in v])
    ff = map_coefficients(x->mod_sym(lift(ZZ, coeff(x, 0)), p_pow), f)
    elem = zero(K)
    v = [v[findall(x-> j in x, b)[1]] for j=1:length(c)]
    bb = one(K)
    for i = 1:length(dual)
      b = dual[i]
      d = conjugates(b, C, pr)
      cf = mod_sym(lift(ZZ, coeff(dot(v, d), 0)), p_pow)
      elem += cf*bb
      bb *= gen(K)
    end
    elem *= den
    if iszero(ff(elem))
      return elem
    end
#    if all(x->nbits(x) < nbits(p_pow) - 30, coefficients(ff))
#      f = interpolate(Qpt, c, [v[findall(x-> j in x, b)[1]] for j=1:length(c)])
#      elem = map_coefficients(x->QQ(rational_reconstruction(lift(ZZ, coeff(x, 0)), p_pow)[2:3]...), f)(gen(K))
#
#      if is_zero(ff(elem))
#        return elem
#      end
#    end
    if pr > pr_max
        error("probably something bad?")
    end
    pr *= 2
    #if the block system is illegal, this will not terminate.
  end
end

################################################################################
#
#  Subfield
#
################################################################################

sub(K::NumField, args...; kw...) = subfield(K, args...; kw...)

@doc raw"""
    subfield(L::NumField, elements::Vector{<: NumFieldelem};
                          is_basis::Bool = false) -> NumField, Map

Return the simple number field $K$ generated by the given elements over the
base field $k$ of $L$ together with the embedding $k \to L$.

If `is_basis` is `true`, it is assumed that `elements` holds a $k$-basis of
$K$.

```jldoctest
julia> Qx, x = QQ[:x]; L, a = number_field(x^4 + 6*x^2 + 4, :a);

julia> K, KtoL = subfield(L, [a^2]);

julia> K
Number field with defining polynomial x^2 + 6*x + 4
  over rational field
```
"""
function subfield(K::NumField, elt::Vector{<:NumFieldElem}; is_basis::Bool = false, isbasis::Bool = false)
  @req all(x -> parent(x) === K, elt) "Elements must be contained in the field"

  if K isa AbsSimpleNumField
    # in this case the block code does not need a basis
    s = _subfield_primitive_element_from_basis(K, elt)
    s *= denominator(s)
    return _subfield_from_primitive_element(K, s)
  end

  if length(elt) == 1
    return _subfield_from_primitive_element(K, elt[1])
  end
  isbasis = is_basis || isbasis

  if isbasis
    s = _subfield_primitive_element_from_basis(K, elt)
  else
    bas = _subfield_basis(K, elt)
    s = _subfield_primitive_element_from_basis(K, bas)
  end

  return _subfield_from_primitive_element(K, s)
end

function _subfield_from_primitive_element(K::AbsSimpleNumField, s::AbsSimpleNumFieldElem)
  @vtime :Subfields 1 f = minpoly(Globals.Qx, s)
  f = denominator(f) * f
  L, _ = number_field(f, cached = false)
  return L, hom(L, K, s, check = false)
end

function _subfield_from_primitive_element(K, s)
  @vtime :Subfields 1 f = minpoly(s)
  L, _ = number_field(f, cached = false)
  return L, hom(L, K, s, check = false)
end

################################################################################
#
#  Fixed field
#
################################################################################

@doc raw"""
    fixed_field(K::SimpleNumField,
                sigma::Map;
                simplify::Bool = true) -> number_field, NumFieldHom{AbsSimpleNumField, AbsSimpleNumField}

Given a number field $K$ and an automorphism $\sigma$ of $K$, this function
returns the fixed field of $\sigma$ as a pair $(L, i)$ consisting of a number
field $L$ and an embedding of $L$ into $K$.

By default, the function tries to find a small defining polynomial of $L$. This
can be disabled by setting `simplify = false`.
"""
function fixed_field(K::SimpleNumField, sigma::T; simplify::Bool = true) where {T <: NumFieldHom}
  return fixed_field(K, T[sigma], simplify = simplify)
end

#@doc raw"""
#    fixed_field(K::SimpleNumField, A::Vector{NumFieldHom{AbsSimpleNumField, AbsSimpleNumField}}) -> number_field, NumFieldHom{AbsSimpleNumField, AbsSimpleNumField}
#
#Given a number field $K$ and a set $A$ of automorphisms of $K$, this function
#returns the fixed field of $A$ as a pair $(L, i)$ consisting of a number field
#$L$ and an embedding of $L$ into $K$.
#
#By default, the function tries to find a small defining polynomial of $L$. This
#can be disabled by setting `simplify = false`.
#"""
function fixed_field(K::AbsSimpleNumField, A::Vector{<:NumFieldHom{AbsSimpleNumField, AbsSimpleNumField}}; simplify::Bool = true)

  autos = small_generating_set(A)
  if length(autos) == 0
    return K, id_hom(K)
  end

  if is_maximal_order_known(K)
    OK = maximal_order(K)
    if isdefined(OK, :lllO)
      k, mk = fixed_field1(K, A)
      return k, mk
    end
  end

  a = gen(K)
  n = degree(K)
  ar_mat = Vector{QQMatrix}()
  v = Vector{AbsSimpleNumFieldElem}(undef, n)
  for i in 1:length(autos)
    domain(autos[i]) !== codomain(autos[i]) && error("Maps must be automorphisms")
    domain(autos[i]) !== K && error("Maps must be automorphisms of K")
    o = one(K)
    # Compute the image of the basis 1,a,...,a^(n - 1) under autos[i] and write
    # the coordinates in a matrix. This is the matrix of autos[i] with respect
    # to 1,a,...a^(n - 1).
    as = autos[i](a)
    if a == as
      continue
    end
    v[1] = o
    for j in 2:n
      o = o * as
      v[j] = o
    end
    bm = basis_matrix(v, FakeFmpqMat)
    # We have to be a bit careful (clever) since in the absolute case the
    # basis matrix is a FakeFmpqMat

    m = QQMatrix(bm.num)
    for j in 1:n
      m[j, j] = m[j, j] - bm.den # This is autos[i] - identity
    end


    push!(ar_mat, m)
  end

  if length(ar_mat) == 0
    return K, id_hom(K)
  else
    bigmatrix = reduce(hcat, ar_mat)
    Ker = kernel(bigmatrix, side = :left)
    bas = Vector{elem_type(K)}(undef, nrows(Ker))
    if simplify
      KasFMat = _improve_subfield_basis(K, Ker)
      for i in 1:nrows(Ker)
        bas[i] = elem_from_mat_row(K, KasFMat.num, i, KasFMat.den)
      end
    else
    #KasFMat = _improve_subfield_basis_no_lll(K, Ker)
      KasFMat = FakeFmpqMat(Ker)
      Ksat = saturate(KasFMat.num)
      Ksat = lll(Ksat)
      onee = one(ZZRingElem)
      for i in 1:nrows(Ker)
        #bas[i] = elem_from_mat_row(K, KasFMat.num, i, KasFMat.den)
        bas[i] = elem_from_mat_row(K, Ksat, i, onee)
      end
    end
  end
  return subfield(K, bas, isbasis = true)
end


function fixed_field(K::RelSimpleNumField, A::Vector{T}; simplify::Bool = true) where {T <: NumFieldHom}
  autos = A

    # Everything is fixed by nothing :)
  if length(autos) == 0
    return K, id_hom(K)
  end

  F = base_field(K)
  a = gen(K)
  n = degree(K)
  ar_mat = Vector{dense_matrix_type(elem_type(F))}()
  v = Vector{elem_type(K)}(undef, n)
  for i in 1:length(autos)
    domain(autos[i]) !== codomain(autos[i]) && error("Maps must be automorphisms")
    domain(autos[i]) !== K && error("Maps must be automorphisms of K")
    o = one(K)
    # Compute the image of the basis 1,a,...,a^(n - 1) under autos[i] and write
    # the coordinates in a matrix. This is the matrix of autos[i] with respect
    # to 1,a,...a^(n - 1).
    as = autos[i](a)
    if a == as
      continue
    end
    v[1] = o
    for j in 2:n
      o = o * as
      v[j] = o
    end

    bm = basis_matrix(v)
    # In the generic case just subtract the identity
    m = bm - identity_matrix(F, degree(K))
    push!(ar_mat, m)
  end

  if length(ar_mat) == 0
    return K, id_hom(K)
  else
    bigmatrix = reduce(hcat, ar_mat)
    Ker = kernel(bigmatrix, side = :left)
    bas = Vector{elem_type(K)}(undef, nrows(Ker))
    for i in 1:nrows(Ker)
      bas[i] = elem_from_mat_row(K, Ker, i)
    end
  end
  return subfield(K, bas, isbasis = true)
end


function fixed_field1(K::AbsSimpleNumField, auts::Vector{<:NumFieldHom{AbsSimpleNumField, AbsSimpleNumField}})

	auts_new = small_generating_set(auts)
  orderG = _order(auts)
  degree_subfield = divexact(degree(K), orderG)
  #TODO: Experiments to see if this is helpful
  #=
  if length(auts_new) == 1 && is_prime_power(degree_subfield)
    #In this case, one of the coefficients of the minpoly of gen(K)
    #over the subfield is a generator for the subfield.
    #if the given generator was not too large, also this element will be ok
		gens = auts
		if orderG != length(auts)
		  gens = closure(auts, orderG)
    end
    conjs = AbsSimpleNumFieldElem[image_primitive_element(x) for x in gens]
		prim_el = sum(conjs)
		def_pol = minpoly(prim_el)
    if degree(def_pol) != degree_subfield
			conjs1 = copy(conjs)
      while degree(def_pol) != degree_subfield
				for i = 1:length(conjs)
          conjs1[i] *= conjs[i]
				end
				prim_el = sum(conjs1)
       	def_pol = minpoly(prim_el)
			end
		end
    subK = number_field(def_pol, cached = false)[1]
    mp = hom(subK, K, prim_el, check = false)
    return subK, mp
	end
=#
  OK = maximal_order(K)
  # If degree(K) is large and the basis is not LLL reduced
  # the linear algebra will be very slow.
  # So lets compute an LLL basis once degree(K) is large.
  # 50 is a heuristic cutoff.
  if isdefined(OK, :lllO) || degree(K) >= 50
    OK = lll(OK)
  end
  M = zero_matrix(ZZ, degree(K), degree(K)*length(auts_new))
  v = Vector{AbsSimpleNumFieldElem}(undef, degree(K))
  MOK = basis_matrix(FakeFmpqMat, OK, copy = false)
  MOKinv = basis_mat_inv(FakeFmpqMat, OK, copy = false)
  for i = 1:length(auts_new)
		v[1] = one(K)
    v[2] = image_primitive_element(auts_new[i])
    for j = 3:degree(K)
      v[j] = v[j-1]*v[2]
		end
    B = basis_matrix(v, FakeFmpqMat)
    mul!(B, B, MOKinv)
    mul!(B, MOK, B)
    @assert isone(B.den)
    for i = 1:degree(K)
      B.num[i, i] -= 1
    end
		_copy_matrix_into_matrix(M, 1, (i-1)*degree(K)+1, B.num)
	end
	@vtime :Subfields 1 Ker = kernel(M, side = :left)
  @assert nrows(Ker) == degree_subfield
  @vtime :Subfields 1 Ker = lll(Ker)
	#The kernel is the maximal order of the subfield.
  bas = Vector{AbsSimpleNumFieldElem}(undef, degree_subfield)
	for i = 1:degree_subfield
    bas[i] = elem_from_mat_row(OK, Ker, i).elem_in_nf
	end
  return subfield(K, bas, isbasis = true)
end


################################################################################
#
#  Fixed field as relative extension
#
################################################################################

function fixed_field(K::AbsSimpleNumField, auts::Vector{<:NumFieldHom{AbsSimpleNumField, AbsSimpleNumField}}, ::Type{RelSimpleNumField{AbsSimpleNumFieldElem}}; simplify_subfield::Bool = true)
  F, mF = fixed_field(K, auts)
  if simplify_subfield
    F, mF1 = simplify(F, cached = false)
    mF = mF1*mF
  end
  all_auts = closure(auts, div(degree(K), degree(F)))
  Kx, x = polynomial_ring(K, "x", cached = false)
  p = prod(x-image_primitive_element(y) for y in all_auts)
  def_eq = map_coefficients(x -> has_preimage_with_preimage(mF, x)[2], p, cached = false)
  L, gL = number_field(def_eq, cached = false, check = false)
  iso = hom(K, L, gL, image_primitive_element(mF), gen(K))
  #I also set the automorphisms...
  autsL = Vector{NfRelToNfRelMor{AbsSimpleNumFieldElem, AbsSimpleNumFieldElem}}(undef, length(all_auts))
  for i = 1:length(autsL)
    autsL[i] = hom(L, L, iso(image_primitive_element(all_auts[i])))
  end
  set_automorphisms!(L, autsL)
  return L, iso
end
