@doc raw"""
    maximal_torus(A::AbstractAssociativeAlgebra) -> Algebra, Map

Given a $K$-algebra $A$, return a maximal $K$-torus, that is, a maximal
separable commutative $K$-subalgebra of $A$.
"""
function maximal_torus(A::AbstractAssociativeAlgebra)
  p = characteristic(base_ring(A))
  if !(0 < p < dim(A))
    throw(NotImplemented())
  end
  # in the matrix algebra case, do not use the regular matrix algebra
  # because it makes things unnnecessarily large
  if A isa MatAlgebra
    return _maximal_torus(A)
  end
  Amat, AmattoA = regular_matrix_algebra(A)
  S, StoAmat = _maximal_torus(Amat)
  return S, compose(StoAmat, AmattoA)
end

# The implementation follows
# "Finding splitting elements and maximal tori in matrix algebras",
# by de Graaf and Ivanyos, 1999.
#
# TODO:
# - Implement the the case where the base field is "large"
# - Implement the fast method

function _maximal_torus(A::MatAlgebra)
  Abasis = matrix.(basis(A))
  K = base_ring(A)
  n = _matdeg(A)
  p = characteristic(K)
  @assert 0 < p < n
  I = one(A)
  Tbasis = [I]
  Tbasismat = basis_matrix(Tbasis)
  S = basis(A)
  push!(S, zero(A))
  e = p^clog(n, Int(p))
  maximal = false
  k = 0
  while !maximal
    maximal = true
    for b in S
      for c in S
        dd = (b + c)^e
        fl = can_solve(Tbasismat, coefficients(dd); side = :left) 
        if !fl
          push!(Tbasis, dd)
          Tbasis = _subalgebra_basis(A, Tbasis)
          Tbasismat = basis_matrix(Tbasis)
          S = A.(_basis_of_centralizer(matrix.(Tbasis), Abasis))
          for s in S
            for t in Tbasis
              @assert s * t == t * s
            end
          end
          push!(S, zero(A))
          maximal = false
          break
        end
      end
      !maximal && break
    end
  end
  return _subalgebra(A, Tbasis)
end

# Compute the subalgebra generated by B (note that subalgebras have the same
# identitet as the overalgebra).
function _subalgebra_basis(A, B::Vector, iscom = true)
  @assert iscom
  push!(B, one(A))
  closed = false
  while !closed
    bmat = echelon_form(basis_matrix(B); trim = true)
    B = [elem_from_mat_row(A, bmat, i) for i in 1:nrows(bmat)]
    closed = true
    for b in B
      for c in B
        fl = can_solve(bmat, coefficients(b * c); side = :left)
        if !fl
          push!(B, b * c)
          closed = false
          break
        end
      end
      !closed && break
    end
  end
  return B
end

# determines a basis of C_A(B), the matrices in the span of A
# commuting with all matrices in the span of B
# 
# currently only works for matrices, but could be written more generically
# caveat: in the matrix algebra case, one should represent everything
# with respect to the overalgebra M_n(K)
function _basis_of_centralizer(B::Vector{T}, A::Vector{T}) where T <: MatElem
  K = base_ring(A[1])
  n = nrows(B[1])
  linind = LinearIndices((n, n))
  k = length(A)
  z = zero_matrix(K, k, length(B)*n*n)
  for (k, a) in enumerate(A)
    for (l, b) in enumerate(B)
      l0 = (l - 1)*n^2
      c = a * b - b * a
      for i in 1:n
        for j in 1:n
          z[k, l0 + linind[i, j]] = c[i, j]
        end
      end
    end
  end
  zK = kernel(z; side = :left)
  if K isa QQField
    zK = denominator(zK) * zK
  end

  cartind = CartesianIndices((n, n))

  res = T[]

  for i in 1:nrows(zK)
    push!(res, sum(zK[i, j] * A[j] for j in 1:length(A)))
  end

  for r in res
    for b in B
      @assert is_zero(r * b - b * r)
    end
  end

  return res
end
