export subalgebra, decompose, radical, is_central, is_simple, central_primitive_idempotents

_base_ring(A::AbsAlgAss) = base_ring(A)

################################################################################
#
#  Morphism types
#
################################################################################

morphism_type(::Type{T}, ::Type{S}) where {R, T <: AbsAlgAss{R}, S <: AbsAlgAss{R}} = AbsAlgAssMor{T, S, Generic.MatSpaceElem{R}}

morphism_type(::Type{T}, ::Type{S}) where {T <: AbsAlgAss{fmpq}, S <: AbsAlgAss{fmpq}} = AbsAlgAssMor{T, S, fmpq_mat}

morphism_type(::Type{T}, ::Type{S}) where {T <: AbsAlgAss{fq}, S <: AbsAlgAss{fq}} = AbsAlgAssMor{T, S, fq_mat}

morphism_type(::Type{T}, ::Type{S}) where {T <: AbsAlgAss{fq_nmod}, S <: AbsAlgAss{fq_nmod}} = AbsAlgAssMor{T, S, fq_nmod_mat}

morphism_type(::Type{T}, ::Type{S}) where {T <: AbsAlgAss{nmod}, S <: AbsAlgAss{nmod}} = AbsAlgAssMor{T, S, nmod_mat}

morphism_type(::Type{T}, ::Type{S}) where {T <: AbsAlgAss{gfp_elem}, S <: AbsAlgAss{gfp_elem}} = AbsAlgAssMor{T, S, gfp_mat}

morphism_type(::Type{T}, ::Type{S}) where {T <: AbsAlgAss{gfp_fmpz_elem}, S <: AbsAlgAss{gfp_fmpz_elem}} = AbsAlgAssMor{T, S, gfp_fmpz_mat}

morphism_type(A::Type{T}) where {T <: AbsAlgAss} = morphism_type(A, A)

################################################################################
#
#  Basis
#
################################################################################

@doc Markdown.doc"""
    basis(A::AbsAlgAss) -> Vector{AbsAlgAssElem}

Returns the basis of $A$.
"""
function basis(A::AbsAlgAss)
  if isdefined(A, :basis)
    return A.basis::Vector{elem_type(A)}
  end
  B = Vector{elem_type(A)}(undef, dim(A))
  for i in 1:dim(A)
    z = Vector{elem_type(base_ring(A))}(undef, dim(A))
    for j in 1:dim(A)
      z[j] = zero(base_ring(A))
    end
    z[i] = one(base_ring(A))
    B[i] = A(z)
  end
  A.basis = B
  return B::Vector{elem_type(A)}
end

################################################################################
#
#  Associativity, Distributivity test
#
################################################################################

function check_associativity(A::AbsAlgAss)
  for i = 1:dim(A)
    for j = 1:dim(A)
      el = A[i] * A[j]
      for k = 1:dim(A)
        if el * A[k] != A[i] * (A[j] * A[k])
          return false
        end
      end
    end
  end
  return true
end

function check_distributivity(A::AbsAlgAss)
  for i = 1:dim(A)
    for j = 1:dim(A)
      el = A[i]*A[j]
      for k = 1:dim(A)
        if A[i] * (A[j] + A[k]) != el + A[i] * A[k]
          return false
        end
      end
    end
  end
  return true
end

################################################################################
#
#  Dimension of/over center
#
################################################################################

@attr Int function dimension_of_center(A::AbsAlgAss)
  C, _ = center(A)
  return dim(C)
end

@attr Int function dimension_over_center(A::AbsAlgAss)
  return divexact(dim(A), dimension_of_center(A))
end

@attr Int function degree_as_central_simple_algebra(A::AbsAlgAss)
  return isqrt(dimension_over_center(A))
end

@attr Bool is_central(A::AbsAlgAss) = dimension_of_center(A) == 1

################################################################################
#
#  Subalgebras
#
################################################################################

# This is the generic fallback which constructs an associative algebra
@doc Markdown.doc"""
    subalgebra(A::AbsAlgAss, e::AbsAlgAssElem, idempotent::Bool = false,
               action::Symbol = :left)
      -> AlgAss, AbsAlgAssMor

Given an algebra $A$ and an element $e$, this function constructs the algebra
$e \cdot A$ (if `action == :left`) respectively $A \cdot e$ (if `action == :right`)
and a map from this algebra to $A$.
If `idempotent` is `true`, it is assumed that $e$ is idempotent in $A$.
"""
function subalgebra(A::AbsAlgAss{T}, e::AbsAlgAssElem{T}, idempotent::Bool = false, action::Symbol = :left) where {T}
  @assert parent(e) == A
  B, mB = AlgAss(A)
  C, mC = subalgebra(B, mB\e, idempotent, action)
  mD = compose_and_squash(mB, mC)
  @assert domain(mD) == C
  return C, mD
end

@doc Markdown.doc"""
    subalgebra(A::AbsAlgAss, basis::Vector{AbsAlgAssElem})
      -> AlgAss, AbsAlgAssMor

Returns the subalgebra $A$ generated by the elements in `basis` and a map
from this algebra to $A$.
"""
function subalgebra(A::AbsAlgAss{T}, basis::Vector{ <: AbsAlgAssElem{T} }) where T
  B, mB = AlgAss(A)
  basis_pre = elem_type(B)[mB\(basis[i]) for i in 1:length(basis)]
  C, mC = subalgebra(B, basis_pre)
  mD = compose_and_squash(mB, mC)
  @assert domain(mD) == C
  return C, mD
end

################################################################################
#
#  Decomposition
#
################################################################################

# Assume that A is a commutative algebra over a finite field of cardinality q.
# This functions computes a basis for ker(x -> x^q).
function kernel_of_frobenius(A::AbsAlgAss)
  F = base_ring(A)
  q = order(F)

  b = A()
  B = zero_matrix(F, dim(A), dim(A))
  for i = 1:dim(A)
    b.coeffs[i] = one(F)
    if i > 1
      b.coeffs[i - 1] = zero(F)
    end
    c = b^q - b
    for j = 1:dim(A)
      B[j, i] = c.coeffs[j]
    end
  end

  V = right_kernel_basis(B)
  return [ A(v) for v in V ]
end

@doc Markdown.doc"""
    decompose(A::AbsAlgAss) -> Array{Tuple{AlgAss, AbsAlgAssMor}}

Given a semisimple algebra $A$ over a field, this function returns a
decomposition of $A$ as a direct sum of simple algebras and maps from these
components to $A$.
"""
function decompose(A::AlgAss{T}) where {T}
  if isdefined(A, :decomposition)
    return A.decomposition::Vector{Tuple{AlgAss{T}, morphism_type(AlgAss{T}, typeof(A))}}
  end

  if is_simple_known(A) && A.is_simple == 1
    B, mB = AlgAss(A)
    return Tuple{AlgAss{T}, morphism_type(AlgAss{T}, typeof(A))}[(B, mB)]
  end

  res = _decompose(A)
  A.decomposition = res
  return res
end

# Generic function for everything besides AlgAss
function decompose(A::AbsAlgAss{T}) where T
  return __decompose(A)
end

function __decompose(A::AbsAlgAss{T}) where {T}
  if isdefined(A, :decomposition)
    return A.decomposition::Vector{Tuple{AlgAss{T}, morphism_type(AlgAss{T}, typeof(A))}}
  end

  B, mB = AlgAss(A)

  if is_simple_known(A) && A.is_simple == 1
    return Tuple{AlgAss{T}, morphism_type(AlgAss{T}, typeof(A))}[ (B, mB) ]
  end

  D = _decompose(B)::Vector{Tuple{AlgAss{T}, morphism_type(AlgAss{T}, AlgAss{T})}}
  res = Tuple{AlgAss{T}, morphism_type(AlgAss{T}, typeof(A))}[]
  for (S, mS) in D
    mD = compose_and_squash(mB, mS)
    push!(res, (S, mD))
  end
  A.decomposition = res
  Z, ZtoB = center(B)
  if dim(Z) != dim(B)
    if isdefined(A, :center)
      @assert A.center[1] === Z
    end
    A.center = (Z, compose_and_squash(mB, ZtoB))
  end
  return res
end

function _decompose(A::AbsAlgAss{T}) where {T}
  @assert _issemisimple(A) != 2 "Algebra is not semisimple"
  if is_commutative(A)
    return _dec_com(A)::Vector{Tuple{AlgAss{T}, morphism_type(AlgAss{T}, typeof(A))}}
  else
    return _dec_via_center(A)::Vector{Tuple{AlgAss{T}, morphism_type(AlgAss{T}, typeof(A))}}
  end
end

function _dec_via_center(A::S) where {T, S <: AbsAlgAss{T}}
  ZA, mZA = center(A)
  Algs = _dec_com(ZA)
  ZA.decomposition = Algs
  res = Tuple{AlgAss{T}, morphism_type(AlgAss{T}, S)}[ subalgebra(A, mZA(BtoZA(one(B))), true) for (B, BtoZA) in Algs]
  for i in 1:length(res)
    res[i][1].is_simple = 1
    B, BtoZA = Algs[i] # B is the centre of res[i][1]
    # Build a map from B to res[i][1] via B -> ZA -> A -> res[i][1]
    M = zero_matrix(base_ring(A), dim(B), dim(res[i][1]))
    for j = 1:dim(B)
      t = mZA(BtoZA(B[j]))
      s = res[i][2]\t
      elem_to_mat_row!(M, j, s)
    end
    if dim(res[i][1]) != dim(B)
      res[i][1].center = (B, hom(B, res[i][1], M))
    else
      # res[i][1] is commutative, so we do not cache the centre
      iM = inv(M)
      BtoA = hom(B, A, M*res[i][2].mat, res[i][2].imat*iM)
      res[i] = (B, BtoA)
    end
  end
  A.decomposition = res
  return res
end

function _dec_com(A::AbsAlgAss{T}) where {T}
  v = get_attribute(A, :central_idempotents)
  if v !== nothing
    w = v::Vector{elem_type(A)}
    return _dec_com_given_idempotents(A, w)
  end

  if characteristic(base_ring(A)) > 0
    return _dec_com_finite(A)::Vector{Tuple{AlgAss{T}, morphism_type(AlgAss{T}, typeof(A))}}
  else
    return _dec_com_gen(A)::Vector{Tuple{AlgAss{T}, morphism_type(AlgAss{T}, typeof(A))}}
  end
end

function _dec_com_given_idempotents(A::AbsAlgAss{T}, v::Vector) where {T}
  dec = Tuple{AlgAss{T}, morphism_type(AlgAss{T}, typeof(A))}[]
  for idem in v
    S, StoA = subalgebra(A, idem, true)
    push!(dec, (S, StoA))
  end
  return dec
end

function _dec_com_gen(A::AbsAlgAss{T}) where {T <: FieldElem}
  if dim(A) == 1
    A.is_simple = 1
    B, mB = AlgAss(A)
    return Tuple{AlgAss{T}, morphism_type(AlgAss{T}, typeof(A))}[(B, mB)]
  end

  F = base_ring(A)

  k = dim(A)

  V = elem_type(A)[A[i] for i in 1:k]

  while true
    c = elem_type(F)[ rand(F, -10:10) for i = 1:k ]
    a = dot(c, V)
    f = minpoly(a)

    if degree(f) < 2
      continue
    end
    if is_irreducible(f)
      if degree(f) == dim(A)
        A.is_simple = 1
        B, mB = AlgAss(A)
        return Tuple{AlgAss{T}, morphism_type(AlgAss{T}, typeof(A))}[(B, mB)]
      end
      continue
    end

    @assert is_squarefree(f)

    fac = factor(f)
    R = parent(f)
    factors = Vector{elem_type(R)}()
    for ff in keys(fac.fac)
      push!(factors, ff)
    end
    sols = Vector{elem_type(R)}()
    right_side = elem_type(R)[ R() for i = 1:length(factors) ]
    max_deg = 0
    for i = 1:length(factors)
      right_side[i] = R(1)
      if i != 1
        right_side[i - 1] = R(0)
      end
      s = crt(right_side, factors)
      push!(sols, s)
      max_deg = max(max_deg, degree(s))
    end
    x = one(A)
    powers = Vector{elem_type(A)}()
    for i = 1:max_deg + 1
      push!(powers, x)
      x *= a
    end
    idems = Vector{elem_type(A)}()
    for s in sols
      idem = A()
      for i = 0:degree(s)
        idem += coeff(s, i)*powers[i + 1]
      end
      push!(idems, idem)
    end

    A.is_simple = 2

    res = Vector{Tuple{AlgAss{T}, morphism_type(AlgAss{T}, typeof(A))}}()
    for idem in idems
      S, StoA = subalgebra(A, idem, true)
      decS = _dec_com_gen(S)::Vector{Tuple{AlgAss{T}, morphism_type(AlgAss{T}, typeof(S))}}
      for (B, BtoS) in decS
        BtoA = compose_and_squash(StoA, BtoS)
        push!(res, (B, BtoA))
      end
    end
    return res
  end
end

function _dec_com_finite(A::AbsAlgAss{T}) where T
  if dim(A) == 1
    A.is_simple = 1
    B, mB = AlgAss(A)
    return Tuple{AlgAss{T}, morphism_type(AlgAss{T}, typeof(A))}[(B, mB)]
  end

  F = base_ring(A)
  @assert !iszero(characteristic(F))
  V = kernel_of_frobenius(A)
  k = length(V)

  if k == 1
    A.is_simple = 1
    B, mB = AlgAss(A)
    return Tuple{AlgAss{T}, morphism_type(AlgAss{T}, typeof(A))}[(B, mB)]
  end

  A.is_simple = 2
  c = elem_type(F)[ rand(F) for i = 1:k ]
  M = zero_matrix(F, dim(A), dim(A))
  a = dot(c, V)
  representation_matrix!(a, M)
  f = minpoly(M)
  while degree(f) < 2
    for i = 1:length(c)
      c[i] = rand(F)
    end
    a = dot(c, V)
    zero!(M)
    representation_matrix!(a, M)
    f = minpoly(M)
  end

  #@assert is_squarefree(f)
  fac = factor(f)
  R = parent(f)
  factorss = collect(keys(fac.fac))
  sols = Vector{typeof(f)}(undef, length(factorss))
  right_side = typeof(f)[ zero(R) for i = 1:length(factorss) ]
  max_deg = 0
  for i = 1:length(factorss)
    right_side[i] = one(R)
    if 1 != i
      right_side[i - 1] = zero(R)
    end
    sols[i] = crt(right_side, factorss)
    max_deg = max(max_deg, degree(sols[i]))
  end
  powers = Vector{elem_type(A)}(undef, max_deg+1)
  powers[1] = one(A)
  powers[2] = a
  x = a
  for i = 3:max_deg + 1
    x *= a
    powers[i] = x
  end

  idems = Vector{elem_type(A)}()
  for s in sols
    idem = A()
    for i = 0:degree(s)
      idem += coeff(s, i)*powers[i + 1]
    end
    push!(idems, idem)
  end

  res = Vector{Tuple{AlgAss{T}, morphism_type(AlgAss{T}, typeof(A))}}()
  for idem in idems
    S, StoA = subalgebra(A, idem, true)
    decS = _dec_com_finite(S)
    for (B, BtoS) in decS
      BtoA = compose_and_squash(StoA, BtoS)
      push!(res, (B, BtoA))
    end
  end
  return res

end

################################################################################
#
#  Decomposition as number fields
#
################################################################################

@doc Markdown.doc"""
    components(::Type{Field}, A::AbsAlgAss)
      -> Vector{Tuple{Field, Morphism}}

Given an étale algebra $A$, return the simple components of $A$
as fields $K$ together with the projection $A \to K$.
"""
function components(::Type{Field}, A::AbsAlgAss)
  @assert iscommutative(A)
  return as_number_fields(A)
end

@doc Markdown.doc"""
    component(::Type{Field}, A::AbsAlgAss, i::Int)
      -> Vector{Tuple{Field, Morphism}}

Given an étale algebra $A$ and index $i$, return the $i$-th simple components
of $A$ as a field $K$ together with the projection $A \to K$.
"""
function component(::Type{Field}, A::AbsAlgAss, i::Int)
  nf = as_number_fields(A)
  return nf[i]
end

@doc Markdown.doc"""
    as_number_fields(A::AbsAlgAss{fmpq})
      -> Vector{Tuple{AnticNumberField, AbsAlgAssToNfAbsMor}}

Given a commutative algebra $A$ over $\mathbb Q$, this function returns a
decomposition of $A$ as direct sum of number fields and maps from $A$ to
these fields.
"""
function as_number_fields(A::AbsAlgAss{T}) where {T}
  return __as_number_fields(A)
end

function __as_number_fields(A::AbsAlgAss{T}; use_maximal_order::Bool = true) where {T}
  if isdefined(A, :maps_to_numberfields)
    NF = A.maps_to_numberfields::Vector{Tuple{_ext_type(T), _abs_alg_ass_to_nf_abs_mor_type(A)}}
    return NF
  end

  result = _as_number_fields(A, use_maximal_order = use_maximal_order)
  @assert all(domain(AtoK) === A for (_, AtoK) in result)
  A.maps_to_numberfields = result
  return result
end

_ext_type(::Type{fmpq}) = AnticNumberField

_ext_type(::Type{nf_elem}) = NfRel{nf_elem}

function _as_number_fields(A::AbsAlgAss{T}; use_maximal_order::Bool = true) where {T}
  d = dim(A)

  Adec = decompose(A)

  fields_not_cached = false
  for i = 1:length(Adec)
    if !isdefined(Adec[i][1], :maps_to_numberfields)
      fields_not_cached = true
    end
  end

  if fields_not_cached && T === fmpq && use_maximal_order
    # Compute a LLL reduced basis of the maximal order of A to find "small"
    # polynomials for the number fields.
    OA = maximal_order(A)
    L = lll(basis_matrix(OA, copy = false).num)
    n = basis_matrix(OA, copy = false).den
    basis_lll = elem_type(A)[ elem_from_mat_row(A, L, i, n) for i = 1:d ]
  elseif fields_not_cached
    basis_lll = basis(A)
  end

  KK = base_ring(A)

  M = zero_matrix(KK, 0, d)
  matrices = Vector{dense_matrix_type(T)}()
  fields = Vector{_ext_type(T)}()
  for i = 1:length(Adec)
    # For each small algebra construct a number field and the isomorphism
    B, BtoA = Adec[i]
    dB = dim(B)
    if !isdefined(B, :maps_to_numberfields)
      local K, BtoK
      found_field = false # Only for debugging
      for j = 1:d
        t = BtoA\basis_lll[j]
        mint = minpoly(t)
        if degree(mint) == dB
          found_field = true
          K, BtoK = _as_field_with_isomorphism(B, t, mint)
          B.maps_to_numberfields = Tuple{_ext_type(T), _abs_alg_ass_to_nf_abs_mor_type(B)}[(K, BtoK)]
          push!(fields, K)
          break
        end
      end
      @assert found_field "This should not happen..."
    else
      K, BtoK = B.maps_to_numberfields[1]::Tuple{_ext_type(T), _abs_alg_ass_to_nf_abs_mor_type(B)}
      push!(fields, K)
    end

    # TODO: We can do a short cut, but the map must be BtoK \circ inv(BtoA)
    #if length(Adec) == 1
    #  res = Tuple{_ext_type(T), _abs_alg_ass_to_nf_abs_mor_type(A)}[(K, BtoK)]
    #  A.maps_to_numberfields = res
    #  return res
    #end

    # Construct the map from K to A
    N = zero_matrix(KK, degree(K), d)
    for j = 1:degree(K)
      t = BtoA(BtoK\basis(K)[j])
      elem_to_mat_row!(N, j, t)
    end
    push!(matrices, N)
    M = vcat(M, N)
  end
  @assert nrows(M) == d

  invM = inv(M)
  matrices2 = Vector{dense_matrix_type(T)}(undef, length(matrices))
  offset = 1
  for i = 1:length(matrices)
    r = nrows(matrices[i])
    N = sub(invM, 1:d, offset:(offset + r - 1))
    matrices2[i] = N
    offset += r
  end

  result = Vector{Tuple{_ext_type(T), _abs_alg_ass_to_nf_abs_mor_type(A)}}()
  for i = 1:length(fields)
    push!(result, (fields[i], AbsAlgAssToNfAbsMor(A, fields[i], matrices2[i], matrices[i])))
  end

  return result
end

################################################################################
#
#  Random elements
#
################################################################################

Random.gentype(::Type{T}) where {T<:AbsAlgAss} = elem_type(T)

function rand(rng::AbstractRNG, Asp::Random.SamplerTrivial{<:AbsAlgAss{T}}) where T
  A = Asp[]
  c = rand(rng, base_ring(A), dim(A))
  return A(c)
end

function rand(A::AbsAlgAss{nf_elem}, rng::UnitRange{Int} = -10:10)
  c = nf_elem[rand(base_ring(A), rng) for i = 1:dim(A)]
  return A(c)
end

function rand(A::AbsAlgAss{T}, rng::UnitRange{Int}) where T
  c = T[rand(base_ring(A), rng) for i = 1:dim(A)]
  return A(c)
end

function rand(A::AlgAss{fmpq}, rng::UnitRange{Int} = -20:20)
  c = [fmpq(rand(FlintZZ, rng)) for i = 1:dim(A)]
  return A(c)
end

################################################################################
#
#  Generators
#
################################################################################

# Reduces the vector v w. r. t. M and writes it in the i-th row of M.
# M should look like this:
#     (0 1 * 0 *)
#     (1 0 * 0 *)
# M = (0 0 0 1 *)
#     (0 0 0 0 0)
#     (0 0 0 0 0),
# i. e. "almost" in rref, but the rows do not have to be sorted.
# For a column c of M pivot_rows[c] should be the row with the pivot or 0.
# The function changes M, v and pivot_rows in place!
function _add_row_to_rref!(M::MatElem{T}, v::Vector{T}, pivot_rows::Vector{Int}, i::Int) where { T <: FieldElem }
  @assert ncols(M) == length(v)
  @assert ncols(M) == length(pivot_rows)
  @assert 1 <= i && i <= nrows(M)

  pivot_found = false
  pivot_col = 0
  s = one(base_ring(M))
  for c = 1:ncols(M)
    if iszero(v[c])
      continue
    end
    if pivot_rows[c] == 0
      # We found an entry in a column of v, where no other row of M has the pivot.
      if pivot_found
        # We already found a pivot
        continue
      end

      pivot_found = true
      pivot_col = c
      pivot_rows[c] = i
      continue
    end

    r = pivot_rows[c]
    # Reduce the entries of v by the row r of M
    t = -v[c] # we assume M[r, c] == 1 (it is the pivot)
    for j = c + 1:ncols(M)
      Mrj = M[r, j]
      if iszero(Mrj)
        continue
      end

      s = mul!(s, t, Mrj)
      v[j] = addeq!(v[j], s)
    end
    v[c] = zero!(v[c])
  end
  if !pivot_found
    return false
  end

  # Make the pivot 1
  t = inv(v[pivot_col])
  for j = pivot_col + 1:ncols(M)
    if iszero(v[j])
      continue
    end

    v[j] = mul!(v[j], v[j], t)
  end
  v[pivot_col] = one(base_ring(M))

  # Reduce the rows above the newly inserted one
  for r = 1:i - 1
    Mrp = M[r, pivot_col]
    if iszero(Mrp)
      continue
    end

    t = -Mrp
    for c = pivot_col + 1:ncols(M)
      s = mul!(s, t, v[c])
      M[r, c] = addeq!(M[r, c], s)
    end
    M[r, pivot_col] = zero(base_ring(M))
  end

  for c = 1:ncols(M)
    M[i, c] = deepcopy(v[c])
  end

  return true
end

@doc Markdown.doc"""
    gens(A::AbsAlgAss, return_full_basis::Typel{Val{T}} = Val{false};
         thorough_search::Bool = false) where T
      -> Vector{AbsAlgAssElem}

Returns a subset of `basis(A)`, which generates $A$ as an algebra over
`base_ring(A)`.
If `return_full_basis` is set to `Val{true}`, the function also returns a
`Vector{AbsAlgAssElem}` containing a full basis consisting of monomials in
the generators and a `Vector{Vector{Tuple{Int, Int}}}` containing the
information on how these monomials are built. E. g.: If the function returns
`g`, `full_basis` and `v`, then we have
`full_basis[i] = prod( g[j]^k for (j, k) in v[i] )`.
If `thorough_search` is `true`, the number of returned generators is possibly
smaller. This will in general increase the runtime. It is not guaranteed that
the number of generators is minimal in any case.
"""
function gens(A::AbsAlgAss, return_full_basis::Type{Val{T}} = Val{false}; thorough_search::Bool = false) where T
  d = dim(A)
  if return_full_basis === Val{false}
    if isdefined(A, :gens)
      return A.gens::Vector{elem_type(A)}
    end
  end

  if thorough_search
    # Sort the basis by the degree of the minpolys (hopefully those with higher
    # degree generate a "bigger" subalgebra)
    minpoly_degrees = [ (i, degree(minpoly(A[i]))) for i = 1:d ]
    sort!(minpoly_degrees, by = x -> x[2], rev = true)
  else
    is_gen = falses(d)
  end

  generators = Vector{elem_type(A)}()
  full_basis = elem_type(A)[ one(A) ] # Contains products of generators which form a full basis
  elts_in_gens = Vector{Tuple{Int, Int}}[ Tuple{Int, Int}[] ]
  B = zero_matrix(base_ring(A), d, d)
  pivot_rows = zeros(Int, d)
  new_elements = Set{Int}()

  s = one(A)
  t = one(A)

  cur_dim = 0
  cur_basis_elt = 1
  while cur_dim != d
    if isempty(new_elements)
      # We have to add a generator
      new_gen = A()
      new_elt = false
      while true
        if thorough_search
          i = minpoly_degrees[cur_basis_elt][1]
        else
          i = rand(1:dim(A))
          while is_gen[i]
            i = rand(1:dim(A))
          end
          is_gen[i] = true
        end
        new_gen = A[i]
        cur_basis_elt += 1
        new_elt = _add_row_to_rref!(B, coefficients(new_gen), pivot_rows, cur_dim + 1)
        if new_elt
          break
        end
      end
      push!(generators, new_gen)
      b = new_gen
      power = 1
      # Compute the powers of new_gen
      while new_elt
        cur_dim += 1
        push!(full_basis, b)
        if power == 1 && length(generators) != 1
          push!(new_elements, length(full_basis))
        end
        ind = Tuple{Int, Int}[ (length(generators), power) ]
        push!(elts_in_gens, ind)
        cur_dim == d ? break : nothing
        b *= new_gen
        power += 1
        new_elt = _add_row_to_rref!(B, coefficients(b), pivot_rows, cur_dim + 1)
      end
      continue
    else
      i = pop!(new_elements)
      b = full_basis[i]
    end

    # Compute all possible products involving b
    n = length(full_basis)
    for r = 1:n
      s = mul!(s, b, full_basis[r])
      for l = 1:n
        if !is_commutative(A)
          t = mul!(t, full_basis[l], s)
        else
          t = s
        end
        new_elt = _add_row_to_rref!(B, coefficients(t), pivot_rows, cur_dim + 1)
        if !new_elt
          continue
        end
        push!(full_basis, deepcopy(t))
        cur_dim += 1
        coord = _merge_elts_in_gens!(elts_in_gens[l], deepcopy(elts_in_gens[i]), elts_in_gens[r])
        push!(elts_in_gens, coord)
        if thorough_search && coord[1][2] == 1 && coord[end][2] == 1
          push!(new_elements, length(full_basis))
        end
        if is_commutative(A)
          break
        end
        cur_dim == d ? break : nothing
      end
      cur_dim == d ? break : nothing
    end
  end

  # Remove the one
  popfirst!(full_basis)
  popfirst!(elts_in_gens)

  if !isdefined(A, :gens)
    A.gens = generators
  end

  if return_full_basis == Val{true}
    return generators, full_basis, elts_in_gens
  else
    return generators
  end
end

################################################################################
#
#  Primitive elements
#
################################################################################

function primitive_element(A::AbsAlgAss)
  a, _ = _primitive_element(A)
  return a
end

function primitive_element(A::AbsAlgAss{fmpq})
  if isdefined(A, :maps_to_numberfields)
    return primitive_element_via_number_fields(A)
  end
  a, _ = _primitive_element(A)
  return a
end

# TODO: Fix this with the types once a new version is released
#function _primitive_element(A::AbsAlgAss)
#  error("Not implemented yet")
#  return nothing
#end

# If T == fmpq, we try to find a small primitive element by
# going "via number fields". There a procedure using LLL
# is implemented to find primitive elements with small minimal
# polynomial. Note that this could be improved by calling into
# simplify for number fields. But it is a bit tricky.
function _primitive_element(A::AbsAlgAss{fmpq})
  a = primitive_element_via_number_fields(A)
  return a, minpoly(a)
end

function __primitive_element(A::S) where {T <: FinFieldElem, S <: AbsAlgAss{T}} #<: Union{nmod, fq, fq_nmod, Generic.Res{fmpz}, fmpq, Generic.ResF{fmpz}, gfp_elem}
  d = dim(A)
  a = rand(A)
  f = minpoly(a)
  while degree(f) < d
    a = rand(A)
    f = minpoly(a)
  end
  return a, f
end

function primitive_element_via_number_fields(A::AbsAlgAss{fmpq})
  fields_and_maps = as_number_fields(A)
  a = A()
  for (K, AtoK) in fields_and_maps
    a += AtoK\gen(K)
  end
  return a
end

function _as_field(A::AbsAlgAss{T}) where T
  d = dim(A)
  a, mina = __primitive_element(A)
  b = one(A)
  M = zero_matrix(base_ring(A), d, d)
  elem_to_mat_row!(M, 1, b)
  for i in 1:(d - 1)
    b = mul!(b, b, a)
    elem_to_mat_row!(M, i + 1, b)
  end
  B = inv(M)
  N = zero_matrix(base_ring(A), 1, d)
  local f
  let N = N, B = B
    f = function(x)
      for i in 1:d
        N[1, i] = x.coeffs[i]
      end
      return N * B
    end
  end
  return a, mina, f
end

function _as_field_with_isomorphism(A::AbsAlgAss{fmpq}) #<: Union{fmpq, gfp_elem, Generic.ResF{fmpz}, fq_nmod, fq} }
  return _as_field_with_isomorphism(A, _primitive_element(A)...)
end

function _as_field_with_isomorphism(A::AbsAlgAss{S}) where { S } #<: Union{fmpq, gfp_elem, Generic.ResF{fmpz}, fq_nmod, fq} }
  return _as_field_with_isomorphism(A, __primitive_element(A)...)
end

# Assuming a is a primitive element of A and mina its minimal polynomial, this
# functions constructs the field base_ring(A)/mina and the isomorphism between
# A and this field.
function _as_field_with_isomorphism(A::AbsAlgAss{S}, a::AbsAlgAssElem{S}, mina::T) where {S, T} # where { S <: Union{fmpq, gfp_elem, Generic.ResF{fmpz}, fq_nmod, fq}, T <: Union{fmpq_poly, gfp_poly, gfp_fmpz_poly, fq_nmod_poly, fq_poly} }
  s = one(A)
  M = zero_matrix(base_ring(A), dim(A), dim(A))
  elem_to_mat_row!(M, 1, s)
  for i = 2:dim(A)
    s = mul!(s, s, a)
    elem_to_mat_row!(M, i, s)
  end

  return __as_field_with_isomorphism(A, mina, M)
end

function __as_field_with_isomorphism(A::AbsAlgAss{S}, f, M) where {S <: Union{fmpq, nf_elem}}
  K = number_field(f, cached = false)[1]
  return K, AbsAlgAssToNfAbsMor(A, K, inv(M), M)
end

function __as_field_with_isomorphism(A::AbsAlgAss{gfp_elem}, f::gfp_poly, M::gfp_mat)
  Fq = FqNmodFiniteField(f, Symbol("a"), false)
  return Fq, AbsAlgAssToFqMor(A, Fq, inv(M), M, parent(f))
end

function __as_field_with_isomorphism(A, f::gfp_fmpz_poly, M)
#function __as_field_with_isomorphism(A::AbsAlgAss{Generic.ResF{fmpz}}, f::gfp_fmpz_poly, M::Generic.MatSpaceElem{Generic.ResF{fmpz}})
  Fq = FqFiniteField(f, Symbol("a"), false)
  return Fq, AbsAlgAssToFqMor(A, Fq, inv(M), M, parent(f))
end

function __as_field_with_isomorphism(A::AbsAlgAss{S}, f::T, M::U) where { S <: Union{ fq_nmod, fq }, T <: Union{ fq_nmod_poly, fq_poly }, U <: Union{ fq_nmod_mat, fq_mat } }
  Fr, RtoFr = field_extension(f)
  return Fr, AbsAlgAssToFqMor(A, Fr, inv(M), M, parent(f), RtoFr)
end

################################################################################
#
#  Regular matrix algebra
#
################################################################################

@doc Markdown.doc"""
    regular_matrix_algebra(A::Union{ AlgAss, AlgGrp }) -> AlgMat, AbsAlgAssMor

Returns the matrix algebra $B$ generated by the right representation matrices
of the basis elements of $A$ and a map from $B$ to $A$.
"""
function regular_matrix_algebra(A::Union{ AlgAss, AlgGrp })
  K = base_ring(A)
  B = matrix_algebra(K, [ representation_matrix(A[i], :right) for i = 1:dim(A) ], isbasis = true)
  return B, hom(B, A, identity_matrix(K, dim(A)), identity_matrix(K, dim(A)))
end

###############################################################################
#
#  Construction of a crossed product algebra
#
###############################################################################

function find_elem(G::Vector{T}, el::T) where T
  i=1
  while true
    if image_primitive_element(el) == image_primitive_element(G[i])
      return i
    end
    i+=1
  end
end


#K/Q is a Galois extension.
function CrossedProductAlgebra(K::AnticNumberField, G::Vector{T}, cocval::Matrix{nf_elem}) where T

  n=degree(K)
  m=length(G)
  #=
  Multiplication table
  I order the basis in this way:
  First, I put the basis of the Galois Group, then the product of them with the first
  element of basis of the order and so on...
  =#

  M=Array{fmpq,3}(undef, n*m, n*m, n*m)
  for i=1:n*m
    for j=1:n*m
      for s=1:n*m
        M[i,j,s]=fmpq(0)
      end
    end
  end
  B=basis(K)
  for i=1:n
    for j=1:m
      #I have the element B[i]*G[j]
      for k=1:n
        for h=1:m
          # I take the element B[k]*G[h]
          # and I take the product
          # B[i]*G[j]* B[k]*G[h]=B[i]*G[j](B[k])*c[j,h]*(G[j]*G[h])
          ind=find_elem(G,G[h] * G[j])
          x=B[i]*G[j](B[k])*cocval[j,h]
          #@show i, j, k,h,  ind,B[i],G[j](B[k]),cocval[j,h],  x
          for s=0:n-1
            M[j+(i-1)*n, h+(k-1)*n, ind+s*n]=coeff(x,s)
          end
          #@show M
        end
      end
    end
  end
  return AlgAss(FlintQQ, M)

end

function CrossedProductAlgebra(O::NfOrd, G::Vector{T}, cocval::Matrix{nf_elem}) where T

  n=degree(O)
  m=length(G)
  K=nf(O)
  #=
  Multiplication table
  I order the basis in this way:
  First, I put the basis of the Galois Group, then the product of them with the first
  element of basis of the order and so on...
  =#

  M=Array{fmpq,3}(undef, n*m, n*m, n*m)
  for i=1:n*m
    for j=1:n*m
      for s=1:n*m
        M[i,j,s]=fmpq(0)
      end
    end
  end
  B = basis(O, copy = false)
  el = O(0)
  for j=1:m
    for k=1:n
      l =O(G[j](K(B[k])), false)
      for h=1:m
        ind = find_elem(G, G[h] * G[j])
        t = O(cocval[j,h], false)
        for i=1:n
          #I have the element B[i]*G[j]
          # I take the element B[k]*G[h]
          # and I take the product
          # B[i]*G[j]* B[k]*G[h]=B[i]*G[j](B[k])*c[j,h]*(G[j]*G[h])
          mul!(el, B[i], l)
          mul!(el, el, t)
          y = coordinates(el)
          for s=0:n-1
            M[j+(i-1)*m, h+(k-1)*m, ind+s*m] = y[s+1]
          end
        end
      end
    end
  end
  j1 = find_identity(G, *)
  j = find_elem(G, j1)
  O1 = fmpq[0 for i=1:n*m]
  O1[j] = fmpq(1)
  A = AlgAss(FlintQQ, M, O1)
  A.is_simple = 1
  return A

end

###############################################################################
#
#  Trace Matrix
#
###############################################################################

function _assure_trace_basis(A::AbsAlgAss{T}) where T
  if isdefined(A, :trace_basis_elem)
    return nothing
  end

  mt = multiplication_table(A, copy = false)
  A.trace_basis_elem = Vector{T}(undef, dim(A))
  for i = 1:dim(A)
    A.trace_basis_elem[i] = sum(mt[i, j, j] for j = 1:dim(A))
  end
  return nothing
end

@doc Markdown.doc"""
    trace_matrix(A::AbsAlgAss) -> MatElem

Returns a matrix $M$ over the base ring of $A$ such that
$M_{i, j} = \mathrm{tr}(b_i \cdot b_j)$, where $b_1, \dots, b_n$ is the
basis of $A$.
"""
function trace_matrix(A::AbsAlgAss)
  F = base_ring(A)
  n = dim(A)
  M = zero_matrix(F, n, n)
  for i = 1:n
    M[i, i] = tr(A[i]^2)
  end
  for i = 1:n
    for j = i + 1:n
      x = tr(A[i]*A[j])
      M[i, j] = x
      M[j, i] = x
    end
  end
  return M
end

################################################################################
#
#  Change of ring
#
################################################################################

# This is the generic fallback which constructs an associative algebra
@doc Markdown.doc"""
    restrict_scalars(A::AbsAlgAss{nf_elem}, Q::FlintRationalField)
    restrict_scalars(A::AbsAlgAss{fq_nmod}, Fp::GaloisField)
    restrict_scalars(A::AbsAlgAss{fq}, Fp::Generic.ResField{fmpz})
      -> AlgAss, Function, Function

Given an algebra $A$ over a field $L$ and the prime field $K$ of $L$, this
function returns the restriction $B$ of $A$ to $K$ and maps from $A$ to $B$
and from $B$ to $A$.
"""
function restrict_scalars(A::AbsAlgAss{T}, K::Field) where {T}
  #K == base_ring(A) && throw(error("Not yet implemented"))
  B, BtoA = AlgAss(A)::Tuple{AlgAss{T}, morphism_type(AlgAss{T}, typeof(A))}
  C, BtoC, CtoB = restrict_scalars(B, K)

  function CtoA(x::AbsAlgAssElem)
    @assert parent(x) === C
    return BtoA(CtoB(x))
  end

  function AtoC(x::AbsAlgAssElem)
    @assert parent(x) === A
    return BtoC(BtoA\x)
  end

  return C, AtoC, CtoA
end

################################################################################
#
#  Radical
#
################################################################################

@doc Markdown.doc"""
     radical(A::AbsAlgAss) -> AbsAlgAssIdl

Returns the Jacobson-Radical of $A$.
"""
function radical(A::AbsAlgAss{T}) where { T } #<: Union{ gfp_elem, Generic.ResF{fmpz}, fq_nmod, fq, fmpq, nf_elem } }
  return ideal_from_gens(A, _radical(A), :twosided)
end

# Section 2.3.2 in W. Eberly: Computations for Algebras and Group Representations
# TODO: Fix the type
function _radical(A::AbsAlgAss{T}) where { T } #<: Union{ gfp_elem, Generic.ResF{fmpz} } }
  F = base_ring(A)
  p = characteristic(F)
  k = flog(fmpz(dim(A)), p)

  MF = trace_matrix(A)
  d, B = nullspace(MF)
  if d == 0
    return elem_type(A)[]
  end

  C = transpose(B)
  # Now, iterate: we need to find the kernel of tr((xy)^(p^i))/p^i mod p
  # on the subspace generated by C
  # Hard to believe, but this is linear!!!!
  MZ = zero_matrix(FlintZZ, dim(A), dim(A))
  pl = fmpz(1)
  a = A()
  for l = 1:k
    pl = p*pl
    M = zero_matrix(F, dim(A), nrows(C))
    for i = 1:nrows(C)
      c = elem_from_mat_row(A, C, i)
      for j = 1:dim(A)
        a = mul!(a, c, A[j])
        MF = representation_matrix(a)
        for m = 1:nrows(MF)
          for n = 1:ncols(MF)
            MZ[m, n] = lift(MF[m, n])
          end
        end
        t = tr(MZ^Int(pl))
        @assert iszero(mod(t, pl))
        M[j, i] = F(divexact(t, pl))
      end
    end
    d, B = nullspace(M)
    if d == 0
      return elem_type(A)[]
    end
    C = transpose(B)*C
  end

  return elem_type(A)[ elem_from_mat_row(A, C, i) for i = 1:nrows(C) ]
end

function _radical(A::AbsAlgAss{T}) where { T <: Union{ fq_nmod, fq } }
  F = base_ring(A)

  p = characteristic(F)
  if T <: fq_nmod
    Fp = GF(Int(p))
  else
    Fp = GF(p)
  end
  A2, A2toA = restrict_scalars(A, Fp)
  n = degree(F)

  if n == 1
    J = _radical(A2)
    return elem_type(A)[ A2toA(b) for b in J ]
  end

  k = flog(fmpz(dim(A)), p)
  Qx, x = PolynomialRing(FlintQQ, "x", cached = false)
  f = Qx(push!(fmpq[ -fmpq(coeff(gen(F)^n, i)) for i = 0:(n - 1) ], fmpq(1)))
  K, a = number_field(f, "a")

  MF = trace_matrix(A2)
  d, B = nullspace(MF)
  if d == 0
    return elem_type(A)[]
  end

  C = transpose(B)
  pl = fmpz(1)
  MK = zero_matrix(K, dim(A), dim(A))
  MQx = zero_matrix(Qx, dim(A), dim(A))
  a = A()
  for l = 1:k
    pl = p*pl
    M = zero_matrix(Fp, dim(A2), nrows(C))
    for i = 1:nrows(C)
      c = A2toA(elem_from_mat_row(A2, C, i))
      for j = 1:dim(A)
        a = mul!(a, c, A[j])
        MF = representation_matrix(a)
        MK = _lift_fq_mat!(MF, MK, MQx)
        t = tr(MK^Int(pl))
        @assert all([ iszero(mod(coeff(t, s), pl)) for s = 0:(n - 1) ])
        jn = (j - 1)*n
        for s = 1:n
          M[jn + s, i] = Fp(divexact(numerator(coeff(t, s - 1)), pl))
        end
      end
    end
    d, B = nullspace(M)
    if d == 0
      return elem_type(A)[]
    end
    C = transpose(B)*C
  end

  return elem_type(A)[ A2toA(elem_from_mat_row(A2, C, i)) for i = 1:nrows(C) ]
end

function _lift_fq_mat!(M1::MatElem{T}, M2::MatElem{nf_elem}, M3::MatElem{fmpq_poly}) where { T <: Union{ fq_nmod, fq } }
  @assert ncols(M1) == ncols(M2) && ncols(M1) == ncols(M3)
  @assert nrows(M1) == nrows(M2) && nrows(M1) == nrows(M3)
  n = degree(base_ring(M1))
  K = base_ring(M2)
  R = base_ring(M3)
  for i = 1:nrows(M1)
    for j = 1:ncols(M1)
      # Sadly, there is no setcoeff! for nf_elem...
      for k = 0:(n - 1)
        M3[i, j] = setcoeff!(M3[i, j], k, fmpq(coeff(M1[i, j], k)))
      end
      ccall((:nf_elem_set_fmpq_poly, libantic), Nothing, (Ref{nf_elem}, Ref{fmpq_poly}, Ref{AnticNumberField}), M2[i, j], M3[i, j], K)
    end
  end
  return M2
end

function _radical(A::AbsAlgAss{T}) where { T <: Union{ fmpq, NumFieldElem } }
  M = trace_matrix(A)
  n, N = nullspace(M)
  b = Vector{elem_type(A)}(undef, n)
  t = zeros(base_ring(A), dim(A))
  # the construct A(t) will make a copy (hopefully :))
  for i = 1:n
    for j = 1:dim(A)
      t[j] = N[j, i]
    end
    b[i] = A(t)
  end
  return b
end

################################################################################
#
#  is_simple
#
################################################################################

# TODO: Fix this once we have a new Nemo version

# TODO: Make sure this always returns 1 or 2. So far we only have _radical for
# algebras over Fp, Fq, QQ, and number fields
#function _issemisimple(A::AbsAlgAss)
#  return A.issemisimple
#end

function _issemisimple(A::AbsAlgAss{T}) where { T } #<: Union{ gfp_elem, Generic.ResF{fmpz}, fq, fq_nmod, fmpq, nf_elem } }
  if A.issemisimple == 0
    if isempty(_radical(A))
      A.issemisimple = 1
    else
      A.issemisimple = 2
    end
  end

  return A.issemisimple
end

is_simple_known(A::AbsAlgAss) = A.is_simple != 0

function is_simple(A::AbsAlgAss)
  if A.is_simple != 0
    return A.is_simple == 1
  end

  if _issemisimple(A) == 2
    A.is_simple = 2
    return false
  end
  # Still can't be certain that A is semisimple, since _issemisimple does not
  # always work...

  Adec = decompose(A)
  if length(Adec) == 1
    A.is_simple = 1
    return true
  end
  A.is_simple = 2
  return false
end

################################################################################
#
#  Trace signature
#
################################################################################

function trace_signature(A::AbsAlgAss{nf_elem}, P::InfPlc)
  M = trred_matrix(basis(A))
  Ky, y = PolynomialRing(base_ring(A), "y", cached = false)
  f = charpoly(Ky, M)
  npos = n_positive_roots(f, P; multiplicities = true)
  return (npos, degree(f) - npos)
end

function trace_signature(A::AbsAlgAss{fmpq})
  O = get_attribute(A, :any_order)
  if O === nothing
    M = trred_matrix(basis(A))
  else
    _M = trred_matrix(O::order_type(A))
    M = change_base_ring(QQ, _M)
  end

  Ky, y = PolynomialRing(base_ring(A), "y", cached = false)
  f = charpoly(Ky, M)
  npos = n_positive_roots(f, multiplicities = true)
  return npos, degree(f) - npos
end

################################################################################
#
#  Transport of Wedderburn decompositions
#
################################################################################

# Given epiomorphism h : A -> B, transport the refined wedderburn decomposition
# of A to B
function _transport_refined_wedderburn_decomposition_forward(h::AbsAlgAssMor)
  A = domain(h)
  B = codomain(h)

  if get_attribute(B, :refined_wedderburn, false)
    return true
  end

  _assert_has_refined_wedderburn_decomposition(A)
  dec = decompose(A)
  T = AlgAss{elem_type(base_ring(B))}
  new_dec = Tuple{T, morphism_type(T, typeof(B))}[]
  k = 0
  # We have to be very careful not to change the decomposition of B if it
  # already has one
  if !isdefined(B, :decomposition)
    _ = decompose(B)
  end
  #for (C, CtoA) in dec
  #  e = h(CtoA(one(C)))
  #  if !iszero(e)
  #    CtoB = compose_and_squash(h, CtoA)
  #    push!(new_dec, (C, CtoB))
  #    k += dim(C)
  #  end
  #end
  #@assert dim(B) == k
  #B.decomposition = new_dec

  for (Bc, BctoB) in B.decomposition
    for (C, CtoA) in dec
      e = BctoB\(h(CtoA(one(C))))
      if !iszero(e)
        M = basis_matrix([BctoB\(h(CtoA(b))) for b in basis(C)])
        CtoBc = hom(C, Bc, M, inv(M))
        if isdefined(C, :isomorphic_full_matrix_algebra)
          CM, CtoCM = C.isomorphic_full_matrix_algebra
          f = AbsAlgAssMorGen(Bc, CM, inv(CtoBc).mat * CtoCM.M, CtoCM.Minv * CtoBc.mat)
          Bc.isomorphic_full_matrix_algebra = CM, f
        end
      end
    end
  end
  set_attribute!(B, :refined_wedderburn, true)
  return true
end

################################################################################
#
#  Projection onto component
#
################################################################################

@doc Markdown.doc"""
    product_of_components_with_projection(A::AbsAlgAss, a::Vector{Int})
                                                               -> AbsAlgAss, Map

Return the direct product of the simple components of $A$ specified by `a`
together with the canonical projection, where the ordering is with respect to
the ordering returned by `decompose(A)`.
"""
function product_of_components_with_projection(A::AbsAlgAss, a::Vector{Int})
  dec = decompose(A)
  l = length(dec)
  @req all(i -> 1 <= i <= l, a) "Indicies ($a) must satisfy >= 1 and <= $l"
  algs = [dec[i][1] for i in a]
  injs = [dec[i][2] for i in a]
  r = length(a)
  B, injstoB = direct_product(algs)
  imgs = elem_type(B)[]
  for b in basis(A)
    push!(imgs, sum(injstoB[i](injs[i]\b) for i in 1:r))
  end
  p = hom(A, B, basis_matrix(imgs))
  _transport_refined_wedderburn_decomposition_forward(p)
  return B, p
end
#function product_of_components(A::AbsAlgAss)

@doc Markdown.doc"""
    product_of_components_with_projection(A::AbsAlgAss, a::Vector{Int})
                                                                   -> AbsAlgAss

Return the direct product of the simple components of $A$ specified by `a`, where
the ordering is with respect to the ordering returned by `decompose(A)`.
"""
function product_of_components(A::AbsAlgAss, a::Vector{Int})
  B, = product_of_components(A, a)
  return B
end

@doc Markdown.doc"""
    maximal_eichler_quotient_with_projection(A::AbsAlgAss) -> AbsAlgAss, Map
"""
function maximal_eichler_quotient_with_projection(A::AbsAlgAss)
  v = Int[]
  dec = decompose(A)
  for i in 1:length(dec)
    B, = Hecke._as_algebra_over_center(dec[i][1])
    if !is_eichler(B)
      push!(v, i)
    end
  end
  return product_of_components_with_projection(A, v)
end

################################################################################
#
#  Central primitive idempotents
#
################################################################################

@doc Markdown.doc"""
    central_primitive_idempotents(A::AbsAlgAss) -> Vector

Returns the central primitive idempotents of `A`.

```jldoctest
julia> G = small_group(5, 1);

julia> QG = QQ[G];

julia> length(central_primitive_idempotents(QG))
2
"""
function central_primitive_idempotents(A::AbsAlgAss)
  dec = decompose(A)
  res = Vector{elem_type(A)}(undef, length(dec))
  for i in 1:length(dec)
    B, BtoA = dec[i]
    res[i] = BtoA(one(B))
  end
  return res
end


