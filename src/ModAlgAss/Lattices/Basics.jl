################################################################################
#
#  Lattice constructors in the absolute case
#
################################################################################

# Test whether the Z-module with basis matrix B is O-invariant.
function _defines_lattice(V::ModAlgAss{QQField}, O, B)
  for g in basis(O)
    T = action(V, elem_in_algebra(g))
    #BB = B * T * Binv
    # BB * B = B * T
    BT = B * T
    d1 = denominator(BT)
    d2 = denominator(B)
    d = lcm(d1, d2)
    if !can_solve(change_base_ring(ZZ, d*B), change_base_ring(ZZ, (d * BT)), side = :left)
      return false
    end
  end
  return true
end

@doc raw"""
    lattice(V::ModAlgAss, O::AlgAssAbsOrd, B::MatElem) -> ModAlgAssLat

Given a module with matrix action over a $\mathbf{Q}$-algebra $A$, a
$\mathbf{Z}$-order of $A$, return the lattice with $O$-lattice basis matrix $B$.
"""
function lattice(V::ModAlgAss{QQField}, O::AlgAssAbsOrd, B::MatElem; check::Bool = true)
  if B isa QQMatrix
    return _lattice(V, O, B, check = check)
  else
    return _lattice(V, O, change_base_ring(QQ, B)::QQMatrix, check = check)
  end
end

@doc raw"""
    lattice(V::ModAlgAss, O::AlgAssAbsOrd, B::Vector) -> ModAlgAssLat

Given a module with matrix action over a $\mathbf{Q}$-algebra $A$, a
$\mathbf{Z}$-order of $A$, return the $O$-lattice generated by $B$.
"""
function lattice(V::ModAlgAss{QQField}, O::AlgAssAbsOrd, B::Vector; check::Bool = true)
  return lattice(V, O, matrix(QQ, coordinates.(B)); check)
end

function lattice(V::ModAlgAss{QQField}, O::AlgAssAbsOrd, B::Vector{<:ModAlgAssElem})
  @req all(x -> parent(x) === V, B) "Elements must be contained in module"
  BB = eltype(B)[]
  BO = basis(O)
  for b in BO
    for bb in B
      push!(BB, bb * elem_in_algebra(b))
    end
  end
  M = matrix(coordinates.(BB))
  MM = QQMatrix(hnf!(FakeFmpqMat(M), :upperright))
  r = nrows(MM)
  while is_zero_row(MM, r)
    r = r - 1
  end
  return lattice(V, O, MM[1:r, :])
end

# internal function to construct lattice
function _lattice(V::ModAlgAss{QQField}, O::AlgAssAbsOrd, B::QQMatrix; check::Bool = true, is_hnf::Bool = false)
  if check
    fl = _defines_lattice(V, O, B)
    @req fl "Z-lattice with this basis matrix is not invariant under order"
  end

  @hassert :ModLattice _defines_lattice(V, O, B)

  if !is_hnf
    BB = QQMatrix(hnf!(FakeFmpqMat(B), :upperright))
  else
    BB = B
  end
  # strip zero rows if this is not a basis matrix
  r = findfirst(i -> is_zero_row(BB, i), 1:nrows(BB))
  if r !== nothing
    BB = BB[1:(r - 1), :]
  end
  return ModAlgAssLat{typeof(O), typeof(V), typeof(BB)}(O, V, BB)
end

@doc raw"""
    natural_lattice(O::AlgAssAbsOrd{<:MatAlgebra}) -> ModAlgAssLat

Given a $\mathbf{Z}$-order $O$ of a rational matrix algebra contained in
$\mathrm{M}_n(\mathbf{Z})$, return $\mathbf{Z}^n$ as an $O$-lattice.
"""
function natural_lattice(O::AlgAssAbsOrd{<:MatAlgebra{QQFieldElem, QQMatrix}})
  A = algebra(O)
  if all(x -> isone(denominator(matrix(elem_in_algebra(x)))),
         basis(O, copy = false))
    M = Amodule(A, matrix.(basis(A)))
    if dim(A) == degree(A)^2 # this is a full matrix algebra
      M.is_abs_irreducible = 1
    end
    return lattice(M, O, identity_matrix(QQ, degree(algebra(O))))
  else
    throw(ArgumentError("Order is not contained in M_n(Z)"))
  end
end

################################################################################
#
#  Rank
#
################################################################################

rank(L::ModAlgAssLat) = nrows(basis_matrix(L))

################################################################################
#
#  Basis matrix
#
################################################################################

function basis_matrix(L::ModAlgAssLat)
  @req base_ring(L.base_ring) isa ZZRing "Order of lattice must be a Z-order"
  @req has_matrix_action(L.V) "Action on module must be given by matrices"
  return L.basis
end

function basis_matrix_inverse(L::ModAlgAssLat)
  @req base_ring(L.base_ring) isa ZZRing "Order of lattice must be a Z-order"
  @req has_matrix_action(L.V) "Action on module must be given by matrices"
  if isdefined(L, :basis_inv)
    return L.basis_inv
  else
    M = inv(basis_matrix(L))
    L.basis_inv = M
    return M
  end
end

################################################################################
#
#  String I/O
#
################################################################################

function Base.show(io::IO, L::ModAlgAssLat)
  print(io, "Lattice of rank ", rank(L), " over ", base_ring(L.base_ring))
end

################################################################################
#
#  Lattice arithmetic
#
################################################################################

function _hnf_nonzero(a::QQMatrix)
  b = QQMatrix(hnf(FakeFmpqMat(a)))
  i = 1
  while is_zero_row(b, i)
    i += 1
  end
  return b[i:nrows(b), 1:ncols(b)]
end

function *(m::Int, L::ModAlgAssLat)
  return lattice(L.V, L.base_ring, _hnf_nonzero(m * basis_matrix(L)))
end

function +(L::T, M::T) where {T <: ModAlgAssLat}
  @req L.base_ring === M.base_ring "Lattices must be defined over the same order"
  @req L.V === M.V "Lattices must have same ambient module"
  return lattice(L.V, L.base_ring, _hnf_nonzero(vcat(basis_matrix(L),
                                                     basis_matrix(M))))
end

function intersect(L::T, M::T) where {T <: ModAlgAssLat}
  @req L.base_ring === M.base_ring "Lattices must be defined over the same order"
  @req L.V === M.V "Lattices must have same ambient module"
  BM = basis_matrix(M)
  BN = basis_matrix(N)
  dM = denominator(BM)
  dN = denominator(BN)
  d = lcm(dM, dN)
  BMint = change_base_ring(FlintZZ, d * BM)
  BNint = change_base_ring(FlintZZ, d * BN)
  H = vcat(BMint, BNint)
  k, K = left_kernel(H)
  BI = divexact(change_base_ring(FlintQQ, hnf(view(K, 1:k, 1:nrows(BM)) * BMint)), d)
  return lattice(L.V, L.base_ring, BI)
end

function Base.:(==)(L::T, M::T) where {T <: ModAlgAssLat}
  return L.V === M.V && basis_matrix(L) == basis_matrix(M)
end

################################################################################
#
#  Local containment
#
################################################################################

function is_subset_locally(L::T, M::T, p::IntegerUnion) where {T <: ModAlgAssLat}
  if L.V !== M.V
    return false
  end
  t = basis_matrix(L) * basis_matrix_inverse(M)
  for m in t
    if !iszero(m) && valuation(m, p) < 0
      return false
    end
  end
  return true
end

function is_equal_locally(L::T, M::T, p::IntegerUnion) where {T <: ModAlgAssLat}
  return is_subset_locally(L, M, p) && is_subset_locally(M, L, p)
end

################################################################################
#
#  Action
#
################################################################################

@doc raw"""
    action(L::ModAlgAssLat, x)

Given a lattice $L$ over an order $O$ and an element $x$ of $O$, return
the matrix with which $x$ is acting on $L$.
"""
function action(L::ModAlgAssLat, x)
  T = basis_matrix(L)
  Tinv = basis_matrix_inverse(L)
  M = T * action(L.V, elem_in_algebra(x))
  mul!(M, M, Tinv)
  return M
end

function action_of_basis(L::ModAlgAssLat)
  A = action_of_order_basis(L.V, L.base_ring)
  T = basis_matrix(L)
  Tinv = basis_matrix_inverse(L)
  res = Vector{eltype(A)}(undef, length(A))
  for i in 1:length(res)
    M = T * A[i]
    res[i] = mul!(M, M, Tinv)
  end
  return res
end

################################################################################
#
#  Index
#
################################################################################

function index(L::T, M::T) where {T <: ModAlgAssLat}
  t = basis_matrix(L) * basis_matrix_inverse(M)
  @req !isone(denominator(t)) "First lattice not contained in second lattice"
  return abs(det(t))
end

################################################################################
#
#  Sublattice of free lattice
#
################################################################################

function lattice(O::AlgAssAbsOrd, v::Vector{<:Vector})
  A = algebra(O)
  V = Amodule(A, map(x -> elem_in_algebra.(x), v))
  L = lattice(V, O, identity_matrix(ZZ, dim(V)))
  if rank(L) <= dim(A)
    # I want to try to compute Wedderburn decomposition of the endomorphism algebra
    idm = central_primitive_idempotents(A)
    ids = [i for i in 1:length(idm) if !is_zero(action(V, idm[i]))]
    C, p = product_of_components_with_projection(A, ids)
    W = regular_module(A, p)
    fl, WtoV = is_isomorphic_with_isomorphism(W, V)
    VtoW = inv(WtoV)
    @assert fl
    EV, EVmap = endomorphism_algebra(V)
    EW, EWmap = endomorphism_algebra(W)
    imgs = elem_type(EV)[]
    for b in basis(EW)
      push!(imgs, preimage(EVmap, VtoW * EWmap(b) * WtoV))
    end
    h = hom(EW, EV, basis_matrix(imgs))
    for b in basis(EW)
      for bb in basis(EW)
        @assert h(b * bb) == h(b) * h(bb)
      end
    end
    _transport_refined_wedderburn_decomposition_forward(h)
  end
  return L
end

################################################################################
#
#  Free lattice
#
################################################################################

function free_lattice(O::AlgAssAbsOrd, r::Int)
  B = basis(O)
  @assert r == 1
  return lattice(O, [[b] for b in basis(O)])
end

################################################################################
#
#  Twists
#
################################################################################

function _twists(L::ModAlgAssLat)
  V = L.V
  A = algebra(V)
  @req A isa GroupAlgebra "Algebra of the order must be group algebra"
  Ts = _twists(V)
  # the twists of V are the "same" vector space, so we can just push L to the
  # twists
  res = typeof(L)[]
  for T in Ts
    push!(res, lattice(T, L.base_ring, L.basis))
  end
  return res
end

################################################################################
#
#  Change base ring
#
################################################################################

function change_base_ring(f#=::AbsAlgAssMor=#, O::AlgAssAbsOrd, L::ModAlgAssLat)
  B = codomain(f)
  @assert algebra(L.base_ring) === B
  V = L.V
  A = domain(f)
  BA = basis(A)
  W = Amodule(A, [action(V, f(g)) for g in basis(A)])
  return lattice(W, O, basis_matrix(L))
end

################################################################################
#
#  Subset
#
################################################################################

function is_subset(L::ModAlgAssLat, M::ModAlgAssLat)
  # TODO: improve for full rank lattices
  BL = basis_matrix(L)
  BM = basis_matrix(M)
  dL = denominator(BL)
  dM = denominator(BM)
  d = lcm(dL, dM)
  return can_solve(map_entries(ZZ, d * BM), map_entries(ZZ, d * BL), side = :left)
end
