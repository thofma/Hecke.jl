#default_domain_type(::Type{QQField}) = ZZRing
#
#default_domain_type(::Type{K <: NumField}) = order_type(K)

#order_type(::Type{T}) where {S <: NumField, T <: AbstractAssociativeAlgebra{S}} = AssociativeAlgebraOrder{order_type(parent_type(T)), T}

function _map(x::AbstractAssociativeAlgebraElem, M::EmbeddedModule)
  @assert parent(x) === M.overstructure
  t = _tmp_mat_overring(M, 1)
  elem_to_mat_row!(t, 1, x)
  return t
end

function _map(x::Vector{<:AbstractAssociativeAlgebraElem}, M::EmbeddedModule)
  return coordinates!(_tmp_mat_overring(M, length(x)), x)
end

algebra_type(::Type{AssociativeAlgebraOrder{T, S}}) where {S, T} = T

# order_type(::Type{T}) where {T <: AbstractAssociativeAlgebra{QQFieldElem}} = AssociativeAlgebraOrder{T, ZZRing}
#
# order_type(::Type{T}) where {S <: NumFieldElem, T <: AbstractAssociativeAlgebra{S}} = AlgAssRelOrd{S, fractional_ideal_type(order_type(parent_type(S))), T}
#
# order_type(::Type{T}, ::Type{ZZRing}) where {T <: AbstractAssociativeAlgebra{QQFieldElem}} = AssociativeAlgebraOrder{T, ZZRing}
#
# order_type(::Type{T}, ::Type{S}) where {T, U <: FieldElem, S <: PolyRing{U}} = AssociativeAlgebraOrder{T, S}
#
# order_type(::Type{T}, ::Type{S}) where {T, U <: FieldElem, S <: KInftyRing{U}} = AssociativeAlgebraOrder{T, S}
#
# elem_type(::Type{T}) where {T <: AssociativeAlgebraOrder} = AssociativeAlgebraOrderElem{T, elem_type(algebra_type(T))}
#
# ideal_type(::Type{AssociativeAlgebraOrder{S, T}}) where {S, T} = AssociativeAlgebraOrderIdl{S, T}
#
# # There is no dedicated type for fractional ideals
# fractional_ideal_type(::Type{AssociativeAlgebraOrder{S, T}}) where {S, T} = AssociativeAlgebraOrderIdl{S, T}

@doc raw"""
    algebra(O::AssociativeAlgebraOrder) -> AbstractAssociativeAlgebra

Returns the algebra which contains $O$.
"""
algebra(O::AssociativeAlgebraOrder) = O.algebra

_algebra(O::AssociativeAlgebraOrder) = algebra(O)

base_ring(O::AssociativeAlgebraOrder) = O.base_ring

base_ring_type(::Type{AssociativeAlgebraOrder{T, S}}) where {S, T} = S

@doc raw"""
    is_commutative(O::AssociativeAlgebraOrder) -> Bool

Returns `true` if $O$ is a commutative ring and `false` otherwise.
"""
is_commutative(O::AssociativeAlgebraOrder) = is_commutative(algebra(O))

################################################################################
#
#  Check if given elements form the basis of an order
#
################################################################################

function _is_basis_of_order_with_data(A::AbstractAssociativeAlgebra, R::Ring, elts::Vector)
  if length(elts) != dim(A)
    return false, zero_embedded_module(R, base_ring(A), 0)
  else
    B = basis_matrix(elts)
    fl, M, _ = _is_basis_matrix_of_order_with_data(A, R, B)
    return fl, M, elts
  end
end

# base ring agnostic version
function _is_basis_matrix_of_order_with_data(A::AbstractAssociativeAlgebra, R::Ring, x::MatElem)
  K = base_ring(A)
  M = embedded_module(R, K, x; overstructure = A)
  if nrows(x) != dim(A) || ncols(x) != dim(A)
    return false, M, Vector{elem_type(A)}()
  end
  if !has_full_rank(M)
    return false, M, Vector{elem_type(A)}()
  end
  _ = basis_matrix_inverse(M) # trigger to use inverse for solving
  n = dim(A)
  d = Vector{elem_type(A)}(undef, n)
  # Construct the basis elements from the basis matrix
  for i in 1:n
    d[i] = elem_from_mat_row(A, x, i)
  end

  # Check if R-module spanned by x is closed under multiplcation
  # We do the check block-wise
  l = Vector{elem_type(A)}(undef, n)
  t = one(A)
  for i in 1:n
    for j in 1:n
      if j < i && is_commutative(A)
        # ignore the elments that are there, since we checked them already
        continue
      end
      l[j] = d[i] * d[j]

    end
    if !in(l, M)
      return false, M, Vector{elem_type(A)}()
    end
  end
  # Check if 1 is contained in the Z-module
  if !in(one(A), M)
    return false, M, Vector{elem_type(A)}()
  end
  return true, M, d
end


#
#
# @doc raw"""
#     new_order(A::AbstractAssociativeAlgebra{QQFieldElem}, B::Vector{<: AbstractAssociativeAlgebraElem{QQFieldElem}}; check::Bool = true,
#           isbasis::Bool = false, cached::Bool = true)
#       -> AssociativeAlgebraOrder
#
# Returns the order of $A$ generated by $B$. If `check` is set, it is checked
# whether $B$ defines an order. If `isbasis` is set, then the elements are
# assumed to form a $\mathbb Z$-basis.
# """
function new_order(R::Ring, B::Vector{<:AbstractAssociativeAlgebraElem}; check::Bool = true, is_basis::Bool = false, isbasis::Bool = is_basis, cached::Bool = true)
  @req length(B) > 0 "Number of generators must be positive. Specifiy the algebra as a first argument to accomodate this case."
  return new_order(parent(B[1]), R, B; check, is_basis, isbasis, cached)
end

function new_order(A::AbstractAssociativeAlgebra, R::Ring, B::Vector{<:AbstractAssociativeAlgebraElem}; check::Bool = true, is_basis::Bool = false, isbasis::Bool = is_basis, cached::Bool = true)
  # isbasis is legacy
  if is_basis
    if check
      fl, M = _is_basis_of_order_with_data(A, R, B)
      @req fl "The elements do not define an order"
      return AssociativeAlgebraOrder(A, R, M, copy(B), cached)
    else
      return AssociativeAlgebraOrder(A, R, M, copy(B), cached)
    end
  else
    error("to implement")
    return _order(A, B; cached = cached, check = check)
  end
end

is_maximal_known(O::AssociativeAlgebraOrder) = O.is_maximal != 0

is_known(::typeof(is_maximal), O::AssociativeAlgebraOrder) = is_maximal_known(O)

@inline is_maximal_known_and_maximal(O::AssociativeAlgebraOrder) = isone(O.is_maximal)

@doc raw"""
    is_maximal(O::AssociativeAlgebraOrder) -> Bool

Returns `true` if $O$ is a maximal order and `false` otherwise.
"""
function is_maximal(O::AssociativeAlgebraOrder)
  if O.is_maximal == 1
    return true
  end
  if O.is_maximal == 2
    return false
  end

  A = algebra(O)
  d = discriminant(O)
  if isdefined(A, :maximal_order)
    if d == discriminant(maximal_order(A))
      O.is_maximal = 1
      return true
    else
      O.is_maximal = 2
      return false
    end
  end

  if typeof(A) <: GroupAlgebra
    fac = factor(degree(O))
  else
    fac = factor(abs(d))
  end

  for (p, j) in fac
    # This can be improved a bit. Even in the GroupAlgebra case, we should
    # only look at the primes dividing d with power > 1
    if !(typeof(A) <: GroupAlgebra) && j == 1
      continue
    end
    d2 = discriminant(pmaximal_overorder(O, p))
    if d != d2
      O.is_maximal = 2
      return false
    end
  end
  O.is_maximal = 1
  return true
end

#function _is_basis_matrix_of_order_with_data(A::AbstractAssociativeAlgebra, R::Ring, x::MatElem)
#  if nrows(x) != dim(A) || ncols(x) != dim(A)
#    return false, x, Vector{elem_type(A)}()
#  end
#  local xinv
#  try
#    xinv = inv(x)
#  catch
#    return false, x, Vector{elem_type(A)}()
#  end
#  n = dim(A)
#  B_K = basis(A)
#  d = Vector{elem_type(A)}(undef, n)
#  # Construct the basis elements from the basis matrix
#  for i in 1:n
#    d[i] = elem_from_mat_row(A, x, i)
#  end
#
#  # Check if R-module spanned by x is closed under multiplcation
#  l = Vector{elem_type(A)}(undef, n)
#  for i in 1:n
#    for j in 1:n
#      if j < i && is_commutative(A)
#        continue
#      end
#      l[j] = d[i]*d[j]
#    end
#    Ml = basis_matrix(l)
#    #_, dd = integral_split(Ml * xinv, R)
#    if !_has_preimage(fraction_field_map(R, base_ring(A)), Ml * xinv)
#    #if !is_unit(dd)
#      return false, x, Vector{elem_type(A)}()
#    end
#  end
#  # Check if 1 is contained in the Z-module
#  Ml = basis_matrix([one(A)])
#  _, dd = integral_split(Ml * xinv, R)
#  if !is_unit(dd)
#    return false, x, Vector{elem_type(A)}()
#  end
#  return true, xinv, d
#end

#
# # legacy
# function new_order(A::S, M::FakeFmpqMat; kw...) where {S <: AbstractAssociativeAlgebra{QQFieldElem}}
#   return new_order(A, QQMatrix(M); kw...)
# end
#
# @doc raw"""
#     new_order(A::AbstractAssociativeAlgebra{QQFieldElem}, M::QQMatrix; check::Bool = true,
#           cached::Bool = true)
#       -> AssociativeAlgebraOrder
#
# Returns the order of $A$ with basis matrix $M$. If `check` is set, it is checked
# whether $M$ defines an order.
# """
# function new_order(A::S, M::QQMatrix; check::Bool = true, cached::Bool = true) where {S <: AbstractAssociativeAlgebra{QQFieldElem}}
#   return new_order(A, ZZ, M; check, cached)
# end

function new_order(A::AbstractAssociativeAlgebra, R::Ring, M::MatElem; check::Bool = true, cached::Bool = true, is_basis::Bool = true)
  if is_basis
    if check
      fl, N, v = _is_basis_matrix_of_order_with_data(A, R, M)
      @req fl "Matrix is not basis matrix of an order"
      return AssociativeAlgebraOrder(A, R, N, v, cached)
    end
  else
    elts = [elem_from_mat_row(A, M, i) for i in 1:nrows(M)]
    return new_order(A, R, elts; check, cached)
  end
end

#function _equation_order(A::AbstractAssociativeAlgebra{QQFieldElem})
#  @assert is_commutative(A)
#  a = primitive_element_via_number_fields(A)
#  b = Vector{elem_type(A)}(undef, dim(A))
#  b[1] = one(A)
#  for i = 2:dim(A)
#    b[i] = b[i - 1]*a
#  end
#  return new_order(A, b)
#end

# ################################################################################
# #
# #  Integral group ring
# #
# ################################################################################
#
# function integral_group_ring(A::GroupAlgebra{QQFieldElem})
#   return new_order(A, basis(A))
# end

################################################################################
#
#  Index
#
################################################################################

function _det_basis_matrix(O::AssociativeAlgebraOrder)
  if isdefined(O, :det_basis_matrix)
    return O.det_basis_matrix
  else
    d = det(basis_matrix(O, copy = false))
    O.det_basis_matrix = d
    return d
  end
end

function index(O::AssociativeAlgebraOrder)
  B = basis_matrix_inverse(O, copy = false)
  n = det(B)
  @assert isinteger(n)
  return ZZ(n)
end

function index(O::AssociativeAlgebraOrder, R::AssociativeAlgebraOrder)
  B = basis_matrix_inverse(O, copy = false)
  n = det(B)
  B = basis_matrix_inverse(R, copy = false)
  m = det(B)
  @assert isinteger(m//n)
  return ZZ(m//n)
end

################################################################################
#
#  "Assure" functions for fields
#
################################################################################

function _assure_has_basis(O::AssociativeAlgebraOrder)
  if !isdefined(O, :basis)
    B = basis(algebra(O))
    M = basis_matrix(O, copy = false)
    v = Vector{elem_type(O)}(undef, degree(O))
    for i in 1:degree(O)
      w = sum(M[i, j] * B[j] for j in 1:degree(O))
      v[i] = O(w)
    end
    O.basis = v
  end
  return nothing
end

function assure_basis_mat_inv(O::AssociativeAlgebraOrder)
  if !isdefined(O, :basis_mat_inv)
    O.basis_mat_inv = inv(basis_matrix(O, copy = false))
  end
  return nothing
end

function assure_basis_alg(O::AssociativeAlgebraOrder)
  if isdefined(O, :basis_alg)
    return nothing
  end

  M = basis_matrix(O, copy = false)
  A = algebra(O)
  O.basis_alg = Vector{elem_type(A)}(undef, dim(A))
  for i = 1:dim(A)
    O.basis_alg[i] = elem_from_mat_row(A, M.num, i, M.den)
  end
  return nothing
end

################################################################################
#
#  Basis
#
################################################################################

@doc raw"""
    basis(O::AssociativeAlgebraOrder; copy::Bool = true) -> Vector{AssociativeAlgebraOrderElem}

Returns a $\mathbb Z$-basis of $O$.
"""
function basis(O::AssociativeAlgebraOrder; copy::Bool = true)
  _assure_has_basis(O)
  if copy
    return deepcopy(O.basis)::Vector{elem_type(O)}
  else
    return O.basis::Vector{elem_type(O)}
  end
end

absolute_basis(O::AssociativeAlgebraOrder) = basis(O)

function basis_alg(O::AssociativeAlgebraOrder{T, S}; copy::Bool = true) where {S, T}
  assure_basis_alg(O)
  if copy
    return deepcopy(O.basis_alg)::Vector{elem_type(T)}
  else
    return O.basis_alg::Vector{elem_type(T)}
  end
end

function basis(O::AssociativeAlgebraOrder{T, S}, A::T; copy::Bool = true) where {S, T}
  @req algebra(O) === A "Algebras do not match"
  return basis_alg(O, copy = copy)
end

################################################################################
#
#  (Inverse) basis matrix
#
################################################################################

@doc raw"""
    basis_matrix(O::AssociativeAlgebraOrder; copy::Bool = true) -> QQMatrix

Returns the basis matrix of $O$.
"""
function basis_matrix(x::AssociativeAlgebraOrder; copy::Bool = true)
  error("asd")
  if copy
    return deepcopy(x.basis_matrix)
  else
    return x.basis_matrix
  end
end

function basis_matrix(::Type{FakeFmpqMat}, x::AssociativeAlgebraOrder; copy::Bool = true)
  error("Sss")
  return FakeFmpqMat(basis_matrix(x; copy))
end

@doc raw"""
    basis_mat_inv(O::AssociativeAlgebraOrder; copy::Bool = true) -> QQMatrix

Returns the inverse of the basis matrix of $O$.
"""
function basis_matrix_inverse(O::AssociativeAlgebraOrder; copy::Bool = true)
  error("asdsd")
  assure_basis_mat_inv(O)
  if copy
    return deepcopy(O.basis_mat_inv)::dense_matrix_type(base_ring(algebra(O)))
  else
    return O.basis_mat_inv::dense_matrix_type(base_ring(algebra(O)))
  end
end

################################################################################
#
#  Degree
#
################################################################################

@doc raw"""
    degree(O::AssociativeAlgebraOrder) -> Int

Returns the dimension of the algebra containing $O$.
"""
function degree(O::AssociativeAlgebraOrder)
  return dim(algebra(O))
end

################################################################################
#
#  Inclusion of algebra elements
#
################################################################################

function _check_elem_in_order(a::AbstractAssociativeAlgebraElem, O::AssociativeAlgebraOrder, ::Val{short} = Val(false)) where {short}
  t = zero_matrix(base_ring(parent(a)), 1, degree(O))
  elem_to_mat_row!(t, 1, a)
  t = t*basis_matrix_inverse(O, copy = false)
  if t isa QQMatrix && short
    return is_one(denominator(t))
  end
  tn, d = integral_split(t, base_ring(O))
  if short
    return is_unit(d)
  else
    if !is_unit(d)
      return false, Vector{elem_type(base_ring(O))}()
    else
      v = Vector{elem_type(base_ring(O))}(undef, degree(O))
      for i = 1:degree(O)
        if eltype(v) !== ZZRingElem
          v[i] = deepcopy(tn[1, i])
        else
          v[i] = tn[1, i]
        end
      end
      return true, v
    end
  end
end

@doc raw"""
    in(x::AbstractAssociativeAlgebraElem, O::AssociativeAlgebraOrder) -> Bool

Returns `true` if the algebra element $x$ is in $O$ and `false` otherwise.
"""
function in(x::AbstractAssociativeAlgebraElem, O::AssociativeAlgebraOrder)
  @assert parent(x) === algebra(O)
  return _check_elem_in_order(x, O, Val(true))
end

################################################################################
#
#  Denominator in an order
#
################################################################################

@doc raw"""
    denominator(a::AbstractAssociativeAlgebraElem, O::AssociativeAlgebraOrder) -> ZZRingElem

Returns $d\in \mathbb Z$ such that $d \cdot a \in O$.
"""
function denominator(a::AbstractAssociativeAlgebraElem, O::AssociativeAlgebraOrder)
  t = zero_matrix(QQ, 1, degree(O))
  elem_to_mat_row!(t, 1, a)
  t = mul!(t, t, basis_matrix_inverse(O, copy = false))
  return denominator(t)
end

################################################################################
#
#  Random elements
#
################################################################################

RandomExtensions.maketype(O::AssociativeAlgebraOrder, R::AbstractUnitRange) = elem_type(O)

function rand(rng::AbstractRNG,
              sp::SamplerTrivial{<:Make2{<:NCRingElem,<:AssociativeAlgebraOrder,<:AbstractUnitRange}})
  O, R = sp[][1:2]
  O(map(ZZRingElem, rand(rng, R, degree(O))))

end

RandomExtensions.make(O::AssociativeAlgebraOrder, n::IntegerUnion) =
  make(O, Integer(-n):Integer(n))

@doc raw"""
    rand(O::AssociativeAlgebraOrder, R::AbstractUnitRange) -> AssociativeAlgebraOrderElem

Returns a random element of $O$ whose coefficients lie in $R$.
"""
rand(O::AssociativeAlgebraOrder, R::AbstractUnitRange) = rand(Random.GLOBAL_RNG, O, R)

@doc raw"""
    rand(O::AssociativeAlgebraOrder, n::IntegerUnion) -> AssociativeAlgebraOrderElem

Returns a random element of $O$ whose coefficients are bounded by $n$.
"""
rand(O::AssociativeAlgebraOrder, n::ZZRingElem) = rand(Random.GLOBAL_RNG, O, n)
rand(O::AssociativeAlgebraOrder, n::Integer) = rand(Random.GLOBAL_RNG, O, n)
# these two methods can't be merged with a Union, because of ambiguities

rand(rng::AbstractRNG, O::AssociativeAlgebraOrder, n::Union{ZZRingElem, <:AbstractUnitRange}) = rand(rng, make(O, n))
rand(rng::AbstractRNG, O::AssociativeAlgebraOrder, n::Integer) = rand(rng, make(O, n))


# ################################################################################
# #
# #  Basis matrices from generators
# #
# ################################################################################
#

function coordinates!(M::MatrixElem{T}, A::Vector{<:AbstractAssociativeAlgebraElem{T}}) where T
  n = length(A)
  @assert nrows(M) == n
  d = ncols(M)
  K = base_ring(M)

  for i = 1:n
    elem_to_mat_row!(M, i, A[i])
    #for j = 1:d
    #  M[i, j] = deepcopy(coefficients(A[i], copy = false)[j])
    #end
  end
  return M
end

# function basis_matrix(A::Vector{S}, ::Type{FakeFmpqMat}) where {S <: AbstractAssociativeAlgebraElem{QQFieldElem}}
#   if length(A) == 0
#     return M = FakeFmpqMat(zero_matrix(ZZ, 0, 0), ZZ(1))
#   end
#   @assert length(A) > 0
#   n = length(A)
#   d = dim(parent(A[1]))
#
#   M = zero_matrix(ZZ, n, d)
#
#   t = ZZRingElem()
#
#   deno = one(ZZ)
#   for i in 1:n
#     acoeff = coefficients(A[i], copy = false)
#     for j in 1:d
#       denominator!(t, acoeff[j])
#       lcm!(deno, deno, t)
#     end
#   end
#
#   temp_den = ZZRingElem()
#
#   #dens = [lcm([denominator(coefficients(A[i], copy = false)[j]) for j=1:d]) for i=1:n]
#   #deno = lcm(dens)
#
#   skip_den = isone(deno)
#
#   for i in 1:n
#     acoeff = coefficients(A[i], copy = false)
#     for j in 1:d
#       if skip_den
#         numerator!(t, acoeff[j])
#         M[i, j] = t
#         #M[i, j] = numerator(coefficients(A[i], copy = false)[j])
#       else
#         denominator!(temp_den, acoeff[j])
#         divexact!(temp_den, deno, temp_den)
#         numerator!(t, acoeff[j])
#         mul!(t, t, temp_den)
#         M[i, j] = t
#       end
#       #temp_den = divexact(deno, denominator(coefficients(A[i], copy = false)[j]))
#       #M[i, j] = numerator(coefficients(A[i], copy = false)[j]) * temp_den
#     end
#   end
#   return FakeFmpqMat(M, deno)
# end
#
# function basis_matrix(A::Vector{ <: AbstractAssociativeAlgebraElem{T} }) where T
#   @assert length(A) > 0
#   n = length(A)
#   d = dim(parent(A[1]))
#   K = base_ring(parent(A[1]))
#
#   M = zero_matrix(K, n, d)
#
#   for i = 1:n
#     elem_to_mat_row!(M, i, A[i])
#     #for j = 1:d
#     #  M[i, j] = deepcopy(coefficients(A[i], copy = false)[j])
#     #end
#   end
#   return M
# end
#
# function basis_matrix(A::Vector{AssociativeAlgebraOrderElem{S, T}}) where S where T
#   @assert length(A) > 0
#   n = length(A)
#   d = degree(parent(A[1]))
#   M = zero_matrix(ZZ, n, d)
#
#   for i in 1:n
#     el = coordinates(A[i])
#     for j in 1:d
#       M[i, j] = el[j]
#     end
#   end
#   return M
# end

################################################################################
#
#  Sum of orders
#
################################################################################

# Be careful!
# To be used only in the case of the construction of a maximal order!
function +(a::AssociativeAlgebraOrder, b::AssociativeAlgebraOrder)
  aB = basis_matrix(a, copy = false)
  bB = basis_matrix(b, copy = false)
  d = degree(a)
  c = sub(_hnf(vcat(denominator(bB) * numerator(aB), denominator(aB)*numerator(bB)), :lowerleft), d + 1:2*d, 1:d)
  return new_order(algebra(a), divexact(QQMatrix(c), denominator(aB) * denominator(bB)))
end

################################################################################
#
#  Print
#
################################################################################

function show(io::IO, O::AssociativeAlgebraOrder)
  compact = get(io, :compact, false)
  if compact
    print(io, "Order of ")
    show(IOContext(io, :compact => true), algebra(O))
  else
    print(io, "Order of ")
    print(io, algebra(O))
    println(io, " with basis matrix ")
    print(io, basis_matrix(O.M))
  end
end

################################################################################
#
#  Equality
#
################################################################################

@doc raw"""
    ==(S::AssociativeAlgebraOrder, T::AssociativeAlgebraOrder) -> Bool

Returns `true` if $S$ and $T$ are equal and `false` otherwise.
"""
function ==(S::AssociativeAlgebraOrder, T::AssociativeAlgebraOrder)
  if algebra(S) != algebra(T)
    return false
  end
  return basis_matrix(S, copy = false) == basis_matrix(T, copy = false)
end

function Base.hash(S::AssociativeAlgebraOrder, h::UInt)
  h = hash(algebra(S), h)
  return hash(basis_matrix(S, copy = false), h)
end

################################################################################
#
#  Discriminant and Reduced Trace Matrix
#
################################################################################

@doc raw"""
    trred_matrix(O::AssociativeAlgebraOrder) -> ZZMatrix

Returns the reduced trace matrix $M$ of $O$, i. e. `M[i, j] = trred(b[i]*b[j])`,
where $b$ is a basis of $O$.
"""
function trred_matrix(O::AssociativeAlgebraOrder)
  if isdefined(O, :trred_matrix)
    return O.trred_matrix::dense_matrix_type(base_ring(O))
  end
  A=algebra(O)
  x=O.basis_alg
  m=length(x)
  M=zero_matrix(base_ring(O), m, m)
  a=A()
  for i=1:m
    a = mul!(a, x[i], x[i])
    M[i,i] = base_ring(O)(trred(a))
  end
  for i = 1:m
    for j = i+1:m
      a = mul!(a, x[i], x[j])
      b = base_ring(O)(trred(a))
      M[i,j] = b
      M[j,i] = b
    end
  end
  O.trred_matrix = M
  return M
end

@doc raw"""
    discriminant(O::AssociativeAlgebraOrder) -> ZZRingElem

Returns the discriminant of $O$.
"""
function discriminant(O::AssociativeAlgebraOrder)
  if isdefined(O, :disc)
    return O.disc
  end
  M = trred_matrix(O)
  O.disc = det(M)
  return O.disc
end

################################################################################
#
#  p-maximal overorder
#
################################################################################

function pmaximal_overorder(O::AssociativeAlgebraOrder{S, T}, p::Union{ZZRingElem, Int}) where S where T
  d = discriminant(O)
  if rem(d, p^2) != 0
    return O
  end

  if p > degree(O)
    @vtime :AlgAssOrd 1 O1 = pmaximal_overorder_tr(O,p)::AssociativeAlgebraOrder{S, T}
    return O1
  else
    @vtime :AlgAssOrd 1 O1 = pmaximal_overorder_meataxe(O,p)::AssociativeAlgebraOrder{S, T}
    return O1
  end
end

function pmaximal_overorder_meataxe(O::AssociativeAlgebraOrder{S, T}, p::Union{ZZRingElem, Int}) where {S, T}

  extend = false
  d = discriminant(O)
  while true
    dd = ZZRingElem(1)
    @vtime :AlgAssOrd 1 max_id =_maximal_ideals(O, p*O, p, strict_containment = true)
    for m in max_id
      @vtime :AlgAssOrd 1 OO = _ring_of_multipliers_integral_ideal(m, ZZRingElem(p))
      dd = discriminant(OO)
      if d != dd
        extend = true
        O = OO
        d = dd
        break
      end
    end

    if extend
      if rem(d, p^2) != 0
        break
      end
      extend = false
      continue
    else
      break
    end

  end
  return O
end

function pmaximal_overorder_tr(O::AssociativeAlgebraOrder, p::IntegerUnion)
  #First, the head order by computing the pradical and its ring of multipliers
  d = discriminant(O)
  @vtime :AlgAssOrd 1 I = pradical(O, p)
  @vtime :AlgAssOrd 1 OO = _ring_of_multipliers_integral_ideal(I, ZZRingElem(p))
  dd = discriminant(OO)
  if rem(dd, p^2) != 0
    return OO
  end
  while dd!= d
    d = dd
    O = OO
    @vtime :AlgAssOrd 1 I = pradical(O,p)
    @vtime :AlgAssOrd 1 OO = _ring_of_multipliers_integral_ideal(I, ZZRingElem(p))
    dd = discriminant(OO)
    if rem(dd, p^2) != 0
      return OO
    end
  end
  #Now, we have to check the maximal ideals.

  extend = false
  @vtime :AlgAssOrd 1 max_id = _maximal_ideals(O, I, p, strict_containment = true)
  for m in max_id
    @vtime :AlgAssOrd 1 OO = _ring_of_multipliers_integral_ideal(m, ZZRingElem(p))
    dd = discriminant(OO)
    if d != dd
      extend = true
      O = OO
      d = dd
      break
    end
  end
  if extend
    if rem(dd, p^2) != 0
      return OO
    end
    extend = false
  else
    return OO
  end
  while true
    dd = ZZRingElem(1)
    @vtime :AlgAssOrd 1 max_id = _maximal_ideals(O, p*O, p, strict_containment = true)
    for m in max_id
      OO = _ring_of_multipliers_integral_ideal(m, ZZRingElem(p))
      dd = discriminant(OO)
      if d != dd
        extend = true
        O = OO
        d = dd
        break
      end
    end

    if extend
      if rem(dd, p^2) != 0
        break
      end
      extend = false
      continue
    else
      break
    end

  end
  return O
end

################################################################################
#
#  Maximal Order
#
################################################################################

@doc raw"""
    maximal_order(O::AssociativeAlgebraOrder)

Given an order $O$, this function returns a maximal order containing $O$.
"""
function maximal_order(O::AssociativeAlgebraOrder{S, T}; cached::Bool = true) where S where T
  A = algebra(O)

  # TODO: fix caching
  if cached && has_attribute(O, :maximal_order)
    return get_attribute(O, :maximal_order)::typeof(O)
  end

  #if cached && isdefined(A, :maximal_order)
  #  for OO::order_type(A) in A.maximal_order
  #    d = denominator(basis_matrix(O, copy = false)*basis_matrix_inverse(OO, copy = false))
  #    if isone(d)
  #      set_attribute!(O, :maximal_order, OO)
  #      return OO
  #    end
  #  end
  #end

  # if cached == false, I also want fresh stuff in the components if it does decomposition
  OO = new_maximal_order(O, cached)

  # set_attribute!(O, :maximal_order, OO)

  return OO
end

function new_maximal_order(O::AssociativeAlgebraOrder{S, T}, cache_in_substructures::Bool = true) where {S, T}
  A = algebra(O)

  if degree(O) >= 30 && !is_simple(A)
    OO = _maximal_order_via_decomposition(O, cache_in_substructures)
  else
    d = discriminant(O)
    @vtime :AbsNumFieldOrder fac = factor(d)

    OO = O
    for (p, j) in fac
      if mod(d, p^2) != 0
        continue
      end
      OO += pmaximal_overorder(O, p)
    end
    OO.is_maximal = 1
  end

  # TODO: fix this nonsense
  # if !isdefined(A, :maximal_order)
  #   A.maximal_order = [OO]
  # else
  #   push!(A.maximal_order, OO)
  # end
  return OO
end

function maximal_order(O::AssociativeAlgebraOrder{T, S}) where { S <: GroupAlgebra, T <: GroupAlgebraElem }
  A = algebra(O)

  if isdefined(A, :maximal_order)
    for OO::order_type(A) in A.maximal_order
      d = denominator(basis_matrix(O, copy = false)*basis_matrix_inverse(OO, copy = false))
      if isone(d)
        return OO
      end
    end
  end

  if degree(O) > 40 # group algebra is never simple
    OO = _maximal_order_via_decomposition(O)
  else
    d = discriminant(O)
    @assert degree(O) < 2^31 # squares do not overflow
    fac = factor(degree(O)) # the order of the group

    OO = O
    for (p, j) in fac
      if mod(d, p^2) != 0
        continue
      end
      OO += pmaximal_overorder(O, p)
    end

    for (p, _) in factor(ppio(discriminant(OO), ZZ(degree(O)))[2])
      OO += pmaximal_overorder(O, p)
    end

    OO.is_maximal = 1
  end

  if !isdefined(A, :maximal_order)
    A.maximal_order = [OO]
  else
    push!(A.maximal_order::Vector{order_type(A)}, OO)
  end

  return OO
end

#function _denominator_of_mult_table(A::AbstractAssociativeAlgebra{QQFieldElem})
#  return _denominator_of_mult_table(A, ZZ)
#end

function __denominator_of_mult_table(A::AbstractAssociativeAlgebra, R::Ring)
  f = fraction_field_map(R, base_ring(A))
  mt = multiplication_table(A; copy = false)
  return l = denominator(f, mt)
end

#__denominator_of_mult_table(A::GroupAlgebra{QQFieldElem, <:Any, <:Any}, R::Ring) = one(R)

@doc raw"""
    any_order(A::AbstractAssociativeAlgebra{QQFieldElem}) -> AssociativeAlgebraOrder

Returns any order of $A$.
"""
function any_new_order(A::AbstractAssociativeAlgebra{QQFieldElem})
  return any_new_order(A, ZZ)
end

#function any_new_order(A::AbstractAssociativeAlgebra{QQFieldElem}, ::ZZRing)
#  return get_attribute!(A, :any_order) do
#    d = _denominator_of_mult_table(A)
#    di = dim(A)
#    M = vcat(zero_matrix(QQ, 1, di), d*identity_matrix(QQ, di))
#    oneA = one(A)
#    for i = 1:di
#      M[1, i] = deepcopy(coefficients(oneA, copy = false)[i])
#    end
#    M = _hnf!_integral(M, :lowerleft)
#    O = new_order(A, ZZ, sub(M, 2:di + 1, 1:di))
#    return O
#  end::new_order_type(A)
#end
#
function any_new_order(A::AbstractAssociativeAlgebra, R::Ring)#PolyRing{<:FieldElem})
  # TODO: fix caching
  #return get_attribute!(A, :any_order) do
    K = base_ring(A)
    d = __denominator_of_mult_table(A, R)
    di = dim(A)
    M = vcat(zero_matrix(K, 1, di), d*identity_matrix(K, di))
    oneA = one(A)
    for i = 1:di
      M[1, i] = deepcopy(coefficients(oneA, copy = false)[i])
    end
    M = _hnf!_integral(M, R, :lowerleft)
    O = new_order(A, R, sub(M, 2:di + 1, 1:di))
    return O
  #end::order_type(A, R)
end

#_default_domain(::QQField) = ZZ
#
#@doc raw"""
#    maximal_order(A::AbstractAssociativeAlgebra{QQFieldElem}) -> AssociativeAlgebraOrder
#
#Returns a maximal order of $A$.
#"""
#function maximal_order(A::AbstractAssociativeAlgebra{S}, R = _default_domain(base_ring(A))) where S
#  # TODO: fix the caching
#  if isdefined(A, :maximal_order) && R === _default_domain(base_ring(A))
#    return first(A.maximal_order)::order_type(A)
#  end
#
#  O = any_order(A, R)
#  OO = maximal_order(O)
#  if !isdefined(A, :maximal_order) && R === _default_domain(base_ring(A))
#    A.maximal_order = [OO]
#  end
#  return OO
#end
#
#function maximal_order_via_decomposition(A::AbstractAssociativeAlgebra{QQFieldElem})
#  if isdefined(A, :maximal_order)
#    return first(A.maximal_order)::order_type(A)
#  end
#  fields_and_maps = __as_number_fields(A, use_maximal_order = false)
#  M = zero_matrix(QQ, dim(A), dim(A))
#  row = 1
#  for i = 1:length(fields_and_maps)
#    K = fields_and_maps[i][1]
#    AtoK = fields_and_maps[i][2]
#    O = maximal_order(K)
#    for b in basis(O)
#      a = AtoK\K(b)
#      elem_to_mat_row!(M, row, a)
#      row += 1
#    end
#  end
#  FakeM = FakeFmpqMat(M)
#  FakeM = _hnf!_integral(FakeM, :lowerleft)
#  OO = new_order(A, FakeM)
#  OO.is_maximal = 1
#  A.maximal_order = [OO]
#  return OO
#end

_debug = []

function _maximal_order_via_decomposition(O::AssociativeAlgebraOrder, cache_in_substructures::Bool = true)
  A = algebra(O)
  dec = decompose(A)
  Obas = basis(O)
  bas = elem_type(A)[]
  for i in 1:length(dec)
    Ai, mAi = dec[i]
    gens = [ mAi\(mAi(one(Ai)) * elem_in_algebra(b)) for b in Obas]
    OinAi = new_order(Ai, gens; check = false)
    Mi = maximal_order(OinAi)
    Mibas = [ mAi(elem_in_algebra(b)) for b in basis(Mi)]
    append!(bas, Mibas)
  end
  M = new_order(A, bas, isbasis = true, check = false)
  N = new_order(A, _hnf_integral(basis_matrix(M, copy = false)))
  N.is_maximal = 1
  return N
end

# Requires that O is maximal and A = QQ^(n\times n).
# Computes a maximal order of type
#  (O ... O a^(-1))
#  (:     :   :   )
#  (O ... O a^(-1))
#  (a ... a   O   )
# for an ideal a of O.
# See Bley, Johnston "Computing generators of free modules over orders in group
# algebras", Prop. 5.1.
function _simple_maximal_order(O::AssociativeAlgebraOrder{S1, ZZRing}, ::Val{with_transform} = Val(false)) where { S1 <: MatAlgebra, with_transform }
  A = algebra(O)

  if !(A isa MatAlgebra)
    throw(ArgumentError("Order must be an order in a matrix algebra"))
  end

  n = _matdeg(A)

  # Build a matrix with the first rows of basis elements of O
  M = zero_matrix(QQ, dim(A), n)
  for i = 1:dim(A)
    for j = 1:n
      M[i, j] = deepcopy(matrix(elem_in_algebra(basis(O, copy = false)[i], copy = false), copy = false)[1, j])
    end
  end
  M = _hnf!_integral(M, :upperright)
  M = sub(M, 1:n, 1:n)

  # Compute M * O * M^-1
  iM = inv(M)
  bb = Vector{elem_type(A)}()
  for i = 1:degree(O)
    push!(bb, M*elem_in_algebra(basis(O, copy = false)[i], copy = false)*iM)
  end

  simpleOrder = new_order(A, bb)
  simpleOrder.isnice = true

  @assert basis_matrix(simpleOrder) == identity_matrix(QQ, n^2)

  if with_transform
    return simpleOrder, A(M)
  else
    return simpleOrder
  end
end

function is_simple(O::AssociativeAlgebraOrder)
  return O.is_simple
end

@doc raw"""
    nice_order(O::AssociativeAlgebraOrder) -> AssociativeAlgebraOrder, AlgElem

Given a maximal order `O` in a full matrix algebra over the rationals, return a
nice maximal order `R` and element `a` such that `a O a^-1 = R`.
"""
function nice_order(O::AssociativeAlgebraOrder{S, T}) where {S, T}
  if isdefined(O, :nice_order)
    return O.nice_order::Tuple{typeof(O), elem_type(algebra(O))}
  else
    sO, A = _simple_maximal_order(O, Val(true))
    O.nice_order = sO, A
    return sO, A
  end
end

################################################################################
#
#  Conductor
#
################################################################################

@doc raw"""
    conductor(R::AssociativeAlgebraOrder, S::AssociativeAlgebraOrder, action::Symbol) -> AssociativeAlgebraOrderIdl

Returns the ideal $\{ x \in R \mid xS \subseteq R \}$ if `action == :right` and
$\{ x \in R \mid Sx \subseteq R \}$ if `action == :left`.
It is assumed that $R \subseteq S$.
"""
function conductor(R::AssociativeAlgebraOrder, S::AssociativeAlgebraOrder, action::Symbol = :left)
  n = degree(R)
  t = basis_matrix(R, copy = false)*basis_matrix_inverse(S, copy = false)
  @assert isone(denominator(t))
  basis_mat_R_in_S_inv_num, d = pseudo_inv(numerator(t))
  M = zero_matrix(ZZ, n^2, n)
  B = basis(S, copy = false)

  NN = transpose(representation_matrix(B[1], action)*basis_mat_R_in_S_inv_num)
  NNhnf = hnf(NN)
  H = add_to_hnf_from_matrix_stream(NNhnf, (transpose(representation_matrix(B[k], action) * basis_mat_R_in_S_inv_num) for k in 2:n))
  #for k in 1:n
  #  a = B[k]
  #  N = representation_matrix(a, action)*basis_mat_R_in_S_inv_num
  #  for i in 1:n
  #    for j in 1:n
  #      M[(k - 1)*n + i, j] = N[j, i]
  #    end
  #  end
  #end
  #HH = sub(hnf(M), 1:n, 1:n)
  #@assert H == HH
  Hinv = inv(QQMatrix(transpose(H)))
  Hinv = Hinv*basis_mat_R_in_S_inv_num*basis_matrix(R, copy = false)
  if action == :left
    return ideal(algebra(R), R, Hinv; side=:right)
  else
    return ideal(algebra(R), R, Hinv; side=:left)
  end
end

################################################################################
#
#  Units of quotients
#
################################################################################

# Computes a generating system of U in O, where U is a set of representatives of
# the image of the projection map \pi:O^\times -> (O/g*O)^\times.
# Assumes that O is a maximal order in Mat_{n\times n}(QQ).
# See Bley, Johnson: "Computing generators of free modules over orders in
# group algebras", section 6.
function enum_units(O::AssociativeAlgebraOrder{S, T}, g::ZZRingElem) where { S <: MatAlgebra, T }
  A = algebra(O)
  @assert _matdeg(A)^2 == dim(A)

  n = _matdeg(A)

  L = _simple_maximal_order(O)
  a = basis_matrix(L, copy = false)[dim(A) - 1, dim(A) - 1]
  ai = basis_matrix(L, copy = false)[n, n]

  result = Vector{elem_type(L)}()
  n1 = n - 1
  # n \nmid i, j or n \mid i, j
  for i = 1:n1
    for j = 1:n1
      if j == i
        continue
      end
      E = identity_matrix(QQ, n)
      E[i, j] = deepcopy(g)
      push!(result, L(A(E)))
    end
  end

  # n \nmid i and n \mid j
  for i = 1:n1
    E = identity_matrix(QQ, n)
    E[i, n] = deepcopy(a)
    push!(result, L(A(E)))
  end

  # n \mid i and n \nmid j
  for j = 1:n1
    E = identity_matrix(QQ, n)
    E[n, j] = deepcopy(ai)
    push!(result, L(A(E)))
  end

  E = identity_matrix(QQ, n)
  E[1, 1] = ZZRingElem(-1)
  push!(result, L(A(E)))
  return result
end

################################################################################
#
#  Trace dual ideal
#
################################################################################

function trace_dual(R::AssociativeAlgebraOrder)
  t = inv(QQ.(trred_matrix(R)))*basis_matrix(R, copy = false)
  return ideal(algebra(R), R, t)
end

################################################################################
#
#  "All" maximal orders
#
################################################################################

# # Only works for algebras fulfilling the Eichler condition.
# # This is trivial for algebras over QQ, as there is always just one equivalence
# # class with respect to conjugation.
# representatives_of_maximal_orders(A::StructureConstantAlgebra{QQFieldElem}) = representatives_of_maximal_orders(maximal_order(A))
#
# function representatives_of_maximal_orders(O::AssociativeAlgebraOrder)
#   A = algebra(O)
#   @assert is_simple(A)
#   @assert is_eichler(A)
#   @assert is_maximal(O)
#   return typeof(O)[ O ]
# end

################################################################################
#
#  Subset test
#
################################################################################

function is_subset(R::AssociativeAlgebraOrder, S::AssociativeAlgebraOrder)
  B = basis_matrix(R, copy = false) * basis_matrix_inverse(S, copy = false)
  return is_one(denominator(B))
end
