export is_invertible, contract, swan_module, is_subset_locally, is_equal_locally, lattice_with_local_conditions, primary_decomposition

@doc raw"""
    order(a::AlgAssAbsOrdIdl) -> AlgAssAbsOrd

Returns the order of which $a$ is a (possibly fractional) left or right ideal
if such an order is known.
"""
function order(a::AlgAssAbsOrdIdl)
  if isdefined(a, :order)
    return a.order
  else
    error("No order defined")
  end
end

@doc raw"""
    algebra(a::AlgAssAbsOrdIdl) -> AbsAlgAss

Returns the algebra containing $a$.
"""
algebra(a::AlgAssAbsOrdIdl) = a.algebra

_algebra(a::AlgAssAbsOrdIdl) = algebra(a)

# The basis matrix is (should be) in lowerleft HNF, so if the upper left corner
# is not zero, then the matrix has full rank.
is_full_lattice(a::AlgAssAbsOrdIdl) = !iszero(basis_matrix(a, copy = false)[1, 1])

# Whether I is equal to order(I)
function isone(I::AlgAssAbsOrdIdl)
  if !isone(denominator(I, order(I)))
    return false
  end
  return isone(norm(I, copy = false))
end

function one(I::AlgAssAbsOrdIdl)
  return ideal(order(I), one(order(I)))
end

function Base.copy(I::AlgAssAbsOrdIdl)
  return I
end

function is_full_rank(I::AlgAssAbsOrdIdl)
  @assert I.full_rank != 0
  return I.full_rank == 1
end

function _det_basis_matrix(I::AlgAssAbsOrdIdl)
  if isdefined(I, :det_basis_matrix)
    return I.det_basis_matrix
  else
    d = det(basis_matrix(I, copy = false))
    I.det_basis_matrix = d
    return d
  end
end

function _index(I::AlgAssAbsOrdIdl, O::AlgAssAbsOrd)
  return ZZ(_det_basis_matrix(I)//_det_basis_matrix(O))
end

################################################################################
#
#  Construction
#
################################################################################

@doc raw"""
    ideal(A::AbsAlgAss, M::FakeFmpqMat, M_in_hnf::Bool = false) -> AlgAssAbsOrdIdl

Returns the ideal in $A$ with basis matrix $M$.
If `M_in_hnf == true`, it is assumed that $M$ is already in lower left HNF.
"""
function ideal(A::AbsAlgAss{QQFieldElem}, M::FakeFmpqMat, M_in_hnf::Bool = false)
  if !M_in_hnf
    if false #is_square(M) && (dim(A) > 50 || sum(nbits, numerator(M)) > 1000)
      M = hnf(M, :lowerleft, compute_det = true)
    else
      M = hnf(M, :lowerleft)
    end
  end
  return AlgAssAbsOrdIdl{typeof(A), elem_type(A)}(A, M)
end

@doc raw"""
    ideal(A::AbsAlgAss, O::AlgAssAbsOrd, M::FakeFmpqMat, side::Symbol = :nothing,
          M_in_hnf::Bool = false)
      -> AlgAssAbsOrdIdl

Returns the ideal of $O$ in $A$ with basis matrix $M$ (in the basis of $A$).
If the ideal is known to be a right/left/twosided ideal of $O$, `side` may be
set to `:right`/`:left`/`:twosided` respectively.
If `M_in_hnf == true`, it is assumed that $M$ is already in lower left HNF.
"""
function ideal(A::AbsAlgAss{QQFieldElem}, O::AlgAssAbsOrd, M::FakeFmpqMat, side::Symbol = :nothing, M_in_hnf::Bool = false)
  a = ideal(A, M, M_in_hnf)
  a.order = O
  _set_sidedness(a, side)
  if is_maximal_known(O) && is_maximal(O)
    if side == :left || side == :twosided
      a.left_order = O
    end
    if side == :right || side == :twosided
      a.right_order = O
    end
  end
  return a
end

@doc raw"""
    ideal(O::AlgAssAbsOrd, x::AbsAlgAssElem) -> AlgAssAbsOrdIdl
    ideal(O::AlgAssAbsOrd, x::AlgAssAbsOrdElem) -> AlgAssAbsOrdIdl

Returns the twosided principal ideal of $O$ generated by $x$.
"""
function ideal(O::AlgAssAbsOrd{S, T}, x::T) where {S, T}
  A = algebra(O)
  @assert parent(x) === A
  if iszero(x)
    return _zero_ideal(A, O)
  end

  if is_commutative(O)
    a = ideal(O, x, :left)
    a.isright = 1
    return a
  end

  t1 = A()
  t2 = A()
  M = zero_matrix(FlintQQ, dim(A)^2, dim(A))
  b = basis_alg(O, copy = false)
  for i = 1:degree(O)
    t1 = mul!(t1, b[i], x)
    ii = (i - 1)*degree(O)
    for j = 1:degree(O)
      t2 = mul!(t2, t1, b[j])
      elem_to_mat_row!(M, ii + j, t2)
    end
  end
  M = sub(hnf(FakeFmpqMat(M), :lowerleft), nrows(M) - degree(O) + 1:nrows(M), 1:ncols(M))

  return ideal(A, O, M, :twosided, true)
end

ideal(O::AlgAssAbsOrd{S, T}, x::AlgAssAbsOrdElem{S, T}) where { S, T } = ideal(O, elem_in_algebra(x, copy = false))

@doc raw"""
    ideal(O::AlgAssAbsOrd, x::AbsAlgAssElem, side::Symbol) -> AlgAssAbsOrdIdl
    ideal(O::AlgAssAbsOrd, x::AlgAssAbsOrdElem, side::Symbol) -> AlgAssAbsOrdIdl

Returns the ideal $O \cdot x$ if `side == :left`, and $x \cdot O$ if
`side == :right`.
"""
function ideal(O::AlgAssAbsOrd{S, T}, x::T, side::Symbol) where { S, T }
  A = algebra(O)
  @assert parent(x) === A
  if iszero(x)
    return _zero_ideal(A, O)
  end
  if side == :twosided
    return ideal(O, x)
  end

  if side == :left
    M = basis_matrix(O)*FakeFmpqMat(representation_matrix(x, :right))
  elseif side == :right
    M = basis_matrix(O)*FakeFmpqMat(representation_matrix(x, :left))
  else
    error("Option :$(side) for side not implemented")
  end
  return ideal(A, O, M, side)
end

ideal(O::AlgAssAbsOrd{S, T}, x::AlgAssAbsOrdElem{S, T}, side::Symbol) where { S, T } = ideal(O, elem_in_algebra(x, copy = false), side)

@doc raw"""
    *(O::AlgAssAbsOrd, x::AbsAlgAssElem) -> AlgAssAbsOrdIdl
    *(O::AlgAssAbsOrd, x::AlgAssAbsOrdElem) -> AlgAssAbsOrdIdl
    *(O::AlgAssAbsOrd, x::Int) -> AlgAssAbsOrdIdl
    *(O::AlgAssAbsOrd, x::ZZRingElem) -> AlgAssAbsOrdIdl
    *(x::AbsAlgAssElem, O::AlgAssAbsOrd) -> AlgAssAbsOrdIdl
    *(x::AlgAssAbsOrdElem, O::AlgAssAbsOrd) -> AlgAssAbsOrdIdl
    *(x::Int, O::AlgAssAbsOrd) -> AlgAssAbsOrdIdl
    *(x::ZZRingElem, O::AlgAssAbsOrd) -> AlgAssAbsOrdIdl

Returns the ideal $O \cdot x$ or $x \cdot O$ respectively.
"""
*(O::AlgAssAbsOrd{S, T}, x::T) where {S, T <: Union{AlgAssElem, AlgMatElem, AlgGrpElem}} = ideal(O, x, :left)
*(x::T, O::AlgAssAbsOrd{S, T}) where {S, T <: Union{AlgAssElem, AlgMatElem, AlgGrpElem}} = ideal(O, x, :right)
*(O::AlgAssAbsOrd{S, T}, x::AlgAssAbsOrdElem{S, T}) where {S, T} = ideal(O, x, :left)
*(x::AlgAssAbsOrdElem{S, T}, O::AlgAssAbsOrd{S, T}) where {S, T} = ideal(O, x, :right)
*(O::AlgAssAbsOrd, x::Union{ Int, ZZRingElem }) = ideal(O, O(x), :left)
*(x::Union{ Int, ZZRingElem }, O::AlgAssAbsOrd) = ideal(O, O(x), :right)

@doc raw"""
    ideal_from_lattice_gens(A::AbsAlgAss, v::Vector{ <: AbsAlgAssElem })
      -> AlgAssAbsOrdIdl

Returns the ideal in $A$ generated by the elements of `v` as a
$\mathbb Z$-lattice.
"""
function ideal_from_lattice_gens(A::AbsAlgAss{QQFieldElem}, v::Vector{ <: AbsAlgAssElem{QQFieldElem} })
  M = zero_matrix(FlintQQ, max(length(v), dim(A)), dim(A))
  for i = 1:length(v)
    elem_to_mat_row!(M, i, v[i])
  end
  M = hnf(FakeFmpqMat(M), :lowerleft)
  if length(v) >= dim(A)
    M = sub(M, (nrows(M) - dim(A) + 1):nrows(M), 1:dim(A))
  end

  return ideal(A, M, true)
end

@doc raw"""
     ideal_from_lattice_gens(A::AbsAlgAss, O::AlgAssAbsOrd,
                             v::Vector{ <: AbsAlgAssElem},
                             side::Symbol = :nothing)
       -> AlgAssAbsOrdIdl

Returns the ideal of $O$ in $A$ generated by the elements of `v` as a
lattice over $\mathbb Z$.
If the ideal is known to be a right/left/twosided ideal of $O$, `side` may be
set to `:right`/`:left`/`:twosided` respectively.
"""
function ideal_from_lattice_gens(A::S, O::AlgAssAbsOrd{S, T}, v::Vector{T}, side::Symbol = :nothing) where { S <: AbsAlgAss{QQFieldElem}, T <: AbsAlgAssElem{QQFieldElem} }
  a = ideal_from_lattice_gens(A, v)
  a.order = O
  _set_sidedness(a, side)
  return a
end

###############################################################################
#
#  Zero ideal
#
###############################################################################

function _zero_ideal(A::AbsAlgAss{QQFieldElem})
  a = ideal(A, FakeFmpqMat(zero_matrix(FlintZZ, dim(A), dim(A)), ZZRingElem(1)), true)
  a.iszero = 1
  return a
end

function _zero_ideal(A::AbsAlgAss{QQFieldElem}, O::AlgAssAbsOrd)
  a = _zero_ideal(A)
  a.order = O
  _set_sidedness(a, :twosided)
  return a
end

function iszero(a::AlgAssAbsOrdIdl)
  if a.iszero == 0
    if is_zero_row(basis_matrix(a, copy = false).num, dim(algebra(a)))
      a.iszero = 1
    else
      a.iszero = 2
    end
  end
  return a.iszero == 1
end

###############################################################################
#
#  String I/O
#
###############################################################################

function show(io::IO, a::AlgAssAbsOrdIdl)
  print(io, "Ideal in ")
  show(IOContext(io, :compact => true), algebra(a))
  print(io, " with basis matrix\n")
  show(IOContext(io, :compact => true), basis_matrix(a, copy = false))
end

################################################################################
#
#  Deepcopy
#
################################################################################

function Base.deepcopy_internal(a::AlgAssAbsOrdIdl, dict::IdDict)
  b = typeof(a)(algebra(a))
  for i in fieldnames(typeof(a))
    if isdefined(a, i)
      if i != :algebra && i != :order && i != :right_order && i != :left_order && i != :basis_matrix_wrt && i != :norm && i != normred
        setfield!(b, i, Base.deepcopy_internal(getfield(a, i), dict))
      end
    end
  end
  if isdefined(a, :order)
    b.order = order(a)
  end
  if isdefined(a, :right_order)
    b.right_order = right_order(a)
  end
  if isdefined(a, :left_order)
    b.left_order = left_order(a)
  end
  for (O, M) in a.basis_matrix_wrt
    b.basis_matrix_wrt[O] = deepcopy(M)
  end
  for (O, n) in a.norm
    b.norm[O] = deepcopy(n)
  end
  for (O, n) in a.normred
    b.normred[O] = deepcopy(n)
  end

  return b
end

################################################################################
#
#  "Assure" functions for fields
#
################################################################################

function assure_has_basis(a::AlgAssAbsOrdIdl)
  if isdefined(a, :basis)
    return nothing
  end

  M = basis_matrix(a, copy = false)
  A = algebra(a)
  b = Vector{elem_type(A)}(undef, dim(A))
  for i = 1:dim(A)
    b[i] = elem_from_mat_row(A, M.num, i, M.den)
  end
  a.basis = b
  return nothing
end

function assure_has_basis_matrix_wrt(a::AlgAssAbsOrdIdl, O::AlgAssAbsOrd)
  if haskey(a.basis_matrix_wrt, O)
    return nothing
  end

  M = hnf(basis_matrix(a, copy = false)*basis_mat_inv(O, copy = false), :lowerleft)
  a.basis_matrix_wrt[O] = M
  return nothing
end

function assure_has_basis_mat_inv(a::AlgAssAbsOrdIdl)
  if isdefined(a, :basis_mat_inv)
    return nothing
  end
  @assert is_full_lattice(a) "The ideal is not a full lattice"
  a.basis_mat_inv = inv(basis_matrix(a, copy = false))
  return nothing
end

################################################################################
#
#  Basis (matrices)
#
################################################################################

@doc raw"""
    basis(a::AlgAssAbsOrdIdl; copy::Bool = true) -> Vector{AbsAlgAssElem}

Returns the basis of $a$.
"""
function basis(a::AlgAssAbsOrdIdl; copy::Bool = true)
  assure_has_basis(a)
  if copy
    return deepcopy(a.basis)
  else
    return a.basis
  end
end

absolute_basis(a::AlgAssAbsOrdIdl) = basis(a)

@doc raw"""
    basis_matrix(a::AlgAssAbsOrdIdl; copy::Bool = true) -> FakeFmpqMat

Returns the basis matrix of $a$ with respect to the basis of the algebra.
"""
function basis_matrix(a::AlgAssAbsOrdIdl; copy::Bool = true)
  if copy
    return deepcopy(a.basis_matrix)
  else
    return a.basis_matrix
  end
end

@doc raw"""
    basis_mat_inv(a::AlgAssAbsOrdIdl; copy::Bool = true) -> FakeFmpqMat

Returns the inverse of the basis matrix of $a$.
"""
function basis_mat_inv(a::AlgAssAbsOrdIdl; copy::Bool = true)
  assure_has_basis_mat_inv(a)
  if copy
    return deepcopy(a.basis_mat_inv)
  else
    return a.basis_mat_inv
  end
end

@doc raw"""
    basis_matrix_wrt(a::AlgAssAbsOrdIdl, O::AlgAssAbsOrd; copy::Bool = true)
      -> FakeFmpqMat

Returns the basis matrix of $a$ with respect to the basis of $O$.
"""
function basis_matrix_wrt(a::AlgAssAbsOrdIdl, O::AlgAssAbsOrd; copy::Bool = true)
  assure_has_basis_matrix_wrt(a, O)
  if copy
    return deepcopy(a.basis_matrix_wrt[O])
  else
    return a.basis_matrix_wrt[O]
  end
end

@doc raw"""
    integral_basis_matrix_wrt(a::AlgAssAbsOrdIdl, O::AlgAssAbsOrd;
                              copy::Bool = true)
      -> ZZMatrix

Returns the basis matrix of $a$ with respect to the basis of $O$ as an integral
matrix, assuming the ideal is contained in $O$.
"""
function integral_basis_matrix_wrt(a::AlgAssAbsOrdIdl, O::AlgAssAbsOrd; copy::Bool = true)
  M = basis_matrix_wrt(a, O, copy = copy)
  @assert isone(denominator(M, copy = false)) "Ideal is not integral"
  return numerator(M, copy = false)
end

################################################################################
#
#  Arithmetic
#
################################################################################

@doc raw"""
    +(a::AlgAssAbsOrdIdl, b::AlgAssAbsOrdIdl) -> AlgAssAbsOrdIdl

Returns $a + b$.
"""
function +(a::AlgAssAbsOrdIdl{S, T}, b::AlgAssAbsOrdIdl{S, T}) where {S, T}
  @assert algebra(a) === algebra(b)
  if iszero(a)
    return deepcopy(b)
  elseif iszero(b)
    return deepcopy(a)
  end

  d = dim(algebra(a))
  M = vcat(basis_matrix(a, copy = false), basis_matrix(b, copy = false))
  if all(i -> !iszero(M[i, i]), 1:d)
    M = sub(hnf(M, :lowerleft, triangular_top = true), (d + 1):2*d, 1:d)
  else
    M = sub(hnf(M, :lowerleft), (d + 1):2*d, 1:d)
  end
  c = ideal(algebra(a), M, true)
  if isdefined(a, :order) && isdefined(b, :order) && order(a) === order(b)
    c.order = order(a)
  end
  return c
end

function sum(a::Vector{AlgAssAbsOrdIdl{S, T}}) where {S, T}
  @req length(a) > 0 "Cannot sum zero ideals"
  if length(a) == 1
    return a[1]
  end

  mats = FakeFmpqMat[basis_matrix(I) for I in a]

  bigmat = reduce(vcat, mats)
  k = length(a)
  j = 1
  d = ncols(bigmat)

  g = ZZRingElem(0)
  for i in 1:k
    v = view(numerator(bigmat), j:(j + d - 1), 1:d)
    @assert is_lower_triangular(v)
    gg = reduce(*, diagonal(v), init = ZZRingElem(1))
    g = gcd(gg, g)
    j += d
  end
  if !iszero(g)
    M = sub(hnf_modular_eldiv(bigmat, g, :lowerleft), (nrows(bigmat) - d + 1):nrows(bigmat), 1:d)
  else
    M = sub(hnf(bigmat, :lowerleft), (nrows(bigmat) - d + 1):nrows(bigmat), 1:d)
  end

  c = ideal(algebra(a[1]), M, true)
  return c
end

global _matrix = []

@doc raw"""
    *(a::AlgAssAbsOrdIdl, b::AlgAssAbsOrdIdl) -> AlgAssAbsOrdIdl

Returns $a \cdot b$.
"""
function *(a::AlgAssAbsOrdIdl{S, T}, b::AlgAssAbsOrdIdl{S, T}) where {S, T}
  @assert algebra(a) === algebra(b)

  if iszero(a)
    return deepcopy(a)
  elseif iszero(b)
    return deepcopy(b)
  end

  A = algebra(a)
  d = dim(A)
  ba = basis(a, copy = false)
  bb = basis(b, copy = false)
  d2 = d^2

  # We do something more clever if the dimensio is too big
  M = zero_matrix(FlintQQ, d2, d)
  t = one(A)
  for i = 1:d
    i1d = (i - 1)*d
    for j = 1:d
      t = mul!(t, ba[i], bb[j])
      elem_to_mat_row!(M, i1d + j, t)
    end
  end

  _, oned = integral_split(coefficients(one(A)), ZZ)

  if is_full_rank(a) && is_full_rank(b)
    el = b.basis_matrix.den * a.eldiv_mul * a.basis_matrix.den * b.eldiv_mul * denominator_of_multiplication_table(A) * oned
    H = sub(hnf_modular_eldiv!(FakeFmpqMat(M), el), (d2 - d + 1):d2, 1:d)
    @hassert :AlgAssOrd 1 H == sub(hnf(FakeFmpqMat(M)), (d2 - d + 1):d2, 1:d)
  else
    H = sub(hnf(FakeFmpqMat(M)), (d2 - d + 1):d2, 1:d)
    #H = sub(__hnf(FakeFmpqMat(M)), (d2 - d + 1):d2, 1:d)
  end

  c = ideal(A, H, true)

  if _left_order_known_and_maximal(a)
    c.left_order = left_order(a)
  end
  if _right_order_known_and_maximal(b)
    c.right_order = right_order(b)
  end
  if isdefined(a, :order) && isdefined(b, :order) && order(a) === order(b)
    c.order = order(a)
  end

  return c
end

@doc raw"""
    ^(a::AlgAssAbsOrdIdl, e::Int) -> AlgAssAbsOrdIdl
    ^(a::AlgAssAbsOrdIdl, e::ZZRingElem) -> AlgAssAbsOrdIdl

Returns $a^e$.
"""
^(A::AlgAssAbsOrdIdl, e::Int) = Base.power_by_squaring(A, e)
^(A::AlgAssAbsOrdIdl, e::ZZRingElem) = Base.power_by_squaring(A, BigInt(e))

@doc raw"""
    intersect(a::AlgAssAbsOrdIdl, b::AlgAssAbsOrdIdl) -> AlgAssAbsOrdIdl

Returns $a \cap b$.
"""
function intersect(a::AlgAssAbsOrdIdl{S, T}, b::AlgAssAbsOrdIdl{S, T}) where {S, T}
  d = dim(algebra(a))
  M1 = hcat(basis_matrix(a, copy = false), basis_matrix(a, copy = false))
  M2 = hcat(FakeFmpqMat(zero_matrix(FlintZZ, d, d), ZZRingElem(1)), basis_matrix(b, copy = false))
  M = vcat(M1, M2)
  H = sub(hnf(M, :lowerleft), 1:d, 1:d)
  c = ideal(algebra(a), H, true)

  if isdefined(a, :order) && isdefined(b, :order) && order(a) === order(b)
    c.order = order(a)
  end
  return c
end

################################################################################
#
#  Ad hoc multiplication
#
################################################################################

@doc raw"""
    *(a::AlgAssAbsOrdIdl, x::Int) -> AlgAssAbsOrdIdl
    *(x::Int, a::AlgAssAbsOrdIdl) -> AlgAssAbsOrdIdl
    *(a::AlgAssAbsOrdIdl, x::ZZRingElem) -> AlgAssAbsOrdIdl
    *(x::ZZRingElem, a::AlgAssAbsOrdIdl) -> AlgAssAbsOrdIdl
    *(a::AlgAssAbsOrdIdl, x::QQFieldElem) -> AlgAssAbsOrdIdl
    *(x::QQFieldElem, a::AlgAssAbsOrdIdl) -> AlgAssAbsOrdIdl
    *(a::AlgAssAbsOrdIdl{S, T}, x::T) where { S, T } -> AlgAssAbsOrdIdl{S, T}
    *(x::T, a::AlgAssAbsOrdIdl{S, T}) where { S, T } -> AlgAssAbsOrdIdl{S, T}
    *(a::AlgAssAbsOrdIdl{S, T}, x::AlgAssAbsOrdElem{S, T}) where { S, T }
      -> AlgAssAbsOrdIdl{S, T}
    *(x::AlgAssAbsOrdElem{S, T}, a::AlgAssAbsOrdIdl{S, T}) where { S, T }
      -> AlgAssAbsOrdIdl{S, T}

Returns the ideal $a*x$ respectively $x*a$.
"""
function *(a::AlgAssAbsOrdIdl, x::Union{ Int, ZZRingElem, QQFieldElem })
  if iszero(x)
    return _zero_ideal(algebra(a))
  end
  b = ideal(algebra(a), x*basis_matrix(a, copy = false), true)
  if isdefined(a, :left_order)
    b.left_order = left_order(a)
  end
  if isdefined(a, :right_order)
    b.right_order = right_order(a)
  end
  if isdefined(a, :order)
    b.order = order(a)
  end
  return b
end

*(x::Union{ Int, ZZRingElem, QQFieldElem }, a::AlgAssAbsOrdIdl) = a*x

function *(a::AlgAssAbsOrdIdl{S, T}, x::T) where { S, T <: Union{AlgAssElem, AlgGrpElem, AlgMatElem} }
  if iszero(x)
    return _zero_ideal(algebra(a))
  end
  M = basis_matrix(a, copy = false)*FakeFmpqMat(representation_matrix(x, :right))
  b = ideal(algebra(a), M)
  if isdefined(a, :left_order)
    b.left_order = left_order(a)
  end
  return b
end

function *(x::T, a::AlgAssAbsOrdIdl{S, T}) where { S, T <: Union{AlgAssElem, AlgGrpElem, AlgMatElem}}
  if iszero(x)
    return _zero_ideal(algebra(a))
  end
  M = basis_matrix(a, copy = false)*FakeFmpqMat(representation_matrix(x, :left))
  b = ideal(algebra(a), M)
  if isdefined(a, :right_order)
    b.right_order = right_order(a)
  end
  return b
end

function *(a::AlgAssAbsOrdIdl{S, T}, x::AlgAssAbsOrdElem{S, T}) where { S, T }
  b = a*elem_in_algebra(x, copy = false)
  if isdefined(a, :order) && parent(x) === order(a) && is_right_ideal(a)
    b.order = order(a)
    b.isright = a.isright
    b.isleft = a.isleft
  end
  return b
end

function *(x::AlgAssAbsOrdElem{S, T}, a::AlgAssAbsOrdIdl{S, T}) where { S, T }
  b = elem_in_algebra(x, copy = false)*a
  if isdefined(a, :order) && parent(x) === order(a) && is_left_ideal(a)
    b.order = order(a)
    b.isright = a.isright
    b.isleft = a.isleft
  end
  return b
end

################################################################################
#
#  Inclusion of elements in ideals
#
################################################################################

@doc raw"""
    in(x::AbsAlgAssElem, a::AlgAssAbsOrdIdl) -> Bool
    in(x::AlgAssAbsOrdElem, a::AlgAssAbsOrdIdl) -> Bool

Returns `true` if $x$ is in $a$ and `false` otherwise.
"""
function in(x::T, a::AlgAssAbsOrdIdl{S, T}) where { S, T }
  parent(x) !== algebra(a) && error("Algebra of element and ideal must be equal")
  A = algebra(a)
  t = FakeFmpqMat(matrix(FlintQQ, 1, dim(A), coefficients(x, copy = false)))
  t = t*basis_mat_inv(a, copy = false)
  return denominator(t, copy = false) == 1
end

in(x::AlgAssAbsOrdElem{S, T}, a::AlgAssAbsOrdIdl{S, T}) where { S, T } = in(elem_in_algebra(x, copy = false), a)

################################################################################
#
#  Equality
#
################################################################################

@doc raw"""
    ==(a::AlgAssAbsOrdIdl, b::AlgAssAbsOrdIdl) -> Bool

Returns `true` if $a$ and $b$ are equal and `false` otherwise.
"""
function ==(a::AlgAssAbsOrdIdl{S, T}, b::AlgAssAbsOrdIdl{S, T}) where { S, T }
  algebra(a) !== algebra(b) && return false
  return basis_matrix(a, copy = false) == basis_matrix(b, copy = false)
end

################################################################################
#
#  isleft/isright
#
################################################################################

# functions is_right_ideal and is_left_ideal are in AlgAss/Ideal.jl

# This only works if a.order is defined, otherwise order(a) throws an error.
function _test_ideal_sidedness(a::AlgAssAbsOrdIdl, side::Symbol)
  O = order(a)
  return _test_ideal_sidedness(a, O, side)
end

function _test_ideal_sidedness(a::AlgAssAbsOrdIdl, O::AlgAssAbsOrd, side::Symbol)
  A = algebra(a)
  ba = basis(a, copy = false)
  bO = basis_alg(O, copy = false)
  t = A()
  for i = 1:dim(A)
    for j = 1:dim(A)
      if side == :left
        t = mul!(t, bO[i], ba[j])
      elseif side == :right
        t = mul!(t, ba[j], bO[i])
      else
        error("side must be either :left or :right")
      end
      if !(t in a)
        return false
      end
    end
  end
  return true
end

################################################################################
#
#  Ring of multipliers, left and right order
#
################################################################################

# Optimized version of ring_of_multipliers for the maximal order computation.
function _ring_of_multipliers_integral_ideal(I::AlgAssAbsOrdIdl, p::ZZRingElem = ZZRingElem(1))
  O = order(I)
  @hassert :AlgAssOrd 1 Hecke.check_associativity(algebra(O))
  @hassert :AlgAssOrd 1 Hecke.check_distributivity(algebra(O))
  if isdefined(I, :gens) && length(I.gens) < degree(O)
    B = I.gens
  else
    B = basis(I, copy = false)
  end
  m = zero_matrix(FlintZZ, degree(O)*length(B), degree(O))
  for i = 1:length(B)
    M = FakeFmpqMat(representation_matrix(B[i]))
    M = mul!(M, basis_matrix(O, copy = false), M)
    M = mul!(M, M, basis_mat_inv(I, copy = false))
    # M is now the representation matrix of B[i] as element of O multiplied
    # from the left by the inverse basis matrix of I in the basis of O.
    @hassert :AlgAssOrd 1 denominator(M, copy = false) == 1
    M = numerator(M, copy = false)
    for s = 1:degree(O)
      for t = 1:degree(O)
        m[t + (i - 1)*degree(O), s] = M[s, t]
      end
    end
  end
  # In the case of the p-radical, it is important to do this modulo p
  if p == 1
    m = hnf(m)
  else
    hnf_modular_eldiv!(m, p)
  end
  s = prod(ZZRingElem[m[i, i] for i = 1:ncols(m)])
  if s == 1
    return O
  end
  # n is upper right HNF
  n = transpose(view(m, 1:degree(O), 1:degree(O)))
  b = FakeFmpqMat(pseudo_inv(n))
  mul!(b, b, basis_matrix(O, copy = false))
  @hassert :AlgAssOrd 1 defines_order(algebra(O), b)[1]
  O1 = Order(algebra(O), b)
  O1.disc = divexact(discriminant(O), s^2)
  return O1
end

# This computes a basis matrix for \{ x \in A | bx \subseteq a \} if
# side == :left or \{ x \in A | xb \subseteq a \} if side == :right.
function _colon_raw(a::AlgAssAbsOrdIdl{S, T}, b::AlgAssAbsOrdIdl{S, T}, side::Symbol) where { S, T }
  @assert is_full_lattice(a) && is_full_lattice(b)
  A = algebra(a)
  @assert A === algebra(b)
  K = base_ring(A)
  d = dim(A)
  bb = basis(b, copy = false)
  B = QQMatrix(basis_mat_inv(a, copy = false))
  M = zero_matrix(FlintQQ, d^2, d)
  for i = 1:d
    N = representation_matrix(bb[i], side)*B
    for s = 1:d
      for t = 1:d
        M[t + (i - 1)*d, s] = N[s, t]
      end
    end
  end
  M = sub(hnf(FakeFmpqMat(M), :upperright), 1:d, 1:d)
  N = inv(transpose(M))
  return N
end

@doc raw"""
    ring_of_multipliers(a::AlgAssAbsOrdIdl) -> AlgAssAbsOrd

Given an ideal $a$, it returns the ring $(a : a)$.
"""
function ring_of_multipliers(a::AlgAssAbsOrdIdl, action::Symbol = :left)
  M = _colon_raw(a, a, action)
  return Order(algebra(a), hnf(M))
end

@doc raw"""
    left_order(a::AlgAssAbsOrdIdl) -> AlgAssAbsOrd

Returns the largest order of which $a$ is a left ideal, that is
$\{ x \in A \mid xa \subseteq a\}$.
"""
function left_order(a::AlgAssAbsOrdIdl)
  if isdefined(a, :left_order)
    return a.left_order
  end

  a.left_order = ring_of_multipliers(a, :right)
  return a.left_order
end

@doc raw"""
    right_order(a::AlgAssAbsOrdIdl) -> AlgAssAbsOrd

Returns the largest order of which $a$ is a right ideal, that is
$\{ x \in A \mid ax \subseteq a\}$.
"""
function right_order(a::AlgAssAbsOrdIdl)
  if isdefined(a, :right_order)
    return a.right_order
  end

  a.right_order = ring_of_multipliers(a, :left)
  return a.right_order
end

# Checks whether the left order is known and if it is known to be maximal
function _left_order_known_and_maximal(a::AlgAssAbsOrdIdl)
  if !isdefined(a, :left_order)
    return false
  end
  O = left_order(a)
  if is_maximal_known(O) && is_maximal(O)
    return true
  end
  return false
end

# Checks whether the right order is known and if it is known to be maximal
function _right_order_known_and_maximal(a::AlgAssAbsOrdIdl)
  if !isdefined(a, :right_order)
    return false
  end
  O = right_order(a)
  if is_maximal_known(O) && is_maximal(O)
    return true
  end
  return false
end

################################################################################
#
#  Norm
#
################################################################################

function assure_has_norm(a::AlgAssAbsOrdIdl{S, T}, O::AlgAssAbsOrd{S, T}) where { S, T }
  if haskey(a.norm, O)
    return nothing
  end

  a.norm[O] = abs(det(basis_matrix(a, copy = false))*det(basis_mat_inv(O, copy = false)))
  return nothing
end

@doc raw"""
    norm(a::AlgAssAbsOrdIdl, O::AlgAssAbsOrd; copy::Bool = true) -> QQFieldElem

Returns the norm of $a$ considered as an (possibly fractional) ideal of $O$.
"""
function norm(a::AlgAssAbsOrdIdl{S, T}, O::AlgAssAbsOrd{S, T}; copy::Bool = true) where { S, T }
  assure_has_norm(a, O)
  if copy
    return deepcopy(a.norm[O])
  else
    return a.norm[O]
  end
end

@doc raw"""
    norm(a::AlgAssAbsOrdIdl; copy::Bool = true) -> QQFieldElem

Returns the norm of $a$ considered as an (possibly fractional) ideal of
`order(a)`.
"""
norm(a::AlgAssAbsOrdIdl; copy::Bool = true) = norm(a, order(a), copy = copy)

function assure_has_normred(a::AlgAssAbsOrdIdl{S, T}, O::AlgAssAbsOrd{S, T}) where { S, T }
  if haskey(a.normred, O)
    return nothing
  end

  A = algebra(a)
  m = isqrt(dim(A))
  @assert m^2 == dim(A)
  N = norm(a, O, copy = false)
  b, n = is_power(N, m)
  @assert b "Cannot compute reduced norm. Maybe the algebra is not simple and central?"
  a.normred[O] = n
  return nothing
end

@doc raw"""
    normred(a::AlgAssAbsOrdIdl, O::AlgAssAbsOrd; copy::Bool = true) -> QQFieldElem

Returns the reduced norm of $a$ considered as an (possibly fractional) ideal
of $O$.
It is assumed that the algebra containing $a$ is simple and central.
"""
function normred(a::AlgAssAbsOrdIdl{S, T}, O::AlgAssAbsOrd{S, T}; copy::Bool = true) where { S, T }
  @assert is_simple(algebra(a)) && is_central(algebra(a)) "Only implemented for simple and central algebras"
  assure_has_normred(a, O)
  if copy
    return deepcopy(a.normred[O])
  else
    return a.normred[O]
  end
end

@doc raw"""
    normred(a::AlgAssAbsOrdIdl; copy::Bool = true) -> QQFieldElem

Returns the reduced norm of $a$ considered as an (possibly fractional) ideal
of `order(a)`.
"""
normred(a::AlgAssAbsOrdIdl; copy::Bool = true) = normred(a, order(a), copy = copy)

################################################################################
#
#  Locally free basis
#
################################################################################

@doc raw"""
    locally_free_basis(a::AlgAssAbsOrdIdl, p::Union{ Int, ZZRingElem })
      -> AlgAssAbsOrdElem

Returns an element $x$ of the order $O$ of $a$ such that $a_p = O_p \cdot x$
where $p$ is a prime of $\mathbb Z$.
See also `is_locally_free`.
"""
locally_free_basis(I::AlgAssAbsOrdIdl, p::Union{Int, ZZRingElem}; side::Symbol = :right) = locally_free_basis(order(I), I, p, side = side)

@doc raw"""
    locally_free_basis(O::AlgAssAbsOrd, a::AlgAssAbsOrdIdl,
                       p::Union{ Int, ZZRingElem }) -> AlgAssAbsOrdElem

Returns an element $x$ of $O$ such that $a_p = O_p \cdot x$ where $p$ is a
prime of $\mathbb Z$.
It is assumed that $a$ is an ideal of $O$ and $a \subseteq O$.
See also `is_locally_free`.
"""
function locally_free_basis(O::AlgAssAbsOrd, I::AlgAssAbsOrdIdl, p::Union{Int, ZZRingElem}; side::Symbol = :right)
  b, x = is_locally_free(O, I, p, side = side)
  if !b
    error("The ideal is not locally free at the prime")
  end
  return x
end

@doc raw"""
    is_locally_free(a::AlgAssAbsOrdIdl, p::Union{ Int, ZZRingElem })
      -> Bool, AlgAssAbsOrdElem

Returns a tuple `(true, x)` with an element $x$ of the order $O$ of $a$ such
that $a_p = O_p x$ if $a$ is locally free at $p$, and `(false, 0)` otherwise.
$p$ is a prime of $\mathbb Z$.
See also `locally_free_basis`.
"""
is_locally_free(I::AlgAssAbsOrdIdl, p::Union{Int,ZZRingElem}; side::Symbol = :right) = is_locally_free(order(I), I, p, side = side)

# See Bley, Wilson "Computations in relative algebraic K-groups", section 4.2
@doc raw"""
    is_locally_free(O::AlgAssAbsOrd, a::AlgAssAbsOrdIdl, p::ZZRingElem
                   side = :right) -> Bool, AlgAssAbsOrdElem

Returns a tuple `(true, x)` with an element $x$ of $O$ such that $a O_p = x
O_p$ resp. $O_p a = O_p x$ if $a$ is locally free right (resp. left) ideal at
$p$, and `(false, 0)` otherwise.  It is assumed that $a$ is an ideal of $O$ and
$a \subseteq O$.

See also `locally_free_basis`.
"""
function is_locally_free(O::AlgAssAbsOrd, I::AlgAssAbsOrdIdl, p::Union{Int, ZZRingElem}; side::Symbol = :right)
  b = _test_ideal_sidedness(I, O, side)
  !b && error("Ideal is not a $(side) ideal of the order")
  d = denominator(I, O)
  I = d * I
  if side === :left
    fl, alpha = _islocally_free_left(O, I, p)
  elseif side === :right
    B, mB = opposite_algebra(algebra(O))
    OB = mB(O)
    IB = mB(I)
    IB.order = mB(order(I))
    fl, x = _islocally_free_left(OB, IB, p)
    alpha = O(mB\elem_in_algebra(x))
  else
    error("side (:$(side)) must be either :left or :right")
  end
  if fl
    # d * I = alpha => I = x/alpha (locally at p)
    return fl, inv(QQ(d)) * elem_in_algebra(alpha)
  else
    return false, zero(algebra(O))
  end
end

function _islocally_free_left(O::AlgAssAbsOrd, I::AlgAssAbsOrdIdl, p::Union{Int, ZZRingElem})
  OpO, toOpO = AlgAss(O, p*O, p)
  J = radical(OpO)
  OJ, toOJ = quo(OpO, J)
  decOJ = decompose(OJ)
  basisIinO = [ O(b) for b in basis(I, copy = false) ]

  pI = p*I
  IpI, toIpI = AlgAss(I, p*I, p)
  gensJ = Vector{elem_type(IpI)}()
  for b in basis(J, copy = false)
    bb = toOpO\b
    for c in basisIinO
      push!(gensJ, toIpI(bb*c))
    end
  end
  JinIpI = ideal_from_gens(IpI, gensJ)
  IJ, toIJ = quo(IpI, JinIpI)

  a = O()
  for i = 1:length(decOJ)
    A, AtoOJ = decOJ[i]
    B, BtoA = _as_algebra_over_center(A)
    C, BtoC = _as_matrix_algebra(B)
    e = toOpO\(toOJ\(AtoOJ(BtoA(BtoC\C[1]))))
    basiseIJ = Vector{elem_type(IJ)}()
    for b in basisIinO
      bb = toIJ(toIpI(e*b))
      if !iszero(bb)
        push!(basiseIJ, bb)
      end
    end

    # Construct an Fq-basis for e*IJ where Fq \cong centre(A)
    Z, ZtoA = center(A)
    basisZ = elem_type(O)[ toOpO\(toOJ\(AtoOJ(ZtoA(Z[i])))) for i = 1:dim(Z) ]

    basiseIJoverZ = Vector{elem_type(O)}()
    M = zero_matrix(base_ring(IJ), dim(Z), dim(IJ))
    MM = zero_matrix(base_ring(IJ), 0, dim(IJ))
    r = 0
    for i = 1:length(basiseIJ)
      b = toIpI\(toIJ\basiseIJ[i])

      for j = 1:dim(Z)
        bb = toIJ(toIpI(basisZ[j]*b))
        elem_to_mat_row!(M, j, bb)
      end

      N = vcat(MM, M)
      s = rank(N)
      if s > r
        push!(basiseIJoverZ, b)
        MM = N
        r = s
      end
      if r == length(basiseIJ)
        break
      end
    end

    if length(basiseIJoverZ) != degree(C)
      # I is not locally free
      return false, O()
    end

    for i = 1:length(basiseIJoverZ)
      a += mod(toOpO\(toOJ\(AtoOJ(BtoA(BtoC\C[i]))))*basiseIJoverZ[i], pI)
    end
  end

  return true, mod(a, pI)
end

################################################################################
#
#  p-Radical
#
################################################################################

function pradical_meataxe(O::AlgAssAbsOrd, p::Int)
  A1, OtoA1 = quo(O, p*O, p)
  @vtime :AlgAssOrd 1 lg = gens(A1)
  lM = dense_matrix_type(base_ring(A1))[ transpose(representation_matrix(lg[i])) for i = 1:length(lg) ]
  M = Amodule(lM)
  ls = minimal_submodules(M)
  l = sum(nrows(x) for x in ls)
  M1 = zero_matrix(base_ring(A1), l, degree(O))
  i = 1
  for x in ls
    for j = 1:nrows(x)
      for k = 1:degree(O)
        M1[i, k] = x[j, k]
      end
      i += 1
    end
  end
  r = rref!(M1)
  if r == degree(O)
    J = ideal(algebra(O), O, p*basis_matrix(O, copy = false), :twosided)
    J.gens = elem_type(algebra(O))[ p*one(algebra(O)) ]
    return J
  end
  M1 = view(M1, 1:r, 1:degree(O))
  dM = transpose(nullspace(M1)[2])
  g = Vector{elem_type(algebra(O))}(undef, nrows(dM) + 1)
  m = zero_matrix(FlintZZ, degree(O), degree(O))
  for i = 1:nrows(dM)
    for j = 1:ncols(dM)
      m[i, j] = lift(dM[i, j])
    end
    g[i] = elem_in_algebra(elem_from_mat_row(O, m, i), copy = false)
  end
  m = hnf_modular_eldiv!(m, ZZRingElem(p))
  m = m*basis_matrix(O, copy = false)
  g[nrows(dM) + 1] = p*one(algebra(O))
  J = ideal(algebra(O), O, m, :twosided)
  J.gens = g
  return J
end

@doc raw"""
    pradical(O::AlgAssAbsOrd, p::Int) -> AlgAssAbsOrdIdl

Given an order $O$ and a prime $p$, it returns the radical of the ideal
generated by $p$.
"""
function pradical(O::AlgAssAbsOrd, p::Int)
  # See the paper from Ronyai, Structure of finite algebra
  l = clog(ZZRingElem(degree(O)), p)
  if l > 1
    return pradical_meataxe(O, p)
  end
  F = GF(p, cached = false)

  I = change_base_ring(F, trred_matrix(O))
  k, B = nullspace(I)
  # The columns of B give the coordinates of the elements in the order.
  if k == 0
    J = ideal(algebra(O), O, p*basis_matrix(O, copy = false), :twosided)
    J.gens = elem_type(algebra(O))[ p*one(algebra(O)) ]
    return J
  end
  # We have l == 1. In this case, we can output I: it is the standard p-trace
  # method.
  M = zero_matrix(FlintZZ, degree(O), degree(O))
  for i = 1:ncols(B)
    for j = 1:degree(O)
      M[i, j] = lift(B[j, i])
    end
  end
  M = hnf_modular_eldiv!(M, ZZRingElem(p)) # This puts p in the "missing" pivot entries
  M = M*basis_matrix(O, copy = false)
  res = ideal(algebra(O), O, M, :twosided)
  B1 = lift(transpose(B))
  res.gens = Vector{elem_type(algebra(O))}(undef, k + 1)
  for i = 1:k
    res.gens[i] = elem_in_algebra(elem_from_mat_row(O, B1, i), copy = false)
  end
  res.gens[k + 1] = p*one(algebra(O))
  return res
end

################################################################################
#
#  Primes lying over a prime
#
################################################################################

# Returns the twosided maximal ideals of O containing I, where p*O \subseteq I.
# If strict_containment == true and I is already prime, we return an empty array.
function _maximal_ideals(O::AlgAssAbsOrd, I::AlgAssAbsOrdIdl, p::Union{Int, ZZRingElem}; strict_containment::Bool = false)
  A1, OtoA1 = quo(O, I, p)
  @vtime :AlgAssOrd 1 lg = gens(A1)
  lM = dense_matrix_type(base_ring(A1))[ representation_matrix(lg[i]) for i = 1:length(lg) ]
  append!(lM, dense_matrix_type(base_ring(A1))[ representation_matrix(lg[i], :right) for i = 1:length(lg) ])
  M = Amodule(lM)
  ls = maximal_submodules(M)
  if strict_containment && isone(length(ls)) && iszero(nrows(ls[1]))
    ls = typeof(ls[1])[]
  end
  return typeof(I)[_from_submodules_to_ideals(M, O, I, x, A1, OtoA1) for x in ls ]
end

function _from_submodules_to_ideals(M::ModAlgAss, O::AlgAssAbsOrd, I::AlgAssAbsOrdIdl, x::Union{Zmodn_mat, Generic.Mat{Generic.ResidueFieldElem{ZZRingElem}}}, A1::AlgAss, OtoA1::AbsOrdToAlgAssMor)
  @hassert :AlgAssOrd 1 begin r = rref(x)[1]; closure(x, M.action_of_gens) == sub(rref(x)[2], 1:r, 1:ncols(x)) end
  m = zero_matrix(FlintZZ, nrows(x), degree(O))
  g = Vector{elem_type(algebra(O))}(undef, nrows(x))
  for i = 1:nrows(x)
    el = OtoA1\(elem_from_mat_row(A1, x, i))
    for j = 1:degree(O)
      m[i, j] = coordinates(el, copy = false)[j]
    end
    g[i] = elem_in_algebra(elem_from_mat_row(O, m, i), copy = false)
  end
  m = m*basis_matrix(O, copy = false)
  m = vcat(m, basis_matrix(I, copy = false))
  m = sub(hnf(m, :lowerleft), nrows(x) + 1:nrows(m), 1:degree(O))
  J = ideal(algebra(O), O, m, :twosided, true)
  if isdefined(I, :gens)
    append!(g, I.gens)
    J.gens = g
  else
    append!(g, basis(I, copy = false))
  end
  return J
end

@doc raw"""
    prime_ideals_over(O::AlgAssAbsOrd, p::Union{ Int, ZZRingElem })
      -> Vector{AlgAssAbsOrdIdl}

Returns all prime ideals of $O$ lying over the prime number $p$.
"""
function prime_ideals_over(O::AlgAssAbsOrd, p::Union{ Int, ZZRingElem })
  @vtime :AlgAssOrd 1 max_id = collect(_maximal_ideals(O, p*O, Int(p)))
  return max_id
end

@doc raw"""
    prime_ideals_over(O::AlgAssAbsOrd, P::AlgAssAbsOrdIdl)
      -> Vector{AlgAssAbsOrdIdl}

Given a prime ideal $P$ in an order contained in $O$, this function returns
the prime ideals of $O$ lying over $P$.
"""
function prime_ideals_over(O::AlgAssAbsOrd, P::AlgAssAbsOrdIdl)
  O1 = order(P)
  if O1 == O
    return ideal_type(O)[ P ]
  end
  M = maximal_order(O)
  lp = prime_ideals_over(M, minimum(P))
  p_critical_primes = Vector{ideal_type(O)}()
  for Q in lp
    c = contract(Q, O1)
    if c == P
      c1 = contract(Q, O)
      if !(c1 in p_critical_primes)
        push!(p_critical_primes, c1)
      end
    end
  end
  return p_critical_primes
end

################################################################################
#
#  Inverses
#
################################################################################

@doc raw"""
    inv(a::AlgAssAbsOrdIdl) -> AlgAssAbsOrdIdl

Returns an ideal $b$ in `algebra(a)` such that `a*b == left_order(a)`
and `b*a == right_order(b)`.
"""
function inv(a::AlgAssAbsOrdIdl)
  if isdefined(a, :right_order)
    O = right_order(a)
    M = _colon_raw(O(1)*O, a, :right)
  else
    O = left_order(a)
    M = _colon_raw(O(1)*O, a, :left)
  end
  b = ideal(algebra(a), M)
  if isdefined(a, :left_order)
    b.right_order = left_order(a)
  end
  if isdefined(a, :right_order)
    b.left_order = right_order(a)
  end
  if isdefined(a, :order)
    b.order = order(a)
  end
  return b
end

# Tests whether a is invertible in order(a)
function is_invertible(a::AlgAssAbsOrdIdl)
  if iszero(a)
    return false, a
  end

  bmata = basis_matrix(a, copy = false)

  # If a is zero in a component of algebra(a), then it cannot be invertible
  if any(iszero(bmata[i, i]) for i in 1:degree(order(a)))
    return false, a
  end

  if order(a).is_maximal == 1
    return true, inv(a)
  end

  b = inv(a)
  c = a*b
  return isone(c), b
end

################################################################################
#
#  Divexact
#
################################################################################

@doc raw"""
    divexact_left(a::AlgAssAbsOrdIdl, b::AlgAssAbsOrdIdl) -> AlgAssAbsOrdIdl

Returns an ideal $c$ such that $a = b \cdot c$.
"""
function divexact_left(a::AlgAssAbsOrdIdl{S, T}, b::AlgAssAbsOrdIdl{S, T}) where { S, T }
  @assert algebra(a) === algebra(b)
  M = _colon_raw(a, b, :left)
  c = ideal(algebra(a), M)

  if _right_order_known_and_maximal(a)
    c.right_order = right_order(a)
  end
  if _right_order_known_and_maximal(b)
    c.left_order = right_order(b)
  end

  return c
end

@doc raw"""
    divexact_right(a::AlgAssAbsOrdIdl, b::AlgAssAbsOrdIdl) -> AlgAssAbsOrdIdl

Returns an ideal $c$ such that $a = c \cdot b$.
"""
function divexact_right(a::AlgAssAbsOrdIdl{S, T}, b::AlgAssAbsOrdIdl{S, T}) where { S, T }
  @assert algebra(a) === algebra(b)
  M = _colon_raw(a, b, :right)
  c = ideal(algebra(a), M)

  if _left_order_known_and_maximal(a)
    c.left_order = left_order(a)
  end
  if _left_order_known_and_maximal(b)
    c.right_order = left_order(b)
  end

  return c
end

colon(a::AlgAssAbsOrdIdl{S, T}, b::AlgAssAbsOrdIdl{S, T}) where { S, T } = divexact_right(a, b)

################################################################################
#
#  Denominator / Numerator
#
################################################################################

# copy doesn't do anything (yet?)
@doc raw"""
    denominator(a::AlgAssAbsOrdIdl, O::AlgAssAbsOrd) -> ZZRingElem

Returns the smallest positive integer $d$ such that $da$ is contained in $O$.
"""
function denominator(a::AlgAssAbsOrdIdl{S, T}, O::AlgAssAbsOrd{S, T}; copy::Bool = true) where { S, T }
  @assert algebra(a) === algebra(O)
  if iszero(a)
    return ZZRingElem(1)
  end

  M = basis_matrix(a, copy = false)*basis_mat_inv(O, copy = false)
  return denominator(M, copy = false)
end

@doc raw"""
    denominator(a::AlgAssAbsOrdIdl) -> ZZRingElem

Returns the smallest positive integer $d$ such that $da$ is contained in
`order(a)`.
"""
denominator(a::AlgAssAbsOrdIdl; copy::Bool = true) = denominator(a, order(a), copy = copy)

# copy doesn't do anything (yet?)
function numerator(a::AlgAssAbsOrdIdl{S, T}, O::AlgAssAbsOrd{S, T}; copy::Bool = true) where { S, T }
  return denominator(a, O)*a
end

numerator(a::AlgAssAbsOrdIdl; copy::Bool = true) = numerator(a, order(a), copy = copy)

################################################################################
#
#  Ideal Set
#
################################################################################

function show(io::IO, a::AlgAssAbsOrdIdlSet)
  print(io, "Set of ideals of $(order(a))\n")
end

order(a::AlgAssAbsOrdIdlSet) = a.order

parent(I::AlgAssAbsOrdIdl) = AlgAssAbsOrdIdlSet(order(I))

function IdealSet(O::AlgAssAbsOrd)
   return AlgAssAbsOrdIdlSet(O)
end

FracIdealSet(O::AlgAssAbsOrd) = IdealSet(O)

elem_type(::Type{AlgAssAbsOrdIdlSet{S, T}}) where {S, T} = AlgAssAbsOrdIdl{S, T}

elem_type(::AlgAssAbsOrdIdlSet{S, T}) where {S, T} = AlgAssAbsOrdIdl{S, T}

parent_type(::Type{AlgAssAbsOrdIdl{S, T}}) where {S, T} = AlgAssAbsOrdIdlSet{S, T}

function Base.one(S::AlgAssAbsOrdIdlSet)
  return ideal(order(S), one(order(S)))
end

==(x::AlgAssAbsOrdIdlSet, y::AlgAssAbsOrdIdlSet) = x.order === y.order

################################################################################
#
#  Extend/contract
#
################################################################################

@doc raw"""
    extend(a::AlgAssAbsOrdIdl, O::AlgAssAbsOrd) -> AlgAssAbsOrdIdl

Returns $O \cdot a \cdot O$.
It is assumed that the order of $a$ is contained in $O$.
"""
function extend(A::AlgAssAbsOrdIdl{S, T}, O::AlgAssAbsOrd{S, T}, action::Symbol = :twosided) where S where T
  if action == :left || action == :twosided
    A = (O(1)*O)*A
  end
  if action == :right || action == :twosided
    A = A*(O(1)*O)
  end
  A.order = O
  return A
end

@doc raw"""
    *(a::AlgAssAbsOrdIdl, O::AlgAssAbsOrd) -> AlgAssAbsOrdIdl
    *(O::AlgAssAbsOrd, a::AlgAssAbsOrdIdl) -> AlgAssAbsOrdIdl

Returns $a \cdot O$ or $O \cdot a$ respectively.
It is assumed that the order of $a$ is contained in $O$.
"""
*(A::AlgAssAbsOrdIdl, O::AlgAssAbsOrd) = extend(A, O, :right)
*(O::AlgAssAbsOrd, A::AlgAssAbsOrdIdl) = extend(A, O, :left)

@doc raw"""
    contract(a::AlgAssAbsOrdIdl, O::AlgAssAbsOrd) -> AlgAssAbsOrdIdl
    intersect(a::AlgAssAbsOrdIdl, O::AlgAssAbsOrd) -> AlgAssAbsOrdIdl
    intersect(O::AlgAssAbsOrd, a::AlgAssAbsOrdIdl) -> AlgAssAbsOrdIdl

Returns $a \cap O$.
It is assumed that the order of $a$ contains $O$.
"""
function contract(A::AlgAssAbsOrdIdl, O::AlgAssAbsOrd)
  # Assumes O \subseteq order(A)

  d = degree(O)
  M1 = hcat(basis_matrix(A, copy = false), basis_matrix(A, copy = false))
  M2 = hcat(FakeFmpqMat(zero_matrix(FlintZZ, d, d), ZZRingElem(1)), basis_matrix(O, copy = false))
  M = vcat(M1, M2)
  H = sub(hnf(M, :lowerleft), 1:d, 1:d)
  return ideal(algebra(A), O, H, :nothing, true)
end

intersect(O::AlgAssAbsOrd, A::AlgAssAbsOrdIdl) = contract(A, O)
intersect(A::AlgAssAbsOrdIdl, O::AlgAssAbsOrd) = contract(A, O)

# Returns I as an ideal with order O. Mostly for compatibility with NfAbsOrdIdl.
function _as_fractional_ideal_of_smaller_order(O::AlgAssAbsOrd, I::AlgAssAbsOrdIdl)
  return ideal(algebra(O), O, basis_matrix(I))
end

################################################################################
#
#  Move ideals to another algebra
#
################################################################################

# Let m: A -> B be an injection and I an ideal in B. Then this computes the
# ideal O_A\cap I, where O_A is the maximal order of A.
function _as_ideal_of_smaller_algebra(m::AbsAlgAssMor, I::AlgAssAbsOrdIdl)
  A = domain(m)
  B = codomain(m)
  @assert dim(A) <= dim(B)
  @assert algebra(I) === B
  OA = maximal_order(A)
  # Transport OA to B
  M = zero_matrix(FlintQQ, dim(B), dim(B))
  for i = 1:dim(A)
    t = m(basis_alg(OA, copy = false)[i])
    elem_to_mat_row!(M, i, t)
  end
  # Compute the intersection of M and I
  M = FakeFmpqMat(M)
  M1 = hcat(M, M)
  M2 = hcat(FakeFmpqMat(zero_matrix(FlintZZ, dim(B), dim(B)), ZZRingElem(1)), basis_matrix(I, copy = false))
  N = sub(hnf(vcat(M1, M2), :lowerleft), 1:dim(B), 1:dim(B))
  # Map the basis to A
  basis_in_A = Vector{elem_type(A)}(undef, dim(B))
  for i = 1:dim(B)
    t = elem_from_mat_row(B, N.num, i, N.den)
    b, s = haspreimage(m, t)
    @assert b
    basis_in_A[i] = s
  end
  J = ideal_from_lattice_gens(A, OA, basis_in_A)
  return J
end

# Let m: A -> B be an injection and O an order in B. Then this computes the
# order O_A\cap O, where O_A is the maximal order of A.
function _as_order_of_smaller_algebra(m::AbsAlgAssMor, O::AlgAssAbsOrd, OB::AlgAssAbsOrd)
  A = domain(m)
  B = codomain(m)
  @assert dim(A) <= dim(B)
  @assert algebra(O) == B
  OA = maximal_order(A)
  # Transport OA to B
  M = zero_matrix(FlintZZ, dim(B), dim(B))
  for i = 1:dim(A)
    t = OB(m(basis_alg(OA, copy = false)[i]))
    elem_to_mat_row!(M, i, t)
  end
  # Compute the intersection of M and O (in OB)
  N = basis_matrix(O, copy = false)*basis_mat_inv(OB, copy = false)
  @assert N.den == 1
  H = vcat(M, N.num)
  K = left_kernel(H)[2]
  N = sub(K, 1:dim(B), 1:dim(B))*M
  # Map the basis to A
  basis_in_A = Vector{elem_type(A)}(undef, dim(B))
  for i = 1:dim(B)
    t = elem_from_mat_row(OB, N, i)
    b, s = haspreimage(m, elem_in_algebra(t, copy = false))
    @assert b
    basis_in_A[i] = s
  end
  M = zero_matrix(base_ring(A), length(basis_in_A), dim(A))
  for i = 1:length(basis_in_A)
    elem_to_mat_row!(M, i, basis_in_A[i])
  end
  M = FakeFmpqMat(M)
  MM = sub(hnf!(M, :lowerleft), (dim(B) - dim(A) + 1):dim(B), 1:dim(A))
  OO = Order(A, MM)
  return OO
end

# Let m: A -> B be an injection, I an ideal in A and O an order of B. Then this
# computes I*O.
# WE ASSUME THAT m(A) LIES IN THE CENTRE OF B!
function _as_ideal_of_larger_algebra(m::AbsAlgAssMor, I::AlgAssAbsOrdIdl, O::AlgAssAbsOrd)
  A = domain(m)
  B = codomain(m)
  @assert dim(A) <= dim(B)
  @assert algebra(I) == A
  @assert algebra(O) == B

  M = zero_matrix(FlintQQ, dim(A)*dim(B), dim(B))
  X = elem_type(B)[ m(b) for b in basis(I, copy = false) ]
  for i = 1:dim(A)
    for j = 1:dim(B)
      t = X[i]*basis_alg(O, copy = false)[j]
      elem_to_mat_row!(M, (i - 1)*dim(B) + j, t)
    end
  end
  M = sub(hnf(FakeFmpqMat(M), :lowerleft), dim(B)*(dim(A) - 1) + 1:dim(A)*dim(B), 1:dim(B))
  return ideal(B, O, M, :nothing, true)
end

################################################################################
#
#  Hashing
#
################################################################################

function Base.hash(A::AlgAssAbsOrdIdl, h::UInt)
  return Base.hash(basis_matrix(A, copy = false), h)
end

################################################################################
#
#  Idempotents
#
################################################################################

@doc raw"""
    idempotents(a::AlgAssAbsOrdIdl, b::AlgAssAbsOrdIdl)
      -> AlgAssAbsOrdElem, AlgAssAbsOrdElem

Given coprime integral ideals $a$ and $b$, this function returns elements
$x \in a$ and $y \in b$ such that $x + y = 1$.
"""
function idempotents(a::AlgAssAbsOrdIdl, b::AlgAssAbsOrdIdl)
  !(order(a) === order(b)) && error("Orders do not coincide")
  O = order(a)
  d = degree(O)

  V = zero_matrix(FlintZZ, 1 + 2*degree(O), 1 + 2*degree(O))
  V[1, 1] = 1
  u = coordinates(one(O))
  for i = 1:d
    V[1, i + 1] = u[i]
  end

  mata = integral_basis_matrix_wrt(a, O, copy = false)
  matb = integral_basis_matrix_wrt(b, O, copy = false)

  _copy_matrix_into_matrix(V, 2, 2, mata)
  _copy_matrix_into_matrix(V, 2 + d, 2, matb)
  for i = 2:d + 1
    V[i, d + i] = 1
  end

  if is_full_rank(a) || is_full_rank(b)
    eldiv = lcm(_index(a, O), _index(b, O))
    H = hnf_modular_eldiv!(V, eldiv)
  else
    H = hnf!(V)
  end

  for i = 2:d + 1
    if !iszero(H[1, i])
      error("Ideals are not coprime")
    end
  end

  v = sub(H, 1:1, d + 2:2*d + 1)*mata
  z = O([ v[1, i] for i = 1:d ])

  @hassert :AlgAssOrd -z in a
  @hassert :AlgAssOrd one(O) + z in b
  return -z, one(O) + z
end

################################################################################
#
#  From algebra to number field
#
################################################################################

function _as_ideal_of_number_field(I::AlgAssAbsOrdIdl, m::AbsAlgAssToNfAbsMor)
  @assert algebra(order(I)) == domain(m)
  K = codomain(m)
  OK = maximal_order(K)

  b = Vector{elem_type(OK)}()
  for i = 1:dim(domain(m))
    push!(b, OK(m(basis(I, copy = false)[i])))
  end
  return ideal_from_z_gens(OK, b)
end

function _as_ideal_of_number_field(I::FacElem{ <: AlgAssAbsOrdIdl, <: AlgAssAbsOrdIdlSet}, m::AbsAlgAssToNfAbsMor)
  @assert algebra(order(base_ring(parent(I)))) == domain(m)
  K = codomain(m)
  OK = maximal_order(K)

  if isempty(I)
    return FacElemMon(IdealSet(OK))()
  end

  bases = Vector{ideal_type(OK)}()
  exps = Vector{ZZRingElem}()
  for (b, e) in I
    push!(bases, _as_ideal_of_number_field(b, m))
    push!(exps, e)
  end
  return FacElem(bases, exps)
end

function _as_ideal_of_algebra(I::NfAbsOrdIdl, i::Int, O::AlgAssAbsOrd, one_ideals::Vector{Vector{T}}) where { T <: AbsAlgAssElem }
  A = algebra(O)
  fields_and_maps = as_number_fields(A)
  b = Vector{elem_type(A)}()
  for j = 1:length(fields_and_maps)
    K, AtoK = fields_and_maps[j]
    if j == i
      @assert nf(order(I)) == K
      append!(b, [ AtoK\K(bb) for bb in basis(I, copy = false) ])
    else
      append!(b, one_ideals[j])
    end
  end
  return ideal_from_lattice_gens(algebra(O), O, b, :twosided)
end

function _as_ideal_of_algebra(I::FacElem{NfOrdIdl, NfOrdIdlSet}, i::Int, O::AlgAssAbsOrd, one_ideals::Vector{Vector{T}}) where { T <: AbsAlgAssElem }
  if isempty(I)
    return FacElemMon(IdealSet(O))()
  end

  base = Vector{ideal_type(O)}()
  exp = Vector{ZZRingElem}()
  for (b, e) in I
    push!(base, _as_ideal_of_algebra(b, i, O, one_ideals))
    push!(exp, e)
  end
  return FacElem(base, exp)
end

# Returns an array of bases of the ideals O_i(1)*O_i lifted to O, where O_i
# are the maximal orders of the number fields in the decomposition of
# algebra(O).
function _lift_one_ideals(O::AlgAssAbsOrd)
  A = algebra(O)
  fields_and_maps = as_number_fields(A)

  one_ideals = Vector{Vector{elem_type(A)}}()
  for i = 1:length(fields_and_maps)
    K, AtoK = fields_and_maps[i]
    OK = maximal_order(K)
    a = OK(1)*OK
    b = Vector{elem_type(A)}()
    for i = 1:degree(K)
      push!(b, AtoK\K(basis(a, copy = false)[i]))
    end
    push!(one_ideals, b)
  end
  return one_ideals
end

################################################################################
#
#  Factorization
#
################################################################################

@doc raw"""
    factor(I::AlgAssAbsOrdIdl) -> Dict{AlgAssAbsOrdIdl, Int}

Assumes that `algebra(A)` is commutative.
Returns the prime ideal factorization of $I$ as a dictionary.
"""
function factor(I::AlgAssAbsOrdIdl)
  @assert is_commutative(algebra(I))
  O = order(I)
  @hassert :AlgAssOrd ismaximal(O)
  A = algebra(O)
  fields_and_maps = as_number_fields(A)
  @hassert :AlgAssOrd _test_ideal_sidedness(I, O, :left)
  @hassert :AlgAssOrd _test_ideal_sidedness(I, O, :right)

  one_ideals = _lift_one_ideals(O)

  fac = Dict{ideal_type(O), Int}()
  for i = 1:length(fields_and_maps)
    K, AtoK = fields_and_maps[i]
    J = _as_ideal_of_number_field(I, AtoK)
    fac2 = factor(J)
    for (p, e) in fac2
      P = _as_ideal_of_algebra(p, i, O, one_ideals)
      fac[P] = e
    end
  end
  return fac
end

################################################################################
#
#  Normal ideals
#
################################################################################

@doc raw"""
    is_normal(a::AlgAssAbsOrdIdl) -> Bool

Returns `true` if $a$ is a normal ideal and `false` otherwise.
"""
is_normal(a::AlgAssAbsOrdIdl) = is_maximal(left_order(a))

################################################################################
#
#  Minimum
#
################################################################################

@attr ZZRingElem function minimum(P::AlgAssAbsOrdIdl)
  M = basis_mat_inv(P, copy = false)
  v = FakeFmpqMat(matrix(FlintQQ, 1, nrows(M), coefficients(one(algebra(P)))))
  m = denominator(v * M)
  return m
end

################################################################################
#
#  Random elements
#
################################################################################

RandomExtensions.maketype(P::AlgAssAbsOrdIdl, ::Int) = elem_type(algebra(P))

function rand(rng::AbstractRNG,
              sp::SamplerTrivial{<:Make2{<:RingElem,<:AlgAssAbsOrdIdl,Int}})
  a, B = sp[][1:end]
  r = rand(rng, -B:B, dim(algebra(a)))
  b = basis(a, copy = false)
  z = algebra(a)()
  t = algebra(a)()
  for i = 1:dim(algebra(a))
    t = mul!(t, r[i], b[i])
    z = add!(z, z, t)
  end
  return z
end

rand(a::AlgAssAbsOrdIdl, B::Int) = rand(Random.GLOBAL_RNG, a, B)
rand(rng::AbstractRNG, a::AlgAssAbsOrdIdl, B::Int) = rand(rng, make(a, B))

################################################################################
#
#  Coprime representative
#
################################################################################

# Returns x \in A with Ix + a*O == O and Ix \subseteq O.
function integral_coprime_representative(O::AlgAssAbsOrd, I::AlgAssAbsOrdIdl, a::ZZRingElem)
  A = algebra(O)
  d = denominator(I, O)
  I = d*I

  if one(O) in I + a*O
    return one(A)*d
  end

  fac_a = factor(a)
  primes = collect(keys(fac_a.fac))
  q = prod(primes)

  x = A()
  for i = 1:length(primes)
    p = primes[i]
    z = divexact(q, p)
    if one(O) in I + p*O
      # I is already coprime to this prime
      x += A(z)
      continue
    end
    b, g = is_locally_free(O, I, p)
    @assert b "No local generator found for $p"
    ig = inv(elem_in_algebra(g, copy = false))
    Ig = I*ig
    y = denominator(Ig, O)
    @assert valuation(y, p) == 0
    x += ig*y*z
  end
  return x*d
end

################################################################################
#
#  Maximal integral ideals
#
################################################################################

# Computes any maximal integral ideal with left order O (if side = :left) or
# right order O (if side = :right) which contains p.
# Assumes (so far?) that the algebra is simple and O is maximal.
function maximal_integral_ideal(O::AlgAssAbsOrd, p::Union{ ZZRingElem, Int }, side::Symbol)
  A = algebra(O)
  @assert is_simple(A)
  @assert is_maximal(O)

  P = prime_ideals_over(O, p)[1] # if the algebra is simple, then there is exactly one prime lying over p

  # P is the Jacobson radical of O/pO, so O/P is a simple algebra
  B, OtoB = quo(O, P, p)
  C, CtoB = _as_algebra_over_center(B)
  D, CtoD = _as_matrix_algebra(C)

  n = degree(D)
  if isone(n)
    return P
  end

  N = QQMatrix(basis_matrix(P))
  t = zero_matrix(FlintQQ, 1, degree(O))
  # Now we only need to lift a basis for diag(1, ..., 1, 0)*D (side = :left) or
  # D*diag(1, ..., 1, 0) (side = :right) since these are maximal ideals of D.
  if side == :left
    jMax = n - 1
    iMax = n
  elseif side == :right
    jMax = n
    iMax = n - 1
  else
    error("Option :$(side) for side not implemented")
  end
  for j = 1:jMax
    jn = (j - 1)*n
    for i = 1:iMax
      b = (OtoB\(CtoB(CtoD\D[jn + i])))
      elem_to_mat_row!(t, 1, elem_in_algebra(b, copy = false))
      N = vcat(N, deepcopy(t))
    end
  end
  N = FakeFmpqMat(N)
  N = sub(hnf(N, :lowerleft), nrows(N) - degree(O) + 1:nrows(N), 1:degree(O))

  M = ideal(algebra(O), O, N, side, true)
  if side == :left
    M.left_order = O # O is maximal
  else
    M.right_order = O
  end
  return M
end

# Constructs a maximal integral ideal M of O such that M\cap R = p and I\subseteq M,
# where O is the left order (if side = :left) or right order (if side = :right)
# of I. It is assumed that I \subseteq O.
# M is a left ideal of O if side = :left and a right ideal if side = :right.
# Assumes (so far?) that the algebra is simple and O is maximal.
function maximal_integral_ideal_containing(I::AlgAssAbsOrdIdl, p::Union{ ZZRingElem, Int }, side::Symbol)
  if side == :left
    O = left_order(I)
  elseif side == :right
    O = right_order(I)
  else
    error("Option :$(side) for side not implemented")
  end

  @assert is_simple(algebra(O))
  @assert is_maximal(O)

  n = normred(I, O)
  if valuation(n, p) == 0
    error("Cannot find a maximal ideal for the given prime")
  end
  if n == p
    # The ideal is maximal iff its reduced norm is prime
    return I
  end

  P = prime_ideals_over(O, p)[1] # if the algebra is simple, then there is exactly one prime lying over p
  J = I + P
  if normred(J, O) == p
    return J
  end

  OP, toOP = quo(O, P, p)
  B, BtoOP = _as_algebra_over_center(OP)
  C, toC = _as_matrix_algebra(B)

  JinC = ideal_from_gens(C, [ toC(OPtoB(toOP(O(b)))) for b in absolute_basis(J) ])
  y = left_principal_generator(JinC)
  m = matrix(y)
  r = rref!(m)
  k = degree(C)
  @assert r < k - 1 # Otherwise J would be maximal, which we have checked...

  # We need to "add" pivots to m to get rank k - 1
  row = 1
  col = 1
  while r < k - 1
    if !iszero(m[row, col])
      row += 1
      continue
    end

    r += 1
    m[r, col] = 1
    col += 1
  end
  @assert rank(m) == k - 1
  if side == :left
    c = C*C(m)
  else
    c = C(m)*C
  end
  basis_c = basis(c, copy = false)

  t = zero_matrix(FlintQQ, length(basis_c), degree(O))
  for i = 1:length(basis_c)
    b = toOP\(BtoOP(toC\(basis_c[i])))
    elem_to_mat_row!(t, i, elem_in_algebra(b, copy = false))
  end
  m = hnf(vcat(basis_matrix(P), FakeFmpqMat(t)), :lowerleft)
  m = sub(m, length(basis_c) + 1:nrows(m), 1:ncols(m))

  M = ideal(algebra(O), O, m, side, true)
  @assert normred(M, O) == p
  if side == :left
    M.left_order = O # O is maximal
  else
    M.right_order = O
  end

  return M
end

################################################################################
#
#  Swan module
#
################################################################################

function swan_module(R::AlgAssAbsOrd{<: AlgGrp}, r::IntegerUnion)
  A = algebra(R)
  n = order(group(A))
  @req is_coprime(n, r) "Argument must be coprime to group order"
  N = sum(basis(A))
  return N * R + r * R
end

################################################################################
#
#  Subset test
#
################################################################################

function is_subset(R::AlgAssAbsOrdIdl, S::AlgAssAbsOrd)
  B = basis_matrix(R, copy = false) * basis_mat_inv(S, copy = false)
  return is_one(denominator(B))
end

################################################################################
#
#  Lattices with prescribed local behavior
#
################################################################################

# Given X^(p) inside A and R, I want M such that M_p = X^(p)_p and M_q = R_q
# outside the p.
# We first reduce to the case where all X^(p) are contained R.
#
# Then we can reduce to the case that X^(p)_q >= M_q for all q != p.
# Once we have this, we can just intersect the X.

@doc raw"""
    lattice_with_local_conditions(O::AlgAssAbsOrd,
                                  ps::Vector{<: IntegerUnion},
                                  Is::Vector{<: AlgAssAbsOrdIdl})
                                                              -> AlgAssAbsOrdIdl

Given an order $\mathcal{O}$, a list of primes `ps` and a list of lattices `Is`,
return a lattice $M$ such that $M_{p} = I_p$ for the primes $p$ and lattices $I$
in the given lists and $M_q = \mathcal{O}_q$ for primes outside `ps`.
"""
function lattice_with_local_conditions(O::AlgAssAbsOrd,
                                       ps::Vector{<:IntegerUnion}, Is::Vector{<: AlgAssAbsOrdIdl})
  @req all(x -> algebra(x) === algebra(O), Is) """
                                  Lattices and order must live in same algebra"""
  @req length(ps) == length(Is) "Number of lattices and primes must be identical"
  _ps = unique(ps)
  @req length(_ps) == length(ps) "List of primes must not contain duplicates"

  d = one(ZZ)
  for I in Is
    d = lcm(d, denominator(I, O))
  end
  new_Is = [d * I for I in Is]
  new_ps = copy(ps)
  for p in support(d)
    if p in ps
      continue
    end
    push!(new_ps, p)
    push!(new_Is, d * O)
  end
  L = _lattice_with_local_conditions_contained(O, new_ps, new_Is)
  # test
  L = inv(QQ(d)) * L
  qs = _primes_of_local_inequality(1*O, L)
  @assert issubset(qs, ps)
  for i in 1:length(ps)
    @assert is_equal_locally(L, Is[i], ps[i])
  end
  return L
end

# Assume that the I in Is are contained in O
function _lattice_with_local_conditions_contained(O, ps, Is)
  L = 1 * O
  if length(ps) == 0
    return L
  end

  for I in Is
    @assert isunit(denominator(I, O))
  end

  for i in 1:length(ps)
    I = Is[i]
    p = ps[i]
    LL = I
    @assert is_subset_locally(LL, L, p)
    qs = _primes_of_local_inequality(L, LL)
    for q in qs
      if q == p
        continue
      end
      e = _local_exponent(L, LL, q)
      LL = inv(QQ(e)) * LL
      @assert is_subset_locally(L, LL, q)
    end
    L = intersect(L, LL)
  end

  # test
  qs = _primes_of_local_inequality(1*O, L)
  @assert issubset(qs, ps)
  for i in 1:length(ps)
    @assert is_equal_locally(L, Is[i] * O, ps[i])
  end

  return L
end

################################################################################
#
#  Helper functions to compare lattices locally
#
################################################################################

# Return the finitely many primes p such that I_p != J_p
function _primes_of_local_inequality(I::AlgAssAbsOrdIdl, J::AlgAssAbsOrdIdl)
  @assert algebra(I) === algebra(J)
  return _primes_of_local_inequality_by_matrices(QQMatrix(basis_matrix(I)),
                                                 QQMatrix(basis_matrix(J)))
end

function _primes_of_local_inequality_by_matrices(I, J)
  T = I * inv(J)
  Tinv = inv(T)
  primesT = ZZRingElem[]
  primesTinv = ZZRingElem[]
  for a in T
    if !iszero(a)
      append!(primesT, support(denominator(a)))
    end
  end
  for a in Tinv
    if !iszero(a)
      append!(primesTinv, support(denominator(a)))
    end
  end
  return collect(union(Set(primesT), Set(primesTinv)))
end

# Test whether I_p == J_p

function is_equal_locally(I::AlgAssAbsOrdIdl, J::AlgAssAbsOrdIdl, p::IntegerUnion)
  @req algebra(I) === algebra(J) "Lattices must live in same algebra"
  return !(p in _primes_of_local_inequality(I, J))
end

function is_subset_locally(L::T, M::T, p::IntegerUnion) where {T <: AlgAssAbsOrdIdl}
  @req algebra(L) === algebra(M) "Lattices must live in same algebra"
  t = basis_matrix(L) * basis_mat_inv(M)
  for m in QQMatrix(t)
    if !iszero(m) && valuation(m, p) < 0
      return false
    end
  end
  return true
end

# smallest p^e such that p^e * J \subseteq I
# p^e might be rational
function _local_exponent_by_matrices(J, I, p)
  T = J * inv(I)
  d, _ = ppio(denominator(T), ZZRingElem(p))
  return d
end

function _local_exponent(J, I, p)
  return _local_exponent_by_matrices(basis_matrix(J), basis_matrix(I), p)
end

################################################################################
#
#  Primary decomposition
#
################################################################################

@doc raw"""
    primary_decomposition(I::AlgAssAbsOrdIdl [O::Order]) -> Vector{Tuple}

Return the primary decomposition of $I$ over the order $O$ as a list of tuples
$(P, Q)$ where $P$ is prime $Q$ is $P$-primary and $I$ is the product of the
$Q$.

The rational span of $O$ must be etale and if no order is specified, the left
order of $I$ is used.
"""
function primary_decomposition(I::AlgAssAbsOrdIdl, O::AlgAssAbsOrd = left_order(I))
  A = algebra(I)
  @req algebra(I) === algebra(O) "Must be objects in the same algebra"
  @req is_etale(A) "Algebra must be etale"
  @req is_subset(I, O) && is_subset(O, left_order(I)) "Ideal not an ideal for this order"

  M = numerator(basis_matrix(I) * basis_mat_inv(O))
  ps = prime_divisors(det(M))
  eds = elementary_divisors(M)
  d = degree(O)

  res = Tuple{ideal_type(O), ideal_type(O)}[]

  for p in ps
    Ps = prime_ideals_over(O, p)
    for P in Ps
      if I + P == 1 * O
        continue
      end
      # Now find some e such that I + P^e == I + P^(e + 1)
      e = maximum(valuation(x, p) for x in eds)
      # p^e * (O/I)_p  = 0, so p^e \subseteq I locally at p (and at P)
      # Now P is nilpotent in (O/pO), which is an Fp-algebra of dimension d
      # Thus P^d = 0
      # In particular P^d \subseteq p * O
      # So P^(d * e) \subseteq I locally at p/P.
      ee = d * e
      #@show basis_mat_inv(I) * basis_matrix(P^ee)
      #@show basis_mat_inv(p^e * O) * basis_matrix(P^ee)
      @hassert :AlgAssOrd 1 I + P^ee == I + P^(ee + 1)
      push!(res, (I + P^(ee), P))
    end
  end

  @hassert :AlgAssOrd 1 prod(x[1] for x in res; init = 1 * O) == I
  @hassert :AlgAssOrd  all(x -> all(y -> y[2] === x[2] || x[2] + y[2] == 1*O, res), res)

  return res
end
