{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Hecke About Hecke is a software package for algebraic number theory maintained by Claus Fieker, Carlo Sircana and Tommy Hofmann. It is written in julia and is based on the computer algebra package Nemo . https://github.com/thofma/Hecke.jl (Source code) http://thofma.github.io/Hecke.jl/latest/ (Online documentation) So far, Hecke provides the following features: Orders (including element and ideal arithmetic) in number fields Computation of maximal orders Verified residue computations of Dedekind zeta functions Class and Unit group computation, S-units, PID testing Lattice enumeration Sparse linear algebra Normal forms for modules over maximal orders Extensions of number fields, non-simple extensions of number fields Orders and ideals in extensions of fields Abelian groups Ray class groups, quotients of ray class groups Invariant subgroups Class Field Theory Associative Algebras Installation To use Hecke, a julia version of 1.0 is necessary (the latest stable julia version will do). Please see http://julialang.org/downloads for instructions on how to obtain julia for your system. Once a suitable julia version is installed, use the following steps at the julia prompt to install Hecke: julia > using Pkg julia > Pkg . add ( \"Hecke\" ) Quick start Here is a quick example of using Hecke: julia > using Hecke ... Welcome to _ _ _ | | | | | | | | __ | | ___ ___ | | _____ | __ |/ _ \\/ __ | |/ / _ \\ | | | | __ / ( __ | < __ / | _ | | _ |\\ ___ |\\ ___ | _ |\\ _ \\ ___ | Version 0.5 . 0 ... ... which comes with absolutely no warranty whatsoever ( c ) 2015 - 2018 by Claus Fieker , Tommy Hofmann and Carlo Sircana julia > Qx , x = PolynomialRing ( FlintQQ , \"x\" ); julia > f = x ^ 3 + 2 ; julia > K , a = NumberField ( f , \"a\" ); julia > O = maximal_order ( K ); julia > O Maximal order of Number field over Rational Field with defining polynomial x ^ 3 + 2 with basis [ 1 , a , a ^ 2 ] The documentation of the single functions can also be accessed at the julia prompt. Here is an example: help?> signature search: signature ---------------------------------------------------------------------------- signature(O::NfMaximalOrder) -> Tuple{Int, Int} | Returns the signature of the ambient number field of \\mathcal O.","title":"About"},{"location":"#hecke","text":"","title":"Hecke"},{"location":"#about","text":"Hecke is a software package for algebraic number theory maintained by Claus Fieker, Carlo Sircana and Tommy Hofmann. It is written in julia and is based on the computer algebra package Nemo . https://github.com/thofma/Hecke.jl (Source code) http://thofma.github.io/Hecke.jl/latest/ (Online documentation) So far, Hecke provides the following features: Orders (including element and ideal arithmetic) in number fields Computation of maximal orders Verified residue computations of Dedekind zeta functions Class and Unit group computation, S-units, PID testing Lattice enumeration Sparse linear algebra Normal forms for modules over maximal orders Extensions of number fields, non-simple extensions of number fields Orders and ideals in extensions of fields Abelian groups Ray class groups, quotients of ray class groups Invariant subgroups Class Field Theory Associative Algebras","title":"About"},{"location":"#installation","text":"To use Hecke, a julia version of 1.0 is necessary (the latest stable julia version will do). Please see http://julialang.org/downloads for instructions on how to obtain julia for your system. Once a suitable julia version is installed, use the following steps at the julia prompt to install Hecke: julia > using Pkg julia > Pkg . add ( \"Hecke\" )","title":"Installation"},{"location":"#quick-start","text":"Here is a quick example of using Hecke: julia > using Hecke ... Welcome to _ _ _ | | | | | | | | __ | | ___ ___ | | _____ | __ |/ _ \\/ __ | |/ / _ \\ | | | | __ / ( __ | < __ / | _ | | _ |\\ ___ |\\ ___ | _ |\\ _ \\ ___ | Version 0.5 . 0 ... ... which comes with absolutely no warranty whatsoever ( c ) 2015 - 2018 by Claus Fieker , Tommy Hofmann and Carlo Sircana julia > Qx , x = PolynomialRing ( FlintQQ , \"x\" ); julia > f = x ^ 3 + 2 ; julia > K , a = NumberField ( f , \"a\" ); julia > O = maximal_order ( K ); julia > O Maximal order of Number field over Rational Field with defining polynomial x ^ 3 + 2 with basis [ 1 , a , a ^ 2 ] The documentation of the single functions can also be accessed at the julia prompt. Here is an example: help?> signature search: signature ---------------------------------------------------------------------------- signature(O::NfMaximalOrder) -> Tuple{Int, Int} | Returns the signature of the ambient number field of \\mathcal O.","title":"Quick start"},{"location":"FacElem/","text":"Factored Elements In many applications in number theory related to the multiplicative structure of number fields, interesting elements, e.g. units, are extremely large when written wrt. to a fxied basis for the field: for the fundamental unit in Q[\\sqrt d] it is known that the coefficients wrt. the canonical basis 1, \\sqrt d can have O(\\exp \\sqrt d) many digits. All currently known, fast methods construct those elements as power products of smaller elements, allowing the computer to handle them. Mathematically, one can think of factored elements to formally live in the ring Z[K] the group ring of the non-zero field elements. Thus elements are of the form \\prod a*i^{e*i} where a_i are elements in K , typically small and the e_i\\in Z are frequently large exponents. We refer to the a_i as the base and the e_i as the exponents of the factored element. Since K is, in general, no PID, this presentation is non-unique, elements in this form can easily be multiplied, raised to large powers, but in general not compared and not added. In Hecke, this is caputured more generally by the type FacElem , parametrized by the type of the elements in the base and the type of their parent. Important special cases are FacElem{fmpz, FlintIntegerRing} , factored integers FacElem{nf_elem, AnticNumberField} , factored algerbaic numbers FacElem{NfAbsOrdIdl, NfAbsOrdIdlSet} , factored ideals It should be noted that an object of type ` FacElem{fmpz, FlintIntegerRing} will, in general, not represent an integer as the exponents can be negative. Construction In general one can define factored elements by giving 2 arrays, the base and the exponent, or a dictionary containing the pairs: FacElem { B }( base :: Array { B , 1 }, exp :: Array { fmpz , 1 }) -> FacElem { B } Returns the element \\prod b_i^{e_i} , un-expanded. FacElem{B}(d::Dict{B, fmpz}) -> FacElem{B} FacElem{B}(d::Dict{B, Integer}) -> FacElem{B} Returns the element \\prod b^{d[p]} , un-expanded. FacElem { B }( base :: Array { B , 1 }, exp :: Array { fmpz , 1 }) -> FacElem { B } Returns the element \\prod b_i^{e_i} , un-expanded. FacElem{B}(d::Dict{B, fmpz}) -> FacElem{B} FacElem{B}(d::Dict{B, Integer}) -> FacElem{B} Returns the element \\prod b^{d[p]} , un-expanded. ideal ( O :: NfOrd , a :: FacElem { nf_elem , AnticNumberField ) The factored fractional ideal a*O . Conversion The process of computing the value defined by a factored element is available as evaluate . Depending on the types involved this can be very efficient. evaluate{T}(x::FacElem{T}) -> T Expands or evaluates the factored element, i.e. actually computes the value. Does \"square-and-multiply\" on the exponent vectors. evaluate ( x :: FacElem { fmpq }) -> fmpq evaluate ( x :: FacElem { fmpz }) -> fmpz Expands or evaluates the factored element, i.e. actually computes the the element. Works by first obtaining a simplified version of the power product into coprime base elements. evaluate{T}(x::FacElem{T}) -> T Expands or evaluates the factored element, i.e. actually computes the value. Does \"square-and-multiply\" on the exponent vectors. evaluate_naive{T}(x::FacElem{T}) -> T Expands or evaluates the factored element, i.e. actually computes the value. Uses the obvious naive algorithm. Faster for input in finite rings. Special functions In the case where the parent of the base allows for efficient gcd computation, power products can be made unique: simplify ( x :: FacElem { NfOrdIdl , NfOrdIdlSet }) -> FacElem simplify ( x :: FacElem { NfOrdFracIdl , NfOrdFracIdlSet }) -> FacElem Uses coprime_base to obtain a simplified version of x , ie. in the simplified version all base ideals will be pariwise coprime but not neccessarily prime!. simplify ( x :: FacElem { fmpq }) -> FacElem { fmpq } simplify ( x :: FacElem { fmpz }) -> FacElem { fmpz } Simplfies the factored element, i.e. arranges for the base to be coprime. The simplified version can then be used further: isone ( x :: FacElem { fmpq }) -> Bool isone ( x :: FacElem { fmpz }) -> Bool Tests if x represents 1 without an evaluation. factor_coprime ( x :: FacElem { fmpz }) -> Fac { fmpz } Computed a partial factorisation of x , ie. writes x as a product of pariwise coprime integers. factor_coprime ( x :: FacElem { NfOrdIdl , NfOrdIdlSet }) -> Dict { NfOrdIdl , Int } Computed a partial factorisation of x , ie. writes x as a product of pariwise coprime integral ideals. factor_coprime ( Q :: FacElem { NfOrdFracIdl , NfOrdFracIdlSet }) -> Dict { NfOrdIdl , Int } A coprime factorisation of Q : each ideal in Q is split using \\code{integral_split} and then a coprime basis is computed. This does {\\bf not} use any factorisation. factor_coprime ( a :: FacElem { nf_elem , AnticNumberField }, I :: NfOrdIdlSet ) -> Dict { NfOrdIdl , fmpz } Factors the rincipal ideal generated by a into coprimes by computing a coprime basis from the principal ideals in the factorisation of a . factor ( Q :: FacElem { NfOrdFracIdl , NfOrdFracIdlSet }) -> Dict { NfOrdIdl , Int } The factorisation of Q , by refining a coprime factorisation. factor(a::FacElem{nf_elem, AnticNumberField}, I::NfOrdIdlSet) -> Dict{NfOrdIdl, fmpz} Factors the principal ideal generated by a by refinind a coprime factorisation. For factorised algebraic numbers a unique simplification is not possible, however, this allows still do obtain partial results: compact_presentation ( a :: FacElem { nf_elem , AnticNumberField }, n :: Int = 2 ; decom , arb_prec = 100 , short_prec = 1000 ) -> FacElem Computes a presentation a = \\prod a_i^{n_i} where all the exponents n_i are powers of n and, the elements a are \"small\", generically, they have a norm bounded by d^{n/2} where d is the discriminant of the maximal order. As the algorithm needs the factorisation of the principal ideal generated by a , it can be passed in in \\code{decom}. signs ( a :: nf_elem ) -> Dict { InfPlc , Int } signs ( a :: FacElem { nf_elem }) -> Dict { InfPlc , Int } This function returns a dictionary of the signs of a at all infinite places of the ambient number field. The keys are infinite places of the ambient number field. The value is 1 if the sign is positive and -1 if the sign is negative. signs ( a :: nf_elem , l :: Vector { InfPlc }) -> Dict { InfPlc , Int } signs ( a :: FacElem { nf_elem }, l :: Vector { InfPlc }) -> Dict { InfPlc , Int } This function returns a dictionary of the signs of a at places in l . The keys are the elements of l . The value is 1 if the sign is positive and -1 if the sign is negative. The result will contain as many signs as there are real places contained in l . sign ( a :: nf_elem , P :: InfPlc ) -> Int sign ( a :: FacElem { nf_elem }, P :: InfPlc ) -> Int This function returns the sign of a at the place P . The value is 1 if the sign is positive and -1 if the sign is negative. ispositive ( a :: nf_elem , P :: InfPlc ) -> Bool ispositive ( a :: FacElem { nf_elem }, P :: InfPlc ) -> Bool Returns whether the element a is positive at the embedding corresponding to P . The place P must be real. ispositive ( a :: nf_elem , l :: Vector { InfPlc }) -> Bool ispositive ( a :: FacElem { nf_elem }, l :: Vector { InfPlc }) -> Bool Returns whether the element a is positive at the embeddings corresponding to the real places of l . istotally_positive ( a :: nf_elem ) -> Bool istotally_positive ( a :: FacElem { nf_elem }) -> Bool Returns whether the element a is totally positive, that is, whether it is positive at all places of the ambient number field. valuation ( a :: FacElem { nf_elem , AnticNumberField }, P :: NfOrdIdl ) -> fmpz The valuation of a at P . valuation ( A :: FacElem { NfOrdFracIdl , NfOrdFracIdlSet }, p :: NfOrdIdl ) valuation ( A :: FacElem { NfOrdIdl , NfOrdIdlSet }, p :: NfOrdIdl ) The valuation of A at P . evaluate_mod ( a :: FacElem { nf_elem , AnticNumberField }, B :: NfOrdFracIdl ) -> nf_elem Evaluates a using CRT and small primes. Assumes that the ideal generated by a is in fact B . Useful in cases where a has huge exponents, but the evaluated element is actually \"small\". pure_extension ( n :: Int , gen :: FacElem { nf_elem , AnticNumberField }) -> NfRel { nf_elem }, NfRelElem pure_extension ( n :: Int , gen :: nf_elem ) -> NfRel { nf_elem }, NfRelElem Create the field extension with the defining polynomial x^n-gen . reduce_ideal2 ( A :: FacElem { NfOrdIdl }) -> NfOrdIdl , FacElem { nf_elem } Computes B and \\alpha in factored form, such that \\alpha B = A . modular proj(a::FacElem{nf elem, AnticNumberField}, me::modular env) -> Array{fq nmod, 1} Given an algebraic number a in factored form and data \\code{me} as computed by \\code{modular_init}, project a onto the residue class fields. Miscellaneous max_exp ( a :: FacElem ) Finds the largest exponent in the factored element a min_exp ( a :: FacElem ) Finds the smallest exponent in the factored element a maxabs_exp ( a :: FacElem ) Finds the largest exponent by absolute value the factored element a","title":"Factored Elements"},{"location":"FacElem/#factored-elements","text":"In many applications in number theory related to the multiplicative structure of number fields, interesting elements, e.g. units, are extremely large when written wrt. to a fxied basis for the field: for the fundamental unit in Q[\\sqrt d] it is known that the coefficients wrt. the canonical basis 1, \\sqrt d can have O(\\exp \\sqrt d) many digits. All currently known, fast methods construct those elements as power products of smaller elements, allowing the computer to handle them. Mathematically, one can think of factored elements to formally live in the ring Z[K] the group ring of the non-zero field elements. Thus elements are of the form \\prod a*i^{e*i} where a_i are elements in K , typically small and the e_i\\in Z are frequently large exponents. We refer to the a_i as the base and the e_i as the exponents of the factored element. Since K is, in general, no PID, this presentation is non-unique, elements in this form can easily be multiplied, raised to large powers, but in general not compared and not added. In Hecke, this is caputured more generally by the type FacElem , parametrized by the type of the elements in the base and the type of their parent. Important special cases are FacElem{fmpz, FlintIntegerRing} , factored integers FacElem{nf_elem, AnticNumberField} , factored algerbaic numbers FacElem{NfAbsOrdIdl, NfAbsOrdIdlSet} , factored ideals It should be noted that an object of type ` FacElem{fmpz, FlintIntegerRing} will, in general, not represent an integer as the exponents can be negative.","title":"Factored Elements"},{"location":"FacElem/#construction","text":"In general one can define factored elements by giving 2 arrays, the base and the exponent, or a dictionary containing the pairs: FacElem { B }( base :: Array { B , 1 }, exp :: Array { fmpz , 1 }) -> FacElem { B } Returns the element \\prod b_i^{e_i} , un-expanded. FacElem{B}(d::Dict{B, fmpz}) -> FacElem{B} FacElem{B}(d::Dict{B, Integer}) -> FacElem{B} Returns the element \\prod b^{d[p]} , un-expanded. FacElem { B }( base :: Array { B , 1 }, exp :: Array { fmpz , 1 }) -> FacElem { B } Returns the element \\prod b_i^{e_i} , un-expanded. FacElem{B}(d::Dict{B, fmpz}) -> FacElem{B} FacElem{B}(d::Dict{B, Integer}) -> FacElem{B} Returns the element \\prod b^{d[p]} , un-expanded. ideal ( O :: NfOrd , a :: FacElem { nf_elem , AnticNumberField ) The factored fractional ideal a*O .","title":"Construction"},{"location":"FacElem/#conversion","text":"The process of computing the value defined by a factored element is available as evaluate . Depending on the types involved this can be very efficient. evaluate{T}(x::FacElem{T}) -> T Expands or evaluates the factored element, i.e. actually computes the value. Does \"square-and-multiply\" on the exponent vectors. evaluate ( x :: FacElem { fmpq }) -> fmpq evaluate ( x :: FacElem { fmpz }) -> fmpz Expands or evaluates the factored element, i.e. actually computes the the element. Works by first obtaining a simplified version of the power product into coprime base elements. evaluate{T}(x::FacElem{T}) -> T Expands or evaluates the factored element, i.e. actually computes the value. Does \"square-and-multiply\" on the exponent vectors. evaluate_naive{T}(x::FacElem{T}) -> T Expands or evaluates the factored element, i.e. actually computes the value. Uses the obvious naive algorithm. Faster for input in finite rings.","title":"Conversion"},{"location":"FacElem/#special-functions","text":"In the case where the parent of the base allows for efficient gcd computation, power products can be made unique: simplify ( x :: FacElem { NfOrdIdl , NfOrdIdlSet }) -> FacElem simplify ( x :: FacElem { NfOrdFracIdl , NfOrdFracIdlSet }) -> FacElem Uses coprime_base to obtain a simplified version of x , ie. in the simplified version all base ideals will be pariwise coprime but not neccessarily prime!. simplify ( x :: FacElem { fmpq }) -> FacElem { fmpq } simplify ( x :: FacElem { fmpz }) -> FacElem { fmpz } Simplfies the factored element, i.e. arranges for the base to be coprime. The simplified version can then be used further: isone ( x :: FacElem { fmpq }) -> Bool isone ( x :: FacElem { fmpz }) -> Bool Tests if x represents 1 without an evaluation. factor_coprime ( x :: FacElem { fmpz }) -> Fac { fmpz } Computed a partial factorisation of x , ie. writes x as a product of pariwise coprime integers. factor_coprime ( x :: FacElem { NfOrdIdl , NfOrdIdlSet }) -> Dict { NfOrdIdl , Int } Computed a partial factorisation of x , ie. writes x as a product of pariwise coprime integral ideals. factor_coprime ( Q :: FacElem { NfOrdFracIdl , NfOrdFracIdlSet }) -> Dict { NfOrdIdl , Int } A coprime factorisation of Q : each ideal in Q is split using \\code{integral_split} and then a coprime basis is computed. This does {\\bf not} use any factorisation. factor_coprime ( a :: FacElem { nf_elem , AnticNumberField }, I :: NfOrdIdlSet ) -> Dict { NfOrdIdl , fmpz } Factors the rincipal ideal generated by a into coprimes by computing a coprime basis from the principal ideals in the factorisation of a . factor ( Q :: FacElem { NfOrdFracIdl , NfOrdFracIdlSet }) -> Dict { NfOrdIdl , Int } The factorisation of Q , by refining a coprime factorisation. factor(a::FacElem{nf_elem, AnticNumberField}, I::NfOrdIdlSet) -> Dict{NfOrdIdl, fmpz} Factors the principal ideal generated by a by refinind a coprime factorisation. For factorised algebraic numbers a unique simplification is not possible, however, this allows still do obtain partial results: compact_presentation ( a :: FacElem { nf_elem , AnticNumberField }, n :: Int = 2 ; decom , arb_prec = 100 , short_prec = 1000 ) -> FacElem Computes a presentation a = \\prod a_i^{n_i} where all the exponents n_i are powers of n and, the elements a are \"small\", generically, they have a norm bounded by d^{n/2} where d is the discriminant of the maximal order. As the algorithm needs the factorisation of the principal ideal generated by a , it can be passed in in \\code{decom}. signs ( a :: nf_elem ) -> Dict { InfPlc , Int } signs ( a :: FacElem { nf_elem }) -> Dict { InfPlc , Int } This function returns a dictionary of the signs of a at all infinite places of the ambient number field. The keys are infinite places of the ambient number field. The value is 1 if the sign is positive and -1 if the sign is negative. signs ( a :: nf_elem , l :: Vector { InfPlc }) -> Dict { InfPlc , Int } signs ( a :: FacElem { nf_elem }, l :: Vector { InfPlc }) -> Dict { InfPlc , Int } This function returns a dictionary of the signs of a at places in l . The keys are the elements of l . The value is 1 if the sign is positive and -1 if the sign is negative. The result will contain as many signs as there are real places contained in l . sign ( a :: nf_elem , P :: InfPlc ) -> Int sign ( a :: FacElem { nf_elem }, P :: InfPlc ) -> Int This function returns the sign of a at the place P . The value is 1 if the sign is positive and -1 if the sign is negative. ispositive ( a :: nf_elem , P :: InfPlc ) -> Bool ispositive ( a :: FacElem { nf_elem }, P :: InfPlc ) -> Bool Returns whether the element a is positive at the embedding corresponding to P . The place P must be real. ispositive ( a :: nf_elem , l :: Vector { InfPlc }) -> Bool ispositive ( a :: FacElem { nf_elem }, l :: Vector { InfPlc }) -> Bool Returns whether the element a is positive at the embeddings corresponding to the real places of l . istotally_positive ( a :: nf_elem ) -> Bool istotally_positive ( a :: FacElem { nf_elem }) -> Bool Returns whether the element a is totally positive, that is, whether it is positive at all places of the ambient number field. valuation ( a :: FacElem { nf_elem , AnticNumberField }, P :: NfOrdIdl ) -> fmpz The valuation of a at P . valuation ( A :: FacElem { NfOrdFracIdl , NfOrdFracIdlSet }, p :: NfOrdIdl ) valuation ( A :: FacElem { NfOrdIdl , NfOrdIdlSet }, p :: NfOrdIdl ) The valuation of A at P . evaluate_mod ( a :: FacElem { nf_elem , AnticNumberField }, B :: NfOrdFracIdl ) -> nf_elem Evaluates a using CRT and small primes. Assumes that the ideal generated by a is in fact B . Useful in cases where a has huge exponents, but the evaluated element is actually \"small\". pure_extension ( n :: Int , gen :: FacElem { nf_elem , AnticNumberField }) -> NfRel { nf_elem }, NfRelElem pure_extension ( n :: Int , gen :: nf_elem ) -> NfRel { nf_elem }, NfRelElem Create the field extension with the defining polynomial x^n-gen . reduce_ideal2 ( A :: FacElem { NfOrdIdl }) -> NfOrdIdl , FacElem { nf_elem } Computes B and \\alpha in factored form, such that \\alpha B = A . modular proj(a::FacElem{nf elem, AnticNumberField}, me::modular env) -> Array{fq nmod, 1} Given an algebraic number a in factored form and data \\code{me} as computed by \\code{modular_init}, project a onto the residue class fields.","title":"Special functions"},{"location":"FacElem/#miscellaneous","text":"max_exp ( a :: FacElem ) Finds the largest exponent in the factored element a min_exp ( a :: FacElem ) Finds the smallest exponent in the factored element a maxabs_exp ( a :: FacElem ) Finds the largest exponent by absolute value the factored element a","title":"Miscellaneous"},{"location":"toc/","text":"Table of contents Number Fields Introduction Absolute Simple Fields Absolute Non-Simple Fields Simple Relative Fields Non-Simple Relative Fields Implicit Relative Extensions Invariants Elements Introduction Definitions and vocabulary Examples Ideals Creation Arithmetic Class Group Miscaellenous Quotient Rings Maximal Order Introduction Orders Creation Basic invariants Elements Creation Basic invariants Binary and unary operations Representation matrices Trace and norm Random elements Conjugates Ideals Abelian Groups Introduction Class Field Theory Introduction Ray Class Groups Ray Class Fields Conversions Invariants Operations","title":"Toc"},{"location":"toc/#table-of-contents","text":"Number Fields Introduction Absolute Simple Fields Absolute Non-Simple Fields Simple Relative Fields Non-Simple Relative Fields Implicit Relative Extensions Invariants Elements Introduction Definitions and vocabulary Examples Ideals Creation Arithmetic Class Group Miscaellenous Quotient Rings Maximal Order Introduction Orders Creation Basic invariants Elements Creation Basic invariants Binary and unary operations Representation matrices Trace and norm Random elements Conjugates Ideals Abelian Groups Introduction Class Field Theory Introduction Ray Class Groups Ray Class Fields Conversions Invariants Operations","title":"Table of contents"},{"location":"MaximalOrders/Creation/","text":"@module{Hecke} Orders Creation @{MaximalOrder(::AnticNumberField)} @{MaximalOrder(::AnticNumberField, ::Array{fmpz, 1})} Basic invariants @{nf(::NfMaximalOrder)} @{degree(::NfMaximalOrder)} @{basis(::NfMaximalOrder)} @{basis(::NfMaximalOrder, ::AnticNumberField)} @{basis mat(::NfMaximalOrder)} @{basis mat inv(::NfMaximalOrder)} @{index(::NfMaximalOrder)} @{signature(::NfMaximalOrder)} @{isindex divisor(::NfMaximalOrder, ::fmpz)} @{minkowski_mat(::NfMaximalOrder, ::Int)}","title":"Creation"},{"location":"MaximalOrders/Creation/#orders","text":"","title":"Orders"},{"location":"MaximalOrders/Creation/#creation","text":"@{MaximalOrder(::AnticNumberField)} @{MaximalOrder(::AnticNumberField, ::Array{fmpz, 1})}","title":"Creation"},{"location":"MaximalOrders/Creation/#basic-invariants","text":"@{nf(::NfMaximalOrder)} @{degree(::NfMaximalOrder)} @{basis(::NfMaximalOrder)} @{basis(::NfMaximalOrder, ::AnticNumberField)} @{basis mat(::NfMaximalOrder)} @{basis mat inv(::NfMaximalOrder)} @{index(::NfMaximalOrder)} @{signature(::NfMaximalOrder)} @{isindex divisor(::NfMaximalOrder, ::fmpz)} @{minkowski_mat(::NfMaximalOrder, ::Int)}","title":"Basic invariants"},{"location":"MaximalOrders/Elements/","text":"@module{Hecke} Elements Creation @{call(::NfMaximalOrder, ::nf elem, ::Bool)} @{call(::NfMaximalOrder, ::fmpz)} @{call(::NfMaximalOrder, ::Array{fmpz, 1})} @{call(::NfMaximalOrder, ::Array{Int, 1})} @{call(::NfMaximalOrder, ::nf elem, ::Array{fmpz, 1})} @{call(::NfMaximalOrder)} @{zero(::NfMaximalOrder)} @{one(::NfMaximalOrder)} Basic invariants @{parent(::NfOrderElem)} @{elem in nf(::NfOrderElem)} @{coordinates(::NfOrderElem)} @{==(::NfOrderElem, ::NfOrderElem)} @{deepcopy(::NfOrderElem)} @{in(::nf elem, ::NfMaximalOrder)} @{denominator(::nf elem, ::NfMaximalOrder)} Binary and unary operations @{-(::NfOrderElem)} @{ (::NfOrderElem, ::NfOrderElem)} @{+(::NfOrderElem, ::NfOrderElem)} @{-(::NfOrderElem, ::NfOrderElem)} @{ (::NfOrderElem, ::fmpz)} @{+(::NfOrderElem, ::fmpz)} @{-(::NfOrderElem, ::fmpz)} @{^(::NfOrderElem, ::Int)} @{mod(::NfOrderElem, ::Int)} @{powermod(::NfOrderElem, ::Int, ::fmpz)} Representation matrices @{representation matrix(::NfOrderElem)} @{representation matrix(::NfOrderElem, ::AnticNumberField)} Trace and norm @{tr(::NfOrderElem)} @{norm(::NfOrderElem)} Random elements @{rand(::NfMaximalOrder, ::UnitRange{Int})} @{rand(::NfMaximalOrder, ::Int)} Conjugates @{conjugates arb(::NfOrderElem, ::Int)} @{minkowski map(::NfOrderElem, ::Int)} @{conjugates_log(::NfOrderElem)}","title":"Elements"},{"location":"MaximalOrders/Elements/#elements","text":"","title":"Elements"},{"location":"MaximalOrders/Elements/#creation","text":"@{call(::NfMaximalOrder, ::nf elem, ::Bool)} @{call(::NfMaximalOrder, ::fmpz)} @{call(::NfMaximalOrder, ::Array{fmpz, 1})} @{call(::NfMaximalOrder, ::Array{Int, 1})} @{call(::NfMaximalOrder, ::nf elem, ::Array{fmpz, 1})} @{call(::NfMaximalOrder)} @{zero(::NfMaximalOrder)} @{one(::NfMaximalOrder)}","title":"Creation"},{"location":"MaximalOrders/Elements/#basic-invariants","text":"@{parent(::NfOrderElem)} @{elem in nf(::NfOrderElem)} @{coordinates(::NfOrderElem)} @{==(::NfOrderElem, ::NfOrderElem)} @{deepcopy(::NfOrderElem)} @{in(::nf elem, ::NfMaximalOrder)} @{denominator(::nf elem, ::NfMaximalOrder)}","title":"Basic invariants"},{"location":"MaximalOrders/Elements/#binary-and-unary-operations","text":"@{-(::NfOrderElem)} @{ (::NfOrderElem, ::NfOrderElem)} @{+(::NfOrderElem, ::NfOrderElem)} @{-(::NfOrderElem, ::NfOrderElem)} @{ (::NfOrderElem, ::fmpz)} @{+(::NfOrderElem, ::fmpz)} @{-(::NfOrderElem, ::fmpz)} @{^(::NfOrderElem, ::Int)} @{mod(::NfOrderElem, ::Int)} @{powermod(::NfOrderElem, ::Int, ::fmpz)}","title":"Binary and unary operations"},{"location":"MaximalOrders/Elements/#representation-matrices","text":"@{representation matrix(::NfOrderElem)} @{representation matrix(::NfOrderElem, ::AnticNumberField)}","title":"Representation matrices"},{"location":"MaximalOrders/Elements/#trace-and-norm","text":"@{tr(::NfOrderElem)} @{norm(::NfOrderElem)}","title":"Trace and norm"},{"location":"MaximalOrders/Elements/#random-elements","text":"@{rand(::NfMaximalOrder, ::UnitRange{Int})} @{rand(::NfMaximalOrder, ::Int)}","title":"Random elements"},{"location":"MaximalOrders/Elements/#conjugates","text":"@{conjugates arb(::NfOrderElem, ::Int)} @{minkowski map(::NfOrderElem, ::Int)} @{conjugates_log(::NfOrderElem)}","title":"Conjugates"},{"location":"MaximalOrders/Ideals/","text":"Ideals @module{Hecke} @{nf(::NfMaximalOrderIdeal)}","title":"Ideals"},{"location":"MaximalOrders/Ideals/#ideals","text":"@module{Hecke} @{nf(::NfMaximalOrderIdeal)}","title":"Ideals"},{"location":"MaximalOrders/Introduction/","text":"Maximal Order Introduction In Hecke, maximal orders (aka ring of integers), due to their special properties normal orders don't share, come with their own type NfMaximalOrder . While the elements have type NfOrderElem , the ideals and fractional ideals have types NfMaximalOrderIdeal and NfMaximalOrderFracIdeal respectively. While theoretically a number field contains a unique maximal order (the set of all integral elements), for technical reasons in Hecke a number field admits multiple maximal orders, which are uniquely determined by the number field and a chosen integral basis. Let K be a number field of degree d with primitive element \\alpha and \\mathcal O a maximal order K with \\mathbf{Z} -basis (\\omega_1,\\dotsc,\\omega_d) . The basis matrix of \\mathcal O is the unique matrix M_{\\mathcal O} \\in \\operatorname{Mat}_{d \\times d}(\\mathbf{Q}) such that \\begin{align} \\begin{pmatrix} \\omega*1 \\\\ \\omega*2 \\\\ \\vdots \\\\ \\omega*d \\end{pmatrix} = M*{\\mathcal O} \\begin{pmatrix} 1 \\\\ \\alpha \\\\ \\vdots \\\\ \\alpha^{d - 1} \\end{pmatrix}. \\end{align} If \\beta is an element of \\mathcal O , we call the unique integers (x_1,\\dotsc,x_d) \\in \\mathbf Z^d with \\begin{align} \\beta = \\sum*{i=1}^d x*i \\omega_i \\end{align} the coefficients of \\beta with respect to \\mathcal O or just the coefficient vector . For an ideal I of \\mathcal O , a basis matrix of I is a matrix M \\in \\operatorname{Mat}_{d \\times d}(\\mathbf{Z}) , such that the elements (\\alpha_1,\\dotsc,\\alpha_d) definied by \\begin{align} \\begin{pmatrix} \\alpha*1 \\\\ \\alpha*2 \\\\ \\vdots \\\\ \\alpha*d \\end{pmatrix} = M*{\\mathcal O} \\begin{pmatrix} \\omega*1 \\\\ \\omega*2 \\\\ \\vdots \\\\ \\omega_d \\end{pmatrix} \\end{align} form a \\mathbf{Z} -basis of I .","title":"Introduction"},{"location":"MaximalOrders/Introduction/#maximal-order","text":"","title":"Maximal Order"},{"location":"MaximalOrders/Introduction/#introduction","text":"In Hecke, maximal orders (aka ring of integers), due to their special properties normal orders don't share, come with their own type NfMaximalOrder . While the elements have type NfOrderElem , the ideals and fractional ideals have types NfMaximalOrderIdeal and NfMaximalOrderFracIdeal respectively. While theoretically a number field contains a unique maximal order (the set of all integral elements), for technical reasons in Hecke a number field admits multiple maximal orders, which are uniquely determined by the number field and a chosen integral basis. Let K be a number field of degree d with primitive element \\alpha and \\mathcal O a maximal order K with \\mathbf{Z} -basis (\\omega_1,\\dotsc,\\omega_d) . The basis matrix of \\mathcal O is the unique matrix M_{\\mathcal O} \\in \\operatorname{Mat}_{d \\times d}(\\mathbf{Q}) such that \\begin{align} \\begin{pmatrix} \\omega*1 \\\\ \\omega*2 \\\\ \\vdots \\\\ \\omega*d \\end{pmatrix} = M*{\\mathcal O} \\begin{pmatrix} 1 \\\\ \\alpha \\\\ \\vdots \\\\ \\alpha^{d - 1} \\end{pmatrix}. \\end{align} If \\beta is an element of \\mathcal O , we call the unique integers (x_1,\\dotsc,x_d) \\in \\mathbf Z^d with \\begin{align} \\beta = \\sum*{i=1}^d x*i \\omega_i \\end{align} the coefficients of \\beta with respect to \\mathcal O or just the coefficient vector . For an ideal I of \\mathcal O , a basis matrix of I is a matrix M \\in \\operatorname{Mat}_{d \\times d}(\\mathbf{Z}) , such that the elements (\\alpha_1,\\dotsc,\\alpha_d) definied by \\begin{align} \\begin{pmatrix} \\alpha*1 \\\\ \\alpha*2 \\\\ \\vdots \\\\ \\alpha*d \\end{pmatrix} = M*{\\mathcal O} \\begin{pmatrix} \\omega*1 \\\\ \\omega*2 \\\\ \\vdots \\\\ \\omega_d \\end{pmatrix} \\end{align} form a \\mathbf{Z} -basis of I .","title":"Introduction"},{"location":"abelian/introduction/","text":"Abelian Groups Introduction","title":"Introduction"},{"location":"abelian/introduction/#abelian-groups","text":"","title":"Abelian Groups"},{"location":"abelian/introduction/#introduction","text":"","title":"Introduction"},{"location":"class_fields/intro/","text":"Class Field Theory Introduction This chapter deals with abelian extensions of number fields and the rational numbers. Class Field Theory, here specifically, class field theory of global number fields, deals with abelian extension, ie. fields where the group of automorphisms is abelian. For extensions of {\\Q}, the famous Kronnecker-Weber theorem classifies all such fields: a field is abelian if and only if it is contained in some cyclotomic field. For general number fields this is more involved and even for extensions of {\\Q} is is not practical. In Hecke, abelian extensions are parametrized by quotients of so called ray class groups. The language of ray class groups while dated is more applicable to algorithms than the modern language of idel class groups and quotients. Ray Class Groups Given an integral ideal m_0 \\le Z_K and a list of real places m_\\infty , the ray class group modulo (m_0, m_\\infty) , C(m) is defined as the group of ideals coprime to m_0 modulo the elements a\\in K^* s.th. v_p(a-1) \\ge v_p(m_0) and for all v\\in m_\\infty , a^{(v)} >0 . This is a finite abelian group. For m_0 = Z_K and m_\\infty = \\{\\} we get C() is the class group, if m_\\infty contains all real places, we obtain the narrow class group, or strict class group. ray_class_group ( m :: NfOrdIdl , inf_plc :: Array { InfPlc , 1 } = InfPlc []; n_quo ) Given a modulus with finite part m and infinite part inf_plc , it returns the Ray Class Group Cl_m . If n_quo is given, it will return the quotient of the Ray Class Group by n Missing docstring. Missing docstring for class_group(O::Hecke.NfAbsOrd{Nemo.AnticNumberField,Nemo.nf_elem}; bound, method, redo, unit_method, large) . Check Documenter's build log for details. Missing docstring. Missing docstring for class_group(K::Nemo.AnticNumberField) . Check Documenter's build log for details. norm_group ( f :: Nemo . PolyElem , mR :: Hecke . MapRayClassGrp , isabelian :: Bool = true ; of_closure :: Bool = false ) -> Hecke . FinGenGrpAb , Hecke . FinGenGrpAbMap norm_group ( f :: Array { PolyElem { nf_elem }, mR :: Hecke . MapRayClassGrp , isabelian :: Bool = true ; of_closure :: Bool = false ) -> Hecke . FinGenGrpAb , Hecke . FinGenGrpAbMap Computes the subgroup of the Ray Class Group R given by the norm of the extension generated by a/the roots of f . If {{{isabelian}}} is set to true, then the code assumes the field to be abelian, hence the algorithm stops when the quotient by the norm group has the correct order. Even though the algorithm is probabilistic by nature, in this case the result is guaranteed. If {{{of_closure}}} is given, then the norm group of the splitting field of the polynomial(s) is computed. It is the callers responsibility to ensure that the ray class group passed in is large enough. norm_group ( K :: NfRel { nf_elem }, mR :: Hecke . MapRayClassGrp ) -> Hecke . FinGenGrpAb , Hecke . FinGenGrpAbMap norm_group ( K :: NfRel_ns { nf_elem }, mR :: Hecke . MapRayClassGrp ) -> Hecke . FinGenGrpAb , Hecke . FinGenGrpAbMap Computes the subgroup of the Ray Class Group R given by the norm of the extension. Ray Class Fields In general, the construction of a class field starts with a (ray) class group. Each quotient of a ray class group then defines a ray class field, the defining property is that the (relative) automorphism group is canonically isomorphic to the quotient of the ray class group where the isomorphism is given by the Artin (or Frobenius) map. Since, in Hecke, the (ray) class groups have no link to the field, actually this has to be specified using the maps. It should be noted that this is a {\\em lazy} construction: nothing is computed at this point. ray_class_field ( m :: MapClassGrp ) -> ClassField ray_class_field ( m :: MapRayClassGrp ) -> ClassField Creates the (formal) abelian extension defined by the map m: A \\to I where I is the set of ideals coprime to the modulus defining m and A is a quotient of the ray class group (or class group). The map m must be the map returned from a call to {class group} or {ray class_group}. ray_class_field ( m :: Union { MapClassGrp , MapRayClassGrp }, quomap :: GrpAbFinGenMap ) -> ClassField For m a map computed by either {ray class group} or {class_group} and q a canonical projection (quotient map) as returned by {quo} for q quotient of the domain of m and a subgroup of m , create the (formal) abelian extension where the (relative) automorphism group is canonically isomorphic to the codomain of q . ray_class_field ( I :: NfAbsOrdIdl ; n_quo = 0 ) -> ClassField The ray class field modulo I . If {{{n_quo}}} is given, then the largest subfield of exponent n is computed. ray_class_field ( I :: NfAbsOrdIdl , inf :: Array { InfPlc , 1 }; n_quo = 0 ) -> ClassField The ray class field modulo I and the infinite places given. If {{{n_quo}}} is given, then the largest subfield of exponent n is computed. hilbert_class_field ( k :: AnticNumberField ) -> ClassField The Hilbert class field of k as a formal (ray-) class field. ring_class_field ( O :: NfAbsOrd ) -> ClassField The ring class field of O , ie. the maximal abelian extension ramifed only at primes dividing the conductor with the automorphism group isomorphic to the Picard group. Example julia> Qx, x = PolynomialRing(FlintQQ, \"x\"); julia> K, a = NumberField(x^2 - 10, \"a\"); julia> c, mc = class_group(K) (GrpAb: Z/2, ClassGroup map of Set of ideals of Maximal order of Number field over Rational Field with defining polynomial x^2-10 with basis nf_elem[1, a] ) julia> A = ray_class_field(mc) Class field defined mod (<1, 1>, InfPlc[]) of structure Abelian group with structure: Z/2 Conversions Given a ray class field, it is possible to actually compute defining equation(s) for this field. In general, the number field constructed this way will be non-simple by type and is defined by a polynomial for each maximal cyclic quotient of prime power order in the defining group. The algorithm employed is based on Kummer-theory and requires the addition of a suitable root of unity. Progress can be monitored by setting {{{set verbose level(:ClassField, n)}}} where 0\\le n\\le 3 NumberField ( f :: Poly { NumFieldElem }, s :: String ; cached :: Bool = false , check :: Bool = false ) -> NumField , NumFieldElem Given an irreducible polynomial f \\in K[t] over some number field K , this function creates the simple number field L = K[t]/(f) and returns (L, b) , where b is the class of t in L . The string s is used only for printing the primitive element b . Testing that f is irreducible can be disabled by setting the ketword argument to false . NumberField(f::Generic.Poly{T}; cached::Bool = false, check::Bool = false) where T number_field ( f :: Array { Generic . Poly { T }, 1 }, s :: String = \"_ \\$ \" ) where T -> NfRel_ns Given polynomials f = (f_1, \\ldots, f_n) over some number field k , construct K = k[t_1, \\ldots, t_n]/\\langle f_1(t_1), \\ldots, f_n(t_n)\\rangle The ideal in the quotient must be maximal - although this is not tested. NumberField(CF::ClassField) -> Hecke.NfRel_ns{Nemo.nf_elem} Given a (formal) abelian extension, compute the class field by finding defining polynomials for all prime power cyclic subfields. Note, by type this is always a non-simple extension. julia> Qx, x = PolynomialRing(FlintQQ, \"x\"); julia> k, a = NumberField(x^2 - 10, \"a\"); julia> c, mc = class_group(k); julia> A = ray_class_field(mc) Class field defined mod (<1, 1>, InfPlc[]) of structure Abelian group with structure: Z/2 julia> K = number_field(A) non-simple Relative number field over Number field over Rational Field with defining polynomial x^2-10 with defining polynomials AbstractAlgebra.Generic.MPoly{nf_elem}[_$1^2+(-2)] julia> ZK = maximal_order(K) Relative maximal order of non-simple Relative number field over Number field over Rational Field with defining polynomial x^2-10 with defining polynomials AbstractAlgebra.Generic.MPoly{nf_elem}[_$1^2+(-2)] with pseudo-basis (1, 1//1 * <1, a+3>) (_$1+(a), 1//4 * <2, 3*a+2>) julia> isone(discriminant(ZK)) true ray_class_field ( K :: NfRel { nf_elem }) -> ClassField For a (relative) abelian extension, compute an abstract representation as a class field. genus_field ( A :: ClassField , k :: AnticNumberField ) -> ClassField The maximal extension contained in A that is the compositum of K with an abelian extension of k . maximal_abelian_subfield ( A :: ClassField , k :: AnticNumberField ) -> ClassField The maximal abelian extension of k contained in A . k must be a subfield of the base field of A . maximal_abelian_subfield ( K :: NfRel { nf_elem }; of_closure :: Bool = false ) -> ClassField Using a probabilistic algorithm for the norm group computation, determine tha maximal abelian subfield in K over its base field. If {{{of_closure}}} is set to true, then the algorithm is applied to the normal closure if K (without computing it). Invariants degree ( A :: ClassField ) The degree of A over its base field, ie. the size of the defining ideal group. base_ring ( A :: ClassField ) The maximal order of the field that A is defined over. base_field ( A :: ClassField ) The number field that A is defined over. discriminant ( C :: ClassField ) -> NfOrdIdl Using the conductor-discriminant formula, compute the (relative) discriminant of C . This does not use the defining equations. conductor(C::Hecke.ClassField) -> NfOrdIdl, Array{InfPlc,1} Return the conductor of the abelian extension corresponding to C defining_modulus ( CF :: ClassField ) The modulus, ie. an ideal the the set of real places, used to create the class field. iscyclic ( C :: ClassField ) Tests if the (relative) automorphism group of C is cyclic (by checking the defining ideal group). isconductor(C::Hecke.ClassField, m::NfOrdIdl, inf_plc::Array{InfPlc,1}=InfPlc[]; check) -> NfOrdIdl, Array{InfPlc,1} Checks if m, inf_plc is the conductor of the abelian extension corresponding to C. If check is false, it assumes that the given modulus is a multiple of the conductor. This is generically faster than computing the conductor. isnormal ( C :: ClassField ) -> Bool For a class field C defined over a normal base field k , decide if C is normal over Q . iscentral ( C :: ClassField ) -> Bool For a class field C defined over a normal base field k , decide if C is central over Q . Operations *(A::ClassField, B::ClassField) -> ClassField The compositum of a and b as a (formal) class field. compositum ( a :: ClassField , b :: ClassField ) -> ClassField The compositum of a and b as a (formal) class field. == ( a :: ClassField , b :: ClassField ) Tests if a and b are equal. intersect ( a :: ClassField , b :: ClassField ) -> ClassField The intersect of a and b as a class field. prime_decomposition_type ( C :: ClassField , p :: NfAbsOrdIdl ) -> ( Int , Int , Int ) For a prime p in the base ring of r , determine the splitting type of p in r . ie. the tuple (e, f, g) giving the ramification degree, the inertia and the number of primes above p . issubfield ( a :: ClassField , b :: ClassField ) -> Bool Determines of a is a subfield of b . islocal_norm ( r :: ClassField , a :: NfAbsOrdElem ) -> Bool Tests if a is a local norm at all finite places in the extension implictly given by r . islocal_norm ( r :: ClassField , a :: NfAbsOrdElem , p :: NfAbsOrdIdl ) -> Bool Tests if a is a local norm at p in the extension implictly given by r . Currently the conductor cannot have infinite places. normal_closure ( C :: ClassField ) -> ClassField For a ray class field C extending a normal base field k , compute the normal closure over Q . subfields ( C :: ClassField ) -> Array { ClassField , 1 } Find all subfields of C as class fields. Note: this will not find all subfields over Q , but only the ones sharing the same base field. subfields ( C :: ClassField , d :: Int ) -> Array { ClassField , 1 } Find all subfields of C of degree d as class fields. Note: this will not find all subfields over Q , but only the ones sharing the same base field.","title":"Introduction"},{"location":"class_fields/intro/#class-field-theory","text":"","title":"Class Field Theory"},{"location":"class_fields/intro/#introduction","text":"This chapter deals with abelian extensions of number fields and the rational numbers. Class Field Theory, here specifically, class field theory of global number fields, deals with abelian extension, ie. fields where the group of automorphisms is abelian. For extensions of {\\Q}, the famous Kronnecker-Weber theorem classifies all such fields: a field is abelian if and only if it is contained in some cyclotomic field. For general number fields this is more involved and even for extensions of {\\Q} is is not practical. In Hecke, abelian extensions are parametrized by quotients of so called ray class groups. The language of ray class groups while dated is more applicable to algorithms than the modern language of idel class groups and quotients.","title":"Introduction"},{"location":"class_fields/intro/#ray-class-groups","text":"Given an integral ideal m_0 \\le Z_K and a list of real places m_\\infty , the ray class group modulo (m_0, m_\\infty) , C(m) is defined as the group of ideals coprime to m_0 modulo the elements a\\in K^* s.th. v_p(a-1) \\ge v_p(m_0) and for all v\\in m_\\infty , a^{(v)} >0 . This is a finite abelian group. For m_0 = Z_K and m_\\infty = \\{\\} we get C() is the class group, if m_\\infty contains all real places, we obtain the narrow class group, or strict class group. ray_class_group ( m :: NfOrdIdl , inf_plc :: Array { InfPlc , 1 } = InfPlc []; n_quo ) Given a modulus with finite part m and infinite part inf_plc , it returns the Ray Class Group Cl_m . If n_quo is given, it will return the quotient of the Ray Class Group by n Missing docstring. Missing docstring for class_group(O::Hecke.NfAbsOrd{Nemo.AnticNumberField,Nemo.nf_elem}; bound, method, redo, unit_method, large) . Check Documenter's build log for details. Missing docstring. Missing docstring for class_group(K::Nemo.AnticNumberField) . Check Documenter's build log for details. norm_group ( f :: Nemo . PolyElem , mR :: Hecke . MapRayClassGrp , isabelian :: Bool = true ; of_closure :: Bool = false ) -> Hecke . FinGenGrpAb , Hecke . FinGenGrpAbMap norm_group ( f :: Array { PolyElem { nf_elem }, mR :: Hecke . MapRayClassGrp , isabelian :: Bool = true ; of_closure :: Bool = false ) -> Hecke . FinGenGrpAb , Hecke . FinGenGrpAbMap Computes the subgroup of the Ray Class Group R given by the norm of the extension generated by a/the roots of f . If {{{isabelian}}} is set to true, then the code assumes the field to be abelian, hence the algorithm stops when the quotient by the norm group has the correct order. Even though the algorithm is probabilistic by nature, in this case the result is guaranteed. If {{{of_closure}}} is given, then the norm group of the splitting field of the polynomial(s) is computed. It is the callers responsibility to ensure that the ray class group passed in is large enough. norm_group ( K :: NfRel { nf_elem }, mR :: Hecke . MapRayClassGrp ) -> Hecke . FinGenGrpAb , Hecke . FinGenGrpAbMap norm_group ( K :: NfRel_ns { nf_elem }, mR :: Hecke . MapRayClassGrp ) -> Hecke . FinGenGrpAb , Hecke . FinGenGrpAbMap Computes the subgroup of the Ray Class Group R given by the norm of the extension.","title":"Ray Class Groups"},{"location":"class_fields/intro/#ray-class-fields","text":"In general, the construction of a class field starts with a (ray) class group. Each quotient of a ray class group then defines a ray class field, the defining property is that the (relative) automorphism group is canonically isomorphic to the quotient of the ray class group where the isomorphism is given by the Artin (or Frobenius) map. Since, in Hecke, the (ray) class groups have no link to the field, actually this has to be specified using the maps. It should be noted that this is a {\\em lazy} construction: nothing is computed at this point. ray_class_field ( m :: MapClassGrp ) -> ClassField ray_class_field ( m :: MapRayClassGrp ) -> ClassField Creates the (formal) abelian extension defined by the map m: A \\to I where I is the set of ideals coprime to the modulus defining m and A is a quotient of the ray class group (or class group). The map m must be the map returned from a call to {class group} or {ray class_group}. ray_class_field ( m :: Union { MapClassGrp , MapRayClassGrp }, quomap :: GrpAbFinGenMap ) -> ClassField For m a map computed by either {ray class group} or {class_group} and q a canonical projection (quotient map) as returned by {quo} for q quotient of the domain of m and a subgroup of m , create the (formal) abelian extension where the (relative) automorphism group is canonically isomorphic to the codomain of q . ray_class_field ( I :: NfAbsOrdIdl ; n_quo = 0 ) -> ClassField The ray class field modulo I . If {{{n_quo}}} is given, then the largest subfield of exponent n is computed. ray_class_field ( I :: NfAbsOrdIdl , inf :: Array { InfPlc , 1 }; n_quo = 0 ) -> ClassField The ray class field modulo I and the infinite places given. If {{{n_quo}}} is given, then the largest subfield of exponent n is computed. hilbert_class_field ( k :: AnticNumberField ) -> ClassField The Hilbert class field of k as a formal (ray-) class field. ring_class_field ( O :: NfAbsOrd ) -> ClassField The ring class field of O , ie. the maximal abelian extension ramifed only at primes dividing the conductor with the automorphism group isomorphic to the Picard group.","title":"Ray Class Fields"},{"location":"class_fields/intro/#example","text":"julia> Qx, x = PolynomialRing(FlintQQ, \"x\"); julia> K, a = NumberField(x^2 - 10, \"a\"); julia> c, mc = class_group(K) (GrpAb: Z/2, ClassGroup map of Set of ideals of Maximal order of Number field over Rational Field with defining polynomial x^2-10 with basis nf_elem[1, a] ) julia> A = ray_class_field(mc) Class field defined mod (<1, 1>, InfPlc[]) of structure Abelian group with structure: Z/2","title":"Example"},{"location":"class_fields/intro/#conversions","text":"Given a ray class field, it is possible to actually compute defining equation(s) for this field. In general, the number field constructed this way will be non-simple by type and is defined by a polynomial for each maximal cyclic quotient of prime power order in the defining group. The algorithm employed is based on Kummer-theory and requires the addition of a suitable root of unity. Progress can be monitored by setting {{{set verbose level(:ClassField, n)}}} where 0\\le n\\le 3 NumberField ( f :: Poly { NumFieldElem }, s :: String ; cached :: Bool = false , check :: Bool = false ) -> NumField , NumFieldElem Given an irreducible polynomial f \\in K[t] over some number field K , this function creates the simple number field L = K[t]/(f) and returns (L, b) , where b is the class of t in L . The string s is used only for printing the primitive element b . Testing that f is irreducible can be disabled by setting the ketword argument to false . NumberField(f::Generic.Poly{T}; cached::Bool = false, check::Bool = false) where T number_field ( f :: Array { Generic . Poly { T }, 1 }, s :: String = \"_ \\$ \" ) where T -> NfRel_ns Given polynomials f = (f_1, \\ldots, f_n) over some number field k , construct K = k[t_1, \\ldots, t_n]/\\langle f_1(t_1), \\ldots, f_n(t_n)\\rangle The ideal in the quotient must be maximal - although this is not tested. NumberField(CF::ClassField) -> Hecke.NfRel_ns{Nemo.nf_elem} Given a (formal) abelian extension, compute the class field by finding defining polynomials for all prime power cyclic subfields. Note, by type this is always a non-simple extension. julia> Qx, x = PolynomialRing(FlintQQ, \"x\"); julia> k, a = NumberField(x^2 - 10, \"a\"); julia> c, mc = class_group(k); julia> A = ray_class_field(mc) Class field defined mod (<1, 1>, InfPlc[]) of structure Abelian group with structure: Z/2 julia> K = number_field(A) non-simple Relative number field over Number field over Rational Field with defining polynomial x^2-10 with defining polynomials AbstractAlgebra.Generic.MPoly{nf_elem}[_$1^2+(-2)] julia> ZK = maximal_order(K) Relative maximal order of non-simple Relative number field over Number field over Rational Field with defining polynomial x^2-10 with defining polynomials AbstractAlgebra.Generic.MPoly{nf_elem}[_$1^2+(-2)] with pseudo-basis (1, 1//1 * <1, a+3>) (_$1+(a), 1//4 * <2, 3*a+2>) julia> isone(discriminant(ZK)) true ray_class_field ( K :: NfRel { nf_elem }) -> ClassField For a (relative) abelian extension, compute an abstract representation as a class field. genus_field ( A :: ClassField , k :: AnticNumberField ) -> ClassField The maximal extension contained in A that is the compositum of K with an abelian extension of k . maximal_abelian_subfield ( A :: ClassField , k :: AnticNumberField ) -> ClassField The maximal abelian extension of k contained in A . k must be a subfield of the base field of A . maximal_abelian_subfield ( K :: NfRel { nf_elem }; of_closure :: Bool = false ) -> ClassField Using a probabilistic algorithm for the norm group computation, determine tha maximal abelian subfield in K over its base field. If {{{of_closure}}} is set to true, then the algorithm is applied to the normal closure if K (without computing it).","title":"Conversions"},{"location":"class_fields/intro/#invariants","text":"degree ( A :: ClassField ) The degree of A over its base field, ie. the size of the defining ideal group. base_ring ( A :: ClassField ) The maximal order of the field that A is defined over. base_field ( A :: ClassField ) The number field that A is defined over. discriminant ( C :: ClassField ) -> NfOrdIdl Using the conductor-discriminant formula, compute the (relative) discriminant of C . This does not use the defining equations. conductor(C::Hecke.ClassField) -> NfOrdIdl, Array{InfPlc,1} Return the conductor of the abelian extension corresponding to C defining_modulus ( CF :: ClassField ) The modulus, ie. an ideal the the set of real places, used to create the class field. iscyclic ( C :: ClassField ) Tests if the (relative) automorphism group of C is cyclic (by checking the defining ideal group). isconductor(C::Hecke.ClassField, m::NfOrdIdl, inf_plc::Array{InfPlc,1}=InfPlc[]; check) -> NfOrdIdl, Array{InfPlc,1} Checks if m, inf_plc is the conductor of the abelian extension corresponding to C. If check is false, it assumes that the given modulus is a multiple of the conductor. This is generically faster than computing the conductor. isnormal ( C :: ClassField ) -> Bool For a class field C defined over a normal base field k , decide if C is normal over Q . iscentral ( C :: ClassField ) -> Bool For a class field C defined over a normal base field k , decide if C is central over Q .","title":"Invariants"},{"location":"class_fields/intro/#operations","text":"*(A::ClassField, B::ClassField) -> ClassField The compositum of a and b as a (formal) class field. compositum ( a :: ClassField , b :: ClassField ) -> ClassField The compositum of a and b as a (formal) class field. == ( a :: ClassField , b :: ClassField ) Tests if a and b are equal. intersect ( a :: ClassField , b :: ClassField ) -> ClassField The intersect of a and b as a class field. prime_decomposition_type ( C :: ClassField , p :: NfAbsOrdIdl ) -> ( Int , Int , Int ) For a prime p in the base ring of r , determine the splitting type of p in r . ie. the tuple (e, f, g) giving the ramification degree, the inertia and the number of primes above p . issubfield ( a :: ClassField , b :: ClassField ) -> Bool Determines of a is a subfield of b . islocal_norm ( r :: ClassField , a :: NfAbsOrdElem ) -> Bool Tests if a is a local norm at all finite places in the extension implictly given by r . islocal_norm ( r :: ClassField , a :: NfAbsOrdElem , p :: NfAbsOrdIdl ) -> Bool Tests if a is a local norm at p in the extension implictly given by r . Currently the conductor cannot have infinite places. normal_closure ( C :: ClassField ) -> ClassField For a ray class field C extending a normal base field k , compute the normal closure over Q . subfields ( C :: ClassField ) -> Array { ClassField , 1 } Find all subfields of C as class fields. Note: this will not find all subfields over Q , but only the ones sharing the same base field. subfields ( C :: ClassField , d :: Int ) -> Array { ClassField , 1 } Find all subfields of C of degree d as class fields. Note: this will not find all subfields over Q , but only the ones sharing the same base field.","title":"Operations"},{"location":"number_fields/intro/","text":"Number Fields Introduction This chapter deals with number fields. Number fields, in Hecke, come in several different types: AnticNumberField : a finite simple extension of the rational numbers Q NfAbsNS : a finite extension of Q given by several polynomials. We will refer to this as a non-simple field - even though mathematically we can find a primitive elements. NfRel : a finite simple extension of a number field. This is actually parametried by the (element) type of the coefficient field. The complete type of an extension of an absolute field ( AnticNumberField ) is NfRel{nf_elem} . The next extension thus will be NfRel{NfRelElem{nf_elem}} . NfRel_ns : extensions of number fields given by several polynomials. This too will be refered to as a non-simple field. The simple types AnticNumberField and NfRel are also calle simple fields in the rest of this document, NfRel and NfRel_ns are referred to as relative extensions while AnticNumberField and NfAbsNS are called absolute. Internally, simple fields are essentially just (univariate) polynomial quotients in a dense representation, while non-simple fields are multivariate quotient rings, thus have a sparse presentation. In general, simple fields allow much faster arithmetic, while the non-simple fields give easy access to large degree fields. Absolute Simple Fields The most basic number field type is that of AnticNumberField . Internally this is essentially represented as a unvariate quotient with the arithmetic provided by the antic-c-library and implemented in Nemo. Creation Number fields are mostly created using NumberField , but also using number_field . Many of the constructors have arguments of type Symbol or AbstractString , if used, they define the appearance in printing, and printing only. The named parameter check can be true or false, the default being true`. This parameter controlls is the polynomial defining the number field is tested for irreducibility or not. Given that this can be potentially very time consuiming if the degree if large, one can omit this test. Note however, that the behaviour of Hecke is undefined if a reducible polynomial is used to define a field . The named boolean parameter cached is inherited from the underlying Nemo system. Two number fields defined using the same polynomial from the identical polynomial ring and the same (identical) symbol/ string will be identical if cached == true and different if cached == false . NumberField ( f :: fmpq_poly ; cached :: Bool = true , check :: Bool = true ) The number field Q[x]/f generated by f. cyclotomic_field ( n :: Int ) -> AnticNumberField , nf_elem The n -th cyclotomic field defined by the n -the cyclotomic polynomial. wildanger_field ( n :: Int , B :: fmpz ) -> AnticNumberField , nf_elem wildanger_field ( n :: Int , B :: Integer ) -> AnticNumberField , nf_elem Returns the field with defining polynomial x^n + \\sum_{i=0}^{n-1} (-1)^{n-i}Bx^i . These fields tend to have non-trivial class groups. pure_extension ( n :: Int , gen :: Integer ; cached :: Bool = true , check :: Bool = true ) -> AnticNumberField , nf_elem pure_extension ( n :: Int , gen :: fmpz ; cached :: Bool = true , check :: Bool = true ) -> AnticNumberField , nf_elem The number field with defining polynomial x^n-gen . Example julia> Qx, x = PolynomialRing(FlintQQ, \"x\"); julia> K, a = NumberField(x^2 - 10, \"a\"); Absolute Non-Simple Fields Creation number_field ( f :: Array { fmpq_poly , 1 }, s :: String = \"_ \\$ \" ) -> NfAbsNS Let f = (f_1, \\ldots, f_n) be univariate rational polynomials, then we construct K = Q[t_1, \\ldots, t_n]/\\langle f_1(t_1), \\ldots, f_n(t_n)\\rangle The ideal bust be maximal, however, this is not tested. Example julia> Qx, x = PolynomialRing(FlintQQ, \"x\"); julia> K, g = number_field([x^2-2, x^2-3, x^2-5]) (Non-simple number field with defining polynomials fmpq_mpoly[_$1^2 - 2, _$2^2 - 3, _$3^2 - 5], NfAbsNSElem[_$1, _$2, _$3]) julia> g[1]^2 2 julia> minpoly(g[1] + g[2]) x^4-10*x^2+1 Conversion simple_extension ( K :: NfAbsNS ) -> AnticNumberField , Map For a non-simple extension K of Q , find a primitive element and thus an isomorphic simple extension of Q . The map realises this isomorphism. Simple Relative Fields Creation NumberField ( f :: Poly { NumFieldElem }, s :: String ; cached :: Bool = false , check :: Bool = false ) -> NumField , NumFieldElem Given an irreducible polynomial f \\in K[t] over some number field K , this function creates the simple number field L = K[t]/(f) and returns (L, b) , where b is the class of t in L . The string s is used only for printing the primitive element b . Testing that f is irreducible can be disabled by setting the ketword argument to false . NumberField(f::Generic.Poly{T}; cached::Bool = false, check::Bool = false) where T number_field ( f :: Array { Generic . Poly { T }, 1 }, s :: String = \"_ \\$ \" ) where T -> NfRel_ns Given polynomials f = (f_1, \\ldots, f_n) over some number field k , construct K = k[t_1, \\ldots, t_n]/\\langle f_1(t_1), \\ldots, f_n(t_n)\\rangle The ideal in the quotient must be maximal - although this is not tested. NumberField(CF::ClassField) -> Hecke.NfRel_ns{Nemo.nf_elem} Given a (formal) abelian extension, compute the class field by finding defining polynomials for all prime power cyclic subfields. Note, by type this is always a non-simple extension. NumberField ( f :: Poly { NumFieldElem }, s :: String ; cached :: Bool = false , check :: Bool = false ) -> NumField , NumFieldElem Given an irreducible polynomial f \\in K[t] over some number field K , this function creates the simple number field L = K[t]/(f) and returns (L, b) , where b is the class of t in L . The string s is used only for printing the primitive element b . Testing that f is irreducible can be disabled by setting the ketword argument to false . Conversion absolute_field ( K :: NfRel { nf_elem }, cached :: Bool = false ) -> AnticNumberField , Map , Map Given an extension K/k/Q , find an isomorphic extension of Q . absolute_field ( K :: NfRel { NfRelElem }, cached :: Bool = false ) -> NfRel , Map , Map Given an extension E/K/k , find an isomorphic extension of k . In a tower, only the top-most steps are collapsed. absolute_field ( K :: NfRel { NfRelElem }, cached :: Bool = false ) -> NfRel , Map , Map Given an extension E/K/k , find an isomorphic extension of k . In a tower, only the top-most steps are collapsed. Non-Simple Relative Fields Creation number_field ( f :: Array { Generic . Poly { T }, 1 }, s :: String = \"_ \\$ \" ) where T -> NfRel_ns Given polynomials f = (f_1, \\ldots, f_n) over some number field k , construct K = k[t_1, \\ldots, t_n]/\\langle f_1(t_1), \\ldots, f_n(t_n)\\rangle The ideal in the quotient must be maximal - although this is not tested. Conversion simple_extension ( K :: NfRel_ns { nf_elem }) -> NfRel , Map Compute a simple field L as an extension of the base field of K and an isomorphism between L and K simple_extension ( K :: NfRel_ns { nf_elem }, FlintQQ ) -> AnticNumberField , Map , Map absolute_field ( K :: NfRel_ns { nf_elem }) -> AnticNumberField , Map , Map Compute an isomorphic field as an extension of Q together with the isomorphism (1st map) and the embedding of the base field (2nd map). Implicit Relative Extensions Given two absolute fields K and k as well as an embedding \\phi:k \\to K we can regard K as an extension on k , hence invariante of K can be investigated relative to k rathern than over Q . Here we list functions achieving this without actually computing K as an extension of k . minimum ( m :: T , I :: NfOrdIdl ) where T <: Map { AnticNumberField , AnticNumberField } -> NfOrdIdl Given an embedding m:k\\to K of number fields and an integral ideal in K , find the intersect I \\cap \\Z_k . norm ( m :: T , I :: NfOrdIdl ) where T <: Map { AnticNumberField , AnticNumberField } -> NfOrdIdl Given an embedding m:k\\to K of number fields and an integral ideal in K , find the norm N_{K/k}(I) . norm ( m :: T , a :: nf_elem ) where T <: Map { AnticNumberField , AnticNumberField } -> nf_elem Given an embedding m:k\\to K of number fields and an element in K , find the norm N_{K/k}(a) . discriminant ( m :: Map , R :: NfOrd ) -> NfOrdIdl The discriminant ideal of R over the maximal order of the domain of the map m , that is, the ideal generated by all norms of differents of elements in R . ( :: NfAbsOrdIdlSet )( m :: Map , I :: NfOrdIdl ) -> NfOrdIdl Given an embedding m:k\\to K of number fields and an ideal I in k , find the ideal above I in K . Invariants degree ( a :: AnticNumberField ) Return the degree of the given number field, i.e. the degree of its defining polynomial. basis ( K :: AnticNumberField ) -> Vector { nf_elem } Returns the power basis of K , that is, the elements 1,a,\\dotsc,a^{d - 1} , where d is the degree of K . discriminant ( K :: AnticNumberField ) -> fmpq discriminant ( K :: NfRel ) -> The discriminant of the defining polynomial of K {\\bf not} the discriminant of the maximal order. Elements Creation ( a :: AnticNumberField )() Return an empty (0) element. (a::AnticNumberField)(c::Int) Return c as an element in a . Predicates isintegral ( a :: NumFieldElem ) -> Bool Returns whether a is integral, that is, whether the minimal polynomial of a has integral coefficients. Invariants norm ( a :: nf_elem ) Return the absolute norm of a . The result will be a rational number. minpoly ( S :: Ring , M :: MatElem { T }, charpoly_only :: Bool = false ) where { T <: FieldElement } Returns the minimal polynomial p of the matrix M . The polynomial ring S of the resulting polynomial must be supplied and the matrix must be square. minpoly ( S :: Ring , M :: MatElem { T }, charpoly_only :: Bool = false ) where { T <: RingElement } Returns the minimal polynomial p of the matrix M . The polynomial ring S of the resulting polynomial must be supplied and the matrix must be square. minpoly(S::Ring, M::MatAlgElem{T}, charpoly_only::Bool = false) where {T <: RingElement} Returns the minimal polynomial p of the matrix M . The polynomial ring S of the resulting polynomial must be supplied and the matrix must be square. minpoly(a::NumFieldElem) -> Poly Given a number field element a of a number field K , this function returns the minimal polynomial of a over the base field of K . charpoly ( V :: Ring , Y :: Generic . MatrixElem { T }) where { T <: RingElement } Returns the characteristic polynomial p of the matrix M . The polynomial ring R of the resulting polynomial must be supplied and the matrix is assumed to be square. charpoly(a::NumFieldElem) -> Poly Given a number field element a of a number field K , this function returns the characteristic polynomial of a over the base field of K . denominator ( a :: nf_elem ) Return the denominator of the polynomial representation of the given number field element. numerator ( a :: nf_elem ) -> nf_elem For an element a\\in K = Q[t]/f write a as b/d with b\\in Z[t] , \\deg(a) = \\deg(b) and d>0 minimal in Z . This function returns b . isunit ( a :: nf_elem ) Return true if the given number field element is invertible, i.e. nonzero, otherwise return false .","title":"Number fields"},{"location":"number_fields/intro/#number-fields","text":"","title":"Number Fields"},{"location":"number_fields/intro/#introduction","text":"This chapter deals with number fields. Number fields, in Hecke, come in several different types: AnticNumberField : a finite simple extension of the rational numbers Q NfAbsNS : a finite extension of Q given by several polynomials. We will refer to this as a non-simple field - even though mathematically we can find a primitive elements. NfRel : a finite simple extension of a number field. This is actually parametried by the (element) type of the coefficient field. The complete type of an extension of an absolute field ( AnticNumberField ) is NfRel{nf_elem} . The next extension thus will be NfRel{NfRelElem{nf_elem}} . NfRel_ns : extensions of number fields given by several polynomials. This too will be refered to as a non-simple field. The simple types AnticNumberField and NfRel are also calle simple fields in the rest of this document, NfRel and NfRel_ns are referred to as relative extensions while AnticNumberField and NfAbsNS are called absolute. Internally, simple fields are essentially just (univariate) polynomial quotients in a dense representation, while non-simple fields are multivariate quotient rings, thus have a sparse presentation. In general, simple fields allow much faster arithmetic, while the non-simple fields give easy access to large degree fields.","title":"Introduction"},{"location":"number_fields/intro/#absolute-simple-fields","text":"The most basic number field type is that of AnticNumberField . Internally this is essentially represented as a unvariate quotient with the arithmetic provided by the antic-c-library and implemented in Nemo.","title":"Absolute Simple Fields"},{"location":"number_fields/intro/#creation","text":"Number fields are mostly created using NumberField , but also using number_field . Many of the constructors have arguments of type Symbol or AbstractString , if used, they define the appearance in printing, and printing only. The named parameter check can be true or false, the default being true`. This parameter controlls is the polynomial defining the number field is tested for irreducibility or not. Given that this can be potentially very time consuiming if the degree if large, one can omit this test. Note however, that the behaviour of Hecke is undefined if a reducible polynomial is used to define a field . The named boolean parameter cached is inherited from the underlying Nemo system. Two number fields defined using the same polynomial from the identical polynomial ring and the same (identical) symbol/ string will be identical if cached == true and different if cached == false . NumberField ( f :: fmpq_poly ; cached :: Bool = true , check :: Bool = true ) The number field Q[x]/f generated by f. cyclotomic_field ( n :: Int ) -> AnticNumberField , nf_elem The n -th cyclotomic field defined by the n -the cyclotomic polynomial. wildanger_field ( n :: Int , B :: fmpz ) -> AnticNumberField , nf_elem wildanger_field ( n :: Int , B :: Integer ) -> AnticNumberField , nf_elem Returns the field with defining polynomial x^n + \\sum_{i=0}^{n-1} (-1)^{n-i}Bx^i . These fields tend to have non-trivial class groups. pure_extension ( n :: Int , gen :: Integer ; cached :: Bool = true , check :: Bool = true ) -> AnticNumberField , nf_elem pure_extension ( n :: Int , gen :: fmpz ; cached :: Bool = true , check :: Bool = true ) -> AnticNumberField , nf_elem The number field with defining polynomial x^n-gen .","title":"Creation"},{"location":"number_fields/intro/#example","text":"julia> Qx, x = PolynomialRing(FlintQQ, \"x\"); julia> K, a = NumberField(x^2 - 10, \"a\");","title":"Example"},{"location":"number_fields/intro/#absolute-non-simple-fields","text":"","title":"Absolute Non-Simple Fields"},{"location":"number_fields/intro/#creation_1","text":"number_field ( f :: Array { fmpq_poly , 1 }, s :: String = \"_ \\$ \" ) -> NfAbsNS Let f = (f_1, \\ldots, f_n) be univariate rational polynomials, then we construct K = Q[t_1, \\ldots, t_n]/\\langle f_1(t_1), \\ldots, f_n(t_n)\\rangle The ideal bust be maximal, however, this is not tested.","title":"Creation"},{"location":"number_fields/intro/#example_1","text":"julia> Qx, x = PolynomialRing(FlintQQ, \"x\"); julia> K, g = number_field([x^2-2, x^2-3, x^2-5]) (Non-simple number field with defining polynomials fmpq_mpoly[_$1^2 - 2, _$2^2 - 3, _$3^2 - 5], NfAbsNSElem[_$1, _$2, _$3]) julia> g[1]^2 2 julia> minpoly(g[1] + g[2]) x^4-10*x^2+1","title":"Example"},{"location":"number_fields/intro/#conversion","text":"simple_extension ( K :: NfAbsNS ) -> AnticNumberField , Map For a non-simple extension K of Q , find a primitive element and thus an isomorphic simple extension of Q . The map realises this isomorphism.","title":"Conversion"},{"location":"number_fields/intro/#simple-relative-fields","text":"","title":"Simple Relative Fields"},{"location":"number_fields/intro/#creation_2","text":"NumberField ( f :: Poly { NumFieldElem }, s :: String ; cached :: Bool = false , check :: Bool = false ) -> NumField , NumFieldElem Given an irreducible polynomial f \\in K[t] over some number field K , this function creates the simple number field L = K[t]/(f) and returns (L, b) , where b is the class of t in L . The string s is used only for printing the primitive element b . Testing that f is irreducible can be disabled by setting the ketword argument to false . NumberField(f::Generic.Poly{T}; cached::Bool = false, check::Bool = false) where T number_field ( f :: Array { Generic . Poly { T }, 1 }, s :: String = \"_ \\$ \" ) where T -> NfRel_ns Given polynomials f = (f_1, \\ldots, f_n) over some number field k , construct K = k[t_1, \\ldots, t_n]/\\langle f_1(t_1), \\ldots, f_n(t_n)\\rangle The ideal in the quotient must be maximal - although this is not tested. NumberField(CF::ClassField) -> Hecke.NfRel_ns{Nemo.nf_elem} Given a (formal) abelian extension, compute the class field by finding defining polynomials for all prime power cyclic subfields. Note, by type this is always a non-simple extension. NumberField ( f :: Poly { NumFieldElem }, s :: String ; cached :: Bool = false , check :: Bool = false ) -> NumField , NumFieldElem Given an irreducible polynomial f \\in K[t] over some number field K , this function creates the simple number field L = K[t]/(f) and returns (L, b) , where b is the class of t in L . The string s is used only for printing the primitive element b . Testing that f is irreducible can be disabled by setting the ketword argument to false .","title":"Creation"},{"location":"number_fields/intro/#conversion_1","text":"absolute_field ( K :: NfRel { nf_elem }, cached :: Bool = false ) -> AnticNumberField , Map , Map Given an extension K/k/Q , find an isomorphic extension of Q . absolute_field ( K :: NfRel { NfRelElem }, cached :: Bool = false ) -> NfRel , Map , Map Given an extension E/K/k , find an isomorphic extension of k . In a tower, only the top-most steps are collapsed. absolute_field ( K :: NfRel { NfRelElem }, cached :: Bool = false ) -> NfRel , Map , Map Given an extension E/K/k , find an isomorphic extension of k . In a tower, only the top-most steps are collapsed.","title":"Conversion"},{"location":"number_fields/intro/#non-simple-relative-fields","text":"","title":"Non-Simple Relative Fields"},{"location":"number_fields/intro/#creation_3","text":"number_field ( f :: Array { Generic . Poly { T }, 1 }, s :: String = \"_ \\$ \" ) where T -> NfRel_ns Given polynomials f = (f_1, \\ldots, f_n) over some number field k , construct K = k[t_1, \\ldots, t_n]/\\langle f_1(t_1), \\ldots, f_n(t_n)\\rangle The ideal in the quotient must be maximal - although this is not tested.","title":"Creation"},{"location":"number_fields/intro/#conversion_2","text":"simple_extension ( K :: NfRel_ns { nf_elem }) -> NfRel , Map Compute a simple field L as an extension of the base field of K and an isomorphism between L and K simple_extension ( K :: NfRel_ns { nf_elem }, FlintQQ ) -> AnticNumberField , Map , Map absolute_field ( K :: NfRel_ns { nf_elem }) -> AnticNumberField , Map , Map Compute an isomorphic field as an extension of Q together with the isomorphism (1st map) and the embedding of the base field (2nd map).","title":"Conversion"},{"location":"number_fields/intro/#implicit-relative-extensions","text":"Given two absolute fields K and k as well as an embedding \\phi:k \\to K we can regard K as an extension on k , hence invariante of K can be investigated relative to k rathern than over Q . Here we list functions achieving this without actually computing K as an extension of k . minimum ( m :: T , I :: NfOrdIdl ) where T <: Map { AnticNumberField , AnticNumberField } -> NfOrdIdl Given an embedding m:k\\to K of number fields and an integral ideal in K , find the intersect I \\cap \\Z_k . norm ( m :: T , I :: NfOrdIdl ) where T <: Map { AnticNumberField , AnticNumberField } -> NfOrdIdl Given an embedding m:k\\to K of number fields and an integral ideal in K , find the norm N_{K/k}(I) . norm ( m :: T , a :: nf_elem ) where T <: Map { AnticNumberField , AnticNumberField } -> nf_elem Given an embedding m:k\\to K of number fields and an element in K , find the norm N_{K/k}(a) . discriminant ( m :: Map , R :: NfOrd ) -> NfOrdIdl The discriminant ideal of R over the maximal order of the domain of the map m , that is, the ideal generated by all norms of differents of elements in R . ( :: NfAbsOrdIdlSet )( m :: Map , I :: NfOrdIdl ) -> NfOrdIdl Given an embedding m:k\\to K of number fields and an ideal I in k , find the ideal above I in K .","title":"Implicit Relative Extensions"},{"location":"number_fields/intro/#invariants","text":"degree ( a :: AnticNumberField ) Return the degree of the given number field, i.e. the degree of its defining polynomial. basis ( K :: AnticNumberField ) -> Vector { nf_elem } Returns the power basis of K , that is, the elements 1,a,\\dotsc,a^{d - 1} , where d is the degree of K . discriminant ( K :: AnticNumberField ) -> fmpq discriminant ( K :: NfRel ) -> The discriminant of the defining polynomial of K {\\bf not} the discriminant of the maximal order.","title":"Invariants"},{"location":"number_fields/intro/#elements","text":"","title":"Elements"},{"location":"number_fields/intro/#creation_4","text":"( a :: AnticNumberField )() Return an empty (0) element. (a::AnticNumberField)(c::Int) Return c as an element in a .","title":"Creation"},{"location":"number_fields/intro/#predicates","text":"isintegral ( a :: NumFieldElem ) -> Bool Returns whether a is integral, that is, whether the minimal polynomial of a has integral coefficients.","title":"Predicates"},{"location":"number_fields/intro/#invariants_1","text":"norm ( a :: nf_elem ) Return the absolute norm of a . The result will be a rational number. minpoly ( S :: Ring , M :: MatElem { T }, charpoly_only :: Bool = false ) where { T <: FieldElement } Returns the minimal polynomial p of the matrix M . The polynomial ring S of the resulting polynomial must be supplied and the matrix must be square. minpoly ( S :: Ring , M :: MatElem { T }, charpoly_only :: Bool = false ) where { T <: RingElement } Returns the minimal polynomial p of the matrix M . The polynomial ring S of the resulting polynomial must be supplied and the matrix must be square. minpoly(S::Ring, M::MatAlgElem{T}, charpoly_only::Bool = false) where {T <: RingElement} Returns the minimal polynomial p of the matrix M . The polynomial ring S of the resulting polynomial must be supplied and the matrix must be square. minpoly(a::NumFieldElem) -> Poly Given a number field element a of a number field K , this function returns the minimal polynomial of a over the base field of K . charpoly ( V :: Ring , Y :: Generic . MatrixElem { T }) where { T <: RingElement } Returns the characteristic polynomial p of the matrix M . The polynomial ring R of the resulting polynomial must be supplied and the matrix is assumed to be square. charpoly(a::NumFieldElem) -> Poly Given a number field element a of a number field K , this function returns the characteristic polynomial of a over the base field of K . denominator ( a :: nf_elem ) Return the denominator of the polynomial representation of the given number field element. numerator ( a :: nf_elem ) -> nf_elem For an element a\\in K = Q[t]/f write a as b/d with b\\in Z[t] , \\deg(a) = \\deg(b) and d>0 minimal in Z . This function returns b . isunit ( a :: nf_elem ) Return true if the given number field element is invertible, i.e. nonzero, otherwise return false .","title":"Invariants"},{"location":"orders/elements/","text":"Elements Elements in orders have two representations: they can be viewed as elements in the Z^n giving the coefficients wrt to the order basis where they are elements in. On the other hand, as every order is in a field, they also have a representation as number field elements. Since, asymptotically, operations are more efficient in the field (due to fast polynomial arithmetic) than in the order, the primary representation is that as a field element. Creation Elements are constructed either as linear combinations of basis elements or via explicit coercion. Elements will be of type NfOrdElem , the type if actually parametrized by the type of the surrounding field and the type of the field elements. E.g. the type of any element in any order of an absolute simple field will be NfAbsOrdElem{AnticNumberField,nf_elem} ( O :: NfOrd )( a :: Union { fmpz , Integer }) -> NfAbsOrdElem Given an element a of type fmpz or Integer , this function coerces the element into \\mathcal O . It will be checked that a is contained in \\mathcal O if and only if check is true . (O::NfOrd)(arr::Array{fmpz, 1}) Returns the element of \\mathcal O with coefficient vector arr . (O::NfOrd)() -> NfAbsOrdElem This function constructs a new element of \\mathcal O which is set to 0 . Basic properties parent ( g :: perm { T }) where T = PermGroup Return the parent of the permutation g . julia> G = PermutationGroup(5); g = perm([3,4,5,2,1]) (1,3,5)(2,4) julia> parent(g) == G true parent(a::AbstractAlgebra.MatElem{T}, cached::Bool = true) where T <: RingElement Return the parent object of the given matrix. parent(a::AbstractAlgebra.MatAlgElem{T}, cached::Bool = true) where T <: RingElement Return the parent object of the given matrix. parent(a::NfAbsOrdElem) -> NfOrd Returns the order of which a is an element. elem_in_nf ( a :: NfAbsOrdElem ) -> nf_elem Returns the element a considered as an element of the ambient number field. coordinates ( a :: NfAbsOrdElem ) -> Array { fmpz , 1 } Returns the coefficient vector of a . discriminant ( B :: Array { NfAbsOrdElem , 1 }) -> fmpz Returns the discriminant of the family B . == ( x :: NfAbsOrdElem , y :: NfAbsOrdElem ) -> Bool Returns whether x and y are equal. zero ( O :: NfOrd ) -> NfAbsOrdElem Returns the zero element of \\mathcal O . one ( O :: NfOrd ) -> NfAbsOrdElem Returns the one element of \\mathcal O . iszero ( v :: AbstractAlgebra . FPModuleElem { T }) where T <: RingElement Return true if v is the zero element of the module M . iszero(a::NfOrd) -> Bool Tests if a is zero. isone ( a :: NfOrd ) -> Bool Tests if a is one. Arithmetic - ( a :: AbstractAlgebra . ResElem { T }, b :: AbstractAlgebra . ResElem { T }) where { T <: RingElement } Return a - b . -(a::AbstractAlgebra.ResElem{T}, b::T) where {T <: RingElem} Return a - b . -(a::T, b::AbstractAlgebra.ResElem{T}) where {T <: RingElem} Return a - b . -(a::AbstractAlgebra.ResFieldElem{T}, b::AbstractAlgebra.ResFieldElem{T}) where {T <: RingElement} Return a - b . -(a::AbstractAlgebra.ResFieldElem{T}, b::T) where {T <: RingElem} Return a - b . -(a::T, b::AbstractAlgebra.ResFieldElem{T}) where {T <: RingElem} Return a - b . -(a::AbstractAlgebra.PolyElem{T}, b::AbstractAlgebra.PolyElem{T}) where {T <: RingElement} Return a - b . -(a::AbstractAlgebra.NCPolyElem{T}, b::AbstractAlgebra.NCPolyElem{T}) where {T <: NCRingElem} Return a - b . -(a::AbstractAlgebra.RelSeriesElem{T}, b::AbstractAlgebra.RelSeriesElem{T}) where {T <: RingElement} Return a - b . -(a::AbstractAlgebra.AbsSeriesElem{T}, b::AbstractAlgebra.AbsSeriesElem{T}) where {T <: RingElement} Return a - b . -(a::Generic.LaurentSeriesElem{T}, b::Generic.LaurentSeriesElem{T}) where {T <: RingElement} Return a - b . -(x::Generic.MatrixElem{T}, y::Generic.MatrixElem{T}) where {T <: RingElement} Return x - y . -(x::T, y::Generic.MatrixElem{T}) where {T <: RingElem} Return S(x) - y where S is the parent of y . -(x::Generic.MatrixElem{T}, y::T) where {T <: RingElem} Return x - S(y) , where S is the parent of a . -(a::AbstractAlgebra.FracElem{T}, b::AbstractAlgebra.FracElem{T}) where {T <: RingElem} Return a - b . -(a::AbstractAlgebra.FracElem{T}, b::T) where {T <: RingElem} Return a - b . -(a::T, b::AbstractAlgebra.FracElem{T}) where {T <: RingElem} Return a - b . -(x::NfAbsOrdElem) -> NfAbsOrdElem Returns the additive inverse of x . -(A::SMat, B::SMat) -> SMat Return the difference A - B . -(A::SRow, B::SRow) -> SRow Returns the difference of A and B . -(A::SRow) -> SRow Returns the negative of A . -(a::AbsAlgAssElem) -> AbsAlgAssElem Returns -a . -(a::AbsAlgAssElem, b::AbsAlgAssElem) -> AbsAlgAssElem Return a - b . -(a::AlgMatElem, b::AlgMatElem) -> AlgMatElem Return a - b . + ( x :: NfAbsOrdElem , y :: NfAbsOrdElem ) -> NfAbsOrdElem Returns x + y . - ( x :: NfAbsOrdElem , y :: NfAbsOrdElem ) -> NfAbsOrdElem Returns x - y . * ( x :: NfAbsOrdElem , y :: NfAbsOrdElem ) -> NfAbsOrdElem Returns x \\cdot y . ^ ( x :: NfAbsOrdElem , y :: Union { fmpz , Int }) Returns x^y . mod ( a :: NfAbsOrdElem , m :: Union { fmpz , Int }) -> NfAbsOrdElem Reduces the coefficient vector of a modulo m and returns the corresponding element. The coefficient vector of the result will have entries x with 0 \\leq x \\leq m . powermod ( a :: NfAbsOrdElem , i :: fmpz , m :: Integer ) -> NfAbsOrdElem Returns the element a^i modulo m . Miscallenous representation_matrix ( a :: NfAbsOrdElem ) -> fmpz_mat Returns the representation matrix of the element a . representation_matrix ( a :: NfAbsOrdElem , K :: AnticNumberField ) -> FakeFmpqMat Returns the representation matrix of the element a considered as an element of the ambient number field K . It is assumed that K is the ambient number field of the order of a . representation_matrix ( a :: NfAbsOrdElem , K :: AnticNumberField ) -> FakeFmpqMat Returns the representation matrix of the element a considered as an element of the ambient number field K . It is assumed that K is the ambient number field of the order of a . tr ( a :: NfAbsOrdElem ) -> fmpz Returns the trace of a . tr(x::AbsAlgAssElem{T}) where T -> T Returns the trace of a . norm ( a :: NfAbsOrdElem ) -> fmpz Returns the norm of a . norm(a::NfRelOrdFracIdl{T, S}) -> S Returns the norm of a rand ( O :: NfOrd , n :: Union { Integer , fmpz }) -> NfAbsOrdElem Computes a coefficient vector with entries uniformly distributed in \\{-n,\\dotsc,-1,0,1,\\dotsc,n\\} and returns the corresponding element of the order \\mathcal O . minkowski_map ( a :: NfAbsOrdElem , abs_tol :: Int ) -> Array { arb , 1 } Returns the image of a under the Minkowski embedding. Every entry of the array returned is of type arb with radius less then 2^-abs_tol . conjugates_arb ( x :: NfAbsOrdElem , abs_tol :: Int ) -> Array { acb , 1 } Compute the the conjugates of x as elements of type acb . Recall that we order the complex conjugates \\sigma_{r+1}(x),...,\\sigma_{r+2s}(x) such that \\sigma_{i}(x) = \\overline{\\sigma_{i + s}(x)} for r + 2 \\leq i \\leq r + s . Every entry y of the array returned satisfies radius(real(y)) < 2^-abs_tol , radius(imag(y)) < 2^-abs_tol respectively. conjugates_arb_log ( x :: NfAbsOrdElem , abs_tol :: Int ) -> Array { arb , 1 } Returns the elements (\\log(\\lvert \\sigma_1(x) \\rvert),\\dotsc,\\log(\\lvert\\sigma_r(x) \\rvert), \\dotsc,2\\log(\\lvert \\sigma_{r+1}(x) \\rvert),\\dotsc, 2\\log(\\lvert \\sigma_{r+s}(x)\\rvert)) as elements of type arb radius less then 2^-abs_tol . t2 ( x :: NfAbsOrdElem , abs_tol :: Int = 32 ) -> arb Return the T_2 -norm of x . The radius of the result will be less than 2^-abs_tol . minpoly ( S :: Ring , M :: MatElem { T }, charpoly_only :: Bool = false ) where { T <: RingElement } Returns the minimal polynomial p of the matrix M . The polynomial ring S of the resulting polynomial must be supplied and the matrix must be square. minpoly(S::Ring, M::MatAlgElem{T}, charpoly_only::Bool = false) where {T <: RingElement} Returns the minimal polynomial p of the matrix M . The polynomial ring S of the resulting polynomial must be supplied and the matrix must be square. minpoly(a::NfAbsOrdElem) -> fmpz_poly The minimal polynomial of a . charpoly ( V :: Ring , Y :: Generic . MatrixElem { T }) where { T <: RingElement } Returns the characteristic polynomial p of the matrix M . The polynomial ring R of the resulting polynomial must be supplied and the matrix is assumed to be square. charpoly(a::NfAbsOrdElem) -> fmpz_poly charpoly(a::NfAbsOrdElem, FlintZZ) -> fmpz_poly The characteristic polynomial of a .","title":"Elements"},{"location":"orders/elements/#elements","text":"Elements in orders have two representations: they can be viewed as elements in the Z^n giving the coefficients wrt to the order basis where they are elements in. On the other hand, as every order is in a field, they also have a representation as number field elements. Since, asymptotically, operations are more efficient in the field (due to fast polynomial arithmetic) than in the order, the primary representation is that as a field element.","title":"Elements"},{"location":"orders/elements/#creation","text":"Elements are constructed either as linear combinations of basis elements or via explicit coercion. Elements will be of type NfOrdElem , the type if actually parametrized by the type of the surrounding field and the type of the field elements. E.g. the type of any element in any order of an absolute simple field will be NfAbsOrdElem{AnticNumberField,nf_elem} ( O :: NfOrd )( a :: Union { fmpz , Integer }) -> NfAbsOrdElem Given an element a of type fmpz or Integer , this function coerces the element into \\mathcal O . It will be checked that a is contained in \\mathcal O if and only if check is true . (O::NfOrd)(arr::Array{fmpz, 1}) Returns the element of \\mathcal O with coefficient vector arr . (O::NfOrd)() -> NfAbsOrdElem This function constructs a new element of \\mathcal O which is set to 0 .","title":"Creation"},{"location":"orders/elements/#basic-properties","text":"parent ( g :: perm { T }) where T = PermGroup Return the parent of the permutation g . julia> G = PermutationGroup(5); g = perm([3,4,5,2,1]) (1,3,5)(2,4) julia> parent(g) == G true parent(a::AbstractAlgebra.MatElem{T}, cached::Bool = true) where T <: RingElement Return the parent object of the given matrix. parent(a::AbstractAlgebra.MatAlgElem{T}, cached::Bool = true) where T <: RingElement Return the parent object of the given matrix. parent(a::NfAbsOrdElem) -> NfOrd Returns the order of which a is an element. elem_in_nf ( a :: NfAbsOrdElem ) -> nf_elem Returns the element a considered as an element of the ambient number field. coordinates ( a :: NfAbsOrdElem ) -> Array { fmpz , 1 } Returns the coefficient vector of a . discriminant ( B :: Array { NfAbsOrdElem , 1 }) -> fmpz Returns the discriminant of the family B . == ( x :: NfAbsOrdElem , y :: NfAbsOrdElem ) -> Bool Returns whether x and y are equal. zero ( O :: NfOrd ) -> NfAbsOrdElem Returns the zero element of \\mathcal O . one ( O :: NfOrd ) -> NfAbsOrdElem Returns the one element of \\mathcal O . iszero ( v :: AbstractAlgebra . FPModuleElem { T }) where T <: RingElement Return true if v is the zero element of the module M . iszero(a::NfOrd) -> Bool Tests if a is zero. isone ( a :: NfOrd ) -> Bool Tests if a is one.","title":"Basic properties"},{"location":"orders/elements/#arithmetic","text":"- ( a :: AbstractAlgebra . ResElem { T }, b :: AbstractAlgebra . ResElem { T }) where { T <: RingElement } Return a - b . -(a::AbstractAlgebra.ResElem{T}, b::T) where {T <: RingElem} Return a - b . -(a::T, b::AbstractAlgebra.ResElem{T}) where {T <: RingElem} Return a - b . -(a::AbstractAlgebra.ResFieldElem{T}, b::AbstractAlgebra.ResFieldElem{T}) where {T <: RingElement} Return a - b . -(a::AbstractAlgebra.ResFieldElem{T}, b::T) where {T <: RingElem} Return a - b . -(a::T, b::AbstractAlgebra.ResFieldElem{T}) where {T <: RingElem} Return a - b . -(a::AbstractAlgebra.PolyElem{T}, b::AbstractAlgebra.PolyElem{T}) where {T <: RingElement} Return a - b . -(a::AbstractAlgebra.NCPolyElem{T}, b::AbstractAlgebra.NCPolyElem{T}) where {T <: NCRingElem} Return a - b . -(a::AbstractAlgebra.RelSeriesElem{T}, b::AbstractAlgebra.RelSeriesElem{T}) where {T <: RingElement} Return a - b . -(a::AbstractAlgebra.AbsSeriesElem{T}, b::AbstractAlgebra.AbsSeriesElem{T}) where {T <: RingElement} Return a - b . -(a::Generic.LaurentSeriesElem{T}, b::Generic.LaurentSeriesElem{T}) where {T <: RingElement} Return a - b . -(x::Generic.MatrixElem{T}, y::Generic.MatrixElem{T}) where {T <: RingElement} Return x - y . -(x::T, y::Generic.MatrixElem{T}) where {T <: RingElem} Return S(x) - y where S is the parent of y . -(x::Generic.MatrixElem{T}, y::T) where {T <: RingElem} Return x - S(y) , where S is the parent of a . -(a::AbstractAlgebra.FracElem{T}, b::AbstractAlgebra.FracElem{T}) where {T <: RingElem} Return a - b . -(a::AbstractAlgebra.FracElem{T}, b::T) where {T <: RingElem} Return a - b . -(a::T, b::AbstractAlgebra.FracElem{T}) where {T <: RingElem} Return a - b . -(x::NfAbsOrdElem) -> NfAbsOrdElem Returns the additive inverse of x . -(A::SMat, B::SMat) -> SMat Return the difference A - B . -(A::SRow, B::SRow) -> SRow Returns the difference of A and B . -(A::SRow) -> SRow Returns the negative of A . -(a::AbsAlgAssElem) -> AbsAlgAssElem Returns -a . -(a::AbsAlgAssElem, b::AbsAlgAssElem) -> AbsAlgAssElem Return a - b . -(a::AlgMatElem, b::AlgMatElem) -> AlgMatElem Return a - b . + ( x :: NfAbsOrdElem , y :: NfAbsOrdElem ) -> NfAbsOrdElem Returns x + y . - ( x :: NfAbsOrdElem , y :: NfAbsOrdElem ) -> NfAbsOrdElem Returns x - y . * ( x :: NfAbsOrdElem , y :: NfAbsOrdElem ) -> NfAbsOrdElem Returns x \\cdot y . ^ ( x :: NfAbsOrdElem , y :: Union { fmpz , Int }) Returns x^y . mod ( a :: NfAbsOrdElem , m :: Union { fmpz , Int }) -> NfAbsOrdElem Reduces the coefficient vector of a modulo m and returns the corresponding element. The coefficient vector of the result will have entries x with 0 \\leq x \\leq m . powermod ( a :: NfAbsOrdElem , i :: fmpz , m :: Integer ) -> NfAbsOrdElem Returns the element a^i modulo m .","title":"Arithmetic"},{"location":"orders/elements/#miscallenous","text":"representation_matrix ( a :: NfAbsOrdElem ) -> fmpz_mat Returns the representation matrix of the element a . representation_matrix ( a :: NfAbsOrdElem , K :: AnticNumberField ) -> FakeFmpqMat Returns the representation matrix of the element a considered as an element of the ambient number field K . It is assumed that K is the ambient number field of the order of a . representation_matrix ( a :: NfAbsOrdElem , K :: AnticNumberField ) -> FakeFmpqMat Returns the representation matrix of the element a considered as an element of the ambient number field K . It is assumed that K is the ambient number field of the order of a . tr ( a :: NfAbsOrdElem ) -> fmpz Returns the trace of a . tr(x::AbsAlgAssElem{T}) where T -> T Returns the trace of a . norm ( a :: NfAbsOrdElem ) -> fmpz Returns the norm of a . norm(a::NfRelOrdFracIdl{T, S}) -> S Returns the norm of a rand ( O :: NfOrd , n :: Union { Integer , fmpz }) -> NfAbsOrdElem Computes a coefficient vector with entries uniformly distributed in \\{-n,\\dotsc,-1,0,1,\\dotsc,n\\} and returns the corresponding element of the order \\mathcal O . minkowski_map ( a :: NfAbsOrdElem , abs_tol :: Int ) -> Array { arb , 1 } Returns the image of a under the Minkowski embedding. Every entry of the array returned is of type arb with radius less then 2^-abs_tol . conjugates_arb ( x :: NfAbsOrdElem , abs_tol :: Int ) -> Array { acb , 1 } Compute the the conjugates of x as elements of type acb . Recall that we order the complex conjugates \\sigma_{r+1}(x),...,\\sigma_{r+2s}(x) such that \\sigma_{i}(x) = \\overline{\\sigma_{i + s}(x)} for r + 2 \\leq i \\leq r + s . Every entry y of the array returned satisfies radius(real(y)) < 2^-abs_tol , radius(imag(y)) < 2^-abs_tol respectively. conjugates_arb_log ( x :: NfAbsOrdElem , abs_tol :: Int ) -> Array { arb , 1 } Returns the elements (\\log(\\lvert \\sigma_1(x) \\rvert),\\dotsc,\\log(\\lvert\\sigma_r(x) \\rvert), \\dotsc,2\\log(\\lvert \\sigma_{r+1}(x) \\rvert),\\dotsc, 2\\log(\\lvert \\sigma_{r+s}(x)\\rvert)) as elements of type arb radius less then 2^-abs_tol . t2 ( x :: NfAbsOrdElem , abs_tol :: Int = 32 ) -> arb Return the T_2 -norm of x . The radius of the result will be less than 2^-abs_tol . minpoly ( S :: Ring , M :: MatElem { T }, charpoly_only :: Bool = false ) where { T <: RingElement } Returns the minimal polynomial p of the matrix M . The polynomial ring S of the resulting polynomial must be supplied and the matrix must be square. minpoly(S::Ring, M::MatAlgElem{T}, charpoly_only::Bool = false) where {T <: RingElement} Returns the minimal polynomial p of the matrix M . The polynomial ring S of the resulting polynomial must be supplied and the matrix must be square. minpoly(a::NfAbsOrdElem) -> fmpz_poly The minimal polynomial of a . charpoly ( V :: Ring , Y :: Generic . MatrixElem { T }) where { T <: RingElement } Returns the characteristic polynomial p of the matrix M . The polynomial ring R of the resulting polynomial must be supplied and the matrix is assumed to be square. charpoly(a::NfAbsOrdElem) -> fmpz_poly charpoly(a::NfAbsOrdElem, FlintZZ) -> fmpz_poly The characteristic polynomial of a .","title":"Miscallenous"},{"location":"orders/frac_ideals/","text":"Fractional ideals A fractional ideal in the number field K is a Z_K -module A such that there exists an integer d>0 wich dA is an (integral) ideal in Z_K . Due to the Dedekind property of Z_K , the ideals for a multiplicative group. Fractional ideals are represented as an integral ideal and an additional denominator. They are of type NfOrdFracIdl . Creation frac_ideal ( O :: NfOrd , A :: fmpz_mat , b :: fmpz , A_in_hnf :: Bool = false ) -> NfOrdFracIdl Creates the fractional ideal of \\mathcal O with basis matrix A/b . If A in hnf is set, then it is assumed that A is already in lower left HNF. frac_ideal ( O :: NfOrd , A :: fmpz_mat , b :: fmpz , A_in_hnf :: Bool = false ) -> NfOrdFracIdl Creates the fractional ideal of \\mathcal O with basis matrix A/b . If A in hnf is set, then it is assumed that A is already in lower left HNF. frac_ideal ( O :: NfOrd , A :: FakeFmpqMat , A_in_hnf :: Bool = false ) -> NfOrdFracIdl Creates the fractional ideal of \\mathcal O with basis matrix A . If A in hnf is set, then it is assumed that the numerator of A is already in lower left HNF. frac_ideal ( O :: NfOrd , I :: NfOrdIdl ) -> NfOrdFracIdl Turns the ideal I into a fractional ideal of \\mathcal O . frac_ideal ( O :: NfOrd , I :: NfOrdIdl , b :: fmpz ) -> NfOrdFracIdl Creates the fractional ideal I/b of \\mathcal O . frac_ideal ( O :: NfOrd , a :: nf_elem ) -> NfOrdFracIdl Creates the principal fractional ideal (a) of \\mathcal O . frac_ideal ( O :: NfOrd , a :: NfOrdElem ) -> NfOrdFracIdl Creates the principal fractional ideal (a) of \\mathcal O . inv ( a :: LocElem { T }, checked :: Bool = true ) where { T <: RingElem } Returns the inverse element of a if a is a unit. If 'checked = false' the invertibility of a is not checked and the corresponding inverse element of the Fraction Field is returned. inv(A::NfAbsOrdIdl) -> NfOrdFracIdl Computes the inverse of A, that is, the fractional ideal B such that AB = \\mathcal O_K . inv(a::NfRelOrdIdl) -> NfRelOrdFracIdl inv(a::NfRelOrdFracIdl) -> NfRelOrdFracIdl Computes the inverse of a , that is, the fractional ideal b such that ab = O , where O is the ambient order of a . O must be maximal. Arithmetic == ( x :: NfOrdFracIdl , y :: NfOrdFracIdl ) -> Bool Returns whether x and y are equal. inv ( A :: NfOrdFracIdl ) -> NfOrdFracIdl Returns the fractional ideal B such that AB = \\mathcal O . integral_split ( A :: NfOrdFracIdl ) -> NfOrdIdl , NfOrdIdl Computes the unique coprime integral ideals N and D s.th. A = ND^{-1} Miscaellenous order ( a :: NfOrdFracIdl ) -> NfOrd The order that was used to define the ideal a . basis_mat ( I :: NfOrdFracIdl ) -> FakeFmpqMat Returns the basis matrix of I with respect to the basis of the order. basis_mat_inv ( I :: NfOrdFracIdl ) -> FakeFmpqMat Returns the inverse of the basis matrix of I . basis ( I :: NfOrdFracIdl ) -> Array { nf_elem , 1 } Returns the \\mathbf Z -basis of I . norm ( I :: NfOrdFracIdl ) -> fmpq Returns the norm of I","title":"Fractional Ideals"},{"location":"orders/frac_ideals/#fractional-ideals","text":"A fractional ideal in the number field K is a Z_K -module A such that there exists an integer d>0 wich dA is an (integral) ideal in Z_K . Due to the Dedekind property of Z_K , the ideals for a multiplicative group. Fractional ideals are represented as an integral ideal and an additional denominator. They are of type NfOrdFracIdl .","title":"Fractional ideals"},{"location":"orders/frac_ideals/#creation","text":"frac_ideal ( O :: NfOrd , A :: fmpz_mat , b :: fmpz , A_in_hnf :: Bool = false ) -> NfOrdFracIdl Creates the fractional ideal of \\mathcal O with basis matrix A/b . If A in hnf is set, then it is assumed that A is already in lower left HNF. frac_ideal ( O :: NfOrd , A :: fmpz_mat , b :: fmpz , A_in_hnf :: Bool = false ) -> NfOrdFracIdl Creates the fractional ideal of \\mathcal O with basis matrix A/b . If A in hnf is set, then it is assumed that A is already in lower left HNF. frac_ideal ( O :: NfOrd , A :: FakeFmpqMat , A_in_hnf :: Bool = false ) -> NfOrdFracIdl Creates the fractional ideal of \\mathcal O with basis matrix A . If A in hnf is set, then it is assumed that the numerator of A is already in lower left HNF. frac_ideal ( O :: NfOrd , I :: NfOrdIdl ) -> NfOrdFracIdl Turns the ideal I into a fractional ideal of \\mathcal O . frac_ideal ( O :: NfOrd , I :: NfOrdIdl , b :: fmpz ) -> NfOrdFracIdl Creates the fractional ideal I/b of \\mathcal O . frac_ideal ( O :: NfOrd , a :: nf_elem ) -> NfOrdFracIdl Creates the principal fractional ideal (a) of \\mathcal O . frac_ideal ( O :: NfOrd , a :: NfOrdElem ) -> NfOrdFracIdl Creates the principal fractional ideal (a) of \\mathcal O . inv ( a :: LocElem { T }, checked :: Bool = true ) where { T <: RingElem } Returns the inverse element of a if a is a unit. If 'checked = false' the invertibility of a is not checked and the corresponding inverse element of the Fraction Field is returned. inv(A::NfAbsOrdIdl) -> NfOrdFracIdl Computes the inverse of A, that is, the fractional ideal B such that AB = \\mathcal O_K . inv(a::NfRelOrdIdl) -> NfRelOrdFracIdl inv(a::NfRelOrdFracIdl) -> NfRelOrdFracIdl Computes the inverse of a , that is, the fractional ideal b such that ab = O , where O is the ambient order of a . O must be maximal.","title":"Creation"},{"location":"orders/frac_ideals/#arithmetic","text":"== ( x :: NfOrdFracIdl , y :: NfOrdFracIdl ) -> Bool Returns whether x and y are equal. inv ( A :: NfOrdFracIdl ) -> NfOrdFracIdl Returns the fractional ideal B such that AB = \\mathcal O . integral_split ( A :: NfOrdFracIdl ) -> NfOrdIdl , NfOrdIdl Computes the unique coprime integral ideals N and D s.th. A = ND^{-1}","title":"Arithmetic"},{"location":"orders/frac_ideals/#miscaellenous","text":"order ( a :: NfOrdFracIdl ) -> NfOrd The order that was used to define the ideal a . basis_mat ( I :: NfOrdFracIdl ) -> FakeFmpqMat Returns the basis matrix of I with respect to the basis of the order. basis_mat_inv ( I :: NfOrdFracIdl ) -> FakeFmpqMat Returns the inverse of the basis matrix of I . basis ( I :: NfOrdFracIdl ) -> Array { nf_elem , 1 } Returns the \\mathbf Z -basis of I . norm ( I :: NfOrdFracIdl ) -> fmpq Returns the norm of I","title":"Miscaellenous"},{"location":"orders/ideals/","text":"Ideals (Integral) ideals in orders are always free Z -module of the same rank as the order, hence have a representation via a Z -basis. This can be made unique by normalising the corresponding matrix to be in reduced row echelon form (HNF). For ideals in maximal orders Z_K , we also have a second presentation coming from the Z_K module structure and the fact that Z_K is a Dedekind ring: ideals can be generated by 2 elements, one of which can be any non-zero element in the ideal. For efficiency, we will choose the 1st generator to be an integer. Ideals here are of type NfAbsOrdIdl , which is, similar to the elements above, also indexed by the type of the field and their elements: NfAbsOrdIdl{AnticNumberField,nf_elem} for ideals in simple absolute fields. Different to elements, the parent of an ideal is teh set of all ideals in the ring, of type NfAbsOrdIdlSet . Creation ideal ( O :: NfOrd , a :: fmpz ) -> NfAbsOrdIdl ideal ( O :: NfOrd , a :: Integer ) -> NfAbsOrdIdl Returns the ideal of \\mathcal O which is generated by a . ideal ( O :: NfOrd , x :: fmpz_mat , check :: Bool = false , x_in_hnf :: Bool = false ) -> NfAbsOrdIdl Creates the ideal of \\mathcal O with basis matrix x . If check is set, then it is checked whether x defines an ideal (expensive). If x in hnf is set, then it is assumed that x is already in lower left HNF. ideal ( O :: NfOrd , x :: NfOrdElem ) -> NfAbsOrdIdl Creates the principal ideal (x) of \\mathcal O . ideal ( O :: NfOrd , x :: fmpz , y :: NfOrdElem ) -> NfAbsOrdIdl ideal ( O :: NfOrd , x :: Integer , y :: NfOrdElem ) -> NfAbsOrdIdl Creates the ideal (x, y) of \\mathcal O . ideal ( O :: NfOrd , I :: NfAbsOrdIdl ) -> NfOrdFracIdl The fractional ideal of O generated by a Z-basis of I . * ( O :: NfOrd , x :: NfOrdElem ) -> NfAbsOrdIdl * ( x :: NfOrdElem , O :: NfOrd ) -> NfAbsOrdIdl Returns the principal ideal (x) of \\mathcal O . prime_decomposition ( O :: NfAbsOrd , p :: Integer , degree_limit :: Int = 0 , lower_limit :: Int = 0 ) -> Array { Tuple { NfOrdIdl , Int }, 1 } Returns an array of tuples (\\mathfrak p_i,e_i) such that p \\mathcal O is the product of the \\mathfrak p_i^{e_i} and \\mathfrak p_i \\neq \\mathfrak p_j for i \\neq j . If degree_limit is a nonzero integer k > 0 , then only those prime ideals \\mathfrak p with \\deg(\\mathfrak p) \\leq k will be returned. Similarly if \\lower_limit is a nonzero integer l > 0 , then only those prime ideals \\mathfrak p with l \\leq \\deg(\\mathfrak p) will be returned. Note that in this case it may happen that p\\mathcal O is not the product of the \\mathfrak p_i^{e_i} . prime_decomposition ( O :: NfAbsOrd , p :: Integer , degree_limit :: Int = 0 , lower_limit :: Int = 0 ) -> Array { Tuple { NfOrdIdl , Int }, 1 } Returns an array of tuples (\\mathfrak p_i,e_i) such that p \\mathcal O is the product of the \\mathfrak p_i^{e_i} and \\mathfrak p_i \\neq \\mathfrak p_j for i \\neq j . If degree_limit is a nonzero integer k > 0 , then only those prime ideals \\mathfrak p with \\deg(\\mathfrak p) \\leq k will be returned. Similarly if \\lower_limit is a nonzero integer l > 0 , then only those prime ideals \\mathfrak p with l \\leq \\deg(\\mathfrak p) will be returned. Note that in this case it may happen that p\\mathcal O is not the product of the \\mathfrak p_i^{e_i} . factor ( A :: NfOrdIdl ) -> Dict { NfOrdIdl , Int } Computes the prime ideal factorization A as a dictionary, the keys being the prime ideal divisors: If lp = factor_dict(A) , then keys(lp) are the prime ideal divisors of A and lp[P] is the P -adic valuation of A for all P in keys(lp) . factor(a::nf_elem, I::NfOrdIdlSet) -> Dict{NfOrdIdl, fmpz} Factors the principal ideal generated by a . Arithmetic == ( x :: NfAbsOrdIdl , y :: NfAbsOrdIdl ) Returns whether x and y are equal. + ( x :: NfOrdIdl , y :: NfOrdIdl ) Returns x + y . * ( x :: NfOrdIdl , y :: NfOrdIdl ) Returns x \\cdot y . divexact ( A :: NfOrdIdl , B :: NfOrdIdl ) -> NfOrdIdl Returns AB^{-1} assuming that AB^{-1} is again an integral ideal. divides ( A :: NfOrdIdl , B :: NfOrdIdl ) Checks if B divides A intersect ( x :: NfOrdIdl , y :: NfOrdIdl ) -> NfOrdIdl lcm ( x :: NfOrdIdl , y :: NfOrdIdl ) -> NfOrdIdl Returns x \\cap y . gcd(A::NfOrdIdl, B::NfOrdIdl) -> NfOrdIdl The gcd or sum (A+B). gcd(A::NfOrdIdl, p::fmpz) -> NfOrdIdl The gcd or sum (A + pO). intersect ( x :: NfOrdIdl , y :: NfOrdIdl ) -> NfOrdIdl lcm ( x :: NfOrdIdl , y :: NfOrdIdl ) -> NfOrdIdl Returns x \\cap y . colon ( a :: NfAbsOrdIdl , b :: NfAbsOrdIdl ) -> NfOrdFracIdl The ideal (a:b) = \\{x \\in K | xb \\subseteq a\\} = \\hom(b, a) where K is the number field. in ( x :: NfOrdElem , y :: NfAbsOrdIdl ) in ( x :: nf_elem , y :: NfAbsOrdIdl ) in ( x :: fmpz , y :: NfAbsOrdIdl ) Returns whether x is contained in y . ispower ( A :: NfAbsOrdIdl , n :: Int ) -> Bool , NfAbsOrdIdl ispower ( A :: NfOrdFracIdl , n :: Int ) -> Bool , NfOrdFracIdl Computes, if possible, an ideal B s.th. B^n==A holds. In this case, {{{true}}} and B are returned. ispower ( I :: NfAbsOrdIdl ) -> Int , NfAbsOrdIdl ispower ( a :: NfOrdFracIdl ) -> Int , NfOrdFracIdl Writes a = r^e with e maximal. Note: 1 = 1^0 . isinvertible ( A :: NfAbsOrdIdl ) -> Bool , NfOrdFracIdl Returns true and an inverse of A or false and an ideal B such that A*B \\subsetneq order(A) , if A is not invertible. isone ( A :: NfAbsOrdIdl ) -> Bool isunit ( A :: NfAbsOrdIdl ) -> Bool Tests if A is the trivial ideal generated by 1 . Class Group The group of invertable ideals in any order forms a group and the principal ideals a subgroup. The finite quotient is called class group for maximal orders and Picard group or ring class group in general. class_group ( O :: NfOrd ; bound = - 1 , method = 3 , redo = false , large = 1000 ) -> GrpAbFinGen , Map Returns a group A and a map f from A to the set of ideals of O . The inverse of the map is the projection onto the group of ideals modulo the group of principal ideals. \\texttt{redo} allows to trigger a re-computation, thus avoiding the cache. \\texttt{bound}, when given, is the bound for the factor base. class_group ( K :: AnticNumberField ) -> GrpAbFinGen , Map Shortcut for {{{class group(maximal order(K))}}}: returns the class group as an abelian group and a map from this group to the set of ideals of the maximal order. picard_group ( O :: NfOrd ) -> GrpAbFinGen , MapClassGrp Returns the Picard group of O and a map from the group in the set of (invertible) ideals of O. ring_class_group ( O :: NfAbsOrd ) The ring class group (Picard group) of O . julia> k, a = wildanger_field(3, 13); julia> zk = maximal_order(k); julia> c, mc = class_group(zk) (GrpAb: Z/9, ClassGroup map of Set of ideals of Maximal order of Number field over Rational Field with defining polynomial x^3-13*x^2+13*x-13 with basis nf_elem[1, _$, 1//2*_$^2 + 1//2] ) julia> lp = prime_ideals_up_to(zk, 20); julia> [ mc \\ I for I = lp] 10-element Array{GrpAbFinGenElem,1}: Element of GrpAb: Z/9 with components [4] Element of GrpAb: Z/9 with components [1] Element of GrpAb: Z/9 with components [4] Element of GrpAb: Z/9 with components [5] Element of GrpAb: Z/9 with components [3] Element of GrpAb: Z/9 with components [2] Element of GrpAb: Z/9 with components [7] Element of GrpAb: Z/9 with components [1] Element of GrpAb: Z/9 with components [0] Element of GrpAb: Z/9 with components [2] julia> mc(c[1]) <2, 3//2*_$^2 + 1//2> Norm: 2 Minimum: 2 basis_mat [2 0 0] [1 1 0] [1 0 1] two normal wrt: 2 julia> order(c[1]) 9 julia> mc(c[1])^Int(order(c[1])) <512, 15850805895379398141//2*_$^2 - 7865890757002315674*_$ + 17160967849687022455//2> Norm: 512 Minimum: 512 two normal wrt: 2 julia> mc \\ ans Element of GrpAb: Z/9 with components [0] The class group, or more precisely the information used to compute it also allows for principal ideal testing and related tasks. In general, due to the size of the objetcs, the fac_elem versions are more effcient. isprincipal ( A :: NfOrdIdl ) -> Bool , NfOrdElem isprincipal ( A :: NfOrdFracIdl ) -> Bool , NfOrdElem Tests if A is principal and returns (\\mathtt{true}, \\alpha) if A = \\langle \\alpha\\rangle of (\\mathtt{false}, 1) otherwise. isprincipal_fac_elem ( A :: NfOrdIdl ) -> Bool , FacElem { nf_elem , NumberField } Tests if A is principal and returns (\\mathtt{true}, \\alpha) if A = \\langle \\alpha\\rangle of (\\mathtt{false}, 1) otherwise. The generator will be in factored form. power_class ( A :: NfOrdIdl , e :: fmpz ) -> NfOrdIdl Computes a (small) ideal in the same class as A^e power_product_class ( A :: Array { NfOrdIdl , 1 }, e :: Array { fmpz , 1 }) -> NfOrdIdl Computes a (small) ideal in the same class as \\prod A_i^{e_i} . power_reduce2 ( A :: NfOrdIdl , e :: fmpz ) -> NfOrdIdl , FacElem { nf_elem } Computes B and \\alpha in factored form, such that \\alpha B = A^e B has small norm. class_group_ideal_relation ( I :: NfOrdIdl , c :: ClassGrpCtx ) -> nf_elem , SRow { fmpz } Finds a number field element \\alpha such that \\alpha I factors over the factor base in c . julia> I = mc(c[1]) <2, 3//2*_$^2 + 1//2> Norm: 2 Minimum: 2 basis_mat [2 0 0] [1 1 0] [1 0 1] two normal wrt: 2 julia> Hecke.isprincipal(I) (false, 1) julia> I = I^Int(order(c[1])) <512, 15850805895379398141//2*_$^2 - 7865890757002315674*_$ + 17160967849687022455//2> Norm: 512 Minimum: 512 two normal wrt: 2 julia> Hecke.isprincipal(I) (true, 1//2*_$^2 - 3*_$ + 9//2) julia> Hecke.isprincipal_fac_elem(I) (true, Factored element with data Dict(5*_$+49=>-48,_$+38=>11,_$+1=>35,5=>-51,_$^2 - 2*_$ - 2=>-39,7=>39,_$+2=>80,1//2*_$^2 + 5//2=>-66,-_$^2 + 10*_$ + 12=>48,_$-4=>16,11=>-40,_$^2 + 1*_$ + 2=>51,_$+5=>17,107=>-11,_$-16=>11,_$-35=>11,1=>1)) The computation of S -units is also tied to the class group: unit_group ( O :: NfOrd ) -> GrpAbFinGen , Map Returns a group U and an isomorphism map f \\colon U \\to \\mathcal O^\\times . A set of fundamental units of \\mathcal O can be obtained via [ f(U[1+i]) for i in 1:unit_rank(O) ] . f(U[1]) will give a generator for the torsion subgroup. unit_group_fac_elem ( O :: NfOrd ) -> GrpAbFinGen , Map Returns a group U and an isomorphism map f \\colon U \\to \\mathcal O^\\times . A set of fundamental units of \\mathcal O can be obtained via [ f(U[1+i]) for i in 1:unit_rank(O) ] . f(U[1]) will give a generator for the torsion subgroup. All elements will be returned in factored form. sunit_group ( I :: Array { NfOrdIdl , 1 }) -> GrpAb , Map For an array I of (coprime prime) ideals, find the S -unit group defined by I , ie. the group of non-zero field elements which are only divisible by ideals in I . sunit_group_fac_elem ( I :: Array { NfOrdIdl , 1 }) -> GrpAb , Map For an array I of (coprime prime) ideals, find the S -unit group defined by I , ie. the group of non-zero field elements which are only divisible by ideals in I . The map will return elements in factored form. sunit_mod_units_group_fac_elem ( I :: Array { NfOrdIdl , 1 }) -> GrpAb , Map For an array I of (coprime prime) ideals, find the S -unit group defined by I , ie. the group of non-zero field elements which are only divisible by ideals in I modulo the units of the field. The map will return elements in factored form. julia> u, mu = unit_group(zk) (GrpAb: Z/2 x Z, UnitGroup map of Maximal order of Number field over Rational Field with defining polynomial x^3-13*x^2+13*x-13 with basis nf_elem[1, _$, 1//2*_$^2 + 1//2] ) julia> mu(u[2]) -_$^2 + 1*_$ - 1 julia> u, mu = unit_group_fac_elem(zk) (GrpAb: Z/2 x Z, UnitGroup map of Factored elements over Number field over Rational Field with defining polynomial x^3-13*x^2+13*x-13 ) julia> mu(u[2]) Factored element with data Dict(5*_$+49=>3,_$+38=>1,5=>1,_$^2 - 2*_$ - 2=>4,7=>-4,_$+2=>-6,1//2*_$^2 + 5//2=>4,-_$^2 + 10*_$ + 12=>-3,_$-4=>-1,11=>3,_$^2 + 1*_$ + 2=>-1,_$+5=>-7,107=>-1,_$-16=>1,_$-35=>1) julia> evaluate(ans) -_$^2 + 1*_$ - 1 julia> lp = factor(6*zk) Dict{NfAbsOrdIdl{AnticNumberField,nf_elem},Int64} with 4 entries: <3, _$^2 + 1> => 1 <2, 3//2*_$^2 + 1//2> => 1 <2, 7//2*_$^2 + 3//2> => 2 <3, _$-1> => 1 julia> s, ms = Hecke.sunit_group(collect(keys(lp))) (GrpAb: Z/2 x Z^5, SUnits map of Number field over Rational Field with defining polynomial x^3-13*x^2+13*x-13 for NfAbsOrdIdl{AnticNumberField,nf_elem}[<3, _$^2 + 1>, <2, 3//2*_$^2 + 1//2>, <2, 7//2*_$^2 + 3//2>, <3, _$-1>] ) julia> ms(s[4]) 1//2*_$^2 - 6*_$ - 1//2 julia> norm(ans) -18 julia> factor(numerator(ans)) -1 * 2 * 3^2 Miscaellenous order ( I :: NfAbsOrdIdl ) -> NfOrd Returns the order of I . nf ( x :: NfAbsOrdIdl ) -> AnticNumberField Returns the number field, of which x is an integral ideal. basis ( A :: NfAbsOrdIdl ) -> Array { NfOrdElem , 1 } Returns the basis of A. basis_mat ( A :: NfAbsOrdIdl ) -> fmpz_mat Returns the basis matrix of A . basis_mat_inv ( O :: NfOrd ) -> FakeFmpqMat Returns the inverse of the basis matrix of \\mathcal O . basis_mat_inv(A::NfAbsOrdIdl) -> fmpz_mat Returns the inverse basis matrix of A . basis_mat_inv ( A :: NfAbsOrdIdl ) -> FakeFmpqMat Returns the inverse of the basis matrix of A . has_basis ( A :: NfAbsOrdIdl ) -> Bool Returns whether A has a basis already computed. has_basis_mat ( A :: NfAbsOrdIdl ) -> Bool Returns whether A knows its basis matrix. has_2_elem ( A :: NfAbsOrdIdl ) -> Bool Returns whether A is generated by two elements. has_2_elem_normal ( A :: NfAbsOrdIdl ) -> Bool Returns whether A has normal two element generators. has_weakly_normal ( A :: NfAbsOrdIdl ) -> Bool Returns whether A has weakly normal two element generators. has_basis_princ_gen_special ( A :: NfAbsOrdIdl ) -> Bool Returns whether A knows if it is generated by a rational integer. principal_gen ( A :: NfOrdIdl ) -> NfOrdElem For a principal ideal A , find a generator. principal_gen_fac_elem ( A :: NfOrdIdl ) -> FacElem { nf_elem , NumberField } For a principal ideal A , find a generator in factored form. minimum ( A :: NfAbsOrdIdl ) -> fmpz Returns the smallest nonnegative element in A \\cap \\mathbf Z . has_minimum ( A :: NfAbsOrdIdl ) -> Bool Returns whether A knows its mininum. norm ( A :: NfAbsOrdIdl ) -> fmpz Returns the norm of A , that is, the cardinality of \\mathcal O/A , where \\mathcal O is the order of A . norm(a::NfRelOrdFracIdl{T, S}) -> S Returns the norm of a has_norm ( A :: NfAbsOrdIdl ) -> Bool Returns whether A knows its norm. idempotents ( x :: NfOrdIdl , y :: NfOrdIdl ) -> NfOrdElem , NfOrdElem Returns a tuple (e, f) consisting of elements e in x , f in y such that 1 = e + f . If the ideals are not coprime, an error is raised. isprime ( A :: NfOrdIdl ) -> Bool Returns whether A is a prime ideal. isprime_known ( A :: NfOrdIdl ) -> Bool Returns whether A knows if it is prime. splitting_type ( P :: NfOrdIdl ) -> Int , Int The ramification index and inertia degree of the prime ideal P . First value is the ramificatio index, the second the degree of P . isramified ( O :: NfOrd , p :: Int ) -> Bool Returns whether the integer p is ramified in \\mathcal O . It is assumed that p is prime. ramification_index ( P :: NfOrdIdl ) -> Int The ramification index of the prime-ideal P . degree ( P :: NfOrdIdl ) -> Int The inertia degree of the prime-ideal P . valuation ( a :: nf_elem , p :: NfOrdIdl ) -> fmpz valuation ( a :: NfOrdElem , p :: NfOrdIdl ) -> fmpz valuation ( a :: fmpz , p :: NfOrdIdl ) -> fmpz Computes the \\mathfrak p -adic valuation of a , that is, the largest i such that a is contained in \\mathfrak p^i . valuation ( a :: nf_elem , p :: NfOrdIdl ) -> fmpz valuation ( a :: NfOrdElem , p :: NfOrdIdl ) -> fmpz valuation ( a :: fmpz , p :: NfOrdIdl ) -> fmpz Computes the \\mathfrak p -adic valuation of a , that is, the largest i such that a is contained in \\mathfrak p^i . valuation ( A :: NfOrdIdl , p :: NfOrdIdl ) -> fmpz Computes the \\mathfrak p -adic valuation of A , that is, the largest i such that A is contained in \\mathfrak p^i . valuation ( a :: Integer , p :: NfOrdIdl ) -> fmpz Computes the \\mathfrak p -adic valuation of a , that is, the largest i such that a is contained in \\mathfrak p^i . valuation ( a :: nf_elem , p :: NfOrdIdl ) -> fmpz valuation ( a :: NfOrdElem , p :: NfOrdIdl ) -> fmpz valuation ( a :: fmpz , p :: NfOrdIdl ) -> fmpz Computes the \\mathfrak p -adic valuation of a , that is, the largest i such that a is contained in \\mathfrak p^i . valuation ( A :: NfOrdFracIdl , p :: NfOrdIdl ) The valuation of A at p . Quotient Rings Missing docstring. Missing docstring for quo(::NfOrd, ::NfOrdIdl) . Check Documenter's build log for details. ResidueRing ( O :: NfOrd , I :: NfOrdIdl ) -> NfOrdQuoRing ResidueRing ( O :: AlgAssAbsOrd , I :: AlgAssAbsOrdIdl ) -> AbsOrdQuoRing The quotient ring O modulo I as a new ring. ResidueField ( O :: NfOrd , P :: NfOrdIdl , check :: Bool = true ) -> Field , Map Returns the residue field of the prime ideal P together with th projection map. If check is true, the ideal is checked for being prime. mod ( x :: NfOrdElem , I :: NfAbsOrdIdl ) Returns the unique element y of the ambient order of x with x \\equiv y \\bmod I and the following property: If a_1,\\dotsc,a_d \\in \\Z_{\\geq 1} are the diagonal entries of the unique HNF basis matrix of I and (b_1,\\dotsc,b_d) is the coefficient vector of y , then 0 \\leq b_i < a_i for 1 \\leq i \\leq d . crt ( r1 :: NfOrdElem , i1 :: NfOrdIdl , r2 :: NfOrdElem , i2 :: NfOrdIdl ) -> NfOrdElem Find x s.th x \\equiv r1 \\bmod i1 and x \\equiv r2 \\bmod i2 using (((idempotents)))","title":"Ideals"},{"location":"orders/ideals/#ideals","text":"(Integral) ideals in orders are always free Z -module of the same rank as the order, hence have a representation via a Z -basis. This can be made unique by normalising the corresponding matrix to be in reduced row echelon form (HNF). For ideals in maximal orders Z_K , we also have a second presentation coming from the Z_K module structure and the fact that Z_K is a Dedekind ring: ideals can be generated by 2 elements, one of which can be any non-zero element in the ideal. For efficiency, we will choose the 1st generator to be an integer. Ideals here are of type NfAbsOrdIdl , which is, similar to the elements above, also indexed by the type of the field and their elements: NfAbsOrdIdl{AnticNumberField,nf_elem} for ideals in simple absolute fields. Different to elements, the parent of an ideal is teh set of all ideals in the ring, of type NfAbsOrdIdlSet .","title":"Ideals"},{"location":"orders/ideals/#creation","text":"ideal ( O :: NfOrd , a :: fmpz ) -> NfAbsOrdIdl ideal ( O :: NfOrd , a :: Integer ) -> NfAbsOrdIdl Returns the ideal of \\mathcal O which is generated by a . ideal ( O :: NfOrd , x :: fmpz_mat , check :: Bool = false , x_in_hnf :: Bool = false ) -> NfAbsOrdIdl Creates the ideal of \\mathcal O with basis matrix x . If check is set, then it is checked whether x defines an ideal (expensive). If x in hnf is set, then it is assumed that x is already in lower left HNF. ideal ( O :: NfOrd , x :: NfOrdElem ) -> NfAbsOrdIdl Creates the principal ideal (x) of \\mathcal O . ideal ( O :: NfOrd , x :: fmpz , y :: NfOrdElem ) -> NfAbsOrdIdl ideal ( O :: NfOrd , x :: Integer , y :: NfOrdElem ) -> NfAbsOrdIdl Creates the ideal (x, y) of \\mathcal O . ideal ( O :: NfOrd , I :: NfAbsOrdIdl ) -> NfOrdFracIdl The fractional ideal of O generated by a Z-basis of I . * ( O :: NfOrd , x :: NfOrdElem ) -> NfAbsOrdIdl * ( x :: NfOrdElem , O :: NfOrd ) -> NfAbsOrdIdl Returns the principal ideal (x) of \\mathcal O . prime_decomposition ( O :: NfAbsOrd , p :: Integer , degree_limit :: Int = 0 , lower_limit :: Int = 0 ) -> Array { Tuple { NfOrdIdl , Int }, 1 } Returns an array of tuples (\\mathfrak p_i,e_i) such that p \\mathcal O is the product of the \\mathfrak p_i^{e_i} and \\mathfrak p_i \\neq \\mathfrak p_j for i \\neq j . If degree_limit is a nonzero integer k > 0 , then only those prime ideals \\mathfrak p with \\deg(\\mathfrak p) \\leq k will be returned. Similarly if \\lower_limit is a nonzero integer l > 0 , then only those prime ideals \\mathfrak p with l \\leq \\deg(\\mathfrak p) will be returned. Note that in this case it may happen that p\\mathcal O is not the product of the \\mathfrak p_i^{e_i} . prime_decomposition ( O :: NfAbsOrd , p :: Integer , degree_limit :: Int = 0 , lower_limit :: Int = 0 ) -> Array { Tuple { NfOrdIdl , Int }, 1 } Returns an array of tuples (\\mathfrak p_i,e_i) such that p \\mathcal O is the product of the \\mathfrak p_i^{e_i} and \\mathfrak p_i \\neq \\mathfrak p_j for i \\neq j . If degree_limit is a nonzero integer k > 0 , then only those prime ideals \\mathfrak p with \\deg(\\mathfrak p) \\leq k will be returned. Similarly if \\lower_limit is a nonzero integer l > 0 , then only those prime ideals \\mathfrak p with l \\leq \\deg(\\mathfrak p) will be returned. Note that in this case it may happen that p\\mathcal O is not the product of the \\mathfrak p_i^{e_i} . factor ( A :: NfOrdIdl ) -> Dict { NfOrdIdl , Int } Computes the prime ideal factorization A as a dictionary, the keys being the prime ideal divisors: If lp = factor_dict(A) , then keys(lp) are the prime ideal divisors of A and lp[P] is the P -adic valuation of A for all P in keys(lp) . factor(a::nf_elem, I::NfOrdIdlSet) -> Dict{NfOrdIdl, fmpz} Factors the principal ideal generated by a .","title":"Creation"},{"location":"orders/ideals/#arithmetic","text":"== ( x :: NfAbsOrdIdl , y :: NfAbsOrdIdl ) Returns whether x and y are equal. + ( x :: NfOrdIdl , y :: NfOrdIdl ) Returns x + y . * ( x :: NfOrdIdl , y :: NfOrdIdl ) Returns x \\cdot y . divexact ( A :: NfOrdIdl , B :: NfOrdIdl ) -> NfOrdIdl Returns AB^{-1} assuming that AB^{-1} is again an integral ideal. divides ( A :: NfOrdIdl , B :: NfOrdIdl ) Checks if B divides A intersect ( x :: NfOrdIdl , y :: NfOrdIdl ) -> NfOrdIdl lcm ( x :: NfOrdIdl , y :: NfOrdIdl ) -> NfOrdIdl Returns x \\cap y . gcd(A::NfOrdIdl, B::NfOrdIdl) -> NfOrdIdl The gcd or sum (A+B). gcd(A::NfOrdIdl, p::fmpz) -> NfOrdIdl The gcd or sum (A + pO). intersect ( x :: NfOrdIdl , y :: NfOrdIdl ) -> NfOrdIdl lcm ( x :: NfOrdIdl , y :: NfOrdIdl ) -> NfOrdIdl Returns x \\cap y . colon ( a :: NfAbsOrdIdl , b :: NfAbsOrdIdl ) -> NfOrdFracIdl The ideal (a:b) = \\{x \\in K | xb \\subseteq a\\} = \\hom(b, a) where K is the number field. in ( x :: NfOrdElem , y :: NfAbsOrdIdl ) in ( x :: nf_elem , y :: NfAbsOrdIdl ) in ( x :: fmpz , y :: NfAbsOrdIdl ) Returns whether x is contained in y . ispower ( A :: NfAbsOrdIdl , n :: Int ) -> Bool , NfAbsOrdIdl ispower ( A :: NfOrdFracIdl , n :: Int ) -> Bool , NfOrdFracIdl Computes, if possible, an ideal B s.th. B^n==A holds. In this case, {{{true}}} and B are returned. ispower ( I :: NfAbsOrdIdl ) -> Int , NfAbsOrdIdl ispower ( a :: NfOrdFracIdl ) -> Int , NfOrdFracIdl Writes a = r^e with e maximal. Note: 1 = 1^0 . isinvertible ( A :: NfAbsOrdIdl ) -> Bool , NfOrdFracIdl Returns true and an inverse of A or false and an ideal B such that A*B \\subsetneq order(A) , if A is not invertible. isone ( A :: NfAbsOrdIdl ) -> Bool isunit ( A :: NfAbsOrdIdl ) -> Bool Tests if A is the trivial ideal generated by 1 .","title":"Arithmetic"},{"location":"orders/ideals/#class-group","text":"The group of invertable ideals in any order forms a group and the principal ideals a subgroup. The finite quotient is called class group for maximal orders and Picard group or ring class group in general. class_group ( O :: NfOrd ; bound = - 1 , method = 3 , redo = false , large = 1000 ) -> GrpAbFinGen , Map Returns a group A and a map f from A to the set of ideals of O . The inverse of the map is the projection onto the group of ideals modulo the group of principal ideals. \\texttt{redo} allows to trigger a re-computation, thus avoiding the cache. \\texttt{bound}, when given, is the bound for the factor base. class_group ( K :: AnticNumberField ) -> GrpAbFinGen , Map Shortcut for {{{class group(maximal order(K))}}}: returns the class group as an abelian group and a map from this group to the set of ideals of the maximal order. picard_group ( O :: NfOrd ) -> GrpAbFinGen , MapClassGrp Returns the Picard group of O and a map from the group in the set of (invertible) ideals of O. ring_class_group ( O :: NfAbsOrd ) The ring class group (Picard group) of O . julia> k, a = wildanger_field(3, 13); julia> zk = maximal_order(k); julia> c, mc = class_group(zk) (GrpAb: Z/9, ClassGroup map of Set of ideals of Maximal order of Number field over Rational Field with defining polynomial x^3-13*x^2+13*x-13 with basis nf_elem[1, _$, 1//2*_$^2 + 1//2] ) julia> lp = prime_ideals_up_to(zk, 20); julia> [ mc \\ I for I = lp] 10-element Array{GrpAbFinGenElem,1}: Element of GrpAb: Z/9 with components [4] Element of GrpAb: Z/9 with components [1] Element of GrpAb: Z/9 with components [4] Element of GrpAb: Z/9 with components [5] Element of GrpAb: Z/9 with components [3] Element of GrpAb: Z/9 with components [2] Element of GrpAb: Z/9 with components [7] Element of GrpAb: Z/9 with components [1] Element of GrpAb: Z/9 with components [0] Element of GrpAb: Z/9 with components [2] julia> mc(c[1]) <2, 3//2*_$^2 + 1//2> Norm: 2 Minimum: 2 basis_mat [2 0 0] [1 1 0] [1 0 1] two normal wrt: 2 julia> order(c[1]) 9 julia> mc(c[1])^Int(order(c[1])) <512, 15850805895379398141//2*_$^2 - 7865890757002315674*_$ + 17160967849687022455//2> Norm: 512 Minimum: 512 two normal wrt: 2 julia> mc \\ ans Element of GrpAb: Z/9 with components [0] The class group, or more precisely the information used to compute it also allows for principal ideal testing and related tasks. In general, due to the size of the objetcs, the fac_elem versions are more effcient. isprincipal ( A :: NfOrdIdl ) -> Bool , NfOrdElem isprincipal ( A :: NfOrdFracIdl ) -> Bool , NfOrdElem Tests if A is principal and returns (\\mathtt{true}, \\alpha) if A = \\langle \\alpha\\rangle of (\\mathtt{false}, 1) otherwise. isprincipal_fac_elem ( A :: NfOrdIdl ) -> Bool , FacElem { nf_elem , NumberField } Tests if A is principal and returns (\\mathtt{true}, \\alpha) if A = \\langle \\alpha\\rangle of (\\mathtt{false}, 1) otherwise. The generator will be in factored form. power_class ( A :: NfOrdIdl , e :: fmpz ) -> NfOrdIdl Computes a (small) ideal in the same class as A^e power_product_class ( A :: Array { NfOrdIdl , 1 }, e :: Array { fmpz , 1 }) -> NfOrdIdl Computes a (small) ideal in the same class as \\prod A_i^{e_i} . power_reduce2 ( A :: NfOrdIdl , e :: fmpz ) -> NfOrdIdl , FacElem { nf_elem } Computes B and \\alpha in factored form, such that \\alpha B = A^e B has small norm. class_group_ideal_relation ( I :: NfOrdIdl , c :: ClassGrpCtx ) -> nf_elem , SRow { fmpz } Finds a number field element \\alpha such that \\alpha I factors over the factor base in c . julia> I = mc(c[1]) <2, 3//2*_$^2 + 1//2> Norm: 2 Minimum: 2 basis_mat [2 0 0] [1 1 0] [1 0 1] two normal wrt: 2 julia> Hecke.isprincipal(I) (false, 1) julia> I = I^Int(order(c[1])) <512, 15850805895379398141//2*_$^2 - 7865890757002315674*_$ + 17160967849687022455//2> Norm: 512 Minimum: 512 two normal wrt: 2 julia> Hecke.isprincipal(I) (true, 1//2*_$^2 - 3*_$ + 9//2) julia> Hecke.isprincipal_fac_elem(I) (true, Factored element with data Dict(5*_$+49=>-48,_$+38=>11,_$+1=>35,5=>-51,_$^2 - 2*_$ - 2=>-39,7=>39,_$+2=>80,1//2*_$^2 + 5//2=>-66,-_$^2 + 10*_$ + 12=>48,_$-4=>16,11=>-40,_$^2 + 1*_$ + 2=>51,_$+5=>17,107=>-11,_$-16=>11,_$-35=>11,1=>1)) The computation of S -units is also tied to the class group: unit_group ( O :: NfOrd ) -> GrpAbFinGen , Map Returns a group U and an isomorphism map f \\colon U \\to \\mathcal O^\\times . A set of fundamental units of \\mathcal O can be obtained via [ f(U[1+i]) for i in 1:unit_rank(O) ] . f(U[1]) will give a generator for the torsion subgroup. unit_group_fac_elem ( O :: NfOrd ) -> GrpAbFinGen , Map Returns a group U and an isomorphism map f \\colon U \\to \\mathcal O^\\times . A set of fundamental units of \\mathcal O can be obtained via [ f(U[1+i]) for i in 1:unit_rank(O) ] . f(U[1]) will give a generator for the torsion subgroup. All elements will be returned in factored form. sunit_group ( I :: Array { NfOrdIdl , 1 }) -> GrpAb , Map For an array I of (coprime prime) ideals, find the S -unit group defined by I , ie. the group of non-zero field elements which are only divisible by ideals in I . sunit_group_fac_elem ( I :: Array { NfOrdIdl , 1 }) -> GrpAb , Map For an array I of (coprime prime) ideals, find the S -unit group defined by I , ie. the group of non-zero field elements which are only divisible by ideals in I . The map will return elements in factored form. sunit_mod_units_group_fac_elem ( I :: Array { NfOrdIdl , 1 }) -> GrpAb , Map For an array I of (coprime prime) ideals, find the S -unit group defined by I , ie. the group of non-zero field elements which are only divisible by ideals in I modulo the units of the field. The map will return elements in factored form. julia> u, mu = unit_group(zk) (GrpAb: Z/2 x Z, UnitGroup map of Maximal order of Number field over Rational Field with defining polynomial x^3-13*x^2+13*x-13 with basis nf_elem[1, _$, 1//2*_$^2 + 1//2] ) julia> mu(u[2]) -_$^2 + 1*_$ - 1 julia> u, mu = unit_group_fac_elem(zk) (GrpAb: Z/2 x Z, UnitGroup map of Factored elements over Number field over Rational Field with defining polynomial x^3-13*x^2+13*x-13 ) julia> mu(u[2]) Factored element with data Dict(5*_$+49=>3,_$+38=>1,5=>1,_$^2 - 2*_$ - 2=>4,7=>-4,_$+2=>-6,1//2*_$^2 + 5//2=>4,-_$^2 + 10*_$ + 12=>-3,_$-4=>-1,11=>3,_$^2 + 1*_$ + 2=>-1,_$+5=>-7,107=>-1,_$-16=>1,_$-35=>1) julia> evaluate(ans) -_$^2 + 1*_$ - 1 julia> lp = factor(6*zk) Dict{NfAbsOrdIdl{AnticNumberField,nf_elem},Int64} with 4 entries: <3, _$^2 + 1> => 1 <2, 3//2*_$^2 + 1//2> => 1 <2, 7//2*_$^2 + 3//2> => 2 <3, _$-1> => 1 julia> s, ms = Hecke.sunit_group(collect(keys(lp))) (GrpAb: Z/2 x Z^5, SUnits map of Number field over Rational Field with defining polynomial x^3-13*x^2+13*x-13 for NfAbsOrdIdl{AnticNumberField,nf_elem}[<3, _$^2 + 1>, <2, 3//2*_$^2 + 1//2>, <2, 7//2*_$^2 + 3//2>, <3, _$-1>] ) julia> ms(s[4]) 1//2*_$^2 - 6*_$ - 1//2 julia> norm(ans) -18 julia> factor(numerator(ans)) -1 * 2 * 3^2","title":"Class Group"},{"location":"orders/ideals/#miscaellenous","text":"order ( I :: NfAbsOrdIdl ) -> NfOrd Returns the order of I . nf ( x :: NfAbsOrdIdl ) -> AnticNumberField Returns the number field, of which x is an integral ideal. basis ( A :: NfAbsOrdIdl ) -> Array { NfOrdElem , 1 } Returns the basis of A. basis_mat ( A :: NfAbsOrdIdl ) -> fmpz_mat Returns the basis matrix of A . basis_mat_inv ( O :: NfOrd ) -> FakeFmpqMat Returns the inverse of the basis matrix of \\mathcal O . basis_mat_inv(A::NfAbsOrdIdl) -> fmpz_mat Returns the inverse basis matrix of A . basis_mat_inv ( A :: NfAbsOrdIdl ) -> FakeFmpqMat Returns the inverse of the basis matrix of A . has_basis ( A :: NfAbsOrdIdl ) -> Bool Returns whether A has a basis already computed. has_basis_mat ( A :: NfAbsOrdIdl ) -> Bool Returns whether A knows its basis matrix. has_2_elem ( A :: NfAbsOrdIdl ) -> Bool Returns whether A is generated by two elements. has_2_elem_normal ( A :: NfAbsOrdIdl ) -> Bool Returns whether A has normal two element generators. has_weakly_normal ( A :: NfAbsOrdIdl ) -> Bool Returns whether A has weakly normal two element generators. has_basis_princ_gen_special ( A :: NfAbsOrdIdl ) -> Bool Returns whether A knows if it is generated by a rational integer. principal_gen ( A :: NfOrdIdl ) -> NfOrdElem For a principal ideal A , find a generator. principal_gen_fac_elem ( A :: NfOrdIdl ) -> FacElem { nf_elem , NumberField } For a principal ideal A , find a generator in factored form. minimum ( A :: NfAbsOrdIdl ) -> fmpz Returns the smallest nonnegative element in A \\cap \\mathbf Z . has_minimum ( A :: NfAbsOrdIdl ) -> Bool Returns whether A knows its mininum. norm ( A :: NfAbsOrdIdl ) -> fmpz Returns the norm of A , that is, the cardinality of \\mathcal O/A , where \\mathcal O is the order of A . norm(a::NfRelOrdFracIdl{T, S}) -> S Returns the norm of a has_norm ( A :: NfAbsOrdIdl ) -> Bool Returns whether A knows its norm. idempotents ( x :: NfOrdIdl , y :: NfOrdIdl ) -> NfOrdElem , NfOrdElem Returns a tuple (e, f) consisting of elements e in x , f in y such that 1 = e + f . If the ideals are not coprime, an error is raised. isprime ( A :: NfOrdIdl ) -> Bool Returns whether A is a prime ideal. isprime_known ( A :: NfOrdIdl ) -> Bool Returns whether A knows if it is prime. splitting_type ( P :: NfOrdIdl ) -> Int , Int The ramification index and inertia degree of the prime ideal P . First value is the ramificatio index, the second the degree of P . isramified ( O :: NfOrd , p :: Int ) -> Bool Returns whether the integer p is ramified in \\mathcal O . It is assumed that p is prime. ramification_index ( P :: NfOrdIdl ) -> Int The ramification index of the prime-ideal P . degree ( P :: NfOrdIdl ) -> Int The inertia degree of the prime-ideal P . valuation ( a :: nf_elem , p :: NfOrdIdl ) -> fmpz valuation ( a :: NfOrdElem , p :: NfOrdIdl ) -> fmpz valuation ( a :: fmpz , p :: NfOrdIdl ) -> fmpz Computes the \\mathfrak p -adic valuation of a , that is, the largest i such that a is contained in \\mathfrak p^i . valuation ( a :: nf_elem , p :: NfOrdIdl ) -> fmpz valuation ( a :: NfOrdElem , p :: NfOrdIdl ) -> fmpz valuation ( a :: fmpz , p :: NfOrdIdl ) -> fmpz Computes the \\mathfrak p -adic valuation of a , that is, the largest i such that a is contained in \\mathfrak p^i . valuation ( A :: NfOrdIdl , p :: NfOrdIdl ) -> fmpz Computes the \\mathfrak p -adic valuation of A , that is, the largest i such that A is contained in \\mathfrak p^i . valuation ( a :: Integer , p :: NfOrdIdl ) -> fmpz Computes the \\mathfrak p -adic valuation of a , that is, the largest i such that a is contained in \\mathfrak p^i . valuation ( a :: nf_elem , p :: NfOrdIdl ) -> fmpz valuation ( a :: NfOrdElem , p :: NfOrdIdl ) -> fmpz valuation ( a :: fmpz , p :: NfOrdIdl ) -> fmpz Computes the \\mathfrak p -adic valuation of a , that is, the largest i such that a is contained in \\mathfrak p^i . valuation ( A :: NfOrdFracIdl , p :: NfOrdIdl ) The valuation of A at p .","title":"Miscaellenous"},{"location":"orders/ideals/#quotient-rings","text":"Missing docstring. Missing docstring for quo(::NfOrd, ::NfOrdIdl) . Check Documenter's build log for details. ResidueRing ( O :: NfOrd , I :: NfOrdIdl ) -> NfOrdQuoRing ResidueRing ( O :: AlgAssAbsOrd , I :: AlgAssAbsOrdIdl ) -> AbsOrdQuoRing The quotient ring O modulo I as a new ring. ResidueField ( O :: NfOrd , P :: NfOrdIdl , check :: Bool = true ) -> Field , Map Returns the residue field of the prime ideal P together with th projection map. If check is true, the ideal is checked for being prime. mod ( x :: NfOrdElem , I :: NfAbsOrdIdl ) Returns the unique element y of the ambient order of x with x \\equiv y \\bmod I and the following property: If a_1,\\dotsc,a_d \\in \\Z_{\\geq 1} are the diagonal entries of the unique HNF basis matrix of I and (b_1,\\dotsc,b_d) is the coefficient vector of y , then 0 \\leq b_i < a_i for 1 \\leq i \\leq d . crt ( r1 :: NfOrdElem , i1 :: NfOrdIdl , r2 :: NfOrdElem , i2 :: NfOrdIdl ) -> NfOrdElem Find x s.th x \\equiv r1 \\bmod i1 and x \\equiv r2 \\bmod i2 using (((idempotents)))","title":"Quotient Rings"},{"location":"orders/introduction/","text":"Introduction This chapter deals with absolute number fields and orders there of. Definitions and vocabulary We begin by collecting the necessary definitions and vocabulary. This is in particular important for everything related to embeddings of number fields into archimedean fields, since they are at least two (slighlty) different normalizations. Number fields By an absolute number field we mean finite extensions of \\mathbf Q , which is of type AnticNumberField and whose elements are of type nf_elem . Such an absolute number field K is always given in the form K = \\mathbf Q(\\alpha) = \\mathbf Q[X]/(f) , where f \\in \\mathbf Q[X] is an irreducible polynomial. See here for more information on the different types of fields supported. We call (1,\\alpha,\\alpha^2,\\dotsc,\\alpha^{d-1}) , where d is the degree [K : \\mathbf Q] the power basis of K . If \\beta is any element of K , then the representation matrix of \\beta is the matrix representing K \\to K, \\gamma \\mapsto \\beta \\gamma with respect to the power basis, that is, \\beta \\cdot (1,\\alpha,\\dotsc,\\alpha^{d-1}) = M_\\alpha (1, \\alpha, \\dotsc, \\alpha^{d-1}). Let (r,s) be the signature of K , that is, K has r real embeddings \\sigma_i \\colon K \\to \\mathbf{R} , 1 \\leq i \\leq r , and 2s complex embeddings \\sigma_i \\colon K \\to \\mathbf{C} , 1 \\leq i \\leq 2s . In Hecke the complex embeddings are always ordered such that \\sigma_i = \\overline{\\sigma_{i+s}} for r + 1 \\leq i \\leq r + s . The \\mathbf{Q} -linear function K \\longrightarrow \\mathbf R^{d}, \\ \\alpha \\longmapsto (\\sigma_1(\\alpha),\\dotsc,\\sigma_r(\\alpha),\\sqrt{2}\\operatorname{Re}(\\sigma_{r+1}(\\alpha)),\\sqrt{2}\\operatorname{Im}(\\sigma_{r+1}(\\alpha)),\\dotsc,\\sqrt{2}\\operatorname{Re}(\\sigma_{r+s}(\\alpha)),\\sqrt{2}\\operatorname{Im}(\\sigma_{r+s}(\\alpha)) is called the Minkowski map (or Minkowski embedding ). Orders If K = \\mathbf Q(\\alpha) is an absolute number field, then an order \\mathcal O of K is a subring of the ring of integers \\mathcal O_K , which is free of rank [ K : \\mathbf Q] as a \\mathbf Z -module. The natural order \\mathbf Z[\\alpha] is called the equation order of K . In Hecke orders of absolute number fields are constructed (implicitely) by specifying a \\mathbf Z -basis, which is refered to as the basis of \\mathcal O . If (\\omega_1,\\dotsc,\\omega_d) is the basis of \\mathcal O , then the matrix B \\in \\operatorname{Mat}_{d \\times d}(\\mathbf Q) with \\begin{pmatrix} \\omega*1 \\\\ \\vdots \\\\ \\omega*d \\end{pmatrix} = B \\begin{pmatrix} 1 \\\\ \\vdots \\\\ \\alpha^{d - 1} \\end{pmatrix} is called the basis matrix of \\mathcal O . We call \\det(B) the generalized index of \\mathcal O . In case \\mathbf Z[\\alpha] \\subseteq \\mathcal O , the determinant \\det(B)^{-1} is in fact equal to [ \\mathcal O : \\mathbf Z[\\alpha]] and is called the index of \\mathcal O . The matrix \\begin{pmatrix} \\sigma*1(\\omega*1) & \\dotsc & \\sigma*r(\\omega*1) & \\sqrt{2}\\operatorname{Re}(\\sigma*{r+1}(\\omega*1)) & \\sqrt{2}\\operatorname{Im}(\\sigma*{r+1}(\\omega*1)) & \\dotsc & \\sqrt{2}\\operatorname{Im}(\\sigma*{r+s}(\\omega*1)) \\\\ \\sigma*1(\\omega*2) & \\dotsc & \\sigma*r(\\omega*2) & \\sqrt{2}\\operatorname{Re}(\\sigma*{r+1}(\\omega*2)) & \\sqrt{2}\\operatorname{Im}(\\sigma*{r+1}(\\omega*2)) & \\dotsc & \\sqrt{2}\\operatorname{Im}(\\sigma*{r+s}(\\omega*2)) \\\\ \\vdots & \\dotsc & \\vdots & \\vdots & \\dotsc & \\vdots & \\vdots\\\\ \\sigma*1(\\omega*d) & \\dotsc & \\sigma*r(\\omega*d) & \\sqrt{2}\\operatorname{Re}(\\sigma*{r+1}(\\omega*d)) & \\sqrt{2}\\operatorname{Im}(\\sigma*{r+2}(\\omega*d)) & \\dotsc & \\sqrt{2}\\operatorname{Im}(\\sigma*{r+s}(\\omega*d)) \\end{pmatrix} \\in \\operatorname{Mat}_{d\\times d}(\\mathbf R). is called the Minkowski matrix of \\mathcal O . Examples Usually, to create an order, one starts with a field (or a polynomial): julia> Qx, x = PolynomialRing(FlintQQ, \"x\"); julia> K, a = NumberField(x^2 - 10, \"a\"); julia> E = EquationOrder(K) Order of Number field over Rational Field with defining polynomial x^2-10 with Z-basis NfAbsOrdElem{AnticNumberField,nf_elem}[1, a] julia> Z_K = MaximalOrder(K) Maximal order of Number field over Rational Field with defining polynomial x^2-10 with basis nf_elem[1, a] julia> conductor(E) Ideal of (Order of Number field over Rational Field with defining polynomial x^2-10 with Z-basis NfAbsOrdElem{AnticNumberField,nf_elem}[1, a]) with basis matrix [1 0] [0 1] julia> E == Z_K true Once orders are created, we can play with elements and ideals: julia> lp = prime_decomposition(Z_K, 2) 1-element Array{Tuple{NfAbsOrdIdl{AnticNumberField,nf_elem},Int64},1}: (<2, a> Norm: 2 Minimum: 2 two normal wrt: 2, 2) julia> p = lp[1][1] <2, a> Norm: 2 Minimum: 2 two normal wrt: 2 julia> isprincipal(p) (false, 1) julia> fl, alpha = isprincipal(p^2) (true, -2) julia> norm(alpha) 4 It is possible to work with residue fields as well: julia> Fp, mFp = ResidueField(Z_K, p) (Finite field of degree 1 over F_2, Map with following data Domain: ======= Maximal order of Number field over Rational Field with defining polynomial x^2-10 with basis nf_elem[1, a] Codomain: ========= Finite field of degree 1 over F_2 ) julia> [ mFp(x) for x = basis(Z_K)] 2-element Array{fq,1}: 1 0","title":"Introduction"},{"location":"orders/introduction/#introduction","text":"This chapter deals with absolute number fields and orders there of.","title":"Introduction"},{"location":"orders/introduction/#definitions-and-vocabulary","text":"We begin by collecting the necessary definitions and vocabulary. This is in particular important for everything related to embeddings of number fields into archimedean fields, since they are at least two (slighlty) different normalizations.","title":"Definitions and vocabulary"},{"location":"orders/introduction/#number-fields","text":"By an absolute number field we mean finite extensions of \\mathbf Q , which is of type AnticNumberField and whose elements are of type nf_elem . Such an absolute number field K is always given in the form K = \\mathbf Q(\\alpha) = \\mathbf Q[X]/(f) , where f \\in \\mathbf Q[X] is an irreducible polynomial. See here for more information on the different types of fields supported. We call (1,\\alpha,\\alpha^2,\\dotsc,\\alpha^{d-1}) , where d is the degree [K : \\mathbf Q] the power basis of K . If \\beta is any element of K , then the representation matrix of \\beta is the matrix representing K \\to K, \\gamma \\mapsto \\beta \\gamma with respect to the power basis, that is, \\beta \\cdot (1,\\alpha,\\dotsc,\\alpha^{d-1}) = M_\\alpha (1, \\alpha, \\dotsc, \\alpha^{d-1}). Let (r,s) be the signature of K , that is, K has r real embeddings \\sigma_i \\colon K \\to \\mathbf{R} , 1 \\leq i \\leq r , and 2s complex embeddings \\sigma_i \\colon K \\to \\mathbf{C} , 1 \\leq i \\leq 2s . In Hecke the complex embeddings are always ordered such that \\sigma_i = \\overline{\\sigma_{i+s}} for r + 1 \\leq i \\leq r + s . The \\mathbf{Q} -linear function K \\longrightarrow \\mathbf R^{d}, \\ \\alpha \\longmapsto (\\sigma_1(\\alpha),\\dotsc,\\sigma_r(\\alpha),\\sqrt{2}\\operatorname{Re}(\\sigma_{r+1}(\\alpha)),\\sqrt{2}\\operatorname{Im}(\\sigma_{r+1}(\\alpha)),\\dotsc,\\sqrt{2}\\operatorname{Re}(\\sigma_{r+s}(\\alpha)),\\sqrt{2}\\operatorname{Im}(\\sigma_{r+s}(\\alpha)) is called the Minkowski map (or Minkowski embedding ).","title":"Number fields"},{"location":"orders/introduction/#orders","text":"If K = \\mathbf Q(\\alpha) is an absolute number field, then an order \\mathcal O of K is a subring of the ring of integers \\mathcal O_K , which is free of rank [ K : \\mathbf Q] as a \\mathbf Z -module. The natural order \\mathbf Z[\\alpha] is called the equation order of K . In Hecke orders of absolute number fields are constructed (implicitely) by specifying a \\mathbf Z -basis, which is refered to as the basis of \\mathcal O . If (\\omega_1,\\dotsc,\\omega_d) is the basis of \\mathcal O , then the matrix B \\in \\operatorname{Mat}_{d \\times d}(\\mathbf Q) with \\begin{pmatrix} \\omega*1 \\\\ \\vdots \\\\ \\omega*d \\end{pmatrix} = B \\begin{pmatrix} 1 \\\\ \\vdots \\\\ \\alpha^{d - 1} \\end{pmatrix} is called the basis matrix of \\mathcal O . We call \\det(B) the generalized index of \\mathcal O . In case \\mathbf Z[\\alpha] \\subseteq \\mathcal O , the determinant \\det(B)^{-1} is in fact equal to [ \\mathcal O : \\mathbf Z[\\alpha]] and is called the index of \\mathcal O . The matrix \\begin{pmatrix} \\sigma*1(\\omega*1) & \\dotsc & \\sigma*r(\\omega*1) & \\sqrt{2}\\operatorname{Re}(\\sigma*{r+1}(\\omega*1)) & \\sqrt{2}\\operatorname{Im}(\\sigma*{r+1}(\\omega*1)) & \\dotsc & \\sqrt{2}\\operatorname{Im}(\\sigma*{r+s}(\\omega*1)) \\\\ \\sigma*1(\\omega*2) & \\dotsc & \\sigma*r(\\omega*2) & \\sqrt{2}\\operatorname{Re}(\\sigma*{r+1}(\\omega*2)) & \\sqrt{2}\\operatorname{Im}(\\sigma*{r+1}(\\omega*2)) & \\dotsc & \\sqrt{2}\\operatorname{Im}(\\sigma*{r+s}(\\omega*2)) \\\\ \\vdots & \\dotsc & \\vdots & \\vdots & \\dotsc & \\vdots & \\vdots\\\\ \\sigma*1(\\omega*d) & \\dotsc & \\sigma*r(\\omega*d) & \\sqrt{2}\\operatorname{Re}(\\sigma*{r+1}(\\omega*d)) & \\sqrt{2}\\operatorname{Im}(\\sigma*{r+2}(\\omega*d)) & \\dotsc & \\sqrt{2}\\operatorname{Im}(\\sigma*{r+s}(\\omega*d)) \\end{pmatrix} \\in \\operatorname{Mat}_{d\\times d}(\\mathbf R). is called the Minkowski matrix of \\mathcal O .","title":"Orders"},{"location":"orders/introduction/#examples","text":"Usually, to create an order, one starts with a field (or a polynomial): julia> Qx, x = PolynomialRing(FlintQQ, \"x\"); julia> K, a = NumberField(x^2 - 10, \"a\"); julia> E = EquationOrder(K) Order of Number field over Rational Field with defining polynomial x^2-10 with Z-basis NfAbsOrdElem{AnticNumberField,nf_elem}[1, a] julia> Z_K = MaximalOrder(K) Maximal order of Number field over Rational Field with defining polynomial x^2-10 with basis nf_elem[1, a] julia> conductor(E) Ideal of (Order of Number field over Rational Field with defining polynomial x^2-10 with Z-basis NfAbsOrdElem{AnticNumberField,nf_elem}[1, a]) with basis matrix [1 0] [0 1] julia> E == Z_K true Once orders are created, we can play with elements and ideals: julia> lp = prime_decomposition(Z_K, 2) 1-element Array{Tuple{NfAbsOrdIdl{AnticNumberField,nf_elem},Int64},1}: (<2, a> Norm: 2 Minimum: 2 two normal wrt: 2, 2) julia> p = lp[1][1] <2, a> Norm: 2 Minimum: 2 two normal wrt: 2 julia> isprincipal(p) (false, 1) julia> fl, alpha = isprincipal(p^2) (true, -2) julia> norm(alpha) 4 It is possible to work with residue fields as well: julia> Fp, mFp = ResidueField(Z_K, p) (Finite field of degree 1 over F_2, Map with following data Domain: ======= Maximal order of Number field over Rational Field with defining polynomial x^2-10 with basis nf_elem[1, a] Codomain: ========= Finite field of degree 1 over F_2 ) julia> [ mFp(x) for x = basis(Z_K)] 2-element Array{fq,1}: 1 0","title":"Examples"},{"location":"orders/orders/","text":"Orders Orders, ie. unitary subrings that are free Z -modules of rank equal to the degree of the number field, are at the core of the arithmetic of number fields. In Hecke, orders are always represented using the module structure, be it the Z -module structure for orders in absolute fields, of the structure as a module over the maximal order of the base field in the case of relative extensions. In this chapter we only deal with orders in absolute fields. There are more general definitions of orders in number fields available, but those are (currently) not implemented in Hecke. Among all orders in a fixed field, there is a unique maximal one, called the maximal order, or ring of integers of the field. It is well known that this is the only order that is a Dedekind domain, hence has a rich ideal structure as well. The maximal order is also the integral closure of Z in the number field and can also be interpreted as a normalisation of any other order. Creation and basic properties Order ( B :: Array { nf_elem , 1 }; check :: Bool = true , cached :: Bool = true ) -> NfOrd Returns the order generated B . If check is set, it is checked whether B defines an order. If isbasis is set, then elements are assumed to form a \\Z -basis. Order ( K :: AnticNumberField , A :: FakeFmpqMat ; check :: Bool = true ) -> NfOrd Returns the order which has basis matrix A with respect to the power basis of K . If check is set, it is checked whether A defines an order. Order ( K :: AnticNumberField , A :: fmpz_mat , check :: Bool = true ) -> NfOrd Returns the order which has basis matrix A with respect to the power basis of K . If check is set, it is checked whether A defines an order. Order(K::RelativeExtension, M::PMat) -> NfRelOrd Returns the order which has basis pseudo-matrix M with respect to the power basis of K . Order(A::AbsAlgAss{<: NumFieldElem}, M::PMat{<: NumFieldElem, T}) -> AlgAssRelOrd Returns the order of A with basis pseudo-matrix M . EquationOrder ( K :: NfAbs ) -> NfAbsOrd Returns the equation order of the absolute number field K . maximal_order ( K :: Union { AnticNumberField , NfAbsNS }; discriminant :: fmpz , ramified_primes :: Vector { fmpz }) -> NfAbsOrd Returns the maximal order of K . Additional information can be supplied if they are already known, as the ramified primes or the discriminant of the maximal order. Example julia> Qx, xx = FlintQQ[\"x\"]; julia> K, a = NumberField(x^3 + 2, \"a\"); julia> O = MaximalOrder(K); maximal_order ( O :: NfAbsOrd ; index_divisors :: Vector { fmpz }, discriminant :: fmpz , ramified_primes :: Vector { fmpz }) -> NfAbsOrd Returns the maximal order of the number field that contains O . Additional information can be supplied if they are already known, as the ramified primes, the discriminant of the maximal order or a set of integers dividing the index of O in the maximal order. maximal_order ( O :: NfAbsOrd ; index_divisors :: Vector { fmpz }, discriminant :: fmpz , ramified_primes :: Vector { fmpz }) -> NfAbsOrd Returns the maximal order of the number field that contains O . Additional information can be supplied if they are already known, as the ramified primes, the discriminant of the maximal order or a set of integers dividing the index of O in the maximal order. maximal_order ( K :: Union { AnticNumberField , NfAbsNS }; discriminant :: fmpz , ramified_primes :: Vector { fmpz }) -> NfAbsOrd Returns the maximal order of K . Additional information can be supplied if they are already known, as the ramified primes or the discriminant of the maximal order. Example julia> Qx, xx = FlintQQ[\"x\"]; julia> K, a = NumberField(x^3 + 2, \"a\"); julia> O = MaximalOrder(K); lll ( M :: NfOrd ) -> NfOrd The same order, but with the basis now being LLL reduced wrt. the Minkowski metric. By Chistov's fundamental theorem, the computation of the maximal order is basically as hard as the factorisation of the discriminant. In order to help the computer, Hecke also provides the following signatures: Missing docstring. Missing docstring for maximal_order(::AnticNumberField, ::Array{fmpz, 1}) . Check Documenter's build log for details. It is also possible the execute the steps individually: pradical ( O :: NfOrd , p :: { fmpz | Integer }) -> NfAbsOrdIdl Given a prime number p , this function returns the p -radical \\sqrt{p\\mathcal O} of \\mathcal O , which is just \\{ x \\in \\mathcal O \\mid \\exists k \\in \\mathbf Z_{\\geq 0} \\colon x^k \\in p\\mathcal O \\} . It is not checked that p is prime. ring_of_multipliers ( I :: NfAbsOrdIdl ) -> NfAbsOrd Computes the order (I : I) , which is the set of all x \\in K with xI \\subseteq I . ring_of_multipliers(a::NfRelOrdIdl) -> NfRelOrd Computes the order (a : a) , which is the set of all x \\in K with xa \\subseteq a , where K is the ambient number field of a . Example julia> Qx, x = PolynomialRing(FlintQQ, \"x\"); julia> K, a = NumberField(x^2 - 2, \"a\"); julia> O = EquationOrder(K) Order of Number field over Rational Field with defining polynomial x^2-2 with Z-basis NfAbsOrdElem{AnticNumberField,nf_elem}[1, a] parent ( O :: NfAbsOrd ) -> NfOrdSet Returns the parent of \\mathcal O , that is, the set of orders of the ambient number field. isequation_order ( O :: NfAbsOrd ) -> Bool Returns whether \\mathcal O is the equation order of the ambient number field K . signature ( O :: NfOrd ) -> Tuple { Int , Int } Returns the signature of the ambient number field of \\mathcal O . nf ( O :: NfAbsOrd ) -> AnticNumberField Returns the ambient number field of \\mathcal O . degree ( O :: NfOrd ) -> Int Returns the degree of \\mathcal O . basis ( O :: NfOrd ) -> Array { NfOrdElem , 1 } Returns the \\mathbf Z -basis of \\mathcal O . basis ( O :: NfOrd , K :: AnticNumberField ) -> Array { nf_elem , 1 } Returns the \\mathbf Z -basis elements of \\mathcal O as elements of the ambient number field. basis_mat ( O :: NfOrd ) -> FakeFmpqMat Returns the basis matrix of \\mathcal O with respect to the power basis of the ambient number field. basis_mat_inv ( O :: NfOrd ) -> FakeFmpqMat Returns the inverse of the basis matrix of \\mathcal O . basis_mat_inv(A::NfAbsOrdIdl) -> fmpz_mat Returns the inverse basis matrix of A . discriminant ( O :: NfOrd ) -> fmpz Returns the discriminant of \\mathcal O . discriminant ( B :: Array { NfAbsOrdElem , 1 }) -> fmpz Returns the discriminant of the family B . gen_index ( O :: NfOrd ) -> fmpq Returns the generalized index of \\mathcal O with respect to the equation order of the ambient number field. index ( O :: NfOrd ) -> fmpz Assuming that the order \\mathcal O contains the equation order \\mathbf Z[\\alpha] of the ambient number field, this function returns the index [ \\mathcal O : \\mathbf Z] . isindex_divisor ( O :: NfOrd , d :: fmpz ) -> Bool isindex_divisor ( O :: NfOrd , d :: Int ) -> Bool Returns whether d is a divisor of the index of \\mathcal O . It is assumed that \\mathcal O contains the equation order of the ambient number field. minkowski_mat ( O :: NfOrd , abs_tol :: Int = 64 ) -> arb_mat Returns the Minkowski matrix of \\mathcal O . Thus if \\mathcal O has degree d , then the result is a matrix in \\operatorname{Mat}_{d\\times d}(\\mathbf R) . The entries of the matrix are real balls of type arb with radius less then 2^-abs_tol . in ( a :: nf_elem , O :: NfOrd ) -> Bool Checks whether a lies in \\mathcal O . denominator ( a :: nf_elem , O :: NfOrd ) -> fmpz Returns the smallest positive integer k such that k \\cdot a is contained in \\mathcal O . norm_change_const ( O :: NfOrd ) -> ( Float64 , Float64 ) Returns (c_1, c_2) \\in \\mathbf R_{>0}^2 such that for all x = \\sum_{i=1}^d x_i \\omega_i \\in \\mathcal O we have T_2(x) \\leq c_1 \\cdot \\sum_i^d x_i^2 and \\sum_i^d x_i^2 \\leq c_2 \\cdot T_2(x) , where (\\omega_i)_i is the \\mathbf Z -basis of \\mathcal O . trace_matrix ( O :: NfOrd ) -> fmpz_mat Returns the trace matrix of \\mathcal O , that is, the matrix (\\operatorname{tr}_{K/\\mathbf Q}(b_i \\cdot b_j))_{1 \\leq i, j \\leq d} . + ( R :: NfOrd , S :: NfOrd ) -> NfOrd Given two orders R , S of K , this function returns the smallest order containing both R and S . It is assumed that R , S contain the ambient equation order and have coprime index. poverorder ( O :: NfOrd , p :: fmpz ) -> NfOrd poverorder ( O :: NfOrd , p :: Integer ) -> NfOrd This function tries to find an order that is locally larger than \\mathcal O at the prime p : If p divides the index [ \\mathcal O_K : \\mathcal O] , this function will return an order R such that v_p([ \\mathcal O_K : R]) < v_p([ \\mathcal O_K : \\mathcal O]) . Otherwise \\mathcal O is returned. pmaximal_overorder ( O :: NfOrd , p :: fmpz ) -> NfOrd pmaximal_overorder ( O :: NfOrd , p :: Integer ) -> NfOrd This function finds a p -maximal order R containing \\mathcal O . That is, the index [ \\mathcal O_K : R] is not divisible by p .","title":"Basics"},{"location":"orders/orders/#orders","text":"Orders, ie. unitary subrings that are free Z -modules of rank equal to the degree of the number field, are at the core of the arithmetic of number fields. In Hecke, orders are always represented using the module structure, be it the Z -module structure for orders in absolute fields, of the structure as a module over the maximal order of the base field in the case of relative extensions. In this chapter we only deal with orders in absolute fields. There are more general definitions of orders in number fields available, but those are (currently) not implemented in Hecke. Among all orders in a fixed field, there is a unique maximal one, called the maximal order, or ring of integers of the field. It is well known that this is the only order that is a Dedekind domain, hence has a rich ideal structure as well. The maximal order is also the integral closure of Z in the number field and can also be interpreted as a normalisation of any other order.","title":"Orders"},{"location":"orders/orders/#creation-and-basic-properties","text":"Order ( B :: Array { nf_elem , 1 }; check :: Bool = true , cached :: Bool = true ) -> NfOrd Returns the order generated B . If check is set, it is checked whether B defines an order. If isbasis is set, then elements are assumed to form a \\Z -basis. Order ( K :: AnticNumberField , A :: FakeFmpqMat ; check :: Bool = true ) -> NfOrd Returns the order which has basis matrix A with respect to the power basis of K . If check is set, it is checked whether A defines an order. Order ( K :: AnticNumberField , A :: fmpz_mat , check :: Bool = true ) -> NfOrd Returns the order which has basis matrix A with respect to the power basis of K . If check is set, it is checked whether A defines an order. Order(K::RelativeExtension, M::PMat) -> NfRelOrd Returns the order which has basis pseudo-matrix M with respect to the power basis of K . Order(A::AbsAlgAss{<: NumFieldElem}, M::PMat{<: NumFieldElem, T}) -> AlgAssRelOrd Returns the order of A with basis pseudo-matrix M . EquationOrder ( K :: NfAbs ) -> NfAbsOrd Returns the equation order of the absolute number field K . maximal_order ( K :: Union { AnticNumberField , NfAbsNS }; discriminant :: fmpz , ramified_primes :: Vector { fmpz }) -> NfAbsOrd Returns the maximal order of K . Additional information can be supplied if they are already known, as the ramified primes or the discriminant of the maximal order. Example julia> Qx, xx = FlintQQ[\"x\"]; julia> K, a = NumberField(x^3 + 2, \"a\"); julia> O = MaximalOrder(K); maximal_order ( O :: NfAbsOrd ; index_divisors :: Vector { fmpz }, discriminant :: fmpz , ramified_primes :: Vector { fmpz }) -> NfAbsOrd Returns the maximal order of the number field that contains O . Additional information can be supplied if they are already known, as the ramified primes, the discriminant of the maximal order or a set of integers dividing the index of O in the maximal order. maximal_order ( O :: NfAbsOrd ; index_divisors :: Vector { fmpz }, discriminant :: fmpz , ramified_primes :: Vector { fmpz }) -> NfAbsOrd Returns the maximal order of the number field that contains O . Additional information can be supplied if they are already known, as the ramified primes, the discriminant of the maximal order or a set of integers dividing the index of O in the maximal order. maximal_order ( K :: Union { AnticNumberField , NfAbsNS }; discriminant :: fmpz , ramified_primes :: Vector { fmpz }) -> NfAbsOrd Returns the maximal order of K . Additional information can be supplied if they are already known, as the ramified primes or the discriminant of the maximal order. Example julia> Qx, xx = FlintQQ[\"x\"]; julia> K, a = NumberField(x^3 + 2, \"a\"); julia> O = MaximalOrder(K); lll ( M :: NfOrd ) -> NfOrd The same order, but with the basis now being LLL reduced wrt. the Minkowski metric. By Chistov's fundamental theorem, the computation of the maximal order is basically as hard as the factorisation of the discriminant. In order to help the computer, Hecke also provides the following signatures: Missing docstring. Missing docstring for maximal_order(::AnticNumberField, ::Array{fmpz, 1}) . Check Documenter's build log for details. It is also possible the execute the steps individually: pradical ( O :: NfOrd , p :: { fmpz | Integer }) -> NfAbsOrdIdl Given a prime number p , this function returns the p -radical \\sqrt{p\\mathcal O} of \\mathcal O , which is just \\{ x \\in \\mathcal O \\mid \\exists k \\in \\mathbf Z_{\\geq 0} \\colon x^k \\in p\\mathcal O \\} . It is not checked that p is prime. ring_of_multipliers ( I :: NfAbsOrdIdl ) -> NfAbsOrd Computes the order (I : I) , which is the set of all x \\in K with xI \\subseteq I . ring_of_multipliers(a::NfRelOrdIdl) -> NfRelOrd Computes the order (a : a) , which is the set of all x \\in K with xa \\subseteq a , where K is the ambient number field of a .","title":"Creation and basic properties"},{"location":"orders/orders/#example","text":"julia> Qx, x = PolynomialRing(FlintQQ, \"x\"); julia> K, a = NumberField(x^2 - 2, \"a\"); julia> O = EquationOrder(K) Order of Number field over Rational Field with defining polynomial x^2-2 with Z-basis NfAbsOrdElem{AnticNumberField,nf_elem}[1, a] parent ( O :: NfAbsOrd ) -> NfOrdSet Returns the parent of \\mathcal O , that is, the set of orders of the ambient number field. isequation_order ( O :: NfAbsOrd ) -> Bool Returns whether \\mathcal O is the equation order of the ambient number field K . signature ( O :: NfOrd ) -> Tuple { Int , Int } Returns the signature of the ambient number field of \\mathcal O . nf ( O :: NfAbsOrd ) -> AnticNumberField Returns the ambient number field of \\mathcal O . degree ( O :: NfOrd ) -> Int Returns the degree of \\mathcal O . basis ( O :: NfOrd ) -> Array { NfOrdElem , 1 } Returns the \\mathbf Z -basis of \\mathcal O . basis ( O :: NfOrd , K :: AnticNumberField ) -> Array { nf_elem , 1 } Returns the \\mathbf Z -basis elements of \\mathcal O as elements of the ambient number field. basis_mat ( O :: NfOrd ) -> FakeFmpqMat Returns the basis matrix of \\mathcal O with respect to the power basis of the ambient number field. basis_mat_inv ( O :: NfOrd ) -> FakeFmpqMat Returns the inverse of the basis matrix of \\mathcal O . basis_mat_inv(A::NfAbsOrdIdl) -> fmpz_mat Returns the inverse basis matrix of A . discriminant ( O :: NfOrd ) -> fmpz Returns the discriminant of \\mathcal O . discriminant ( B :: Array { NfAbsOrdElem , 1 }) -> fmpz Returns the discriminant of the family B . gen_index ( O :: NfOrd ) -> fmpq Returns the generalized index of \\mathcal O with respect to the equation order of the ambient number field. index ( O :: NfOrd ) -> fmpz Assuming that the order \\mathcal O contains the equation order \\mathbf Z[\\alpha] of the ambient number field, this function returns the index [ \\mathcal O : \\mathbf Z] . isindex_divisor ( O :: NfOrd , d :: fmpz ) -> Bool isindex_divisor ( O :: NfOrd , d :: Int ) -> Bool Returns whether d is a divisor of the index of \\mathcal O . It is assumed that \\mathcal O contains the equation order of the ambient number field. minkowski_mat ( O :: NfOrd , abs_tol :: Int = 64 ) -> arb_mat Returns the Minkowski matrix of \\mathcal O . Thus if \\mathcal O has degree d , then the result is a matrix in \\operatorname{Mat}_{d\\times d}(\\mathbf R) . The entries of the matrix are real balls of type arb with radius less then 2^-abs_tol . in ( a :: nf_elem , O :: NfOrd ) -> Bool Checks whether a lies in \\mathcal O . denominator ( a :: nf_elem , O :: NfOrd ) -> fmpz Returns the smallest positive integer k such that k \\cdot a is contained in \\mathcal O . norm_change_const ( O :: NfOrd ) -> ( Float64 , Float64 ) Returns (c_1, c_2) \\in \\mathbf R_{>0}^2 such that for all x = \\sum_{i=1}^d x_i \\omega_i \\in \\mathcal O we have T_2(x) \\leq c_1 \\cdot \\sum_i^d x_i^2 and \\sum_i^d x_i^2 \\leq c_2 \\cdot T_2(x) , where (\\omega_i)_i is the \\mathbf Z -basis of \\mathcal O . trace_matrix ( O :: NfOrd ) -> fmpz_mat Returns the trace matrix of \\mathcal O , that is, the matrix (\\operatorname{tr}_{K/\\mathbf Q}(b_i \\cdot b_j))_{1 \\leq i, j \\leq d} . + ( R :: NfOrd , S :: NfOrd ) -> NfOrd Given two orders R , S of K , this function returns the smallest order containing both R and S . It is assumed that R , S contain the ambient equation order and have coprime index. poverorder ( O :: NfOrd , p :: fmpz ) -> NfOrd poverorder ( O :: NfOrd , p :: Integer ) -> NfOrd This function tries to find an order that is locally larger than \\mathcal O at the prime p : If p divides the index [ \\mathcal O_K : \\mathcal O] , this function will return an order R such that v_p([ \\mathcal O_K : R]) < v_p([ \\mathcal O_K : \\mathcal O]) . Otherwise \\mathcal O is returned. pmaximal_overorder ( O :: NfOrd , p :: fmpz ) -> NfOrd pmaximal_overorder ( O :: NfOrd , p :: Integer ) -> NfOrd This function finds a p -maximal order R containing \\mathcal O . That is, the index [ \\mathcal O_K : R] is not divisible by p .","title":"Example"},{"location":"sparse/intro/","text":"Sparse linear algebra Introduction This chapter deals with sparse linear algebra over commutative rings and fields. Sparse linear algebra, that is, linear algebra with sparse matrices, plays an important role in various algorithms in algebraic number theory. For example, it is one of the key ingredients in the computation of class groups and discrete logarithms using index calculus methods. Sparse rows Building blocks for sparse matrices are sparse rows, which are modelled by objects of type \\texttt{SRow}. More precisely, the type is of parametrized form objects of type SRow . More precisely, the type is of parametrized form SRow{T} , where T is the element type of the base ring R . For example, SRow{fmpz} is the type for sparse rows over the integers. It is important to note that sparse rows do not have a fixed number of columns, that is, they represent elements of \\{ (x_i)_i \\in R^{\\mathbb{N}} \\mid x_i = 0 \\text{ for almost all }i\\} . In particular any two sparse rows over the same base ring can be added. Creation sparse_row ( R :: Ring , J :: Vector { Tuple { Int , T }}) -> SRow { T } Constructs the sparse row (a_i)_i with a_{i_j} = x_j , where J = (i_j, x_j)_j . The elements x_i must belong to the ring R . sparse_row ( R :: Ring , J :: Vector { Tuple { Int , T }}) -> SRow { T } Constructs the sparse row (a_i)_i with a_{i_j} = x_j , where J = (i_j, x_j)_j . The elements x_i must belong to the ring R . sparse_row(R::Ring, J::Vector{Tuple{Int, Int}}) -> SRow Constructs the sparse row (a_i)_i over R with a_{i_j} = x_j , where J = (i_j, x_j)_j . sparse_row ( R :: Ring , J :: Vector { Int }, V :: Vector { T }) -> SRow { T } Constructs the sparse row (a_i)_i over R with a_{i_j} = x_j , where J = (i_j)_j and V = (x_j)_j . Basic operations == ( x :: SRow , y :: SRow ) Checks whether x and y are the same sparse row, that is, whether x and y have the same non-zero entries. + ( A :: SRow , B :: SRow ) -> SRow Returns the sum of A and B . getindex ( A :: SRow , j :: Int ) -> RingElem Given a sparse row (a_i)_{i} and an index j return a_j . * ( b :: T , A :: SRow { T }) -> SRow Return the sparse row obtained by multiplying all elements of A by b . div ( A :: SRow { T }, b :: T ) -> SRow Return the sparse row obtained by dividing all elements of A by b using div . divexact ( A :: SRow { T }, b :: T ) -> SRow Return the sparse row obtained by dividing all elements of A by b using divexact . add_scaled_row ( A :: SRow { T }, B :: SRow { T }, c :: T ) -> SRow { T } Returns the row c A + B . Change of base ring change_ring ( A :: SRow , R :: Ring ) -> SRow Create a new sparse row by coercing all elements into the ring R . Maximum, minimum and 2-norm maximum ( A :: SRow { T }) -> T Returns the largest entry of A . minimum ( A :: SRow { T }) -> T Returns the smallest entry of A . norm2 ( A :: SRow { T } -> T Returns A \\cdot A^t . Functionality for integral sparse rows lift ( A :: SRow { nmod }) -> SRow { fmpz } Return the sparse row obtained by lifting all entries in A . mod! ( A :: SRow { fmpz }, n :: fmpz ) -> SRow { fmpz } Inplace reduction of all entries of A modulo n to the positive residue system. mod_sym! ( A :: SRow { fmpz }, n :: fmpz ) -> SRow { fmpz } Inplace reduction of all entries of A modulo n to the symmetric residue system. maximum ( abs , A :: SRow { fmpz }) -> fmpz Returns the largest, in absolute value, entry of A . Sparse matrices Let R be a commutative ring. Sparse matrices with base ring R are modlled by objects of type SMat . More precisely, the type is of parametrized form SRow{T} , where T is the element type of the base ring. For example, SMat{fmpz} is the type for sparse matrices over the integers. In constrast to sparse rows, sparse matrices have a fixed number of rows and columns, that is, they represent elements of the matrices space \\mathrm{Mat}_{n\\times m}(R) . Internally, sparse matrices are implemented as an array of sparse rows. As a consequence, Unlike their dense counterparts, sparse matrices have a mutable number of rows and it is very performant to add additional rows. Construction","title":"Sparse Linear Algebra"},{"location":"sparse/intro/#sparse-linear-algebra","text":"","title":"Sparse linear algebra"},{"location":"sparse/intro/#introduction","text":"This chapter deals with sparse linear algebra over commutative rings and fields. Sparse linear algebra, that is, linear algebra with sparse matrices, plays an important role in various algorithms in algebraic number theory. For example, it is one of the key ingredients in the computation of class groups and discrete logarithms using index calculus methods.","title":"Introduction"},{"location":"sparse/intro/#sparse-rows","text":"Building blocks for sparse matrices are sparse rows, which are modelled by objects of type \\texttt{SRow}. More precisely, the type is of parametrized form objects of type SRow . More precisely, the type is of parametrized form SRow{T} , where T is the element type of the base ring R . For example, SRow{fmpz} is the type for sparse rows over the integers. It is important to note that sparse rows do not have a fixed number of columns, that is, they represent elements of \\{ (x_i)_i \\in R^{\\mathbb{N}} \\mid x_i = 0 \\text{ for almost all }i\\} . In particular any two sparse rows over the same base ring can be added.","title":"Sparse rows"},{"location":"sparse/intro/#creation","text":"sparse_row ( R :: Ring , J :: Vector { Tuple { Int , T }}) -> SRow { T } Constructs the sparse row (a_i)_i with a_{i_j} = x_j , where J = (i_j, x_j)_j . The elements x_i must belong to the ring R . sparse_row ( R :: Ring , J :: Vector { Tuple { Int , T }}) -> SRow { T } Constructs the sparse row (a_i)_i with a_{i_j} = x_j , where J = (i_j, x_j)_j . The elements x_i must belong to the ring R . sparse_row(R::Ring, J::Vector{Tuple{Int, Int}}) -> SRow Constructs the sparse row (a_i)_i over R with a_{i_j} = x_j , where J = (i_j, x_j)_j . sparse_row ( R :: Ring , J :: Vector { Int }, V :: Vector { T }) -> SRow { T } Constructs the sparse row (a_i)_i over R with a_{i_j} = x_j , where J = (i_j)_j and V = (x_j)_j .","title":"Creation"},{"location":"sparse/intro/#basic-operations","text":"== ( x :: SRow , y :: SRow ) Checks whether x and y are the same sparse row, that is, whether x and y have the same non-zero entries. + ( A :: SRow , B :: SRow ) -> SRow Returns the sum of A and B . getindex ( A :: SRow , j :: Int ) -> RingElem Given a sparse row (a_i)_{i} and an index j return a_j . * ( b :: T , A :: SRow { T }) -> SRow Return the sparse row obtained by multiplying all elements of A by b . div ( A :: SRow { T }, b :: T ) -> SRow Return the sparse row obtained by dividing all elements of A by b using div . divexact ( A :: SRow { T }, b :: T ) -> SRow Return the sparse row obtained by dividing all elements of A by b using divexact . add_scaled_row ( A :: SRow { T }, B :: SRow { T }, c :: T ) -> SRow { T } Returns the row c A + B .","title":"Basic operations"},{"location":"sparse/intro/#change-of-base-ring","text":"change_ring ( A :: SRow , R :: Ring ) -> SRow Create a new sparse row by coercing all elements into the ring R .","title":"Change of base ring"},{"location":"sparse/intro/#maximum-minimum-and-2-norm","text":"maximum ( A :: SRow { T }) -> T Returns the largest entry of A . minimum ( A :: SRow { T }) -> T Returns the smallest entry of A . norm2 ( A :: SRow { T } -> T Returns A \\cdot A^t .","title":"Maximum, minimum and 2-norm"},{"location":"sparse/intro/#functionality-for-integral-sparse-rows","text":"lift ( A :: SRow { nmod }) -> SRow { fmpz } Return the sparse row obtained by lifting all entries in A . mod! ( A :: SRow { fmpz }, n :: fmpz ) -> SRow { fmpz } Inplace reduction of all entries of A modulo n to the positive residue system. mod_sym! ( A :: SRow { fmpz }, n :: fmpz ) -> SRow { fmpz } Inplace reduction of all entries of A modulo n to the symmetric residue system. maximum ( abs , A :: SRow { fmpz }) -> fmpz Returns the largest, in absolute value, entry of A .","title":"Functionality for integral sparse rows"},{"location":"sparse/intro/#sparse-matrices","text":"Let R be a commutative ring. Sparse matrices with base ring R are modlled by objects of type SMat . More precisely, the type is of parametrized form SRow{T} , where T is the element type of the base ring. For example, SMat{fmpz} is the type for sparse matrices over the integers. In constrast to sparse rows, sparse matrices have a fixed number of rows and columns, that is, they represent elements of the matrices space \\mathrm{Mat}_{n\\times m}(R) . Internally, sparse matrices are implemented as an array of sparse rows. As a consequence, Unlike their dense counterparts, sparse matrices have a mutable number of rows and it is very performant to add additional rows.","title":"Sparse matrices"},{"location":"sparse/intro/#construction","text":"","title":"Construction"}]}