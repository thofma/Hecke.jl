{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Hecke About Hecke is a software package for algebraic number theory maintained by Claus Fieker, Carlo Sircana and Tommy Hofmann. It is written in julia and is based on the computer algebra package Nemo . https://github.com/thofma/Hecke.jl (Source code) https://thofma.github.io/Hecke.jl/dev/ (Online documentation) So far, Hecke provides the following features: Orders (including element and ideal arithmetic) in number fields Computation of maximal orders Verified residue computations of Dedekind zeta functions Class and Unit group computation, S-units, PID testing Lattice enumeration Sparse linear algebra Normal forms for modules over maximal orders Extensions of number fields, non-simple extensions of number fields Orders and ideals in extensions of fields Abelian groups Ray class groups, quotients of ray class groups Invariant subgroups Class Field Theory Associative Algebras Installation To use Hecke, a julia version of 1.0 is necessary (the latest stable julia version will do). Please see https://julialang.org/downloads/ for instructions on how to obtain julia for your system. Once a suitable julia version is installed, use the following steps at the julia prompt to install Hecke: julia > using Pkg julia > Pkg . add ( \"Hecke\" ) Quick start Here is a quick example of using Hecke: julia > using Hecke ... Welcome to _ _ _ | | | | | | | | __ | | ___ ___ | | _____ | __ |/ _ \\/ __ | |/ / _ \\ | | | | __ / ( __ | < __ / | _ | | _ |\\ ___ |\\ ___ | _ |\\ _ \\ ___ | Version 0.9.0 ... ... which comes with absolutely no warranty whatsoever ( c ) 2015 - 2018 by Claus Fieker , Tommy Hofmann and Carlo Sircana julia > Qx , x = PolynomialRing ( FlintQQ , \"x\" ); julia > f = x ^ 3 + 2 ; julia > K , a = NumberField ( f , \"a\" ); julia > O = maximal_order ( K ); julia > O Maximal order of Number field over Rational Field with defining polynomial x ^ 3 + 2 with basis [ 1 , a , a ^ 2 ] The documentation of the single functions can also be accessed at the julia prompt. Here is an example: help?> signature search: signature ---------------------------------------------------------------------------- signature(O::NfMaximalOrder) -> Tuple{Int, Int} | Returns the signature of the ambient number field of \\mathcal O.","title":"About"},{"location":"#hecke","text":"","title":"Hecke"},{"location":"#about","text":"Hecke is a software package for algebraic number theory maintained by Claus Fieker, Carlo Sircana and Tommy Hofmann. It is written in julia and is based on the computer algebra package Nemo . https://github.com/thofma/Hecke.jl (Source code) https://thofma.github.io/Hecke.jl/dev/ (Online documentation) So far, Hecke provides the following features: Orders (including element and ideal arithmetic) in number fields Computation of maximal orders Verified residue computations of Dedekind zeta functions Class and Unit group computation, S-units, PID testing Lattice enumeration Sparse linear algebra Normal forms for modules over maximal orders Extensions of number fields, non-simple extensions of number fields Orders and ideals in extensions of fields Abelian groups Ray class groups, quotients of ray class groups Invariant subgroups Class Field Theory Associative Algebras","title":"About"},{"location":"#installation","text":"To use Hecke, a julia version of 1.0 is necessary (the latest stable julia version will do). Please see https://julialang.org/downloads/ for instructions on how to obtain julia for your system. Once a suitable julia version is installed, use the following steps at the julia prompt to install Hecke: julia > using Pkg julia > Pkg . add ( \"Hecke\" )","title":"Installation"},{"location":"#quick-start","text":"Here is a quick example of using Hecke: julia > using Hecke ... Welcome to _ _ _ | | | | | | | | __ | | ___ ___ | | _____ | __ |/ _ \\/ __ | |/ / _ \\ | | | | __ / ( __ | < __ / | _ | | _ |\\ ___ |\\ ___ | _ |\\ _ \\ ___ | Version 0.9.0 ... ... which comes with absolutely no warranty whatsoever ( c ) 2015 - 2018 by Claus Fieker , Tommy Hofmann and Carlo Sircana julia > Qx , x = PolynomialRing ( FlintQQ , \"x\" ); julia > f = x ^ 3 + 2 ; julia > K , a = NumberField ( f , \"a\" ); julia > O = maximal_order ( K ); julia > O Maximal order of Number field over Rational Field with defining polynomial x ^ 3 + 2 with basis [ 1 , a , a ^ 2 ] The documentation of the single functions can also be accessed at the julia prompt. Here is an example: help?> signature search: signature ---------------------------------------------------------------------------- signature(O::NfMaximalOrder) -> Tuple{Int, Int} | Returns the signature of the ambient number field of \\mathcal O.","title":"Quick start"},{"location":"FacElem/","text":"Factored Elements In many applications in number theory related to the multiplicative structure of number fields, interesting elements, e.g. units, are extremely large when written wrt. to a fxied basis for the field: for the fundamental unit in Q[\\sqrt d] it is known that the coefficients wrt. the canonical basis 1, \\sqrt d can have O(\\exp \\sqrt d) many digits. All currently known, fast methods construct those elements as power products of smaller elements, allowing the computer to handle them. Mathematically, one can think of factored elements to formally live in the ring Z[K] the group ring of the non-zero field elements. Thus elements are of the form \\prod a*i^{e*i} where a_i are elements in K , typically small and the e_i\\in Z are frequently large exponents. We refer to the a_i as the base and the e_i as the exponents of the factored element. Since K is, in general, no PID, this presentation is non-unique, elements in this form can easily be multiplied, raised to large powers, but in general not compared and not added. In Hecke, this is caputured more generally by the type FacElem , parametrized by the type of the elements in the base and the type of their parent. Important special cases are FacElem{fmpz, FlintIntegerRing} , factored integers FacElem{nf_elem, AnticNumberField} , factored algerbaic numbers FacElem{NfAbsOrdIdl, NfAbsOrdIdlSet} , factored ideals It should be noted that an object of type ` FacElem{fmpz, FlintIntegerRing} will, in general, not represent an integer as the exponents can be negative. Construction In general one can define factored elements by giving 2 arrays, the base and the exponent, or a dictionary containing the pairs: # FacElem \u2014 Type . FacElem { B }( R , base :: Vector { B }, exp :: Vector { fmpz }) -> FacElem { B } Returns the element \\prod b_i^{e_i} , un-expanded. source FacElem{B}(base::Vector{B}, exp::Vector{fmpz}) -> FacElem{B} Returns the element \\prod b_i^{e_i} , un-expanded. source FacElem{B}(R, d::Dict{B, fmpz}) -> FacElem{B} FacElem{B}(R, d::Dict{B, Integer}) -> FacElem{B} Returns the element \\prod b^{d[p]} , un-expanded. source FacElem{B}(d::Dict{B, fmpz}) -> FacElem{B} FacElem{B}(d::Dict{B, Integer}) -> FacElem{B} Returns the element \\prod b^{d[p]} , un-expanded. source # FacElem \u2014 Method . FacElem { B }( R , base :: Vector { B }, exp :: Vector { fmpz }) -> FacElem { B } Returns the element \\prod b_i^{e_i} , un-expanded. source FacElem{B}(base::Vector{B}, exp::Vector{fmpz}) -> FacElem{B} Returns the element \\prod b_i^{e_i} , un-expanded. source FacElem{B}(R, d::Dict{B, fmpz}) -> FacElem{B} FacElem{B}(R, d::Dict{B, Integer}) -> FacElem{B} Returns the element \\prod b^{d[p]} , un-expanded. source FacElem{B}(d::Dict{B, fmpz}) -> FacElem{B} FacElem{B}(d::Dict{B, Integer}) -> FacElem{B} Returns the element \\prod b^{d[p]} , un-expanded. source # ideal \u2014 Method . ideal ( O :: NfOrd , a :: FacElem { nf_elem , AnticNumberField ) The factored fractional ideal a*O . source Conversion The process of computing the value defined by a factored element is available as evaluate . Depending on the types involved this can be very efficient. # evaluate \u2014 Method . evaluate { T }( x :: FacElem { T }) -> T Expands or evaluates the factored element, i.e. actually computes the value. Does \"square-and-multiply\" on the exponent vectors. source # evaluate \u2014 Method . evaluate ( x :: FacElem { fmpq }) -> fmpq evaluate ( x :: FacElem { fmpz }) -> fmpz Expands or evaluates the factored element, i.e. actually computes the the element. Works by first obtaining a simplified version of the power product into coprime base elements. source # evaluate \u2014 Method . evaluate { T }( x :: FacElem { T }) -> T Expands or evaluates the factored element, i.e. actually computes the value. Does \"square-and-multiply\" on the exponent vectors. source # evaluate_naive \u2014 Method . evaluate_naive { T }( x :: FacElem { T }) -> T Expands or evaluates the factored element, i.e. actually computes the value. Uses the obvious naive algorithm. Faster for input in finite rings. source Special functions In the case where the parent of the base allows for efficient gcd computation, power products can be made unique: # simplify \u2014 Method . simplify ( x :: FacElem { NfOrdIdl , NfOrdIdlSet }) -> FacElem simplify ( x :: FacElem { NfOrdFracIdl , NfOrdFracIdlSet }) -> FacElem Uses coprime_base to obtain a simplified version of x , ie. in the simplified version all base ideals will be pariwise coprime but not neccessarily prime!. source # simplify \u2014 Method . simplify ( x :: FacElem { fmpq }) -> FacElem { fmpq } simplify ( x :: FacElem { fmpz }) -> FacElem { fmpz } Simplfies the factored element, i.e. arranges for the base to be coprime. source The simplified version can then be used further: # isone \u2014 Method . isone ( x :: FacElem { fmpq }) -> Bool isone ( x :: FacElem { fmpz }) -> Bool Tests if x represents 1 without an evaluation. source # factor_coprime \u2014 Method . factor_coprime ( x :: FacElem { fmpz }) -> Fac { fmpz } Computed a partial factorisation of x , ie. writes x as a product of pariwise coprime integers. source # factor_coprime \u2014 Method . factor_coprime ( x :: FacElem { NfOrdIdl , NfOrdIdlSet }) -> Dict { NfOrdIdl , Int } Computed a partial factorisation of x , ie. writes x as a product of pariwise coprime integral ideals. source # factor_coprime \u2014 Method . factor_coprime ( Q :: FacElem { NfOrdFracIdl , NfOrdFracIdlSet }) -> Dict { NfOrdIdl , Int } A coprime factorisation of Q : each ideal in Q is split using \\code{integral_split} and then a coprime basis is computed. This does {\\bf not} use any factorisation. source # factor_coprime \u2014 Method . factor_coprime ( a :: FacElem { nf_elem , AnticNumberField }, I :: NfOrdIdlSet ) -> Dict { NfOrdIdl , fmpz } Factors the rincipal ideal generated by a into coprimes by computing a coprime basis from the principal ideals in the factorisation of a . source # factor \u2014 Method . factor ( Q :: FacElem { NfOrdFracIdl , NfOrdFracIdlSet }) -> Dict { NfOrdIdl , Int } The factorisation of Q , by refining a coprime factorisation. source # factor \u2014 Method . factor ( a :: FacElem { nf_elem , AnticNumberField }, I :: NfOrdIdlSet ) -> Dict { NfOrdIdl , fmpz } Factors the principal ideal generated by a by refinind a coprime factorisation. source For factorised algebraic numbers a unique simplification is not possible, however, this allows still do obtain partial results: # compact_presentation \u2014 Function . compact_presentation ( a :: FacElem { nf_elem , AnticNumberField }, n :: Int = 2 ; decom , arb_prec = 100 , short_prec = 1000 ) -> FacElem Computes a presentation a = \\prod a_i^{n_i} where all the exponents n_i are powers of n and, the elements a_i are \"small\", generically, they have a norm bounded by d^{n/2} where d is the discriminant of the maximal order. As the algorithm needs the factorisation of the principal ideal generated by a , it can be passed in in \\code{decom}. source # signs \u2014 Method . signs ( a :: nf_elem ) -> Dict { InfPlc , Int } signs ( a :: FacElem { nf_elem }) -> Dict { InfPlc , Int } This function returns a dictionary of the signs of a at all infinite places of the ambient number field. The keys are infinite places of the ambient number field. The value is 1 if the sign is positive and -1 if the sign is negative. source # signs \u2014 Method . signs ( a :: nf_elem , l :: Vector { InfPlc }) -> Dict { InfPlc , Int } signs ( a :: FacElem { nf_elem }, l :: Vector { InfPlc }) -> Dict { InfPlc , Int } This function returns a dictionary of the signs of a at places in l . The keys are the elements of l . The value is 1 if the sign is positive and -1 if the sign is negative. The result will contain as many signs as there are real places contained in l . source # sign \u2014 Method . sign ( a :: nf_elem , P :: InfPlc ) -> Int sign ( a :: FacElem { nf_elem }, P :: InfPlc ) -> Int This function returns the sign of a at the place P . The value is 1 if the sign is positive and -1 if the sign is negative. source # ispositive \u2014 Method . ispositive ( a :: nf_elem , P :: InfPlc ) -> Bool ispositive ( a :: FacElem { nf_elem }, P :: InfPlc ) -> Bool Returns whether the element a is positive at the embedding corresponding to P . The place P must be real. source # ispositive \u2014 Method . ispositive ( a :: nf_elem , l :: Vector { InfPlc }) -> Bool ispositive ( a :: FacElem { nf_elem }, l :: Vector { InfPlc }) -> Bool Returns whether the element a is positive at the embeddings corresponding to the real places of l . source # istotally_positive \u2014 Method . istotally_positive ( a :: nf_elem ) -> Bool istotally_positive ( a :: FacElem { nf_elem }) -> Bool Returns whether the element a is totally positive, that is, whether it is positive at all places of the ambient number field. source # valuation \u2014 Method . valuation ( a :: FacElem { nf_elem , AnticNumberField }, P :: NfOrdIdl ) -> fmpz The valuation of a at P . source # valuation \u2014 Method . valuation ( A :: FacElem { NfOrdFracIdl , NfOrdFracIdlSet }, p :: NfOrdIdl ) valuation ( A :: FacElem { NfOrdIdl , NfOrdIdlSet }, p :: NfOrdIdl ) The valuation of A at P . source # evaluate_mod \u2014 Method . evaluate_mod ( a :: FacElem { nf_elem , AnticNumberField }, B :: NfOrdFracIdl ) -> nf_elem Evaluates a using CRT and small primes. Assumes that the ideal generated by a is in fact B . Useful in cases where a has huge exponents, but the evaluated element is actually \"small\". source # reduce_ideal \u2014 Method . reduce_ideal ( A :: FacElem { NfOrdIdl }) -> NfOrdIdl , FacElem { nf_elem } Computes B and \\alpha in factored form, such that \\alpha B = A . source # modular_proj \u2014 Method . modular_proj ( a :: FacElem { nf_elem , AnticNumberField }, me :: modular_env ) -> Vector { fq_nmod } Given an algebraic number a in factored form and data \\code{me} as computed by \\code{modular_init}, project a onto the residue class fields. source Miscellaneous # max_exp \u2014 Method . max_exp ( a :: FacElem ) Finds the largest exponent in the factored element a . source # min_exp \u2014 Method . min_exp ( a :: FacElem ) Finds the smallest exponent in the factored element a . source # maxabs_exp \u2014 Method . maxabs_exp ( a :: FacElem ) Finds the largest exponent by absolute value in the factored element a . source","title":"Factored Elements"},{"location":"FacElem/#factored-elements","text":"In many applications in number theory related to the multiplicative structure of number fields, interesting elements, e.g. units, are extremely large when written wrt. to a fxied basis for the field: for the fundamental unit in Q[\\sqrt d] it is known that the coefficients wrt. the canonical basis 1, \\sqrt d can have O(\\exp \\sqrt d) many digits. All currently known, fast methods construct those elements as power products of smaller elements, allowing the computer to handle them. Mathematically, one can think of factored elements to formally live in the ring Z[K] the group ring of the non-zero field elements. Thus elements are of the form \\prod a*i^{e*i} where a_i are elements in K , typically small and the e_i\\in Z are frequently large exponents. We refer to the a_i as the base and the e_i as the exponents of the factored element. Since K is, in general, no PID, this presentation is non-unique, elements in this form can easily be multiplied, raised to large powers, but in general not compared and not added. In Hecke, this is caputured more generally by the type FacElem , parametrized by the type of the elements in the base and the type of their parent. Important special cases are FacElem{fmpz, FlintIntegerRing} , factored integers FacElem{nf_elem, AnticNumberField} , factored algerbaic numbers FacElem{NfAbsOrdIdl, NfAbsOrdIdlSet} , factored ideals It should be noted that an object of type ` FacElem{fmpz, FlintIntegerRing} will, in general, not represent an integer as the exponents can be negative.","title":"Factored Elements"},{"location":"FacElem/#construction","text":"In general one can define factored elements by giving 2 arrays, the base and the exponent, or a dictionary containing the pairs: # FacElem \u2014 Type . FacElem { B }( R , base :: Vector { B }, exp :: Vector { fmpz }) -> FacElem { B } Returns the element \\prod b_i^{e_i} , un-expanded. source FacElem{B}(base::Vector{B}, exp::Vector{fmpz}) -> FacElem{B} Returns the element \\prod b_i^{e_i} , un-expanded. source FacElem{B}(R, d::Dict{B, fmpz}) -> FacElem{B} FacElem{B}(R, d::Dict{B, Integer}) -> FacElem{B} Returns the element \\prod b^{d[p]} , un-expanded. source FacElem{B}(d::Dict{B, fmpz}) -> FacElem{B} FacElem{B}(d::Dict{B, Integer}) -> FacElem{B} Returns the element \\prod b^{d[p]} , un-expanded. source # FacElem \u2014 Method . FacElem { B }( R , base :: Vector { B }, exp :: Vector { fmpz }) -> FacElem { B } Returns the element \\prod b_i^{e_i} , un-expanded. source FacElem{B}(base::Vector{B}, exp::Vector{fmpz}) -> FacElem{B} Returns the element \\prod b_i^{e_i} , un-expanded. source FacElem{B}(R, d::Dict{B, fmpz}) -> FacElem{B} FacElem{B}(R, d::Dict{B, Integer}) -> FacElem{B} Returns the element \\prod b^{d[p]} , un-expanded. source FacElem{B}(d::Dict{B, fmpz}) -> FacElem{B} FacElem{B}(d::Dict{B, Integer}) -> FacElem{B} Returns the element \\prod b^{d[p]} , un-expanded. source # ideal \u2014 Method . ideal ( O :: NfOrd , a :: FacElem { nf_elem , AnticNumberField ) The factored fractional ideal a*O . source","title":"Construction"},{"location":"FacElem/#conversion","text":"The process of computing the value defined by a factored element is available as evaluate . Depending on the types involved this can be very efficient. # evaluate \u2014 Method . evaluate { T }( x :: FacElem { T }) -> T Expands or evaluates the factored element, i.e. actually computes the value. Does \"square-and-multiply\" on the exponent vectors. source # evaluate \u2014 Method . evaluate ( x :: FacElem { fmpq }) -> fmpq evaluate ( x :: FacElem { fmpz }) -> fmpz Expands or evaluates the factored element, i.e. actually computes the the element. Works by first obtaining a simplified version of the power product into coprime base elements. source # evaluate \u2014 Method . evaluate { T }( x :: FacElem { T }) -> T Expands or evaluates the factored element, i.e. actually computes the value. Does \"square-and-multiply\" on the exponent vectors. source # evaluate_naive \u2014 Method . evaluate_naive { T }( x :: FacElem { T }) -> T Expands or evaluates the factored element, i.e. actually computes the value. Uses the obvious naive algorithm. Faster for input in finite rings. source","title":"Conversion"},{"location":"FacElem/#special-functions","text":"In the case where the parent of the base allows for efficient gcd computation, power products can be made unique: # simplify \u2014 Method . simplify ( x :: FacElem { NfOrdIdl , NfOrdIdlSet }) -> FacElem simplify ( x :: FacElem { NfOrdFracIdl , NfOrdFracIdlSet }) -> FacElem Uses coprime_base to obtain a simplified version of x , ie. in the simplified version all base ideals will be pariwise coprime but not neccessarily prime!. source # simplify \u2014 Method . simplify ( x :: FacElem { fmpq }) -> FacElem { fmpq } simplify ( x :: FacElem { fmpz }) -> FacElem { fmpz } Simplfies the factored element, i.e. arranges for the base to be coprime. source The simplified version can then be used further: # isone \u2014 Method . isone ( x :: FacElem { fmpq }) -> Bool isone ( x :: FacElem { fmpz }) -> Bool Tests if x represents 1 without an evaluation. source # factor_coprime \u2014 Method . factor_coprime ( x :: FacElem { fmpz }) -> Fac { fmpz } Computed a partial factorisation of x , ie. writes x as a product of pariwise coprime integers. source # factor_coprime \u2014 Method . factor_coprime ( x :: FacElem { NfOrdIdl , NfOrdIdlSet }) -> Dict { NfOrdIdl , Int } Computed a partial factorisation of x , ie. writes x as a product of pariwise coprime integral ideals. source # factor_coprime \u2014 Method . factor_coprime ( Q :: FacElem { NfOrdFracIdl , NfOrdFracIdlSet }) -> Dict { NfOrdIdl , Int } A coprime factorisation of Q : each ideal in Q is split using \\code{integral_split} and then a coprime basis is computed. This does {\\bf not} use any factorisation. source # factor_coprime \u2014 Method . factor_coprime ( a :: FacElem { nf_elem , AnticNumberField }, I :: NfOrdIdlSet ) -> Dict { NfOrdIdl , fmpz } Factors the rincipal ideal generated by a into coprimes by computing a coprime basis from the principal ideals in the factorisation of a . source # factor \u2014 Method . factor ( Q :: FacElem { NfOrdFracIdl , NfOrdFracIdlSet }) -> Dict { NfOrdIdl , Int } The factorisation of Q , by refining a coprime factorisation. source # factor \u2014 Method . factor ( a :: FacElem { nf_elem , AnticNumberField }, I :: NfOrdIdlSet ) -> Dict { NfOrdIdl , fmpz } Factors the principal ideal generated by a by refinind a coprime factorisation. source For factorised algebraic numbers a unique simplification is not possible, however, this allows still do obtain partial results: # compact_presentation \u2014 Function . compact_presentation ( a :: FacElem { nf_elem , AnticNumberField }, n :: Int = 2 ; decom , arb_prec = 100 , short_prec = 1000 ) -> FacElem Computes a presentation a = \\prod a_i^{n_i} where all the exponents n_i are powers of n and, the elements a_i are \"small\", generically, they have a norm bounded by d^{n/2} where d is the discriminant of the maximal order. As the algorithm needs the factorisation of the principal ideal generated by a , it can be passed in in \\code{decom}. source # signs \u2014 Method . signs ( a :: nf_elem ) -> Dict { InfPlc , Int } signs ( a :: FacElem { nf_elem }) -> Dict { InfPlc , Int } This function returns a dictionary of the signs of a at all infinite places of the ambient number field. The keys are infinite places of the ambient number field. The value is 1 if the sign is positive and -1 if the sign is negative. source # signs \u2014 Method . signs ( a :: nf_elem , l :: Vector { InfPlc }) -> Dict { InfPlc , Int } signs ( a :: FacElem { nf_elem }, l :: Vector { InfPlc }) -> Dict { InfPlc , Int } This function returns a dictionary of the signs of a at places in l . The keys are the elements of l . The value is 1 if the sign is positive and -1 if the sign is negative. The result will contain as many signs as there are real places contained in l . source # sign \u2014 Method . sign ( a :: nf_elem , P :: InfPlc ) -> Int sign ( a :: FacElem { nf_elem }, P :: InfPlc ) -> Int This function returns the sign of a at the place P . The value is 1 if the sign is positive and -1 if the sign is negative. source # ispositive \u2014 Method . ispositive ( a :: nf_elem , P :: InfPlc ) -> Bool ispositive ( a :: FacElem { nf_elem }, P :: InfPlc ) -> Bool Returns whether the element a is positive at the embedding corresponding to P . The place P must be real. source # ispositive \u2014 Method . ispositive ( a :: nf_elem , l :: Vector { InfPlc }) -> Bool ispositive ( a :: FacElem { nf_elem }, l :: Vector { InfPlc }) -> Bool Returns whether the element a is positive at the embeddings corresponding to the real places of l . source # istotally_positive \u2014 Method . istotally_positive ( a :: nf_elem ) -> Bool istotally_positive ( a :: FacElem { nf_elem }) -> Bool Returns whether the element a is totally positive, that is, whether it is positive at all places of the ambient number field. source # valuation \u2014 Method . valuation ( a :: FacElem { nf_elem , AnticNumberField }, P :: NfOrdIdl ) -> fmpz The valuation of a at P . source # valuation \u2014 Method . valuation ( A :: FacElem { NfOrdFracIdl , NfOrdFracIdlSet }, p :: NfOrdIdl ) valuation ( A :: FacElem { NfOrdIdl , NfOrdIdlSet }, p :: NfOrdIdl ) The valuation of A at P . source # evaluate_mod \u2014 Method . evaluate_mod ( a :: FacElem { nf_elem , AnticNumberField }, B :: NfOrdFracIdl ) -> nf_elem Evaluates a using CRT and small primes. Assumes that the ideal generated by a is in fact B . Useful in cases where a has huge exponents, but the evaluated element is actually \"small\". source # reduce_ideal \u2014 Method . reduce_ideal ( A :: FacElem { NfOrdIdl }) -> NfOrdIdl , FacElem { nf_elem } Computes B and \\alpha in factored form, such that \\alpha B = A . source # modular_proj \u2014 Method . modular_proj ( a :: FacElem { nf_elem , AnticNumberField }, me :: modular_env ) -> Vector { fq_nmod } Given an algebraic number a in factored form and data \\code{me} as computed by \\code{modular_init}, project a onto the residue class fields. source","title":"Special functions"},{"location":"FacElem/#miscellaneous","text":"# max_exp \u2014 Method . max_exp ( a :: FacElem ) Finds the largest exponent in the factored element a . source # min_exp \u2014 Method . min_exp ( a :: FacElem ) Finds the smallest exponent in the factored element a . source # maxabs_exp \u2014 Method . maxabs_exp ( a :: FacElem ) Finds the largest exponent by absolute value in the factored element a . source","title":"Miscellaneous"},{"location":"examples/","text":"Examples and sample code Reduction of polynomials over number fields modulo a prime ideal","title":"Examples"},{"location":"examples/#examples-and-sample-code","text":"Reduction of polynomials over number fields modulo a prime ideal","title":"Examples and sample code"},{"location":"misc/","text":"Miscalleneous Integer related # euler_phi_inv \u2014 Function . euler_phi_inv ( n :: Integer ) -> Vector { fmpz } The inverse of the Euler totient functions: find all x s.th. phi(x) = n holds. source euler_phi_inv(n::fmpz) -> Vector{fmpz} The inverse of the Euler totient functions: find all x s.th. phi(x) = n holds. source euler_phi_inv(n::fmpz, zk::NfAbsOrd{AnticNumberField, nf_elem}) -> Vector{NfOrdIdl} The inverse of the ideal totient function: all ideals A s.th. the unit group of the residue ring has the required size. source # modord \u2014 Method . modord ( a :: fmpz , m :: fmpz ) -> Int modord ( a :: Integer , m :: Integer ) The multiplicative order of a modulo m (not a good algorithm). source # isprime_power \u2014 Method . isprime_power ( n :: fmpz ) -> Bool isprime_power ( n :: Integer ) -> Bool Tests if n is the exact power of a prime number. source # primes_up_to \u2014 Method . primes_up_to ( n :: Int ) -> Vector { Int } Returns a vector containing all the prime numbers up to n . source Analytic # dickman_rho \u2014 Function . dickman_rho ( x :: Number , prec :: Int = 55 ) Number Evaluates the Dickman- \\rho function at x . source dickman_rho(x::Number, e::UnitRange{Int}, prec::Int=55) Number[] Evaluates the Dickman- \\rho function at i*x for all i\\in e . source # psi_guess \u2014 Function . psi_guess ( x :: Number , B :: Int ) Number Uses the dickman_rho function to estimate \\psi(x, B) the number of B -smooth integers bounded by x . source psi_guess(x::Number, e::UnitRange, B::Int) Number Uses the dickman_rho function to estimate \\psi(x^i, B) the number of B -smooth integers bounded by x^i for i \\in e . source # psi_lower \u2014 Function . psi_lower ( N :: Integer , B :: Int , a :: Int = 776 ) -> Vector { Int }, fmpz_abs_series psi_lower ( N :: fmpz , B :: Int , a :: Int = 776 ) -> Vector { Int }, fmpz_abs_series Uses Bernstein's ideas: https://cr.yp.to/papers/psi.pdf to compute lower bounds on the psi function counting smooth numbers. An array L is returned s.th. \\psi(2^{i-1}, B) \\ge L_i for 1\\le i\\le \\rceil \\log_2(B)\\lceil . The second return value is Bernstein's power series. The optional other parameter a controls the precision of the result, it defaults to 776. source psi_lower(N::Integer, B::NfFactorBase) -> Vector{Int}, fmpz_abs_series psi_lower(N::fmpz, B::NfFactorBase) -> Vector{Int}, fmpz_abs_series psi_upper(N::Integer, B::NfFactorBase) -> Vector{Int}, fmpz_abs_series psi_upper(N::fmpz, B::NfFactorBase) -> Vector{Int}, fmpz_abs_series Uses Bernstein's techniques to bound the number of ideals A of norm bounded by N that are smooth over the factor base B . source Linear Algebra # largest_elementary_divisor \u2014 Function . largest_elementary_divisor ( A :: fmpz_mat ) -> fmpz The largest elementary divisor of A , that is, the last diagonal entry of the Smith normal form of A . source # maximal_elementary_divisor \u2014 Method . maximal_elementary_divisor ( A :: fmpz_mat ) -> fmpz The largest elementary divisor of A , that is, the last diagonal entry of the Smith normal form of A . source # mod_sym \u2014 Method . mod_sym ( M :: fmpz_mat , p :: fmpz ) -> fmpz_mat Reduces every entry modulo p into the symmetric residue system. source # mod_sym! \u2014 Method . mod_sym! ( M :: fmpz_mat , p :: fmpz ) Reduces every entry modulo p in-place, into the symmetric residue system. source # mod! \u2014 Method . mod! ( M :: fmpz_mat , p :: fmpz ) Reduces every entry modulo p in-place, i.e. applies the mod function to every entry. Positive residue system. source # saturate \u2014 Method . saturate ( A :: fmpz_mat ) -> fmpz_mat Computes the saturation of A , that is, a basis for \\mathbf{Q}\\otimes M \\cap \\mathbf{Z}^n , where M is the row span of A and n the number of rows of A . Equivalently, return TA for an invertible rational matrix T such that TA is integral and the elementary divisors of TA are all trivial. source # elementary_divisors \u2014 Method . elementary_divisors ( A :: fmpz_mat ) -> Vector { fmpz } The elementary divisors of A , that is, the diagonal entries of the Smith normal form of A . source # jordan_normal_form \u2014 Function . jordan_normal_form ( M :: MatElem { T }) where T <: FieldElem -> MatElem { T }, MatElem { T } Returns matrices J and S such that J = SMS^{-1} and J is in Jordan normal form. source # divisors \u2014 Method . divisors ( A :: fmpz_mat , d :: fmpz ) -> fmpz Returns the diagonal entries of a diagonal form of A . We assume that all the elementary divisors are divisors of d . source # snf_with_transform \u2014 Method . snf_with_transform ( A :: fmpz_mat , l :: Bool = true , r :: Bool = true ) -> fmpz_mat , fmpz_mat , fmpz_mat Given some integer matrix A , compute the Smith normal form (elementary divisor normal form) of A . If l and/ or r are true, then the corresponding left and/ or right transformation matrices are computed as well. source Polynomials CRT # induce_crt \u2014 Function . induce_crt ( a :: fmpz_poly , p :: fmpz , b :: fmpz_poly , q :: fmpz , signed :: Bool = false ) -> fmpz_poly Given integral polynomials a and b as well as coprime integer moduli p and q , find f = a \\bmod p and f=b \\bmod q . If signed is set, the symmetric representative is used, the positive one otherwise. source induce_crt(L::Vector{PolyElem}, c::crt_env{fmpz}) -> fmpz_poly Given fmpz_poly polynomials L[i] and a crt\\_env , apply the crt function to each coefficient resulting in a polynomial f = L[i] \\bmod p[i] . source induce_crt(L::Vector{MatElem}, c::crt_env{fmpz}) -> fmpz_mat Given matrices L[i] and a crt\\_env , apply the crt function to each coefficient resulting in a matrix M = L[i] \\bmod p[i] . source induce_crt(a::Generic.Poly{nf_elem}, p::fmpz, b::Generic.Poly{nf_elem}, q::fmpz) -> Generic.Poly{nf_elem}, fmpz Given polynomials a defined modulo p and b modulo q , apply the CRT to all coefficients recursively. Implicitly assumes that a and b have integral coefficients (i.e. no denominators). source # induce_rational_reconstruction \u2014 Function . induce_rational_reconstruction ( a :: fmpz_poly , M :: fmpz ) -> fmpq_poly Apply rational_reconstruction to each coefficient of a , resulting in either a fail (return (false, s.th.)) or (true, g) for some rational polynomial g s.th. g \\equiv a \\bmod M . source induce_rational_reconstruction(a::Generic.Poly{nf_elem}, M::fmpz) -> bool, Generic.Poly{nf_elem} Apply rational reconstruction to the coefficients of a . Implicitly assumes the coefficients to be integral (no checks done) returns true iff this is successful for all coefficients. source","title":"Misc"},{"location":"misc/#miscalleneous","text":"","title":"Miscalleneous"},{"location":"misc/#integer-related","text":"# euler_phi_inv \u2014 Function . euler_phi_inv ( n :: Integer ) -> Vector { fmpz } The inverse of the Euler totient functions: find all x s.th. phi(x) = n holds. source euler_phi_inv(n::fmpz) -> Vector{fmpz} The inverse of the Euler totient functions: find all x s.th. phi(x) = n holds. source euler_phi_inv(n::fmpz, zk::NfAbsOrd{AnticNumberField, nf_elem}) -> Vector{NfOrdIdl} The inverse of the ideal totient function: all ideals A s.th. the unit group of the residue ring has the required size. source # modord \u2014 Method . modord ( a :: fmpz , m :: fmpz ) -> Int modord ( a :: Integer , m :: Integer ) The multiplicative order of a modulo m (not a good algorithm). source # isprime_power \u2014 Method . isprime_power ( n :: fmpz ) -> Bool isprime_power ( n :: Integer ) -> Bool Tests if n is the exact power of a prime number. source # primes_up_to \u2014 Method . primes_up_to ( n :: Int ) -> Vector { Int } Returns a vector containing all the prime numbers up to n . source","title":"Integer related"},{"location":"misc/#analytic","text":"# dickman_rho \u2014 Function . dickman_rho ( x :: Number , prec :: Int = 55 ) Number Evaluates the Dickman- \\rho function at x . source dickman_rho(x::Number, e::UnitRange{Int}, prec::Int=55) Number[] Evaluates the Dickman- \\rho function at i*x for all i\\in e . source # psi_guess \u2014 Function . psi_guess ( x :: Number , B :: Int ) Number Uses the dickman_rho function to estimate \\psi(x, B) the number of B -smooth integers bounded by x . source psi_guess(x::Number, e::UnitRange, B::Int) Number Uses the dickman_rho function to estimate \\psi(x^i, B) the number of B -smooth integers bounded by x^i for i \\in e . source # psi_lower \u2014 Function . psi_lower ( N :: Integer , B :: Int , a :: Int = 776 ) -> Vector { Int }, fmpz_abs_series psi_lower ( N :: fmpz , B :: Int , a :: Int = 776 ) -> Vector { Int }, fmpz_abs_series Uses Bernstein's ideas: https://cr.yp.to/papers/psi.pdf to compute lower bounds on the psi function counting smooth numbers. An array L is returned s.th. \\psi(2^{i-1}, B) \\ge L_i for 1\\le i\\le \\rceil \\log_2(B)\\lceil . The second return value is Bernstein's power series. The optional other parameter a controls the precision of the result, it defaults to 776. source psi_lower(N::Integer, B::NfFactorBase) -> Vector{Int}, fmpz_abs_series psi_lower(N::fmpz, B::NfFactorBase) -> Vector{Int}, fmpz_abs_series psi_upper(N::Integer, B::NfFactorBase) -> Vector{Int}, fmpz_abs_series psi_upper(N::fmpz, B::NfFactorBase) -> Vector{Int}, fmpz_abs_series Uses Bernstein's techniques to bound the number of ideals A of norm bounded by N that are smooth over the factor base B . source","title":"Analytic"},{"location":"misc/#linear-algebra","text":"# largest_elementary_divisor \u2014 Function . largest_elementary_divisor ( A :: fmpz_mat ) -> fmpz The largest elementary divisor of A , that is, the last diagonal entry of the Smith normal form of A . source # maximal_elementary_divisor \u2014 Method . maximal_elementary_divisor ( A :: fmpz_mat ) -> fmpz The largest elementary divisor of A , that is, the last diagonal entry of the Smith normal form of A . source # mod_sym \u2014 Method . mod_sym ( M :: fmpz_mat , p :: fmpz ) -> fmpz_mat Reduces every entry modulo p into the symmetric residue system. source # mod_sym! \u2014 Method . mod_sym! ( M :: fmpz_mat , p :: fmpz ) Reduces every entry modulo p in-place, into the symmetric residue system. source # mod! \u2014 Method . mod! ( M :: fmpz_mat , p :: fmpz ) Reduces every entry modulo p in-place, i.e. applies the mod function to every entry. Positive residue system. source # saturate \u2014 Method . saturate ( A :: fmpz_mat ) -> fmpz_mat Computes the saturation of A , that is, a basis for \\mathbf{Q}\\otimes M \\cap \\mathbf{Z}^n , where M is the row span of A and n the number of rows of A . Equivalently, return TA for an invertible rational matrix T such that TA is integral and the elementary divisors of TA are all trivial. source # elementary_divisors \u2014 Method . elementary_divisors ( A :: fmpz_mat ) -> Vector { fmpz } The elementary divisors of A , that is, the diagonal entries of the Smith normal form of A . source # jordan_normal_form \u2014 Function . jordan_normal_form ( M :: MatElem { T }) where T <: FieldElem -> MatElem { T }, MatElem { T } Returns matrices J and S such that J = SMS^{-1} and J is in Jordan normal form. source # divisors \u2014 Method . divisors ( A :: fmpz_mat , d :: fmpz ) -> fmpz Returns the diagonal entries of a diagonal form of A . We assume that all the elementary divisors are divisors of d . source # snf_with_transform \u2014 Method . snf_with_transform ( A :: fmpz_mat , l :: Bool = true , r :: Bool = true ) -> fmpz_mat , fmpz_mat , fmpz_mat Given some integer matrix A , compute the Smith normal form (elementary divisor normal form) of A . If l and/ or r are true, then the corresponding left and/ or right transformation matrices are computed as well. source","title":"Linear Algebra"},{"location":"misc/#polynomials","text":"","title":"Polynomials"},{"location":"misc/#crt","text":"# induce_crt \u2014 Function . induce_crt ( a :: fmpz_poly , p :: fmpz , b :: fmpz_poly , q :: fmpz , signed :: Bool = false ) -> fmpz_poly Given integral polynomials a and b as well as coprime integer moduli p and q , find f = a \\bmod p and f=b \\bmod q . If signed is set, the symmetric representative is used, the positive one otherwise. source induce_crt(L::Vector{PolyElem}, c::crt_env{fmpz}) -> fmpz_poly Given fmpz_poly polynomials L[i] and a crt\\_env , apply the crt function to each coefficient resulting in a polynomial f = L[i] \\bmod p[i] . source induce_crt(L::Vector{MatElem}, c::crt_env{fmpz}) -> fmpz_mat Given matrices L[i] and a crt\\_env , apply the crt function to each coefficient resulting in a matrix M = L[i] \\bmod p[i] . source induce_crt(a::Generic.Poly{nf_elem}, p::fmpz, b::Generic.Poly{nf_elem}, q::fmpz) -> Generic.Poly{nf_elem}, fmpz Given polynomials a defined modulo p and b modulo q , apply the CRT to all coefficients recursively. Implicitly assumes that a and b have integral coefficients (i.e. no denominators). source # induce_rational_reconstruction \u2014 Function . induce_rational_reconstruction ( a :: fmpz_poly , M :: fmpz ) -> fmpq_poly Apply rational_reconstruction to each coefficient of a , resulting in either a fail (return (false, s.th.)) or (true, g) for some rational polynomial g s.th. g \\equiv a \\bmod M . source induce_rational_reconstruction(a::Generic.Poly{nf_elem}, M::fmpz) -> bool, Generic.Poly{nf_elem} Apply rational reconstruction to the coefficients of a . Implicitly assumes the coefficients to be integral (no checks done) returns true iff this is successful for all coefficients. source","title":"CRT"},{"location":"abelian/elements/","text":"Elements Elements in a finitely geenrated abelian group are of type GrpAbFinGenElem and are always given as a linear combination of the generators. Internally this representation is normliased to have a unique representative. Creation In addition to the standard function id , zero and one that can be used to create the neutral element, we also support more targeted creation: # gens \u2014 Method . gens ( G :: GrpAbFinGen ) -> Vector { GrpAbFinGenElem } The sequence of generators of G . source # GrpAbFinGen \u2014 Method . ( A :: GrpAbFinGen )( x :: Vector { fmpz }) -> GrpAbFinGenElem Given an array x of elements of type fmpz of the same length as ngens( A ), this function returns the element of A with components x . source # GrpAbFinGen \u2014 Method . ( A :: GrpAbFinGen )( x :: fmpz_mat ) -> GrpAbFinGenElem Given a matrix over the integers with 1 row and ngens(A) columns, this function returns the element of A with components x . source # getindex \u2014 Method . getindex ( A :: GrpAbFinGen , i :: Int ) -> GrpAbFinGenElem Returns the element of A with components (0,\\dotsc,0,1,0,\\dotsc,0) , where the 1 is at the i -th position. source # rand \u2014 Method . rand ( G :: GrpAbFinGen ) -> GrpAbFinGenElem Returns an element of G chosen uniformly at random. source # rand \u2014 Method . rand ( G :: GrpAbFinGen , B :: fmpz ) -> GrpAbFinGenElem For a (potentially infinite) abelian group G , return an element chosen uniformly at random with coefficients bounded by B . source # parent \u2014 Method . parent ( x :: GrpAbFinGenElem ) -> GrpAbFinGen Returns the parent of x . source Access # getindex \u2014 Method . getindex ( x :: GrpAbFinGenElem , i :: Int ) -> fmpz Returns the i -th component of the element x . source Predicates We have the standard predicated iszero , isone and isidentity to test an element for being trivial. Invariants # order \u2014 Method . order ( A :: GrpAbFinGenElem ) -> fmpz Returns the order of A . It is assumed that the order is finite. source Iterator One can iterate over the elements of a finite abelian group. julia> G = abelian_group ( fmpz [ 1 2 ; 3 4 ]) (General) abelian group with relation matrix [1 2; 3 4] julia> for g = G println ( g ) end Element of (General) abelian group with relation matrix [1 2; 3 4] with structure of GrpAb: Z/2 with components [0 0] Element of (General) abelian group with relation matrix [1 2; 3 4] with structure of GrpAb: Z/2 with components [0 1]","title":"Elements"},{"location":"abelian/elements/#elements","text":"Elements in a finitely geenrated abelian group are of type GrpAbFinGenElem and are always given as a linear combination of the generators. Internally this representation is normliased to have a unique representative.","title":"Elements"},{"location":"abelian/elements/#creation","text":"In addition to the standard function id , zero and one that can be used to create the neutral element, we also support more targeted creation: # gens \u2014 Method . gens ( G :: GrpAbFinGen ) -> Vector { GrpAbFinGenElem } The sequence of generators of G . source # GrpAbFinGen \u2014 Method . ( A :: GrpAbFinGen )( x :: Vector { fmpz }) -> GrpAbFinGenElem Given an array x of elements of type fmpz of the same length as ngens( A ), this function returns the element of A with components x . source # GrpAbFinGen \u2014 Method . ( A :: GrpAbFinGen )( x :: fmpz_mat ) -> GrpAbFinGenElem Given a matrix over the integers with 1 row and ngens(A) columns, this function returns the element of A with components x . source # getindex \u2014 Method . getindex ( A :: GrpAbFinGen , i :: Int ) -> GrpAbFinGenElem Returns the element of A with components (0,\\dotsc,0,1,0,\\dotsc,0) , where the 1 is at the i -th position. source # rand \u2014 Method . rand ( G :: GrpAbFinGen ) -> GrpAbFinGenElem Returns an element of G chosen uniformly at random. source # rand \u2014 Method . rand ( G :: GrpAbFinGen , B :: fmpz ) -> GrpAbFinGenElem For a (potentially infinite) abelian group G , return an element chosen uniformly at random with coefficients bounded by B . source # parent \u2014 Method . parent ( x :: GrpAbFinGenElem ) -> GrpAbFinGen Returns the parent of x . source","title":"Creation"},{"location":"abelian/elements/#access","text":"# getindex \u2014 Method . getindex ( x :: GrpAbFinGenElem , i :: Int ) -> fmpz Returns the i -th component of the element x . source","title":"Access"},{"location":"abelian/elements/#predicates","text":"We have the standard predicated iszero , isone and isidentity to test an element for being trivial.","title":"Predicates"},{"location":"abelian/elements/#invariants","text":"# order \u2014 Method . order ( A :: GrpAbFinGenElem ) -> fmpz Returns the order of A . It is assumed that the order is finite. source","title":"Invariants"},{"location":"abelian/elements/#iterator","text":"One can iterate over the elements of a finite abelian group. julia> G = abelian_group ( fmpz [ 1 2 ; 3 4 ]) (General) abelian group with relation matrix [1 2; 3 4] julia> for g = G println ( g ) end Element of (General) abelian group with relation matrix [1 2; 3 4] with structure of GrpAb: Z/2 with components [0 0] Element of (General) abelian group with relation matrix [1 2; 3 4] with structure of GrpAb: Z/2 with components [0 1]","title":"Iterator"},{"location":"abelian/introduction/","text":"Abelian Groups Here we describe the interface to abelian groups in Hecke. Introduction Within Hecke, abelian groups are of generic abstract type GrpAb which does not have to be finitely generated, \\mathbb Q/\\mathbb Z is an example of a more general abelian group. Having said that, most of the functionality is restricted to abelian groups that are finitely presented as \\mathbb Z -modules. Basic Creation Finitely presented (as \\mathbb Z -modules) abelian groups are of type GrpAbFinGen with elements of type GrpAbFinGenElem . The creation is mostly via a relation matrix M = (m_{i,j}) for 1\\le i\\le n and 1\\le j\\le m . This creates a group with m generators e_j and relations \\sum_{i=1}^n m_{i,j} e_j = 0. # abelian_group \u2014 Method . abelian_group ( :: Type { T } = GrpAbFinGen , M :: fmpz_mat ) -> GrpAbFinGen Creates the abelian group with relation matrix M . That is, the group will have ncols(M) generators and each row of M describes one relation. source # abelian_group \u2014 Method . abelian_group ( :: Type { T } = GrpAbFinGen , M :: AbstractMatrix { <: IntegerUnion }) Creates the abelian group with relation matrix M . That is, the group will have ncols(M) generators and each row of M describes one relation. source # abelian_group \u2014 Method . abelian_group ( :: Type { T } = GrpAbFinGen , M :: AbstractMatrix { <: IntegerUnion }) Creates the abelian group with relation matrix M . That is, the group will have ncols(M) generators and each row of M describes one relation. source Alternatively, there are shortcuts to create products of cyclic groups: # abelian_group \u2014 Method . abelian_group ( :: Type { T } = GrpAbFinGen , M :: AbstractVector { <: IntegerUnion }) -> GrpAbFinGen abelian_group ( :: Type { T } = GrpAbFinGen , M :: IntegerUnion ... ) -> GrpAbFinGen Creates the direct product of the cyclic groups \\mathbf{Z}/m_i , where m_i is the i th entry of M . source julia> G = abelian_group ( 2 , 2 , 6 ) GrpAb: (Z/2)^2 x Z/6 or even # free_abelian_group \u2014 Method . free_abelian_group ( :: Type { T } = GrpAbFinGen , n :: Int ) -> GrpAbFinGen Creates the free abelian group of rank n . source # abelian_groups \u2014 Method . abelian_groups ( n :: Int ) -> Vector { GrpAbFinGen } Given a positive integer n , return a list of all abelian groups of order n . source julia> abelian_groups ( 8 ) 3-element Vector{GrpAbFinGen}: GrpAb: (Z/2)^3 GrpAb: Z/2 x Z/4 GrpAb: Z/8 Invariants # issnf \u2014 Method . issnf ( G :: GrpAbFinGen ) -> Bool Returns whether the current relation matrix of the group G is in Smith normal form. source # ngens \u2014 Method . ngens ( G :: GrpAbFinGen ) -> Int Returns the number of generators of G in the current representation. source # nrels \u2014 Method . nrels ( G :: GrpAbFinGen ) -> Int Returns the number of relations of G in the current representation. source # rels \u2014 Method . rels ( A :: GrpAbFinGen ) -> fmpz_mat Returns the currently used relations of G as a single matrix. source # isfinite \u2014 Method . isfinite ( A :: GrpAbFinGen ) -> Bool Returns whether A is finite. source # isinfinite \u2014 Method . isinfinite ( A :: GrpAbFinGen ) -> Bool Returns whether A is infinite. source # rank \u2014 Method . rank ( A :: GrpAbFinGen ) -> Int Returns the rank of A , that is, the dimension of the \\mathbf{Q} -vectorspace A \\otimes_{\\mathbf Z} \\mathbf Q . source # order \u2014 Method . order ( A :: GrpAbFinGen ) -> fmpz Returns the order of A . It is assumed that A is finite. source # exponent \u2014 Method . exponent ( A :: GrpAbFinGen ) -> fmpz Returns the exponent of A . It is assumed that A is finite. source # istrivial \u2014 Method . istrivial ( A :: GrpAbFinGen ) -> Bool Checks if A is the trivial group. source # istorsion \u2014 Method . istorsion ( G :: GrpAbFinGen ) -> Bool Returns true if and only if G is a torsion group. source # iscyclic \u2014 Method . iscyclic ( G :: GrpAbFinGen ) -> Bool Returns whether G is cyclic. source # elementary_divisors \u2014 Method . elementary_divisors ( G :: GrpAbFinGen ) -> Vector { fmpz } Given G , returns the elementary divisors of G , that is, the unique positive integers e_1,\\dotsc,e_k with e_i \\mid e_{i + 1} and G \\cong \\mathbf{Z}/e_1\\mathbf{Z} \\times \\dotsb \\times \\mathbf{Z}/e_k\\mathbf{Z} . source","title":"Introduction"},{"location":"abelian/introduction/#abelian-groups","text":"Here we describe the interface to abelian groups in Hecke.","title":"Abelian Groups"},{"location":"abelian/introduction/#introduction","text":"Within Hecke, abelian groups are of generic abstract type GrpAb which does not have to be finitely generated, \\mathbb Q/\\mathbb Z is an example of a more general abelian group. Having said that, most of the functionality is restricted to abelian groups that are finitely presented as \\mathbb Z -modules.","title":"Introduction"},{"location":"abelian/introduction/#basic-creation","text":"Finitely presented (as \\mathbb Z -modules) abelian groups are of type GrpAbFinGen with elements of type GrpAbFinGenElem . The creation is mostly via a relation matrix M = (m_{i,j}) for 1\\le i\\le n and 1\\le j\\le m . This creates a group with m generators e_j and relations \\sum_{i=1}^n m_{i,j} e_j = 0. # abelian_group \u2014 Method . abelian_group ( :: Type { T } = GrpAbFinGen , M :: fmpz_mat ) -> GrpAbFinGen Creates the abelian group with relation matrix M . That is, the group will have ncols(M) generators and each row of M describes one relation. source # abelian_group \u2014 Method . abelian_group ( :: Type { T } = GrpAbFinGen , M :: AbstractMatrix { <: IntegerUnion }) Creates the abelian group with relation matrix M . That is, the group will have ncols(M) generators and each row of M describes one relation. source # abelian_group \u2014 Method . abelian_group ( :: Type { T } = GrpAbFinGen , M :: AbstractMatrix { <: IntegerUnion }) Creates the abelian group with relation matrix M . That is, the group will have ncols(M) generators and each row of M describes one relation. source Alternatively, there are shortcuts to create products of cyclic groups: # abelian_group \u2014 Method . abelian_group ( :: Type { T } = GrpAbFinGen , M :: AbstractVector { <: IntegerUnion }) -> GrpAbFinGen abelian_group ( :: Type { T } = GrpAbFinGen , M :: IntegerUnion ... ) -> GrpAbFinGen Creates the direct product of the cyclic groups \\mathbf{Z}/m_i , where m_i is the i th entry of M . source julia> G = abelian_group ( 2 , 2 , 6 ) GrpAb: (Z/2)^2 x Z/6 or even # free_abelian_group \u2014 Method . free_abelian_group ( :: Type { T } = GrpAbFinGen , n :: Int ) -> GrpAbFinGen Creates the free abelian group of rank n . source # abelian_groups \u2014 Method . abelian_groups ( n :: Int ) -> Vector { GrpAbFinGen } Given a positive integer n , return a list of all abelian groups of order n . source julia> abelian_groups ( 8 ) 3-element Vector{GrpAbFinGen}: GrpAb: (Z/2)^3 GrpAb: Z/2 x Z/4 GrpAb: Z/8","title":"Basic Creation"},{"location":"abelian/introduction/#invariants","text":"# issnf \u2014 Method . issnf ( G :: GrpAbFinGen ) -> Bool Returns whether the current relation matrix of the group G is in Smith normal form. source # ngens \u2014 Method . ngens ( G :: GrpAbFinGen ) -> Int Returns the number of generators of G in the current representation. source # nrels \u2014 Method . nrels ( G :: GrpAbFinGen ) -> Int Returns the number of relations of G in the current representation. source # rels \u2014 Method . rels ( A :: GrpAbFinGen ) -> fmpz_mat Returns the currently used relations of G as a single matrix. source # isfinite \u2014 Method . isfinite ( A :: GrpAbFinGen ) -> Bool Returns whether A is finite. source # isinfinite \u2014 Method . isinfinite ( A :: GrpAbFinGen ) -> Bool Returns whether A is infinite. source # rank \u2014 Method . rank ( A :: GrpAbFinGen ) -> Int Returns the rank of A , that is, the dimension of the \\mathbf{Q} -vectorspace A \\otimes_{\\mathbf Z} \\mathbf Q . source # order \u2014 Method . order ( A :: GrpAbFinGen ) -> fmpz Returns the order of A . It is assumed that A is finite. source # exponent \u2014 Method . exponent ( A :: GrpAbFinGen ) -> fmpz Returns the exponent of A . It is assumed that A is finite. source # istrivial \u2014 Method . istrivial ( A :: GrpAbFinGen ) -> Bool Checks if A is the trivial group. source # istorsion \u2014 Method . istorsion ( G :: GrpAbFinGen ) -> Bool Returns true if and only if G is a torsion group. source # iscyclic \u2014 Method . iscyclic ( G :: GrpAbFinGen ) -> Bool Returns whether G is cyclic. source # elementary_divisors \u2014 Method . elementary_divisors ( G :: GrpAbFinGen ) -> Vector { fmpz } Given G , returns the elementary divisors of G , that is, the unique positive integers e_1,\\dotsc,e_k with e_i \\mid e_{i + 1} and G \\cong \\mathbf{Z}/e_1\\mathbf{Z} \\times \\dotsb \\times \\mathbf{Z}/e_k\\mathbf{Z} . source","title":"Invariants"},{"location":"abelian/maps/","text":"Maps between abelian groups are mainly of type GrpAbFinGenMap . They allow normal map operations such as image , preimage , domain , codomain and can be created in a variety of situations. Maps Maps between abelian groups can be constructed via images of the generators pairs of elements via composition and isomorphism/ inclusion testing <a id='hom-Tuple{GrpAbFinGen, GrpAbFinGen, Matrix{var\"#s5\"} where var\"#s5\"<:(Map{GrpAbFinGen, GrpAbFinGen, S, T} where {S, T})}' href='#hom-Tuple{GrpAbFinGen, GrpAbFinGen, Matrix{var\"#s5\"} where var\"#s5\"<:(Map{GrpAbFinGen, GrpAbFinGen, S, T} where {S, T})}'># hom \u2014 Method . hom ( G :: GrpAbFinGen , H :: GrpAbFinGen , A :: Matrix { <: Map { GrpAbFinGen , GrpAbFinGen }}) -> Map Given groups G and H that are created as direct products as well as a matrix A containing maps A[i,j] : G_i \\to H_j , return the induced homomorphism. source # isisomorphic \u2014 Method . isisomorphic ( G :: GrpAbFinGen , H :: GrpAbFinGen ) -> Bool Checks if G and H are isomorphic. source julia> G = free_abelian_group ( 2 ) GrpAb: Z^2 julia> h = hom ( G , G , [ gen ( G , 2 ), 3 * gen ( G , 1 )]) Map with following data Domain: ======= Abelian group with structure: Z^2 Codomain: ========= Abelian group with structure: Z^2 julia> h ( gen ( G , 1 )) Element of GrpAb: Z^2 with components [0 1] julia> h ( gen ( G , 2 )) Element of GrpAb: Z^2 with components [3 0] Homomorphisms also allow addition and subtraction corresponding to the pointwise operation: julia> G = free_abelian_group ( 2 ) GrpAb: Z^2 julia> h = hom ( G , G , [ 2 * gen ( G , 2 ), 3 * gen ( G , 1 )]) Map with following data Domain: ======= Abelian group with structure: Z^2 Codomain: ========= Abelian group with structure: Z^2 julia> ( h + h )( gen ( G , 1 )) Element of GrpAb: Z^2 with components [0 4]","title":"Maps"},{"location":"abelian/maps/#maps","text":"Maps between abelian groups can be constructed via images of the generators pairs of elements via composition and isomorphism/ inclusion testing <a id='hom-Tuple{GrpAbFinGen, GrpAbFinGen, Matrix{var\"#s5\"} where var\"#s5\"<:(Map{GrpAbFinGen, GrpAbFinGen, S, T} where {S, T})}' href='#hom-Tuple{GrpAbFinGen, GrpAbFinGen, Matrix{var\"#s5\"} where var\"#s5\"<:(Map{GrpAbFinGen, GrpAbFinGen, S, T} where {S, T})}'># hom \u2014 Method . hom ( G :: GrpAbFinGen , H :: GrpAbFinGen , A :: Matrix { <: Map { GrpAbFinGen , GrpAbFinGen }}) -> Map Given groups G and H that are created as direct products as well as a matrix A containing maps A[i,j] : G_i \\to H_j , return the induced homomorphism. source # isisomorphic \u2014 Method . isisomorphic ( G :: GrpAbFinGen , H :: GrpAbFinGen ) -> Bool Checks if G and H are isomorphic. source julia> G = free_abelian_group ( 2 ) GrpAb: Z^2 julia> h = hom ( G , G , [ gen ( G , 2 ), 3 * gen ( G , 1 )]) Map with following data Domain: ======= Abelian group with structure: Z^2 Codomain: ========= Abelian group with structure: Z^2 julia> h ( gen ( G , 1 )) Element of GrpAb: Z^2 with components [0 1] julia> h ( gen ( G , 2 )) Element of GrpAb: Z^2 with components [3 0] Homomorphisms also allow addition and subtraction corresponding to the pointwise operation: julia> G = free_abelian_group ( 2 ) GrpAb: Z^2 julia> h = hom ( G , G , [ 2 * gen ( G , 2 ), 3 * gen ( G , 1 )]) Map with following data Domain: ======= Abelian group with structure: Z^2 Codomain: ========= Abelian group with structure: Z^2 julia> ( h + h )( gen ( G , 1 )) Element of GrpAb: Z^2 with components [0 4]","title":"Maps"},{"location":"abelian/structural/","text":"Structural Computations Abelian groups support a wide range of structural operations such as enumeration of subgroups (outer) direct products tensor and hom constructions free resolutions and general complexes (co)-homology and tensor and hom -functors # snf \u2014 Method . snf ( A :: GrpAbFinGen ) -> GrpAbFinGen , Map Returns a pair (G, f) , where G is an abelian group in canonical Smith normal form isomorphic to G and an isomorphism f : G \\to A . source # find_isomorphism \u2014 Method . find_isomorphism ( G , op , A :: GrpAb ) -> Dict , Dict Given an abelian group A and a collection G which is an abelian group with the operation op , this functions returns isomorphisms G \\to A and A \\to G encoded as dictionaries. It is assumed that G and A are isomorphic. source Subgroups and Quotients # torsion_subgroup \u2014 Method . torsion_subgroup ( G :: GrpAbFinGen ) -> GrpAbFinGen , Map Returns the torsion subgroup of G . source # sub \u2014 Method . sub ( G :: GrpAbFinGen , s :: Vector { GrpAbFinGenElem }) -> GrpAbFinGen , Map Create the subgroup H of G generated by the elements in s together with the injection \\iota : H \\to G . source # sub \u2014 Method . sub ( s :: Vector { GrpAbFinGenElem }) -> GrpAbFinGen , Map Assuming that the non-empty array s contains elements of an abelian group G , this functions returns the subgroup H of G generated by the elements in s together with the injection \\iota : H \\to G . source sub ( A :: SMat , r :: UnitRange , c :: UnitRange ) -> SMat Return the submatrix of A , where the rows correspond to r and the columns correspond to c . source # sub \u2014 Method . sub ( G :: GrpAbFinGen , M :: fmpz_mat ) -> GrpAbFinGen , Map Create the subgroup H of G generated by the elements corresponding to the rows of M together with the injection \\iota : H \\to G . source # sub \u2014 Method . sub ( G :: GrpAbFinGen , n :: fmpz ) -> GrpAbFinGen , Map Create the subgroup n \\cdot G of G together with the injection \\iota : n\\cdot G \\to G . source # sub \u2014 Method . sub ( G :: GrpAbFinGen , n :: Integer ) -> GrpAbFinGen , Map Create the subgroup n \\cdot G of G together with the injection \\iota : n \\cdot G \\to G . source # psylow_subgroup \u2014 Method . psylow_subgroup ( G :: GrpAbFinGen , p :: IntegerUnion ) -> GrpAbFinGen , Map Returns the p -Sylow subgroup of G . source # has_quotient \u2014 Method . has_quotient ( G :: GrpAbFinGen , invariant :: Vector { Int }) -> Bool Given an abelian group G , returns true if it has a quotient with given elementary divisors and false otherwise. source # has_complement \u2014 Method . has_complement ( f :: GrpAbFinGenMap ) -> Bool , GrpAbFinGenMap Given a map representing a subgroup of a group G , returns either true and an injection of a complement in G , or false. source A sophisticated algorithm for the enumeration of all (or selected) subgroups of a finite abelian group is available. # psubgroups \u2014 Method . psubgroups ( g :: GrpAbFinGen , p :: Integer ; subtype = :all , quotype = :all , index = - 1 , order = - 1 ) Return an iterator for the subgroups of G of the specific form. Note that subtype (and quotype ) is the type of the subgroup as an abelian p -group. source julia> G = abelian_group ([ 6 , 12 ]) GrpAb: Z/6 x Z/12 julia> shapes = MSet { Vector { fmpz }}() MSet{Vector{fmpz}}() julia> for U = psubgroups ( G , 2 ) push! ( shapes , elementary_divisors ( U [ 1 ])) end julia> shapes MSet(fmpz[2, 4], fmpz[2, 2], fmpz[2] : 3, fmpz[1], fmpz[4] : 2) So there are 2 subgroups isomorphic to C_4 ( fmpz[4] : 2 ), 1 isomorphic to C_2\\times C_4 , 1 trivial and 3 C_2 subgroups. # subgroups \u2014 Method . subgroups ( g :: GrpAbFinGen ; subtype = :all , quotype = :all , index = - 1 , order = - 1 ) Return an iterator for the subgroups of G of the specific form. source julia> for U = subgroups ( G , subtype = [ 2 ]) @show U [ 1 ], map ( U [ 2 ], gens ( U [ 1 ])) end (U[1], map(U[2], gens(U[1]))) = (GrpAb: Z/2, GrpAbFinGenElem[Element of GrpAb: Z/6 x Z/12 with components [0 6]]) (U[1], map(U[2], gens(U[1]))) = (GrpAb: Z/2, GrpAbFinGenElem[Element of GrpAb: Z/6 x Z/12 with components [3 6]]) (U[1], map(U[2], gens(U[1]))) = (GrpAb: Z/2, GrpAbFinGenElem[Element of GrpAb: Z/6 x Z/12 with components [3 0]]) julia> for U = subgroups ( G , quotype = [ 2 ]) @show U [ 1 ], map ( U [ 2 ], gens ( U [ 1 ])) end (U[1], map(U[2], gens(U[1]))) = ((General) abelian group with relation matrix [4 0 0; 0 3 0; 0 0 3], GrpAbFinGenElem[Element of GrpAb: Z/6 x Z/12 with components [3 3], Element of GrpAb: Z/6 x Z/12 with components [0 4], Element of GrpAb: Z/6 x Z/12 with components [2 0]]) (U[1], map(U[2], gens(U[1]))) = ((General) abelian group with relation matrix [4 0 0; 0 3 0; 0 0 3], GrpAbFinGenElem[Element of GrpAb: Z/6 x Z/12 with components [0 3], Element of GrpAb: Z/6 x Z/12 with components [0 4], Element of GrpAb: Z/6 x Z/12 with components [2 0]]) (U[1], map(U[2], gens(U[1]))) = ((General) abelian group with relation matrix [2 0 0 0; 0 2 0 0; 0 0 3 0; 0 0 0 3], GrpAbFinGenElem[Element of GrpAb: Z/6 x Z/12 with components [3 6], Element of GrpAb: Z/6 x Z/12 with components [0 6], Element of GrpAb: Z/6 x Z/12 with components [0 4], Element of GrpAb: Z/6 x Z/12 with components [2 0]]) # quo \u2014 Method . quo ( G :: GrpAbFinGen , s :: Vector { GrpAbFinGenElem }) -> GrpAbFinGen , Map Create the quotient H of G by the subgroup generated by the elements in s , together with the projection p : G \\to H . source # quo \u2014 Method . quo ( G :: GrpAbFinGen , M :: fmpz_mat ) -> GrpAbFinGen , Map Create the quotient H of G by the subgroup generated by the elements corresponding to the rows of M , together with the projection p : G \\to H . source # quo \u2014 Method . quo ( G :: GrpAbFinGen , n :: Integer } ) -> GrpAbFinGen , Map quo ( G :: GrpAbFinGen , n :: fmpz } ) -> GrpAbFinGen , Map Returns the quotient H = G/nG together with the projection p : G \\to H . source # quo \u2014 Method . quo ( G :: GrpAbFinGen , n :: Integer } ) -> GrpAbFinGen , Map quo ( G :: GrpAbFinGen , n :: fmpz } ) -> GrpAbFinGen , Map Returns the quotient H = G/nG together with the projection p : G \\to H . source # quo \u2014 Method . quo ( G :: GrpAbFinGen , U :: GrpAbFinGen ) -> GrpAbFinGen , Map Create the quotient H of G by U , together with the projection p : G \\to H . source For 2 subgroups U and V of the same group G , U+V returns the smallest subgroup of G containing both. Similarly, U\\cap V computes the intersection and U \\subset V tests for inclusion. The difference between issubset = \\subset and issubgroup is that the inclusion map is also returned in the 2nd call. # intersect \u2014 Method . intersect ( mG :: GrpAbFinGenMap , mH :: GrpAbFinGenMap ) -> GrpAbFinGen , Map Given two injective maps of abelian groups with the same codomain G , return the intersection of the images as a subgroup of G . source Direct Products # direct_product \u2014 Method . direct_product ( G :: GrpAbFinGen ... ; task :: Symbol = :sum ) -> GrpAbFinGen , GrpAbFinGenMap , GrpAbFinGenMap Returns the direct product D of the abelian groups G_i . task can be \":sum\", \":prod\", \":both\" or \":none\" and determines which canonical maps are computed as well: \":sum\" for the injections, \":prod\" for the projections. source # canonical_injection \u2014 Method . canonical_injection ( G :: GrpAbFinGen , i :: Int ) -> Map Given a group G that was created as a direct product, return the injection from the i th component. source # canonical_projection \u2014 Method . canonical_projection ( G :: GrpAbFinGen , i :: Int ) -> Map Given a group G that was created as a direct product, return the projection onto the i th component. source # flat \u2014 Method . flat ( G :: GrpAbFinGen ) -> GrpAbFinGen , Map Given a group G that is created using (iterated) direct products, or (iterated) tensor product, return a group that is a flat product: (A \\oplus B) \\oplus C is returned as A \\oplus B \\oplus C , (resp. \\otimes ) together with the isomorphism. source Tensor Producs # tensor_product \u2014 Method . tensor_product ( G :: GrpAbFinGen ... ; task :: Symbol = :map ) -> GrpAbFinGen , Map Given groups G_i , compute the tensor product G_1\\otimes \\cdots \\otimes G_n . If task is set to \":map\", a map \\phi is returned that maps tuples in G_1 \\times \\cdots \\times G_n to pure tensors g_1 \\otimes \\cdots \\otimes g_n . The map admits a preimage as well. source <a id='hom-Tuple{GrpAbFinGen, GrpAbFinGen, Vector{var\"#s5\"} where var\"#s5\"<:(Map{GrpAbFinGen, GrpAbFinGen, S, T} where {S, T})}' href='#hom-Tuple{GrpAbFinGen, GrpAbFinGen, Vector{var\"#s5\"} where var\"#s5\"<:(Map{GrpAbFinGen, GrpAbFinGen, S, T} where {S, T})}'># hom \u2014 Method . hom ( G :: GrpAbFinGen , H :: GrpAbFinGen , A :: Vector { <: Map { GrpAbFinGen , GrpAbFinGen }}) -> Map Given groups G = G_1 \\otimes \\cdots \\otimes G_n and H = H_1 \\otimes \\cdot \\otimes H_n as well as maps \\phi_i: G_i\\to H_i , compute the tensor product of the maps. source Hom-Group # hom \u2014 Method . hom ( G :: GrpAbFinGen , H :: GrpAbFinGen ; task :: Symbol = :map ) -> GrpAbFinGen , Map Computes the group of all homomorpisms from G to H as an abstract group. If task is \":map\", then a map \\phi is computed that can be used to obtain actual homomorphisms. This map also allows preimages. Set task to \":none\" to not compute the map. source","title":"Structural Computations"},{"location":"abelian/structural/#structural-computations","text":"Abelian groups support a wide range of structural operations such as enumeration of subgroups (outer) direct products tensor and hom constructions free resolutions and general complexes (co)-homology and tensor and hom -functors # snf \u2014 Method . snf ( A :: GrpAbFinGen ) -> GrpAbFinGen , Map Returns a pair (G, f) , where G is an abelian group in canonical Smith normal form isomorphic to G and an isomorphism f : G \\to A . source # find_isomorphism \u2014 Method . find_isomorphism ( G , op , A :: GrpAb ) -> Dict , Dict Given an abelian group A and a collection G which is an abelian group with the operation op , this functions returns isomorphisms G \\to A and A \\to G encoded as dictionaries. It is assumed that G and A are isomorphic. source","title":"Structural Computations"},{"location":"abelian/structural/#subgroups-and-quotients","text":"# torsion_subgroup \u2014 Method . torsion_subgroup ( G :: GrpAbFinGen ) -> GrpAbFinGen , Map Returns the torsion subgroup of G . source # sub \u2014 Method . sub ( G :: GrpAbFinGen , s :: Vector { GrpAbFinGenElem }) -> GrpAbFinGen , Map Create the subgroup H of G generated by the elements in s together with the injection \\iota : H \\to G . source # sub \u2014 Method . sub ( s :: Vector { GrpAbFinGenElem }) -> GrpAbFinGen , Map Assuming that the non-empty array s contains elements of an abelian group G , this functions returns the subgroup H of G generated by the elements in s together with the injection \\iota : H \\to G . source sub ( A :: SMat , r :: UnitRange , c :: UnitRange ) -> SMat Return the submatrix of A , where the rows correspond to r and the columns correspond to c . source # sub \u2014 Method . sub ( G :: GrpAbFinGen , M :: fmpz_mat ) -> GrpAbFinGen , Map Create the subgroup H of G generated by the elements corresponding to the rows of M together with the injection \\iota : H \\to G . source # sub \u2014 Method . sub ( G :: GrpAbFinGen , n :: fmpz ) -> GrpAbFinGen , Map Create the subgroup n \\cdot G of G together with the injection \\iota : n\\cdot G \\to G . source # sub \u2014 Method . sub ( G :: GrpAbFinGen , n :: Integer ) -> GrpAbFinGen , Map Create the subgroup n \\cdot G of G together with the injection \\iota : n \\cdot G \\to G . source # psylow_subgroup \u2014 Method . psylow_subgroup ( G :: GrpAbFinGen , p :: IntegerUnion ) -> GrpAbFinGen , Map Returns the p -Sylow subgroup of G . source # has_quotient \u2014 Method . has_quotient ( G :: GrpAbFinGen , invariant :: Vector { Int }) -> Bool Given an abelian group G , returns true if it has a quotient with given elementary divisors and false otherwise. source # has_complement \u2014 Method . has_complement ( f :: GrpAbFinGenMap ) -> Bool , GrpAbFinGenMap Given a map representing a subgroup of a group G , returns either true and an injection of a complement in G , or false. source A sophisticated algorithm for the enumeration of all (or selected) subgroups of a finite abelian group is available. # psubgroups \u2014 Method . psubgroups ( g :: GrpAbFinGen , p :: Integer ; subtype = :all , quotype = :all , index = - 1 , order = - 1 ) Return an iterator for the subgroups of G of the specific form. Note that subtype (and quotype ) is the type of the subgroup as an abelian p -group. source julia> G = abelian_group ([ 6 , 12 ]) GrpAb: Z/6 x Z/12 julia> shapes = MSet { Vector { fmpz }}() MSet{Vector{fmpz}}() julia> for U = psubgroups ( G , 2 ) push! ( shapes , elementary_divisors ( U [ 1 ])) end julia> shapes MSet(fmpz[2, 4], fmpz[2, 2], fmpz[2] : 3, fmpz[1], fmpz[4] : 2) So there are 2 subgroups isomorphic to C_4 ( fmpz[4] : 2 ), 1 isomorphic to C_2\\times C_4 , 1 trivial and 3 C_2 subgroups. # subgroups \u2014 Method . subgroups ( g :: GrpAbFinGen ; subtype = :all , quotype = :all , index = - 1 , order = - 1 ) Return an iterator for the subgroups of G of the specific form. source julia> for U = subgroups ( G , subtype = [ 2 ]) @show U [ 1 ], map ( U [ 2 ], gens ( U [ 1 ])) end (U[1], map(U[2], gens(U[1]))) = (GrpAb: Z/2, GrpAbFinGenElem[Element of GrpAb: Z/6 x Z/12 with components [0 6]]) (U[1], map(U[2], gens(U[1]))) = (GrpAb: Z/2, GrpAbFinGenElem[Element of GrpAb: Z/6 x Z/12 with components [3 6]]) (U[1], map(U[2], gens(U[1]))) = (GrpAb: Z/2, GrpAbFinGenElem[Element of GrpAb: Z/6 x Z/12 with components [3 0]]) julia> for U = subgroups ( G , quotype = [ 2 ]) @show U [ 1 ], map ( U [ 2 ], gens ( U [ 1 ])) end (U[1], map(U[2], gens(U[1]))) = ((General) abelian group with relation matrix [4 0 0; 0 3 0; 0 0 3], GrpAbFinGenElem[Element of GrpAb: Z/6 x Z/12 with components [3 3], Element of GrpAb: Z/6 x Z/12 with components [0 4], Element of GrpAb: Z/6 x Z/12 with components [2 0]]) (U[1], map(U[2], gens(U[1]))) = ((General) abelian group with relation matrix [4 0 0; 0 3 0; 0 0 3], GrpAbFinGenElem[Element of GrpAb: Z/6 x Z/12 with components [0 3], Element of GrpAb: Z/6 x Z/12 with components [0 4], Element of GrpAb: Z/6 x Z/12 with components [2 0]]) (U[1], map(U[2], gens(U[1]))) = ((General) abelian group with relation matrix [2 0 0 0; 0 2 0 0; 0 0 3 0; 0 0 0 3], GrpAbFinGenElem[Element of GrpAb: Z/6 x Z/12 with components [3 6], Element of GrpAb: Z/6 x Z/12 with components [0 6], Element of GrpAb: Z/6 x Z/12 with components [0 4], Element of GrpAb: Z/6 x Z/12 with components [2 0]]) # quo \u2014 Method . quo ( G :: GrpAbFinGen , s :: Vector { GrpAbFinGenElem }) -> GrpAbFinGen , Map Create the quotient H of G by the subgroup generated by the elements in s , together with the projection p : G \\to H . source # quo \u2014 Method . quo ( G :: GrpAbFinGen , M :: fmpz_mat ) -> GrpAbFinGen , Map Create the quotient H of G by the subgroup generated by the elements corresponding to the rows of M , together with the projection p : G \\to H . source # quo \u2014 Method . quo ( G :: GrpAbFinGen , n :: Integer } ) -> GrpAbFinGen , Map quo ( G :: GrpAbFinGen , n :: fmpz } ) -> GrpAbFinGen , Map Returns the quotient H = G/nG together with the projection p : G \\to H . source # quo \u2014 Method . quo ( G :: GrpAbFinGen , n :: Integer } ) -> GrpAbFinGen , Map quo ( G :: GrpAbFinGen , n :: fmpz } ) -> GrpAbFinGen , Map Returns the quotient H = G/nG together with the projection p : G \\to H . source # quo \u2014 Method . quo ( G :: GrpAbFinGen , U :: GrpAbFinGen ) -> GrpAbFinGen , Map Create the quotient H of G by U , together with the projection p : G \\to H . source For 2 subgroups U and V of the same group G , U+V returns the smallest subgroup of G containing both. Similarly, U\\cap V computes the intersection and U \\subset V tests for inclusion. The difference between issubset = \\subset and issubgroup is that the inclusion map is also returned in the 2nd call. # intersect \u2014 Method . intersect ( mG :: GrpAbFinGenMap , mH :: GrpAbFinGenMap ) -> GrpAbFinGen , Map Given two injective maps of abelian groups with the same codomain G , return the intersection of the images as a subgroup of G . source","title":"Subgroups and Quotients"},{"location":"abelian/structural/#direct-products","text":"# direct_product \u2014 Method . direct_product ( G :: GrpAbFinGen ... ; task :: Symbol = :sum ) -> GrpAbFinGen , GrpAbFinGenMap , GrpAbFinGenMap Returns the direct product D of the abelian groups G_i . task can be \":sum\", \":prod\", \":both\" or \":none\" and determines which canonical maps are computed as well: \":sum\" for the injections, \":prod\" for the projections. source # canonical_injection \u2014 Method . canonical_injection ( G :: GrpAbFinGen , i :: Int ) -> Map Given a group G that was created as a direct product, return the injection from the i th component. source # canonical_projection \u2014 Method . canonical_projection ( G :: GrpAbFinGen , i :: Int ) -> Map Given a group G that was created as a direct product, return the projection onto the i th component. source # flat \u2014 Method . flat ( G :: GrpAbFinGen ) -> GrpAbFinGen , Map Given a group G that is created using (iterated) direct products, or (iterated) tensor product, return a group that is a flat product: (A \\oplus B) \\oplus C is returned as A \\oplus B \\oplus C , (resp. \\otimes ) together with the isomorphism. source","title":"Direct Products"},{"location":"abelian/structural/#tensor-producs","text":"# tensor_product \u2014 Method . tensor_product ( G :: GrpAbFinGen ... ; task :: Symbol = :map ) -> GrpAbFinGen , Map Given groups G_i , compute the tensor product G_1\\otimes \\cdots \\otimes G_n . If task is set to \":map\", a map \\phi is returned that maps tuples in G_1 \\times \\cdots \\times G_n to pure tensors g_1 \\otimes \\cdots \\otimes g_n . The map admits a preimage as well. source <a id='hom-Tuple{GrpAbFinGen, GrpAbFinGen, Vector{var\"#s5\"} where var\"#s5\"<:(Map{GrpAbFinGen, GrpAbFinGen, S, T} where {S, T})}' href='#hom-Tuple{GrpAbFinGen, GrpAbFinGen, Vector{var\"#s5\"} where var\"#s5\"<:(Map{GrpAbFinGen, GrpAbFinGen, S, T} where {S, T})}'># hom \u2014 Method . hom ( G :: GrpAbFinGen , H :: GrpAbFinGen , A :: Vector { <: Map { GrpAbFinGen , GrpAbFinGen }}) -> Map Given groups G = G_1 \\otimes \\cdots \\otimes G_n and H = H_1 \\otimes \\cdot \\otimes H_n as well as maps \\phi_i: G_i\\to H_i , compute the tensor product of the maps. source","title":"Tensor Producs"},{"location":"abelian/structural/#hom-group","text":"# hom \u2014 Method . hom ( G :: GrpAbFinGen , H :: GrpAbFinGen ; task :: Symbol = :map ) -> GrpAbFinGen , Map Computes the group of all homomorpisms from G to H as an abstract group. If task is \":map\", then a map \\phi is computed that can be used to obtain actual homomorphisms. This map also allows preimages. Set task to \":none\" to not compute the map. source","title":"Hom-Group"},{"location":"class_fields/intro/","text":"Class Field Theory Introduction This chapter deals with abelian extensions of number fields and the rational numbers. Class Field Theory, here specifically, class field theory of global number fields, deals with abelian extension, ie. fields where the group of automorphisms is abelian. For extensions of {\\Q}, the famous Kronnecker-Weber theorem classifies all such fields: a field is abelian if and only if it is contained in some cyclotomic field. For general number fields this is more involved and even for extensions of {\\Q} is is not practical. In Hecke, abelian extensions are parametrized by quotients of so called ray class groups. The language of ray class groups while dated is more applicable to algorithms than the modern language of idel class groups and quotients. Ray Class Groups Given an integral ideal m_0 \\le Z_K and a list of real places m_\\infty , the ray class group modulo (m_0, m_\\infty) , C(m) is defined as the group of ideals coprime to m_0 modulo the elements a\\in K^* s.th. v_p(a-1) \\ge v_p(m_0) and for all v\\in m_\\infty , a^{(v)} >0 . This is a finite abelian group. For m_0 = Z_K and m_\\infty = \\{\\} we get C() is the class group, if m_\\infty contains all real places, we obtain the narrow class group, or strict class group. # ray_class_group \u2014 Method . ray_class_group ( m :: NfOrdIdl , inf_plc :: Vector { InfPlc }; n_quo :: Int , lp :: Dict { NfOrdIdl , Int }) -> GrpAbFinGen , MapRayClassGrp Given an ideal m and a set of infinite places of K , this function returns the corresponding ray class group as an abstract group \\mathcal {Cl}_m and a map going from the group into the group of ideals of K that are coprime to m . If n_quo is set, it will return the group modulo n_quo . The factorization of m can be given with the keyword argument lp . source # class_group \u2014 Method . class_group ( K :: AnticNumberField ) -> GrpAbFinGen , Map Shortcut for class_group(maximal_order(K)) : returns the class group as an abelian group and a map from this group to the set of ideals of the maximal order. source # norm_group \u2014 Method . norm_group ( f :: Nemo . PolyElem , mR :: Hecke . MapRayClassGrp , isabelian :: Bool = true ; of_closure :: Bool = false ) -> Hecke . FinGenGrpAb , Hecke . FinGenGrpAbMap norm_group ( f :: Array { PolyElem { nf_elem }}, mR :: Hecke . MapRayClassGrp , isabelian :: Bool = true ; of_closure :: Bool = false ) -> Hecke . FinGenGrpAb , Hecke . FinGenGrpAbMap Computes the subgroup of the Ray Class Group R given by the norm of the extension generated by a/the roots of f . If isabelian is set to true, then the code assumes the field to be abelian, hence the algorithm stops when the quotient by the norm group has the correct order. Even though the algorithm is probabilistic by nature, in this case the result is guaranteed. If of_closure is given, then the norm group of the splitting field of the polynomial(s) is computed. It is the callers responsibility to ensure that the ray class group passed in is large enough. source # norm_group \u2014 Method . norm_group ( K :: NfRel { nf_elem }, mR :: Hecke . MapRayClassGrp ) -> Hecke . FinGenGrpAb , Hecke . FinGenGrpAbMap norm_group ( K :: NfRelNS { nf_elem }, mR :: Hecke . MapRayClassGrp ) -> Hecke . FinGenGrpAb , Hecke . FinGenGrpAbMap Computes the subgroup of the Ray Class Group R given by the norm of the extension. source Ray Class Fields In general, the construction of a class field starts with a (ray) class group. Each quotient of a ray class group then defines a ray class field, the defining property is that the (relative) automorphism group is canonically isomorphic to the quotient of the ray class group where the isomorphism is given by the Artin (or Frobenius) map. Since, in Hecke, the (ray) class groups have no link to the field, actually this has to be specified using the maps. It should be noted that this is a {\\em lazy} construction: nothing is computed at this point. # ray_class_field \u2014 Method . ray_class_field ( m :: MapClassGrp ) -> ClassField ray_class_field ( m :: MapRayClassGrp ) -> ClassField Creates the (formal) abelian extension defined by the map m: A \\to I where I is the set of ideals coprime to the modulus defining m and A is a quotient of the ray class group (or class group). The map m must be the map returned from a call to {class group} or {ray class_group}. source # ray_class_field \u2014 Method . ray_class_field ( m :: Union { MapClassGrp , MapRayClassGrp }, quomap :: GrpAbFinGenMap ) -> ClassField For m a map computed by either {ray class group} or {class_group} and q a canonical projection (quotient map) as returned by {quo} for q quotient of the domain of m and a subgroup of m , create the (formal) abelian extension where the (relative) automorphism group is canonically isomorphic to the codomain of q . source # ray_class_field \u2014 Method . ray_class_field ( I :: NfAbsOrdIdl ; n_quo = 0 ) -> ClassField The ray class field modulo I . If n_quo is given, then the largest subfield of exponent n is computed. source # ray_class_field \u2014 Method . ray_class_field ( I :: NfAbsOrdIdl , inf :: Vector { InfPlc }; n_quo = 0 ) -> ClassField The ray class field modulo I and the infinite places given. If n_quo is given, then the largest subfield of exponent n is computed. source # hilbert_class_field \u2014 Method . hilbert_class_field ( k :: AnticNumberField ) -> ClassField The Hilbert class field of k as a formal (ray-) class field. source # ring_class_field \u2014 Method . ring_class_field ( O :: NfAbsOrd ) -> ClassField The ring class field of O , i.e. the maximal abelian extension ramified only at primes dividing the conductor with the automorphism group isomorphic to the Picard group. source Example julia> Qx , x = PolynomialRing ( FlintQQ , \"x\" ); julia> K , a = NumberField ( x ^ 2 - 10 , \"a\" ); julia> c , mc = class_group ( K ) (GrpAb: Z/2, ClassGroup map of Set of ideals of Maximal order of Number field over Rational Field with defining polynomial x^2 - 10 with basis nf_elem[1, a] ) julia> A = ray_class_field ( mc ) Class field defined mod (<1, 1>, InfPlc[]) of structure Abelian group with structure: Z/2 Conversions Given a ray class field, it is possible to actually compute defining equation(s) for this field. In general, the number field constructed this way will be non-simple by type and is defined by a polynomial for each maximal cyclic quotient of prime power order in the defining group. The algorithm employed is based on Kummer-theory and requires the addition of a suitable root of unity. Progress can be monitored by setting {{{set verbose level(:ClassField, n)}}} where 0\\le n\\le 3 # number_field \u2014 Method . NumberField ( CF :: ClassField ) -> NfRelNS { nf_elem } Given a (formal) abelian extension, compute the class field by finding defining polynomials for all prime power cyclic subfields. Note, the return type is always a non-simple extension. source julia> Qx , x = PolynomialRing ( FlintQQ , \"x\" ); julia> k , a = NumberField ( x ^ 2 - 10 , \"a\" ); julia> c , mc = class_group ( k ); julia> A = ray_class_field ( mc ) Class field defined mod (<1, 1>, InfPlc[]) of structure Abelian group with structure: Z/2 julia> K = number_field ( A ) non-simple Relative number field with defining polynomials AbstractAlgebra.Generic.MPoly{nf_elem}[_$1^2 - 2] over Number field over Rational Field with defining polynomial x^2 - 10 julia> ZK = maximal_order ( K ) Relative maximal order of non-simple Relative number field with defining polynomials AbstractAlgebra.Generic.MPoly{nf_elem}[_$1^2 - 2] over Number field over Rational Field with defining polynomial x^2 - 10 with pseudo-basis (1, 1//1 * <1, 1>) (_$1 + a, 1//4 * <2, a>) julia> isone ( discriminant ( ZK )) true # ray_class_field \u2014 Method . ray_class_field ( K :: NfRel { nf_elem }) -> ClassField For a (relative) abelian extension, compute an abstract representation as a class field. source # genus_field \u2014 Method . genus_field ( A :: ClassField , k :: AnticNumberField ) -> ClassField The maximal extension contained in A that is the compositum of K with an abelian extension of k . source # maximal_abelian_subfield \u2014 Method . maximal_abelian_subfield ( A :: ClassField , k :: AnticNumberField ) -> ClassField The maximal abelian extension of k contained in A . k must be a subfield of the base field of A . source # maximal_abelian_subfield \u2014 Method . maximal_abelian_subfield ( K :: NfRel { nf_elem }; of_closure :: Bool = false ) -> ClassField Using a probabilistic algorithm for the norm group computation, determine the maximal abelian subfield in K over its base field. If of_closure is set to true, then the algorithm is applied to the normal closure of K (without computing it). source Invariants # degree \u2014 Method . degree ( A :: ClassField ) The degree of A over its base field, i.e. the size of the defining ideal group. source # base_ring \u2014 Method . base_ring ( A :: ClassField ) The maximal order of the field that A is defined over. source # base_field \u2014 Method . base_field ( A :: ClassField ) The number field that A is defined over. source # discriminant \u2014 Method . discriminant ( C :: ClassField ) -> NfOrdIdl Using the conductor-discriminant formula, compute the (relative) discriminant of C . This does not use the defining equations. source # conductor \u2014 Method . conductor ( C :: ClassField ) -> NfOrdIdl , Vector { InfPlc } Return the conductor of the abelian extension corresponding to C . source # defining_modulus \u2014 Method . defining_modulus ( CF :: ClassField ) The modulus, i.e. an ideal of the set of real places, used to create the class field. source # iscyclic \u2014 Method . iscyclic ( C :: ClassField ) Tests if the (relative) automorphism group of C is cyclic (by checking the defining ideal group). source # isconductor \u2014 Method . isconductor ( C :: Hecke . ClassField , m :: NfOrdIdl , inf_plc :: Vector { InfPlc } = InfPlc []; check ) -> NfOrdIdl , Vector { InfPlc } Checks if (m, inf_plc) is the conductor of the abelian extension corresponding to C . If check is false , it assumes that the given modulus is a multiple of the conductor. This is usually faster than computing the conductor. source # isnormal \u2014 Method . isnormal ( C :: ClassField ) -> Bool For a class field C defined over a normal base field k , decide if C is normal over Q . source # iscentral \u2014 Method . iscentral ( C :: ClassField ) -> Bool For a class field C defined over a normal base field k , decide if C is central over Q . source Operations # * \u2014 Method . * ( A :: ClassField , B :: ClassField ) -> ClassField The compositum of a and b as a (formal) class field. source # compositum \u2014 Method . compositum ( a :: ClassField , b :: ClassField ) -> ClassField The compositum of a and b as a (formal) class field. source # == \u2014 Method . == ( a :: ClassField , b :: ClassField ) Tests if a and b are equal. source # intersect \u2014 Method . intersect ( a :: ClassField , b :: ClassField ) -> ClassField The intersection of a and b as a class field. source # prime_decomposition_type \u2014 Method . prime_decomposition_type ( C :: ClassField , p :: NfAbsOrdIdl ) -> ( Int , Int , Int ) For a prime p in the base ring of r , determine the splitting type of p in r . ie. the tuple (e, f, g) giving the ramification degree, the inertia and the number of primes above p . source # issubfield \u2014 Method . issubfield ( a :: ClassField , b :: ClassField ) -> Bool Determines if a is a subfield of b . source # islocal_norm \u2014 Method . islocal_norm ( r :: ClassField , a :: NfAbsOrdElem ) -> Bool Tests if a is a local norm at all finite places in the extension implictly given by r . source # islocal_norm \u2014 Method . islocal_norm ( r :: ClassField , a :: NfAbsOrdElem , p :: NfAbsOrdIdl ) -> Bool Tests if a is a local norm at p in the extension implictly given by r . Currently the conductor cannot have infinite places. source # normal_closure \u2014 Method . normal_closure ( C :: ClassField ) -> ClassField For a ray class field C extending a normal base field k , compute the normal closure over Q . source # subfields \u2014 Method . subfields ( C :: ClassField ) -> Vector { ClassField } Find all subfields of C as class fields. Note: this will not find all subfields over Q , but only the ones sharing the same base field. source # subfields \u2014 Method . subfields ( C :: ClassField , d :: Int ) -> Vector { ClassField } Find all subfields of C of degree d as class fields. Note: this will not find all subfields over Q , but only the ones sharing the same base field. source","title":"Introduction"},{"location":"class_fields/intro/#class-field-theory","text":"","title":"Class Field Theory"},{"location":"class_fields/intro/#introduction","text":"This chapter deals with abelian extensions of number fields and the rational numbers. Class Field Theory, here specifically, class field theory of global number fields, deals with abelian extension, ie. fields where the group of automorphisms is abelian. For extensions of {\\Q}, the famous Kronnecker-Weber theorem classifies all such fields: a field is abelian if and only if it is contained in some cyclotomic field. For general number fields this is more involved and even for extensions of {\\Q} is is not practical. In Hecke, abelian extensions are parametrized by quotients of so called ray class groups. The language of ray class groups while dated is more applicable to algorithms than the modern language of idel class groups and quotients.","title":"Introduction"},{"location":"class_fields/intro/#ray-class-groups","text":"Given an integral ideal m_0 \\le Z_K and a list of real places m_\\infty , the ray class group modulo (m_0, m_\\infty) , C(m) is defined as the group of ideals coprime to m_0 modulo the elements a\\in K^* s.th. v_p(a-1) \\ge v_p(m_0) and for all v\\in m_\\infty , a^{(v)} >0 . This is a finite abelian group. For m_0 = Z_K and m_\\infty = \\{\\} we get C() is the class group, if m_\\infty contains all real places, we obtain the narrow class group, or strict class group. # ray_class_group \u2014 Method . ray_class_group ( m :: NfOrdIdl , inf_plc :: Vector { InfPlc }; n_quo :: Int , lp :: Dict { NfOrdIdl , Int }) -> GrpAbFinGen , MapRayClassGrp Given an ideal m and a set of infinite places of K , this function returns the corresponding ray class group as an abstract group \\mathcal {Cl}_m and a map going from the group into the group of ideals of K that are coprime to m . If n_quo is set, it will return the group modulo n_quo . The factorization of m can be given with the keyword argument lp . source # class_group \u2014 Method . class_group ( K :: AnticNumberField ) -> GrpAbFinGen , Map Shortcut for class_group(maximal_order(K)) : returns the class group as an abelian group and a map from this group to the set of ideals of the maximal order. source # norm_group \u2014 Method . norm_group ( f :: Nemo . PolyElem , mR :: Hecke . MapRayClassGrp , isabelian :: Bool = true ; of_closure :: Bool = false ) -> Hecke . FinGenGrpAb , Hecke . FinGenGrpAbMap norm_group ( f :: Array { PolyElem { nf_elem }}, mR :: Hecke . MapRayClassGrp , isabelian :: Bool = true ; of_closure :: Bool = false ) -> Hecke . FinGenGrpAb , Hecke . FinGenGrpAbMap Computes the subgroup of the Ray Class Group R given by the norm of the extension generated by a/the roots of f . If isabelian is set to true, then the code assumes the field to be abelian, hence the algorithm stops when the quotient by the norm group has the correct order. Even though the algorithm is probabilistic by nature, in this case the result is guaranteed. If of_closure is given, then the norm group of the splitting field of the polynomial(s) is computed. It is the callers responsibility to ensure that the ray class group passed in is large enough. source # norm_group \u2014 Method . norm_group ( K :: NfRel { nf_elem }, mR :: Hecke . MapRayClassGrp ) -> Hecke . FinGenGrpAb , Hecke . FinGenGrpAbMap norm_group ( K :: NfRelNS { nf_elem }, mR :: Hecke . MapRayClassGrp ) -> Hecke . FinGenGrpAb , Hecke . FinGenGrpAbMap Computes the subgroup of the Ray Class Group R given by the norm of the extension. source","title":"Ray Class Groups"},{"location":"class_fields/intro/#ray-class-fields","text":"In general, the construction of a class field starts with a (ray) class group. Each quotient of a ray class group then defines a ray class field, the defining property is that the (relative) automorphism group is canonically isomorphic to the quotient of the ray class group where the isomorphism is given by the Artin (or Frobenius) map. Since, in Hecke, the (ray) class groups have no link to the field, actually this has to be specified using the maps. It should be noted that this is a {\\em lazy} construction: nothing is computed at this point. # ray_class_field \u2014 Method . ray_class_field ( m :: MapClassGrp ) -> ClassField ray_class_field ( m :: MapRayClassGrp ) -> ClassField Creates the (formal) abelian extension defined by the map m: A \\to I where I is the set of ideals coprime to the modulus defining m and A is a quotient of the ray class group (or class group). The map m must be the map returned from a call to {class group} or {ray class_group}. source # ray_class_field \u2014 Method . ray_class_field ( m :: Union { MapClassGrp , MapRayClassGrp }, quomap :: GrpAbFinGenMap ) -> ClassField For m a map computed by either {ray class group} or {class_group} and q a canonical projection (quotient map) as returned by {quo} for q quotient of the domain of m and a subgroup of m , create the (formal) abelian extension where the (relative) automorphism group is canonically isomorphic to the codomain of q . source # ray_class_field \u2014 Method . ray_class_field ( I :: NfAbsOrdIdl ; n_quo = 0 ) -> ClassField The ray class field modulo I . If n_quo is given, then the largest subfield of exponent n is computed. source # ray_class_field \u2014 Method . ray_class_field ( I :: NfAbsOrdIdl , inf :: Vector { InfPlc }; n_quo = 0 ) -> ClassField The ray class field modulo I and the infinite places given. If n_quo is given, then the largest subfield of exponent n is computed. source # hilbert_class_field \u2014 Method . hilbert_class_field ( k :: AnticNumberField ) -> ClassField The Hilbert class field of k as a formal (ray-) class field. source # ring_class_field \u2014 Method . ring_class_field ( O :: NfAbsOrd ) -> ClassField The ring class field of O , i.e. the maximal abelian extension ramified only at primes dividing the conductor with the automorphism group isomorphic to the Picard group. source","title":"Ray Class Fields"},{"location":"class_fields/intro/#example","text":"julia> Qx , x = PolynomialRing ( FlintQQ , \"x\" ); julia> K , a = NumberField ( x ^ 2 - 10 , \"a\" ); julia> c , mc = class_group ( K ) (GrpAb: Z/2, ClassGroup map of Set of ideals of Maximal order of Number field over Rational Field with defining polynomial x^2 - 10 with basis nf_elem[1, a] ) julia> A = ray_class_field ( mc ) Class field defined mod (<1, 1>, InfPlc[]) of structure Abelian group with structure: Z/2","title":"Example"},{"location":"class_fields/intro/#conversions","text":"Given a ray class field, it is possible to actually compute defining equation(s) for this field. In general, the number field constructed this way will be non-simple by type and is defined by a polynomial for each maximal cyclic quotient of prime power order in the defining group. The algorithm employed is based on Kummer-theory and requires the addition of a suitable root of unity. Progress can be monitored by setting {{{set verbose level(:ClassField, n)}}} where 0\\le n\\le 3 # number_field \u2014 Method . NumberField ( CF :: ClassField ) -> NfRelNS { nf_elem } Given a (formal) abelian extension, compute the class field by finding defining polynomials for all prime power cyclic subfields. Note, the return type is always a non-simple extension. source julia> Qx , x = PolynomialRing ( FlintQQ , \"x\" ); julia> k , a = NumberField ( x ^ 2 - 10 , \"a\" ); julia> c , mc = class_group ( k ); julia> A = ray_class_field ( mc ) Class field defined mod (<1, 1>, InfPlc[]) of structure Abelian group with structure: Z/2 julia> K = number_field ( A ) non-simple Relative number field with defining polynomials AbstractAlgebra.Generic.MPoly{nf_elem}[_$1^2 - 2] over Number field over Rational Field with defining polynomial x^2 - 10 julia> ZK = maximal_order ( K ) Relative maximal order of non-simple Relative number field with defining polynomials AbstractAlgebra.Generic.MPoly{nf_elem}[_$1^2 - 2] over Number field over Rational Field with defining polynomial x^2 - 10 with pseudo-basis (1, 1//1 * <1, 1>) (_$1 + a, 1//4 * <2, a>) julia> isone ( discriminant ( ZK )) true # ray_class_field \u2014 Method . ray_class_field ( K :: NfRel { nf_elem }) -> ClassField For a (relative) abelian extension, compute an abstract representation as a class field. source # genus_field \u2014 Method . genus_field ( A :: ClassField , k :: AnticNumberField ) -> ClassField The maximal extension contained in A that is the compositum of K with an abelian extension of k . source # maximal_abelian_subfield \u2014 Method . maximal_abelian_subfield ( A :: ClassField , k :: AnticNumberField ) -> ClassField The maximal abelian extension of k contained in A . k must be a subfield of the base field of A . source # maximal_abelian_subfield \u2014 Method . maximal_abelian_subfield ( K :: NfRel { nf_elem }; of_closure :: Bool = false ) -> ClassField Using a probabilistic algorithm for the norm group computation, determine the maximal abelian subfield in K over its base field. If of_closure is set to true, then the algorithm is applied to the normal closure of K (without computing it). source","title":"Conversions"},{"location":"class_fields/intro/#invariants","text":"# degree \u2014 Method . degree ( A :: ClassField ) The degree of A over its base field, i.e. the size of the defining ideal group. source # base_ring \u2014 Method . base_ring ( A :: ClassField ) The maximal order of the field that A is defined over. source # base_field \u2014 Method . base_field ( A :: ClassField ) The number field that A is defined over. source # discriminant \u2014 Method . discriminant ( C :: ClassField ) -> NfOrdIdl Using the conductor-discriminant formula, compute the (relative) discriminant of C . This does not use the defining equations. source # conductor \u2014 Method . conductor ( C :: ClassField ) -> NfOrdIdl , Vector { InfPlc } Return the conductor of the abelian extension corresponding to C . source # defining_modulus \u2014 Method . defining_modulus ( CF :: ClassField ) The modulus, i.e. an ideal of the set of real places, used to create the class field. source # iscyclic \u2014 Method . iscyclic ( C :: ClassField ) Tests if the (relative) automorphism group of C is cyclic (by checking the defining ideal group). source # isconductor \u2014 Method . isconductor ( C :: Hecke . ClassField , m :: NfOrdIdl , inf_plc :: Vector { InfPlc } = InfPlc []; check ) -> NfOrdIdl , Vector { InfPlc } Checks if (m, inf_plc) is the conductor of the abelian extension corresponding to C . If check is false , it assumes that the given modulus is a multiple of the conductor. This is usually faster than computing the conductor. source # isnormal \u2014 Method . isnormal ( C :: ClassField ) -> Bool For a class field C defined over a normal base field k , decide if C is normal over Q . source # iscentral \u2014 Method . iscentral ( C :: ClassField ) -> Bool For a class field C defined over a normal base field k , decide if C is central over Q . source","title":"Invariants"},{"location":"class_fields/intro/#operations","text":"# * \u2014 Method . * ( A :: ClassField , B :: ClassField ) -> ClassField The compositum of a and b as a (formal) class field. source # compositum \u2014 Method . compositum ( a :: ClassField , b :: ClassField ) -> ClassField The compositum of a and b as a (formal) class field. source # == \u2014 Method . == ( a :: ClassField , b :: ClassField ) Tests if a and b are equal. source # intersect \u2014 Method . intersect ( a :: ClassField , b :: ClassField ) -> ClassField The intersection of a and b as a class field. source # prime_decomposition_type \u2014 Method . prime_decomposition_type ( C :: ClassField , p :: NfAbsOrdIdl ) -> ( Int , Int , Int ) For a prime p in the base ring of r , determine the splitting type of p in r . ie. the tuple (e, f, g) giving the ramification degree, the inertia and the number of primes above p . source # issubfield \u2014 Method . issubfield ( a :: ClassField , b :: ClassField ) -> Bool Determines if a is a subfield of b . source # islocal_norm \u2014 Method . islocal_norm ( r :: ClassField , a :: NfAbsOrdElem ) -> Bool Tests if a is a local norm at all finite places in the extension implictly given by r . source # islocal_norm \u2014 Method . islocal_norm ( r :: ClassField , a :: NfAbsOrdElem , p :: NfAbsOrdIdl ) -> Bool Tests if a is a local norm at p in the extension implictly given by r . Currently the conductor cannot have infinite places. source # normal_closure \u2014 Method . normal_closure ( C :: ClassField ) -> ClassField For a ray class field C extending a normal base field k , compute the normal closure over Q . source # subfields \u2014 Method . subfields ( C :: ClassField ) -> Vector { ClassField } Find all subfields of C as class fields. Note: this will not find all subfields over Q , but only the ones sharing the same base field. source # subfields \u2014 Method . subfields ( C :: ClassField , d :: Int ) -> Vector { ClassField } Find all subfields of C of degree d as class fields. Note: this will not find all subfields over Q , but only the ones sharing the same base field. source","title":"Operations"},{"location":"dev/test/","text":"Testing Structure The Hecke tests can be found in Hecke/test/ and are organized in such a way that the file hierarchy mirrors the source directory Hecke/src/ . For example, here is a subset of the src/QuadForm and the test/QuadForm directories: \u251c\u2500\u2500 src \u2502 \u251c\u2500\u2500 QuadForm \u2502 \u2502 \u251c\u2500\u2500 Enumeration.jl \u2502 \u2502 \u251c\u2500\u2500 Herm \u2502 \u2502 \u2502 \u251c\u2500\u2500 Genus.jl \u2502 \u2502 \u251c\u2500\u2500 Quad \u2502 \u2502 \u2502 \u251c\u2500\u2500 Genus.jl \u2502 \u2502 \u2502 \u251c\u2500\u2500 GenusRep.jl \u2502 \u2502 \u2502 \u251c\u2500\u2500 NormalForm.jl \u2502 \u2502 \u2502 \u251c\u2500\u2500 Spaces.jl \u2502 \u2502 \u2502 \u251c\u2500\u2500 Types.jl \u2502 \u2502 \u2502 \u251c\u2500\u2500 ZGenus.jl \u2502 \u2502 \u2502 \u2514\u2500\u2500 ZLattices.jl \u2502 \u2502 \u251c\u2500\u2500 QuadBin.jl \u2502 \u2502 \u251c\u2500\u2500 Torsion.jl \u2502 \u251c\u2500\u2500 QuadForm.jl \u2502 \u2502 \u2502 \u251c\u2500\u2500 test \u2502 \u251c\u2500\u2500 QuadForm \u2502 \u2502 \u251c\u2500\u2500 Enumeration.jl \u2502 \u2502 \u251c\u2500\u2500 Herm \u2502 \u2502 \u2502 \u251c\u2500\u2500 Genus.jl \u2502 \u2502 \u251c\u2500\u2500 Quad \u2502 \u2502 \u2502 \u251c\u2500\u2500 Genus.jl \u2502 \u2502 \u2502 \u251c\u2500\u2500 GenusRep.jl \u2502 \u2502 \u2502 \u251c\u2500\u2500 NormalForm.jl \u2502 \u2502 \u2502 \u251c\u2500\u2500 Spaces.jl \u2502 \u2502 \u2502 \u251c\u2500\u2500 ZGenus.jl \u2502 \u2502 \u2502 \u2514\u2500\u2500 ZLattices.jl \u2502 \u2502 \u251c\u2500\u2500 QuadBin.jl \u2502 \u2502 \u2514\u2500\u2500 Torsion.jl \u2502 \u251c\u2500\u2500 QuadForm.jl Adding tests If one adds functionality to a file, say src/QuadForm/Quad/Genus.jl , a corresponding a test should be added to the corresponding test file. In this case this would be test/QuadForm/Quad/Genus.jl . Assume one adds a new file, say src/QuadForm/New.jl , which is included in src/QuadForm.jl . Then a corresponding file test/QuadForm/Test.jl containing the tests must be added. This new file must then also be included in test/QuadForm.jl . Similar to the above, if a new directory in src/ is added, the same must apply in test/ . Adding long tests If one knows that running a particular test will take a long time, one can use @long_test instead of @test inside the test suite. When running the test suite, tests annotated with @long_test will not be run, unless specifically asked for (see below). The continuous integration servers will run at least one job including the long tests. Running the tests Running all tests All tests can be run as usual with Pkg.test(\"Hecke\") . The whole test suite can be run in parallel using the following options: Set the environment variable HECKE_TEST_VARIABLE=n , where n is the number of processes. On julia >= 1.3, run Pkg.test(\"Hecke\", test_args = [\"-j$(n)\"]) , where n is the number of processes. The tests annotated with @long_test can be invoked by setting HECKE_TESTLONG=1 or adding \"long\" to the test_args keyword argument on julia >= 1.3. Running a subset of tests Because the test structure mirrors the source directory, it is easy to run only a subset of tests. For example, to run all the tests in test/QuadForm/Quad/Genus.jl , one can invoke: julia > Hecke . test_module ( \"QuadForm/Quad/Genus\" ) This also works on the directory level. If one wants to add run all tests for quadratic forms, one can just run julia > Hecke . test_module ( \"QuadForm\" )","title":"Testing"},{"location":"dev/test/#testing","text":"","title":"Testing"},{"location":"dev/test/#structure","text":"The Hecke tests can be found in Hecke/test/ and are organized in such a way that the file hierarchy mirrors the source directory Hecke/src/ . For example, here is a subset of the src/QuadForm and the test/QuadForm directories: \u251c\u2500\u2500 src \u2502 \u251c\u2500\u2500 QuadForm \u2502 \u2502 \u251c\u2500\u2500 Enumeration.jl \u2502 \u2502 \u251c\u2500\u2500 Herm \u2502 \u2502 \u2502 \u251c\u2500\u2500 Genus.jl \u2502 \u2502 \u251c\u2500\u2500 Quad \u2502 \u2502 \u2502 \u251c\u2500\u2500 Genus.jl \u2502 \u2502 \u2502 \u251c\u2500\u2500 GenusRep.jl \u2502 \u2502 \u2502 \u251c\u2500\u2500 NormalForm.jl \u2502 \u2502 \u2502 \u251c\u2500\u2500 Spaces.jl \u2502 \u2502 \u2502 \u251c\u2500\u2500 Types.jl \u2502 \u2502 \u2502 \u251c\u2500\u2500 ZGenus.jl \u2502 \u2502 \u2502 \u2514\u2500\u2500 ZLattices.jl \u2502 \u2502 \u251c\u2500\u2500 QuadBin.jl \u2502 \u2502 \u251c\u2500\u2500 Torsion.jl \u2502 \u251c\u2500\u2500 QuadForm.jl \u2502 \u2502 \u2502 \u251c\u2500\u2500 test \u2502 \u251c\u2500\u2500 QuadForm \u2502 \u2502 \u251c\u2500\u2500 Enumeration.jl \u2502 \u2502 \u251c\u2500\u2500 Herm \u2502 \u2502 \u2502 \u251c\u2500\u2500 Genus.jl \u2502 \u2502 \u251c\u2500\u2500 Quad \u2502 \u2502 \u2502 \u251c\u2500\u2500 Genus.jl \u2502 \u2502 \u2502 \u251c\u2500\u2500 GenusRep.jl \u2502 \u2502 \u2502 \u251c\u2500\u2500 NormalForm.jl \u2502 \u2502 \u2502 \u251c\u2500\u2500 Spaces.jl \u2502 \u2502 \u2502 \u251c\u2500\u2500 ZGenus.jl \u2502 \u2502 \u2502 \u2514\u2500\u2500 ZLattices.jl \u2502 \u2502 \u251c\u2500\u2500 QuadBin.jl \u2502 \u2502 \u2514\u2500\u2500 Torsion.jl \u2502 \u251c\u2500\u2500 QuadForm.jl","title":"Structure"},{"location":"dev/test/#adding-tests","text":"If one adds functionality to a file, say src/QuadForm/Quad/Genus.jl , a corresponding a test should be added to the corresponding test file. In this case this would be test/QuadForm/Quad/Genus.jl . Assume one adds a new file, say src/QuadForm/New.jl , which is included in src/QuadForm.jl . Then a corresponding file test/QuadForm/Test.jl containing the tests must be added. This new file must then also be included in test/QuadForm.jl . Similar to the above, if a new directory in src/ is added, the same must apply in test/ .","title":"Adding tests"},{"location":"dev/test/#adding-long-tests","text":"If one knows that running a particular test will take a long time, one can use @long_test instead of @test inside the test suite. When running the test suite, tests annotated with @long_test will not be run, unless specifically asked for (see below). The continuous integration servers will run at least one job including the long tests.","title":"Adding long tests"},{"location":"dev/test/#running-the-tests","text":"","title":"Running the tests"},{"location":"dev/test/#running-all-tests","text":"All tests can be run as usual with Pkg.test(\"Hecke\") . The whole test suite can be run in parallel using the following options: Set the environment variable HECKE_TEST_VARIABLE=n , where n is the number of processes. On julia >= 1.3, run Pkg.test(\"Hecke\", test_args = [\"-j$(n)\"]) , where n is the number of processes. The tests annotated with @long_test can be invoked by setting HECKE_TESTLONG=1 or adding \"long\" to the test_args keyword argument on julia >= 1.3.","title":"Running all tests"},{"location":"dev/test/#running-a-subset-of-tests","text":"Because the test structure mirrors the source directory, it is easy to run only a subset of tests. For example, to run all the tests in test/QuadForm/Quad/Genus.jl , one can invoke: julia > Hecke . test_module ( \"QuadForm/Quad/Genus\" ) This also works on the directory level. If one wants to add run all tests for quadratic forms, one can just run julia > Hecke . test_module ( \"QuadForm\" )","title":"Running a subset of tests"},{"location":"examples/reduction/","text":"Reduction of polynomials over number fields modulo a prime ideal Given a polynomial f \\in K[x] and a prime ideal \\mathfrak p of \\mathcal O_K , we want to determine the reduction \\bar f \\in F[x] , where F = \\mathcal O_K/\\mathfrak p is the residue field. Concretely, we want to reduce the polynomial f = x^3 + (1 + \u03b6_7 + \u03b6_7^2)x^2 + (23 + 55\u03b6_7^5)x + (\u03b6_7 + 77)/2 over \\mathbf{Q}(\\zeta_7) . We begin by defining the cyclomotic field and the polynomial. julia> K , \u03b6 = cyclotomic_field ( 7 ); julia> Kx , x = K [ 'x' ]; julia> f = x ^ 3 + ( 1 + \u03b6 + \u03b6 ^ 2 ) * x ^ 2 + ( 23 + 55 \u03b6 ^ 5 ) x + ( \u03b6 + 77 ) // 2 x^3 + (z_7^2 + z_7 + 1)*x^2 + (55*z_7^5 + 23)*x + 1//2*z_7 + 77//2 Next we determine the ring of integers \\mathcal O_K and a prime ideal \\mathfrak p lying above the prime p = 29 . julia> OK = maximal_order ( K ); julia> p = 29 ; julia> frakp = prime_decomposition ( OK , p )[ 1 ][ 1 ] <29, z_7 - 7> Norm: 29 Minimum: 29 two normal wrt: 29 We can now determine the residue field F = \\mathcal{O}_K/\\mathfrak p and the canonical map \\mathcal O_K \\to F . julia> F , reduction_map_OK = ResidueField ( OK , frakp ); julia> F Finite field of degree 1 over F_29 julia> reduction_map_OK Map with following data Domain: ======= Maximal order of Cyclotomic field of order 7 with basis nf_elem[1, z_7, z_7^2, z_7^3, z_7^4, z_7^5] Codomain: ========= Finite field of degree 1 over F_29 Not that the reduction map has domain \\mathcal O_K and thus cannot be applied to elements of K . We can extend it to the set of \\mathfrak p -integral elements by invoking the extend function. Not that the domain of the extended map will be the whole K , but the map will throw an error when applied to elements which are not \\mathfrak p -integral. julia> reduction_map_extended = extend ( reduction_map_OK , K ) Map with following data Domain: ======= Cyclotomic field of order 7 Codomain: ========= Finite field of degree 1 over F_29 julia> reduction_map_extended ( K ( 1 // 3 )) 10 julia> reduction_map_extended ( K ( 1 // 29 )) ERROR: Element not p-integral Finally we can reduce f modulo \\mathfrak p , which we obtain by applying the reduction map to the coefficients. julia> fbar = map_coefficients ( reduction_map_extended , f ) x^3 + 28*x^2 + 4*x + 13 julia> base_ring ( fbar ) === F true","title":"Reduction"},{"location":"examples/reduction/#reduction-of-polynomials-over-number-fields-modulo-a-prime-ideal","text":"Given a polynomial f \\in K[x] and a prime ideal \\mathfrak p of \\mathcal O_K , we want to determine the reduction \\bar f \\in F[x] , where F = \\mathcal O_K/\\mathfrak p is the residue field. Concretely, we want to reduce the polynomial f = x^3 + (1 + \u03b6_7 + \u03b6_7^2)x^2 + (23 + 55\u03b6_7^5)x + (\u03b6_7 + 77)/2 over \\mathbf{Q}(\\zeta_7) . We begin by defining the cyclomotic field and the polynomial. julia> K , \u03b6 = cyclotomic_field ( 7 ); julia> Kx , x = K [ 'x' ]; julia> f = x ^ 3 + ( 1 + \u03b6 + \u03b6 ^ 2 ) * x ^ 2 + ( 23 + 55 \u03b6 ^ 5 ) x + ( \u03b6 + 77 ) // 2 x^3 + (z_7^2 + z_7 + 1)*x^2 + (55*z_7^5 + 23)*x + 1//2*z_7 + 77//2 Next we determine the ring of integers \\mathcal O_K and a prime ideal \\mathfrak p lying above the prime p = 29 . julia> OK = maximal_order ( K ); julia> p = 29 ; julia> frakp = prime_decomposition ( OK , p )[ 1 ][ 1 ] <29, z_7 - 7> Norm: 29 Minimum: 29 two normal wrt: 29 We can now determine the residue field F = \\mathcal{O}_K/\\mathfrak p and the canonical map \\mathcal O_K \\to F . julia> F , reduction_map_OK = ResidueField ( OK , frakp ); julia> F Finite field of degree 1 over F_29 julia> reduction_map_OK Map with following data Domain: ======= Maximal order of Cyclotomic field of order 7 with basis nf_elem[1, z_7, z_7^2, z_7^3, z_7^4, z_7^5] Codomain: ========= Finite field of degree 1 over F_29 Not that the reduction map has domain \\mathcal O_K and thus cannot be applied to elements of K . We can extend it to the set of \\mathfrak p -integral elements by invoking the extend function. Not that the domain of the extended map will be the whole K , but the map will throw an error when applied to elements which are not \\mathfrak p -integral. julia> reduction_map_extended = extend ( reduction_map_OK , K ) Map with following data Domain: ======= Cyclotomic field of order 7 Codomain: ========= Finite field of degree 1 over F_29 julia> reduction_map_extended ( K ( 1 // 3 )) 10 julia> reduction_map_extended ( K ( 1 // 29 )) ERROR: Element not p-integral Finally we can reduce f modulo \\mathfrak p , which we obtain by applying the reduction map to the coefficients. julia> fbar = map_coefficients ( reduction_map_extended , f ) x^3 + 28*x^2 + 4*x + 13 julia> base_ring ( fbar ) === F true","title":"Reduction of polynomials over number fields modulo a prime ideal"},{"location":"function_fields/basics/","text":"Creation of number fields For details on creation of rational function fields and extensions thereof, refer to the AbstractAlgebra documentation which can be found here https://nemocas.github.io/AbstractAlgebra.jl/latest/function_field/ .","title":"Creation and basics"},{"location":"function_fields/basics/#creation-of-number-fields","text":"For details on creation of rational function fields and extensions thereof, refer to the AbstractAlgebra documentation which can be found here https://nemocas.github.io/AbstractAlgebra.jl/latest/function_field/ .","title":"Creation of number fields"},{"location":"function_fields/degree_localization/","text":"Degree localization of a rational function field Degree localization Given k(x) a (univariate) rational function field, there are two rings of interest, both of which are Euclidean: k[x] :k_ \\infty(x) = {a/b | a, b \\in k[x] \\;\\;\\mbox{where}\\;\\; \\deg(a) \\leq \\deg(b)} The second of these rings is the localization of k[1/x] at (1/x) inside the rational function field k(x) , i.e. the localization of the function field at the point at infinity, i.e. the valuation ring for valuation - degree (x) . We refer to this ring as the degree localization of the rational function field k(x) . Construction of the degree localization The degree localization of a rational function field k(x) can be constructed using a Localization constructor, passing in the degree function as argument. <a id='Localization-Union{Tuple{T}, Tuple{AbstractAlgebra.Generic.RationalFunctionField{T}, typeof(degree)}} where T<:FieldElement' href='#Localization-Union{Tuple{T}, Tuple{AbstractAlgebra.Generic.RationalFunctionField{T}, typeof(degree)}} where T<:FieldElement'># Localization \u2014 Method . Localization ( K :: RationalFunctionField { T }, :: typeof ( degree )) where T <: FieldElement Return the localization of k[1/x] at (1/x) inside the rational function field k(x) , i.e. the localization of the function field at the point at infinity, i.e. the valuation ring for valuation - degree (x) . This is the ring k_\\infty(x) = \\{ f/g | \\deg(f) \\leq \\deg(g)\\} . source Example + julia> K , x = RationalFunctionField ( FlintQQ , \"x\" ); julia> R = Localization ( K , degree ) Degree localization of Rational function field over Rational Field Elements of the degree localization Elements of the degree localization are created using the parent object R representing the degree localization Example + julia> K , x = RationalFunctionField ( FlintQQ , \"x\" ); julia> R = Localization ( K , degree ) Degree localization of Rational function field over Rational Field julia> a = R () 0 julia> b = R ( 1 ) 1 julia> c = R (( x + 1 ) // x ) (x + 1)//x Note that the degree of the denominator of the function field element passed to the constructor must be at least that of the numerator or an exception is raised. Element functionality # degree \u2014 Method . degree ( a :: KInftyElem ) Return the degree of the given element, i.e. degree(numerator) - degree(denominator) . source # valuation \u2014 Method . valuation ( a :: KInftyElem ) Return the degree valuation of the given element, i.e. -degree(a) . source One can test whether a given element of a rational function field is in the degree localization. <a id='in-Union{Tuple{T}, Tuple{AbstractAlgebra.Generic.Rat{T}, KInftyRing{T}}} where T<:FieldElement' href='#in-Union{Tuple{T}, Tuple{AbstractAlgebra.Generic.Rat{T}, KInftyRing{T}}} where T<:FieldElement'># in \u2014 Method . in ( a :: Generic . Rat { T }, R :: KInftyRing { T }) where T <: FieldElement Return true if the given element of the rational function field is an element of k_\\infty(x) , i.e. if degree(numerator) <= degree(denominator) . source All basic arithmetic operations are provided for elements of the degree localization. As the degree localization is a Euclidean ring, all standard Euclidean functions, including div , divrem , mod , gcd , gcdx , are provided.","title":"Degree localization"},{"location":"function_fields/degree_localization/#degree-localization-of-a-rational-function-field","text":"","title":"Degree localization of a rational function field"},{"location":"function_fields/degree_localization/#degree-localization","text":"Given k(x) a (univariate) rational function field, there are two rings of interest, both of which are Euclidean: k[x] :k_ \\infty(x) = {a/b | a, b \\in k[x] \\;\\;\\mbox{where}\\;\\; \\deg(a) \\leq \\deg(b)} The second of these rings is the localization of k[1/x] at (1/x) inside the rational function field k(x) , i.e. the localization of the function field at the point at infinity, i.e. the valuation ring for valuation - degree (x) . We refer to this ring as the degree localization of the rational function field k(x) .","title":"Degree localization"},{"location":"function_fields/degree_localization/#construction-of-the-degree-localization","text":"The degree localization of a rational function field k(x) can be constructed using a Localization constructor, passing in the degree function as argument. <a id='Localization-Union{Tuple{T}, Tuple{AbstractAlgebra.Generic.RationalFunctionField{T}, typeof(degree)}} where T<:FieldElement' href='#Localization-Union{Tuple{T}, Tuple{AbstractAlgebra.Generic.RationalFunctionField{T}, typeof(degree)}} where T<:FieldElement'># Localization \u2014 Method . Localization ( K :: RationalFunctionField { T }, :: typeof ( degree )) where T <: FieldElement Return the localization of k[1/x] at (1/x) inside the rational function field k(x) , i.e. the localization of the function field at the point at infinity, i.e. the valuation ring for valuation - degree (x) . This is the ring k_\\infty(x) = \\{ f/g | \\deg(f) \\leq \\deg(g)\\} . source","title":"Construction of the degree localization"},{"location":"function_fields/degree_localization/#example","text":"julia> K , x = RationalFunctionField ( FlintQQ , \"x\" ); julia> R = Localization ( K , degree ) Degree localization of Rational function field over Rational Field","title":"Example +"},{"location":"function_fields/degree_localization/#elements-of-the-degree-localization","text":"Elements of the degree localization are created using the parent object R representing the degree localization","title":"Elements of the degree localization"},{"location":"function_fields/degree_localization/#example_1","text":"julia> K , x = RationalFunctionField ( FlintQQ , \"x\" ); julia> R = Localization ( K , degree ) Degree localization of Rational function field over Rational Field julia> a = R () 0 julia> b = R ( 1 ) 1 julia> c = R (( x + 1 ) // x ) (x + 1)//x Note that the degree of the denominator of the function field element passed to the constructor must be at least that of the numerator or an exception is raised.","title":"Example +"},{"location":"function_fields/degree_localization/#element-functionality","text":"# degree \u2014 Method . degree ( a :: KInftyElem ) Return the degree of the given element, i.e. degree(numerator) - degree(denominator) . source # valuation \u2014 Method . valuation ( a :: KInftyElem ) Return the degree valuation of the given element, i.e. -degree(a) . source One can test whether a given element of a rational function field is in the degree localization. <a id='in-Union{Tuple{T}, Tuple{AbstractAlgebra.Generic.Rat{T}, KInftyRing{T}}} where T<:FieldElement' href='#in-Union{Tuple{T}, Tuple{AbstractAlgebra.Generic.Rat{T}, KInftyRing{T}}} where T<:FieldElement'># in \u2014 Method . in ( a :: Generic . Rat { T }, R :: KInftyRing { T }) where T <: FieldElement Return true if the given element of the rational function field is an element of k_\\infty(x) , i.e. if degree(numerator) <= degree(denominator) . source All basic arithmetic operations are provided for elements of the degree localization. As the degree localization is a Euclidean ring, all standard Euclidean functions, including div , divrem , mod , gcd , gcdx , are provided.","title":"Element functionality"},{"location":"function_fields/elements/","text":"Elements For details on element arithmetic in rational function fields and extensions, refer to the AbstractAlgebra documentation which can be found at https://nemocas.github.io/AbstractAlgebra.jl/latest/function_field/ .","title":"Elements"},{"location":"function_fields/elements/#elements","text":"For details on element arithmetic in rational function fields and extensions, refer to the AbstractAlgebra documentation which can be found at https://nemocas.github.io/AbstractAlgebra.jl/latest/function_field/ .","title":"Elements"},{"location":"function_fields/internal/","text":"Function fields, in Hecke, come in several different types: RationalFunctionField : a field of the form k(x) for a field k . FunctionField : a finite extension of a rational function field given by a polynomial. Function fields with the type FunctionField are referred to as simple fields in the rest of this document. They are also referred to as being absolute. Absolute Simple Fields Internally function fields of type FunctionField are essentially represented as a unvariate quotient with the arithmetic provided by the AbstractAlgebra and Nemo packages. As they are defined generically for all AbstractAlgebra, Nemo and Hecke fields k the function field type is implemented in AbstractAlgebra.","title":"Internals"},{"location":"function_fields/internal/#absolute-simple-fields","text":"Internally function fields of type FunctionField are essentially represented as a unvariate quotient with the arithmetic provided by the AbstractAlgebra and Nemo packages. As they are defined generically for all AbstractAlgebra, Nemo and Hecke fields k the function field type is implemented in AbstractAlgebra.","title":"Absolute Simple Fields"},{"location":"function_fields/intro/","text":"Function Fields Introduction By definition, a (univariate) function field can be written as a finite extension of a rational function field k(x) for a field k (commonly k = \\mathbb{Q} or k = \\mathbb{F}_p ). In Hecke, a function field L is currently defined as being a (univariate) rational function field k(x) or a finite extension thereof. In other words, the extension is defined in the the following way: We have L = k(x)/(f) , where f \\in k(x)[y] is an irreducible polynomial ( simple extension ) We refer to k(x) as the base field of the function field L . We call L an absolute function field if the base field is equal to the rational function field k(x) .","title":"Introduction"},{"location":"function_fields/intro/#function-fields","text":"","title":"Function Fields"},{"location":"function_fields/intro/#introduction","text":"By definition, a (univariate) function field can be written as a finite extension of a rational function field k(x) for a field k (commonly k = \\mathbb{Q} or k = \\mathbb{F}_p ). In Hecke, a function field L is currently defined as being a (univariate) rational function field k(x) or a finite extension thereof. In other words, the extension is defined in the the following way: We have L = k(x)/(f) , where f \\in k(x)[y] is an irreducible polynomial ( simple extension ) We refer to k(x) as the base field of the function field L . We call L an absolute function field if the base field is equal to the rational function field k(x) .","title":"Introduction"},{"location":"number_fields/conventions/","text":"Number fields By an absolute number field we mean finite extensions of \\mathbf Q , which is of type AnticNumberField and whose elements are of type nf_elem . Such an absolute number field K is always given in the form K = \\mathbf Q(\\alpha) = \\mathbf Q[X]/(f) , where f \\in \\mathbf Q[X] is an irreducible polynomial. See here for more information on the different types of fields supported. We call (1,\\alpha,\\alpha^2,\\dotsc,\\alpha^{d-1}) , where d is the degree [K : \\mathbf Q] the power basis of K . If \\beta is any element of K , then the representation matrix of \\beta is the matrix representing K \\to K, \\gamma \\mapsto \\beta \\gamma with respect to the power basis, that is, \\beta \\cdot (1,\\alpha,\\dotsc,\\alpha^{d-1}) = M_\\alpha (1, \\alpha, \\dotsc, \\alpha^{d-1}). Let (r,s) be the signature of K , that is, K has r real embeddings \\sigma_i \\colon K \\to \\mathbf{R} , 1 \\leq i \\leq r , and 2s complex embeddings \\sigma_i \\colon K \\to \\mathbf{C} , 1 \\leq i \\leq 2s . In Hecke the complex embeddings are always ordered such that \\sigma_i = \\overline{\\sigma_{i+s}} for r + 1 \\leq i \\leq r + s . The \\mathbf{Q} -linear function \\begin{gather*} K \\longrightarrow \\mathbf R^{d} \\\\ \\alpha \\longmapsto \\Bigl( \\sigma_1(\\alpha), \\dotsc, \\sigma_r(\\alpha), \\sqrt{2}\\operatorname{Re}\\bigl(\\sigma_{r+1}(\\alpha)\\bigr), \\sqrt{2}\\operatorname{Im}\\bigl(\\sigma_{r+1}(\\alpha)\\bigr), \\dotsc, \\sqrt{2}\\operatorname{Re}\\bigl(\\sigma_{r+s}(\\alpha)\\bigr), \\sqrt{2}\\operatorname{Im}\\bigl(\\sigma_{r+s}(\\alpha)\\bigr) \\Bigr) \\end{gather*} is called the Minkowski map (or Minkowski embedding ). If K = \\mathbf Q(\\alpha) is an absolute number field, then an order \\mathcal O of K is a subring of the ring of integers \\mathcal O_K , which is free of rank [ K : \\mathbf Q] as a \\mathbf Z -module. The natural order \\mathbf Z[\\alpha] is called the equation order of K . In Hecke orders of absolute number fields are constructed (implicitely) by specifying a \\mathbf Z -basis, which is refered to as the basis of \\mathcal O . If (\\omega_1,\\dotsc,\\omega_d) is the basis of \\mathcal O , then the matrix B \\in \\operatorname{Mat}_{d \\times d}(\\mathbf Q) with is called the basis matrix of \\mathcal O . We call \\det(B) the generalized index of \\mathcal O . In case \\mathbf Z[\\alpha] \\subseteq \\mathcal O , the determinant \\det(B)^{-1} is in fact equal to [ \\mathcal O : \\mathbf Z[\\alpha]] and is called the index of \\mathcal O . The matrix \\begin{pmatrix} \\sigma_1(\\omega_1) & \\dotsc & \\sigma_r(\\omega_1) & \\sqrt{2}\\operatorname{Re}(\\sigma_{r+1}(\\omega_1)) & \\sqrt{2}\\operatorname{Im}(\\sigma_{r+1}(\\omega_1)) & \\dotsc & \\sqrt{2}\\operatorname{Im}(\\sigma_{r+s}(\\omega_1)) \\\\\\\\ \\sigma_1(\\omega_2) & \\dotsc & \\sigma_r(\\omega_2) & \\sqrt{2}\\operatorname{Re}(\\sigma_{r+1}(\\omega_2)) & \\sqrt{2}\\operatorname{Im}(\\sigma_{r+1}(\\omega_2)) & \\dotsc & \\sqrt{2}\\operatorname{Im}(\\sigma_{r+s}(\\omega_2)) \\\\\\\\ \\vdots & \\ddots & \\vdots & \\vdots & \\vdots & \\ddots & \\vdots\\\\\\\\ \\sigma_1(\\omega_d) & \\dotsc & \\sigma_r(\\omega_d) & \\sqrt{2}\\operatorname{Re}(\\sigma_{r+1}(\\omega_d)) & \\sqrt{2}\\operatorname{Im}(\\sigma_{r+2}(\\omega_d)) & \\dotsc & \\sqrt{2}\\operatorname{Im}(\\sigma_{r+s}(\\omega_d)) \\end{pmatrix} \\in \\operatorname{Mat}_{d\\times d}(\\mathbf R). is called the Minkowski matrix of \\mathcal O .","title":"Conventions"},{"location":"number_fields/conventions/#number-fields","text":"By an absolute number field we mean finite extensions of \\mathbf Q , which is of type AnticNumberField and whose elements are of type nf_elem . Such an absolute number field K is always given in the form K = \\mathbf Q(\\alpha) = \\mathbf Q[X]/(f) , where f \\in \\mathbf Q[X] is an irreducible polynomial. See here for more information on the different types of fields supported. We call (1,\\alpha,\\alpha^2,\\dotsc,\\alpha^{d-1}) , where d is the degree [K : \\mathbf Q] the power basis of K . If \\beta is any element of K , then the representation matrix of \\beta is the matrix representing K \\to K, \\gamma \\mapsto \\beta \\gamma with respect to the power basis, that is, \\beta \\cdot (1,\\alpha,\\dotsc,\\alpha^{d-1}) = M_\\alpha (1, \\alpha, \\dotsc, \\alpha^{d-1}). Let (r,s) be the signature of K , that is, K has r real embeddings \\sigma_i \\colon K \\to \\mathbf{R} , 1 \\leq i \\leq r , and 2s complex embeddings \\sigma_i \\colon K \\to \\mathbf{C} , 1 \\leq i \\leq 2s . In Hecke the complex embeddings are always ordered such that \\sigma_i = \\overline{\\sigma_{i+s}} for r + 1 \\leq i \\leq r + s . The \\mathbf{Q} -linear function \\begin{gather*} K \\longrightarrow \\mathbf R^{d} \\\\ \\alpha \\longmapsto \\Bigl( \\sigma_1(\\alpha), \\dotsc, \\sigma_r(\\alpha), \\sqrt{2}\\operatorname{Re}\\bigl(\\sigma_{r+1}(\\alpha)\\bigr), \\sqrt{2}\\operatorname{Im}\\bigl(\\sigma_{r+1}(\\alpha)\\bigr), \\dotsc, \\sqrt{2}\\operatorname{Re}\\bigl(\\sigma_{r+s}(\\alpha)\\bigr), \\sqrt{2}\\operatorname{Im}\\bigl(\\sigma_{r+s}(\\alpha)\\bigr) \\Bigr) \\end{gather*} is called the Minkowski map (or Minkowski embedding ). If K = \\mathbf Q(\\alpha) is an absolute number field, then an order \\mathcal O of K is a subring of the ring of integers \\mathcal O_K , which is free of rank [ K : \\mathbf Q] as a \\mathbf Z -module. The natural order \\mathbf Z[\\alpha] is called the equation order of K . In Hecke orders of absolute number fields are constructed (implicitely) by specifying a \\mathbf Z -basis, which is refered to as the basis of \\mathcal O . If (\\omega_1,\\dotsc,\\omega_d) is the basis of \\mathcal O , then the matrix B \\in \\operatorname{Mat}_{d \\times d}(\\mathbf Q) with is called the basis matrix of \\mathcal O . We call \\det(B) the generalized index of \\mathcal O . In case \\mathbf Z[\\alpha] \\subseteq \\mathcal O , the determinant \\det(B)^{-1} is in fact equal to [ \\mathcal O : \\mathbf Z[\\alpha]] and is called the index of \\mathcal O . The matrix \\begin{pmatrix} \\sigma_1(\\omega_1) & \\dotsc & \\sigma_r(\\omega_1) & \\sqrt{2}\\operatorname{Re}(\\sigma_{r+1}(\\omega_1)) & \\sqrt{2}\\operatorname{Im}(\\sigma_{r+1}(\\omega_1)) & \\dotsc & \\sqrt{2}\\operatorname{Im}(\\sigma_{r+s}(\\omega_1)) \\\\\\\\ \\sigma_1(\\omega_2) & \\dotsc & \\sigma_r(\\omega_2) & \\sqrt{2}\\operatorname{Re}(\\sigma_{r+1}(\\omega_2)) & \\sqrt{2}\\operatorname{Im}(\\sigma_{r+1}(\\omega_2)) & \\dotsc & \\sqrt{2}\\operatorname{Im}(\\sigma_{r+s}(\\omega_2)) \\\\\\\\ \\vdots & \\ddots & \\vdots & \\vdots & \\vdots & \\ddots & \\vdots\\\\\\\\ \\sigma_1(\\omega_d) & \\dotsc & \\sigma_r(\\omega_d) & \\sqrt{2}\\operatorname{Re}(\\sigma_{r+1}(\\omega_d)) & \\sqrt{2}\\operatorname{Im}(\\sigma_{r+2}(\\omega_d)) & \\dotsc & \\sqrt{2}\\operatorname{Im}(\\sigma_{r+s}(\\omega_d)) \\end{pmatrix} \\in \\operatorname{Mat}_{d\\times d}(\\mathbf R). is called the Minkowski matrix of \\mathcal O .","title":"Number fields"},{"location":"number_fields/elements/","text":"Element operations Creation # gen \u2014 Method . gen ( L :: SimpleNumField ) -> NumFieldElem Given a simple number field L = K[x]/(x) over K , this functions returns the class of x , which is the canonical primitive element of L over K . source # gens \u2014 Method . gens ( L :: NonSimpleNumField ) -> Vector { NumFieldElem } Given a non-simple number field L = K[x_1,\\dotsc,x_n]/(f_1,\\dotsc,f_n) over K , this functions returns the list \\bar x_1,\\dotsc,\\bar x_n . source Elements can also be created by specifying the coordinates with respect to the basis of the number field: ( L :: NumberField )( c :: Vector { NumFieldElem }) -> NumFieldElem Given a number field L/K of degree d and a vector c length d , this constructs the element a with coordinates(a) == c . julia> Qx , x = QQ [ \"x\" ]; julia> K , a = NumberField ( x ^ 2 - 2 , \"a\" ); julia> K ([ 1 , 2 ]) 2*a + 1 julia> L , b = radical_extension ( 3 , a , \"b\" ) (Relative number field over with defining polynomial x^3 - a over Number field over Rational Field with defining polynomial x^2 - 2, b) julia> L ([ a , 1 , 1 // 2 ]) 1//2*b^2 + b + a # quadratic_defect \u2014 Method . quadratic_defect ( a :: NumFieldElem , p ) -> Union { Inf , PosInf } Returns the valuation of the quadratic defect of the element a at p , which can either be prime object or an infinite place of the parent of a . source # hilbert_symbol \u2014 Method . hilbert_symbol ( a :: NumFieldElem , b :: NumFieldElem , p :: NfOrdIdl ) -> Int Returns the local Hilbert symbol (a,b)_p . source # representation_matrix \u2014 Method . representation_matrix ( a :: NumFieldElem ) -> MatElem Returns the representation matrix of a , that is, the matrix representing multiplication with a with respect to the canonical basis of the parent of a . source # basis_matrix \u2014 Method . basis_matrix ( v :: Vector { NumFieldElem }) -> Mat Given a vector v of n elements of a number field K of degree d , this function returns an n x d matrix with entries in the base field of K , where row i contains the coefficients of v[i] with respect of the canonical basis of K . source # coefficients \u2014 Method . coefficients ( a :: SimpleNumFieldElem , i :: Int ) -> Vector { FieldElem } Given a number field element a of a simple number field extension L/K , this function returns the coefficients of a , when expanded in the canonical power basis of L . source # coordinates \u2014 Method . coordinates ( x :: NumFieldElem { T }) -> Vector { T } Given an element x in a number field K , this function returns the coordinates of x with respect to the basis of K (the output of the 'basis' function). source # absolute_coordinates \u2014 Method . absolute_coordinates ( x :: NumFieldElem { T }) -> Vector { T } Given an element x in a number field K , this function returns the coordinates of x with respect to the basis of K over the rationals (the output of the 'absolute_basis' function). source # coeff \u2014 Method . coeff ( a :: SimpleNumFieldElem , i :: Int ) -> FieldElem Given a number field element a of a simple number field extension L/K , this function returns the i -th coefficient of a , when expanded in the canonical power basis of L . The result is an element of K . source # valuation \u2014 Method . valuation ( a :: NumFieldElem , p :: NfOrdIdl ) -> fmpz Computes the \\mathfrak p -adic valuation of a , that is, the largest i such that a is contained in \\mathfrak p^i . source # torsion_unit_order \u2014 Method . torsion_unit_order ( x :: nf_elem , n :: Int ) Given a torsion unit x together with a multiple n of its order, compute the order of x , that is, the smallest k \\in \\mathbb Z_{\\geq 1} such that x^<code>k</code> = 1 . It is not checked whether x is a torsion unit. source # tr \u2014 Method . tr ( a :: NumFieldElem ) -> NumFieldElem Returns the trace of an element a of a number field extension L/K . This will be an element of K . source # absolute_tr \u2014 Method . absolute_tr ( a :: NumFieldElem ) -> fmpq Given a number field element a , returns the absolute trace of a . source # algebraic_split \u2014 Method . algebraic_split ( a :: nf_elem ) -> nf_elem , nf_elem Writes the input as a quotient of two \"small\" algebraic integers. source Conjugates # conjugates \u2014 Method . conjugates ( x :: nf_elem , C :: AcbField ) -> Vector { acb } Compute the conjugates of x as elements of type acb . Recall that we order the complex conjugates \\sigma_{r+1}(x),...,\\sigma_{r+2s}(x) such that \\sigma_{i}(x) = \\overline{sigma_{i + s}(x)} for r + 1 \\leq i \\leq r + s . Let p be the precision of C , then every entry y of the vector returned satisfies radius(real(y)) < 2^-p and radius(imag(y)) < 2^-p respectively. source # conjugates \u2014 Method . conjugates ( x :: nf_elem , abs_tol :: Int ) -> Vector { acb } Compute the conjugates of x as elements of type acb . Recall that we order the complex conjugates \\sigma_{r+1}(x),...,\\sigma_{r+2s}(x) such that \\sigma_{i}(x) = \\overline{sigma_{i + s}(x)} for r + 1 \\leq i \\leq r + s . Every entry y of the vector returned satisfies radius(real(y)) < 2^-abs_tol and radius(imag(y)) < 2^-abs_tol respectively. source # conjugates_log \u2014 Method . conjugates_arb_log ( x :: nf_elem , abs_tol :: Int ) -> Vector { arb } Returns the elements (\\log(\\lvert \\sigma_1(x) \\rvert),\\dotsc,\\log(\\lvert\\sigma_r(x) \\rvert), \\dotsc,2\\log(\\lvert \\sigma_{r+1}(x) \\rvert),\\dotsc, 2\\log(\\lvert \\sigma_{r+s}(x)\\rvert)) as elements of type arb with radius less then 2^-abs_tol . source # conjugates_real \u2014 Method . conjugates_arb_real ( x :: nf_elem , abs_tol :: Int ) -> Vector { arb } Compute the real conjugates of x as elements of type arb . Every entry y of the array returned satisfies radius(y) < 2^-abs_tol . source # conjugates_complex \u2014 Method . conjugates_complex ( x :: nf_elem , abs_tol :: Int ) -> Vector { acb } Compute the complex conjugates of x as elements of type acb . Recall that we order the complex conjugates \\sigma_{r+1}(x),...,\\sigma_{r+2s}(x) such that \\sigma_{i}(x) = \\overline{sigma_{i + s}(x)} for r + 1 \\leq i \\leq r + s . Every entry y of the array returned satisfies radius(real(y)) < 2^-abs_tol and radius(imag(y)) < 2^-abs_tol . source # evaluate \u2014 Method . evaluate ( a :: nf_elem , P :: InfPlc , p :: Int = 20 ) The evaluation of a at the place P , i.e. a real or complex value. p specifies the precision to be returned. source # conjugates_arb_log_normalise \u2014 Method . conjugates_arb_log_normalise ( x :: nf_elem , p :: Int = 10 ) conjugates_arb_log_normalise ( x :: FacElem { nf_elem , AnticNumberField }, p :: Int = 10 ) The \"normalised\" logarithms, i.e. the array c_i\\log |x^{(i)}| - 1/n\\log|N(x)| , so the (weighted) sum adds up to zero. source # minkowski_map \u2014 Method . minkowski_map ( a :: nf_elem , abs_tol :: Int ) -> Vector { arb } Returns the image of a under the Minkowski embedding. Every entry of the array returned is of type arb with radius less then 2^(-abs_tol) . source # isnegative \u2014 Method . isnegative ( a :: nf_elem , P :: InfPlc ) -> Bool isnegative ( a :: FacElem { nf_elem }, P :: InfPlc ) -> Bool Returns whether the element a is negative at the embedding corresponding to P . The place P must be real. source Predicates # isintegral \u2014 Method . isintegral ( a :: NumFieldElem ) -> Bool Returns whether a is integral, that is, whether the minimal polynomial of a has integral coefficients. source # istorsion_unit \u2014 Method . istorsion_unit ( x :: nf_elem , checkisunit :: Bool = false ) -> Bool Returns whether x is a torsion unit, that is, whether there exists n such that x^n = 1 . If checkisunit is true , it is first checked whether x is a unit of the maximal order of the number field x is lying in. source # islocal_norm \u2014 Method . islocal_norm ( L :: NumField , a :: NumFieldElem , P ) Given a number field L/K , an element a \\in K and a prime ideal P of K , returns whether a is a local norm at P . The number field L/K must be a simple extension of degree 2. source # isnorm_divisible \u2014 Method . isnorm_divisible ( a :: nf_elem , n :: fmpz ) -> Bool Checks if the norm of a is divisible by n , assuming that the norm of a is an integer. source # isnorm \u2014 Method . isnorm ( K :: AnticNumberField , a :: fmpz ; extra :: Vector { fmpz }) -> Bool , nf_elem For a fmpz a , try to find T \\in K s.th. N(T) = a holds. If successful, return true and T , otherwise false and some element. In \\testtt{extra} one can pass in additional prime numbers that are allowed to occur in the solution. This will then be supplemented. The element will be returned in factored form. source Invariants # norm \u2014 Method . norm ( a :: NumFieldElem ) -> NumFieldElem Returns the norm of an element a of a number field extension L/K . This will be an element of K . source # absolute_norm \u2014 Method . absolute_norm ( a :: NumFieldElem ) -> fmpq Given a number field element a , returns the absolute norm of a . source # minpoly \u2014 Method . minpoly ( a :: NumFieldElem ) -> PolyElem Given a number field element a of a number field K , this function returns the minimal polynomial of a over the base field of K . source # absolute_minpoly \u2014 Method . absolute_minpoly ( a :: NumFieldElem ) -> PolyElem Given a number field element a of a number field K , this function returns the minimal polynomial of a over the rationals \\mathbf{Q} . source # charpoly \u2014 Method . charpoly ( a :: NumFieldElem ) -> PolyElem Given a number field element a of a number field K , this function returns the characteristic polynomial of a over the base field of K . source # absolute_charpoly \u2014 Method . absolute_charpoly ( a :: NumFieldElem ) -> PolyElem Given a number field element a of a number field K , this function returns the characteristic polynomial of a over the rationals \\mathbf{Q} . source # norm \u2014 Method . norm ( a :: NumFieldElem , k :: NumField ) -> NumFieldElem Returns the norm of an element a of a number field L with respect to a subfield k of L . This will be an element of k . source","title":"Elements"},{"location":"number_fields/elements/#element-operations","text":"","title":"Element operations"},{"location":"number_fields/elements/#creation","text":"# gen \u2014 Method . gen ( L :: SimpleNumField ) -> NumFieldElem Given a simple number field L = K[x]/(x) over K , this functions returns the class of x , which is the canonical primitive element of L over K . source # gens \u2014 Method . gens ( L :: NonSimpleNumField ) -> Vector { NumFieldElem } Given a non-simple number field L = K[x_1,\\dotsc,x_n]/(f_1,\\dotsc,f_n) over K , this functions returns the list \\bar x_1,\\dotsc,\\bar x_n . source Elements can also be created by specifying the coordinates with respect to the basis of the number field: ( L :: NumberField )( c :: Vector { NumFieldElem }) -> NumFieldElem Given a number field L/K of degree d and a vector c length d , this constructs the element a with coordinates(a) == c . julia> Qx , x = QQ [ \"x\" ]; julia> K , a = NumberField ( x ^ 2 - 2 , \"a\" ); julia> K ([ 1 , 2 ]) 2*a + 1 julia> L , b = radical_extension ( 3 , a , \"b\" ) (Relative number field over with defining polynomial x^3 - a over Number field over Rational Field with defining polynomial x^2 - 2, b) julia> L ([ a , 1 , 1 // 2 ]) 1//2*b^2 + b + a # quadratic_defect \u2014 Method . quadratic_defect ( a :: NumFieldElem , p ) -> Union { Inf , PosInf } Returns the valuation of the quadratic defect of the element a at p , which can either be prime object or an infinite place of the parent of a . source # hilbert_symbol \u2014 Method . hilbert_symbol ( a :: NumFieldElem , b :: NumFieldElem , p :: NfOrdIdl ) -> Int Returns the local Hilbert symbol (a,b)_p . source # representation_matrix \u2014 Method . representation_matrix ( a :: NumFieldElem ) -> MatElem Returns the representation matrix of a , that is, the matrix representing multiplication with a with respect to the canonical basis of the parent of a . source # basis_matrix \u2014 Method . basis_matrix ( v :: Vector { NumFieldElem }) -> Mat Given a vector v of n elements of a number field K of degree d , this function returns an n x d matrix with entries in the base field of K , where row i contains the coefficients of v[i] with respect of the canonical basis of K . source # coefficients \u2014 Method . coefficients ( a :: SimpleNumFieldElem , i :: Int ) -> Vector { FieldElem } Given a number field element a of a simple number field extension L/K , this function returns the coefficients of a , when expanded in the canonical power basis of L . source # coordinates \u2014 Method . coordinates ( x :: NumFieldElem { T }) -> Vector { T } Given an element x in a number field K , this function returns the coordinates of x with respect to the basis of K (the output of the 'basis' function). source # absolute_coordinates \u2014 Method . absolute_coordinates ( x :: NumFieldElem { T }) -> Vector { T } Given an element x in a number field K , this function returns the coordinates of x with respect to the basis of K over the rationals (the output of the 'absolute_basis' function). source # coeff \u2014 Method . coeff ( a :: SimpleNumFieldElem , i :: Int ) -> FieldElem Given a number field element a of a simple number field extension L/K , this function returns the i -th coefficient of a , when expanded in the canonical power basis of L . The result is an element of K . source # valuation \u2014 Method . valuation ( a :: NumFieldElem , p :: NfOrdIdl ) -> fmpz Computes the \\mathfrak p -adic valuation of a , that is, the largest i such that a is contained in \\mathfrak p^i . source # torsion_unit_order \u2014 Method . torsion_unit_order ( x :: nf_elem , n :: Int ) Given a torsion unit x together with a multiple n of its order, compute the order of x , that is, the smallest k \\in \\mathbb Z_{\\geq 1} such that x^<code>k</code> = 1 . It is not checked whether x is a torsion unit. source # tr \u2014 Method . tr ( a :: NumFieldElem ) -> NumFieldElem Returns the trace of an element a of a number field extension L/K . This will be an element of K . source # absolute_tr \u2014 Method . absolute_tr ( a :: NumFieldElem ) -> fmpq Given a number field element a , returns the absolute trace of a . source # algebraic_split \u2014 Method . algebraic_split ( a :: nf_elem ) -> nf_elem , nf_elem Writes the input as a quotient of two \"small\" algebraic integers. source","title":"Creation"},{"location":"number_fields/elements/#conjugates","text":"# conjugates \u2014 Method . conjugates ( x :: nf_elem , C :: AcbField ) -> Vector { acb } Compute the conjugates of x as elements of type acb . Recall that we order the complex conjugates \\sigma_{r+1}(x),...,\\sigma_{r+2s}(x) such that \\sigma_{i}(x) = \\overline{sigma_{i + s}(x)} for r + 1 \\leq i \\leq r + s . Let p be the precision of C , then every entry y of the vector returned satisfies radius(real(y)) < 2^-p and radius(imag(y)) < 2^-p respectively. source # conjugates \u2014 Method . conjugates ( x :: nf_elem , abs_tol :: Int ) -> Vector { acb } Compute the conjugates of x as elements of type acb . Recall that we order the complex conjugates \\sigma_{r+1}(x),...,\\sigma_{r+2s}(x) such that \\sigma_{i}(x) = \\overline{sigma_{i + s}(x)} for r + 1 \\leq i \\leq r + s . Every entry y of the vector returned satisfies radius(real(y)) < 2^-abs_tol and radius(imag(y)) < 2^-abs_tol respectively. source # conjugates_log \u2014 Method . conjugates_arb_log ( x :: nf_elem , abs_tol :: Int ) -> Vector { arb } Returns the elements (\\log(\\lvert \\sigma_1(x) \\rvert),\\dotsc,\\log(\\lvert\\sigma_r(x) \\rvert), \\dotsc,2\\log(\\lvert \\sigma_{r+1}(x) \\rvert),\\dotsc, 2\\log(\\lvert \\sigma_{r+s}(x)\\rvert)) as elements of type arb with radius less then 2^-abs_tol . source # conjugates_real \u2014 Method . conjugates_arb_real ( x :: nf_elem , abs_tol :: Int ) -> Vector { arb } Compute the real conjugates of x as elements of type arb . Every entry y of the array returned satisfies radius(y) < 2^-abs_tol . source # conjugates_complex \u2014 Method . conjugates_complex ( x :: nf_elem , abs_tol :: Int ) -> Vector { acb } Compute the complex conjugates of x as elements of type acb . Recall that we order the complex conjugates \\sigma_{r+1}(x),...,\\sigma_{r+2s}(x) such that \\sigma_{i}(x) = \\overline{sigma_{i + s}(x)} for r + 1 \\leq i \\leq r + s . Every entry y of the array returned satisfies radius(real(y)) < 2^-abs_tol and radius(imag(y)) < 2^-abs_tol . source # evaluate \u2014 Method . evaluate ( a :: nf_elem , P :: InfPlc , p :: Int = 20 ) The evaluation of a at the place P , i.e. a real or complex value. p specifies the precision to be returned. source # conjugates_arb_log_normalise \u2014 Method . conjugates_arb_log_normalise ( x :: nf_elem , p :: Int = 10 ) conjugates_arb_log_normalise ( x :: FacElem { nf_elem , AnticNumberField }, p :: Int = 10 ) The \"normalised\" logarithms, i.e. the array c_i\\log |x^{(i)}| - 1/n\\log|N(x)| , so the (weighted) sum adds up to zero. source # minkowski_map \u2014 Method . minkowski_map ( a :: nf_elem , abs_tol :: Int ) -> Vector { arb } Returns the image of a under the Minkowski embedding. Every entry of the array returned is of type arb with radius less then 2^(-abs_tol) . source # isnegative \u2014 Method . isnegative ( a :: nf_elem , P :: InfPlc ) -> Bool isnegative ( a :: FacElem { nf_elem }, P :: InfPlc ) -> Bool Returns whether the element a is negative at the embedding corresponding to P . The place P must be real. source","title":"Conjugates"},{"location":"number_fields/elements/#predicates","text":"# isintegral \u2014 Method . isintegral ( a :: NumFieldElem ) -> Bool Returns whether a is integral, that is, whether the minimal polynomial of a has integral coefficients. source # istorsion_unit \u2014 Method . istorsion_unit ( x :: nf_elem , checkisunit :: Bool = false ) -> Bool Returns whether x is a torsion unit, that is, whether there exists n such that x^n = 1 . If checkisunit is true , it is first checked whether x is a unit of the maximal order of the number field x is lying in. source # islocal_norm \u2014 Method . islocal_norm ( L :: NumField , a :: NumFieldElem , P ) Given a number field L/K , an element a \\in K and a prime ideal P of K , returns whether a is a local norm at P . The number field L/K must be a simple extension of degree 2. source # isnorm_divisible \u2014 Method . isnorm_divisible ( a :: nf_elem , n :: fmpz ) -> Bool Checks if the norm of a is divisible by n , assuming that the norm of a is an integer. source # isnorm \u2014 Method . isnorm ( K :: AnticNumberField , a :: fmpz ; extra :: Vector { fmpz }) -> Bool , nf_elem For a fmpz a , try to find T \\in K s.th. N(T) = a holds. If successful, return true and T , otherwise false and some element. In \\testtt{extra} one can pass in additional prime numbers that are allowed to occur in the solution. This will then be supplemented. The element will be returned in factored form. source","title":"Predicates"},{"location":"number_fields/elements/#invariants","text":"# norm \u2014 Method . norm ( a :: NumFieldElem ) -> NumFieldElem Returns the norm of an element a of a number field extension L/K . This will be an element of K . source # absolute_norm \u2014 Method . absolute_norm ( a :: NumFieldElem ) -> fmpq Given a number field element a , returns the absolute norm of a . source # minpoly \u2014 Method . minpoly ( a :: NumFieldElem ) -> PolyElem Given a number field element a of a number field K , this function returns the minimal polynomial of a over the base field of K . source # absolute_minpoly \u2014 Method . absolute_minpoly ( a :: NumFieldElem ) -> PolyElem Given a number field element a of a number field K , this function returns the minimal polynomial of a over the rationals \\mathbf{Q} . source # charpoly \u2014 Method . charpoly ( a :: NumFieldElem ) -> PolyElem Given a number field element a of a number field K , this function returns the characteristic polynomial of a over the base field of K . source # absolute_charpoly \u2014 Method . absolute_charpoly ( a :: NumFieldElem ) -> PolyElem Given a number field element a of a number field K , this function returns the characteristic polynomial of a over the rationals \\mathbf{Q} . source # norm \u2014 Method . norm ( a :: NumFieldElem , k :: NumField ) -> NumFieldElem Returns the norm of an element a of a number field L with respect to a subfield k of L . This will be an element of k . source","title":"Invariants"},{"location":"number_fields/fields/","text":"Number field operations Creation of number fields General number fields can be created using the function NumberField , of which number_field is an alias. To create a simple number field given by a defining polynomial or a non-simple number field given by defining polynomials, the following functions can be used. # NumberField \u2014 Method . NumberField ( f :: Poly { NumFieldElem }, s :: String ; cached :: Bool = false , check :: Bool = false ) -> NumField , NumFieldElem Given an irreducible polynomial f \\in K[x] over some number field K , this function creates the simple number field L = K[x]/(f) and returns (L, b) , where b is the class of x in L . The string s is used only for printing the primitive element b . check : Controls whether irreducibility of f is checked. cached : Controls whether the result is cached. Examples julia> K , a = quadratic_field ( 5 ); julia> Kt , t = K [ \"t\" ]; julia> L , b = NumberField ( t ^ 3 - 3 , \"b\" ); source # NumberField \u2014 Method . NumberField ( f :: Vector { PolyElem { <: NumFieldElem }}, s :: String = \"_ \\$ \" , check = true ) -> NumField , Vector { NumFieldElem } Given a list f_1, \\ldots, f_n of univariate polynomials in K[x] over some number field K , constructs the extension K[x_1, \\ldots, x_n]/(f_1(x_1), \\ldots, f_n(x_n)) . Examples julia> Qx , x = QQ [ \"x\" ]; julia> K , a = NumberField ([ x ^ 2 - 2 , x ^ 2 - 3 ], \"a\" ) (Non-simple number field with defining polynomials fmpq_mpoly[x1^2 - 2, x2^2 - 3], NfAbsNSElem[a1, a2]) source Tip Many of the constructors have arguments of type Symbol or AbstractString . If used, they define the appearance in printing, and printing only. The named parameter check can be true or false , the default being true . This parameter controls whether the polynomials defining the number field are tested for irreducibility or not. Given that this can be potentially very time consuming if the degree if large, one can disable this test. Note however, that the behaviour of Hecke is undefined if a reducible polynomial is used to define a field . The named boolean parameter cached can be used to disable caching. Two number fields defined using the same polynomial from the identical polynomial ring and the same (identical) symbol/string will be identical if cached == true and different if cached == false . For frequently used number fields like quadratic fields, cyclotomic fields or radical extensions, the following functions are provided: # cyclotomic_field \u2014 Method . cyclotomic_field ( n :: Int ) -> AnticNumberField , nf_elem The cyclotomic field defined by the n -th cyclotomic polynomial. Examples julia> cyclotomic_field ( 10 ) (Cyclotomic field of order 10, z_10) source # quadratic_field \u2014 Method . quadratic_field ( d :: IntegerUnion ) -> AnticNumberField , nf_elem Returns the field with defining polynomial x^2 - d . Examples julia> quadratic_field ( 5 ) (Real quadratic field defined by x^2 - 5, sqrt(5)) source # wildanger_field \u2014 Method . wildanger_field ( n :: Int , B :: fmpz ) -> AnticNumberField , nf_elem Returns the field with defining polynomial x^n + \\sum_{i=0}^{n-1} (-1)^{n-i}Bx^i . These fields tend to have non-trivial class groups. Examples julia> wildanger_field ( 3 , ZZ ( 10 ), \"a\" ) (Number field over Rational Field with defining polynomial x^3 - 10*x^2 + 10*x - 10, a) source # radical_extension \u2014 Method . radical_extension ( n :: Int , a :: NumFieldElem , s = \"_$\" ; check = true , cached = true ) -> NumField , NumFieldElem Given an element a of a number field K and an integer n , create the simple extension of K with the defining polynomial x^n - a . Examples julia> radical_extension ( 5 , QQ ( 2 ), \"a\" ) (Number field over Rational Field with defining polynomial x^5 - 2, a) source # rationals_as_number_field \u2014 Method . rationals_as_number_field () -> AnticNumberField , nf_elem Returns the rational numbers as the number field defined by x - 1 . Examples julia> rationals_as_number_field () (Number field over Rational Field with defining polynomial x - 1, 1) source Basic properties # basis \u2014 Method . basis ( L :: SimpleNumField ) -> Vector { NumFieldElem } Returns the canonical basis of a simple extension L/K , that is, the elements 1,a,\\dotsc,a^{d - 1} , where d is the degree of K and a the primitive element. Examples julia> Qx , x = QQ [ \"x\" ]; julia> K , a = NumberField ( x ^ 2 - 2 , \"a\" ); julia> basis ( K ) 2-element Vector{nf_elem}: 1 a source # basis \u2014 Method . basis ( L :: NonSimpleNumField ) -> Vector { NumFieldElem } Returns the canonical basis of a non-simple extension L/K . If L = K(a_1,\\dotsc,a_n) where each a_i has degree d_i , then the basis will be a_1^{i_1}\\dotsm a_d^{i_d} with 0 \\leq i_j \\leq d_j - 1 for 1 \\leq j \\leq n . Examples julia> Qx , x = QQ [ \"x\" ]; julia> K , ( a1 , a2 ) = NumberField ([ x ^ 2 - 2 , x ^ 2 - 3 ], \"a\" ); julia> basis ( K ) 4-element Vector{NfAbsNSElem}: 1 a1 a2 a1*a2 source # absolute_basis \u2014 Method . absolute_basis ( K :: NumField ) -> Vector { NumFieldElem } Returns an array of elements that form a basis of K (as a vector space) over the rationals. source # defining_polynomial \u2014 Method . defining_polynomial ( L :: SimpleNumField ) -> PolyElem Given a simple number field L/K , constructed as L = K[x]/(f) , this function returns f . source # defining_polynomials \u2014 Method . defining_polynomials ( L :: NonSimpleNumField ) -> Vector { PolyElem } Given a non-simple number field L/K , constructed as L = K[x]/(f_1,\\dotsc,f_r) , return the vector containing the f_i 's. source # absolute_primitive_element \u2014 Method . absolute_primitive_element ( K :: NumField ) -> NumFieldElem Given a number field K , this function returns an element \\gamma \\in K such that K = \\mathbf{Q}(\\gamma) . source # component \u2014 Method . component ( L :: NonSimpleNumField , i :: Int ) -> SimpleNumField , Map Given a non-simple extension L/K , this function returns the simple number field corresponding to the i -th component of L together with its embedding. source # base_field \u2014 Method . base_field ( L :: NumField ) -> NumField Given a number field L/K this function returns the base field K . For absolute extensions this returns \\mathbf{Q} . source Invariants # degree \u2014 Method . degree ( L :: NumField ) -> Int Given a number field L/K , this function returns the degree of L over K . Examples julia> Qx , x = QQ [ \"x\" ]; julia> K , a = NumberField ( x ^ 2 - 2 , \"a\" ); julia> degree ( K ) 2 source # absolute_degree \u2014 Method . absolute_degree ( L :: NumField ) -> Int Given a number field L/K , this function returns the degree of L over \\mathbf Q . source # signature \u2014 Method . signature ( K :: NumField ) Return the signature of the number field of K . Examples julia> Qx , x = QQ [ \"x\" ]; julia> K , a = NumberField ( x ^ 2 - 2 , \"a\" ); julia> signature ( K ) (2, 0) source # unit_group_rank \u2014 Method . unit_group_rank ( K :: NumField ) -> Int Return the rank of the unit group of any order of K . source # class_number \u2014 Method . class_number ( K :: AnticNumberField ) -> fmpz Returns the class number of K . source # relative_class_number \u2014 Method . relative_class_number ( K :: AnticNumberField ) -> fmpz Returns the relative class number of K . The field must be a CM-field. source # regulator \u2014 Method . regulator ( K :: AnticNumberField ) Computes the regulator of K , i.e. the discriminant of the unit lattice for the maximal order of K . source # discriminant \u2014 Method . discriminant ( L :: SimpleNumField ) -> NumFieldElem The discriminant of the defining polynomial of L , not the discriminant of the maximal order of L . source # absolute_discriminant \u2014 Method . absolute_discriminant ( L :: SimpleNumField , QQ ) -> fmpq The absolute discriminant of the defining polynomial of L , not the discriminant of the maximal order of L . This is the norm of the discriminant times the d -th power of the discriminant of the base field, where d is the degree of L . source Predicates # issimple \u2014 Method . issimple ( L :: NumField ) -> Bool Given a number field L/K this function returns whether L is simple, that is, whether L/K is defined by a univariate polynomial. source # isabsolute \u2014 Method . isabsolute ( L :: NumField ) -> Bool Returns whether L is an absolute extension, that is, whether the base field of L is \\mathbf{Q} . source # istotally_real \u2014 Method . istotally_real ( K :: NumberField ) -> Bool Returns true if and only if K is totally real, that is, if all roots of the defining polynomial are real. source # istotally_complex \u2014 Method . istotally_complex ( K :: AnticNumberField ) -> Bool Returns true if and only if K is totally complex, that is, if all roots of the defining polynomial are not real. source # iscm_field \u2014 Method . iscm_field ( K :: AnticNumberField ) -> Bool , NfToNfMor Given a number field K , this function returns true and the complex conjugation if the field is CM, false and the identity otherwise. source # iskummer_extension \u2014 Method . iskummer_extension ( L :: SimpleNumField ) -> Bool Tests if L/K is a Kummer extension, that is, if the defining polynomial is of the form x^n - b for some b \\in K and if K contains the n -th roots of unity. source # isradical_extension \u2014 Method . isradical_extension ( L :: SimpleNumField ) -> Bool Tests if L/K is pure, that is, if the defining polynomial is of the form x^n - b for some b \\in K . source # islinearly_disjoint \u2014 Method . islinearly_disjoint ( K :: SimpleNumField , L :: SimpleNumField ) -> Bool Given two number fields K and L with the same base field k , this function returns whether K and L are linear disjoint over k . source # isweakly_ramified \u2014 Method . isweakly_ramified ( K :: AnticNumberField , P :: NfOrdIdl ) -> Bool Given a prime ideal P of a number field K , return whether P is weakly ramified, that is, whether the second ramification group is trivial. source # istamely_ramified \u2014 Method . istamely_ramified ( K :: AnticNumberField ) -> Bool Returns whether the number field K is tamely ramified. source # istamely_ramified \u2014 Method . istamely_ramified ( O :: NfOrd , p :: Union { Int , fmpz }) -> Bool Returns whether the integer p is tamely ramified in \\mathcal O . It is assumed that p is prime. source # isabelian \u2014 Method . isabelian ( L :: NumField ) -> Bool Check if the number field L/K is abelian over K . The function is probabilistic and assumes GRH. source Subfields # issubfield \u2014 Method . issubfield ( K :: SimpleNumField , L :: SimpleNumField ) -> Bool , Map Returns true and an injection from K to L if K is a subfield of L . Otherwise the function returns false and a morphism mapping everything to 0 . source # subfields \u2014 Method . subfields ( L :: SimpleNumField ) -> Vector { Tuple { NumField , Map }} Given a simple extension L/K , returns all subfields of L containing K as tuples (k, \\iota) consisting of a simple extension k and an embedding \\iota k \\to K . source # principal_subfields \u2014 Method . principal_subfields ( L :: SimpleNumField ) -> Vector { Tuple { NumField , Map }} Return the principal subfields of L as pairs consisting of a subfield k and an embedding k \\to L . source # compositum \u2014 Method . compositum ( K :: AnticNumberField , L :: AnticNumberField ) -> AnticNumberField , Map , Map Assuming L is normal (which is not checked), compute the compositum C of the 2 fields together with the embedding of K \\to C and L \\to C . source # embedding \u2014 Method . embedding ( k :: NumField , K :: NumField ) -> Map Assuming k is known to be a subfield of K , return the embedding map. source # normal_closure \u2014 Method . normal_closure ( K :: AnticNumberField ) -> AnticNumberField , NfToNfMor The normal closure of K together with the embedding map. source # relative_simple_extension \u2014 Method . relative_simple_extension ( K :: NumField , k :: NumField ) -> NfRel Given two fields K\\supset k , it returns K as a simple relative extension L of k and an isomorphism L \\to K . source # issubfield_normal \u2014 Method . issubfield_normal ( K :: AnticNumberField , L :: AnticNumberField ) -> Bool , NfToNfMor Returns true and an injection from K to L if K is a subfield of L . Otherwise the function returns \"false\" and a morphism mapping everything to 0. This function assumes that K is normal. source Conversion # simplify \u2014 Method . simplify ( K :: AnticNumberField ; canonical :: Bool = false ) -> AnticNumberField , NfToNfMor Tries to find an isomorphic field L given by a \"simpler\" defining polynomial. By default, \"simple\" is defined to be of smaller index, testing is done only using a LLL-basis of the maximal order. If canonical is set to true , then a canonical defining polynomial is found, where canonical is using the definition of PARI's polredabs , which is described in http://beta.lmfdb.org/knowledge/show/nf.polredabs. Both versions require a LLL reduced basis for the maximal order. source # absolute_simple_field \u2014 Method . absolute_simple_field ( K :: NumField ) -> NumField , Map Given a number field K , this function returns an absolute simple number field M/\\mathbf{Q} together with a \\mathbf{Q} -linear isomorphism M \\to K . source # simple_extension \u2014 Method . simple_extension ( L :: NonSimpleNumField ) -> SimpleNumField , Map Given a non-simple extension L/K , this function computes a simple extension M/K and a K -linear isomorphism M \\to L . source # simplified_simple_extension \u2014 Method . simplified_simple_extension ( L :: NonSimpleNumField ) -> SimpleNumField , Map Given a non-simple extension L/K , this function returns an isomorphic simple number field with a \"small\" defining equation together with the isomorphism. source Morphisms # isisomorphic \u2014 Method . isisomorphic ( K :: SimpleNumField , L :: SimpleNumField ) -> Bool , Map Returns true and an isomorphism from K to L if K and L are isomorphic. Otherwise the function returns false and a morphism mapping everything to 0 . source # isinvolution \u2014 Method . isinvolution ( f :: NfToNfMor ) -> Bool Returns true if f is an involution, i.e. if f^2 is the identity, false otherwise. source # fixed_field \u2014 Method . fixed_field ( K :: SimpleNumField , sigma :: Map ; simplify :: Bool = true ) -> NumberField , NfToNfMor Given a number field K and an automorphism \\sigma of K , this function returns the fixed field of \\sigma as a pair (L, i) consisting of a number field L and an embedding of L into K . By default, the function tries to find a small defining polynomial of L . This can be disabled by setting simplify = false . source # automorphisms \u2014 Method . automorphisms ( L :: NumField ) -> Vector { NumFieldMor } Given a number field L/K , return a list of all K -automorphisms of L . source # automorphism_group \u2014 Method . automorphism_group ( K :: NumField ) -> GenGrp , GrpGenToNfMorSet Given a number field K , this function returns a group G and a map from G to the automorphisms of K . source # complex_conjugation \u2014 Method . complex_conjugation ( K :: AnticNumberField ) Given a totally complex normal number field, this function returns an automorphism which is the restriction of complex conjugation at one embedding. source Galois theory # normal_basis \u2014 Method . normal_basis ( L :: NumField ) -> NumFieldElem Given a normal number field L/K , this function returns an element a of L , such that the orbit of a under the Galois group of L/K is an K -basis of L . source # decomposition_group \u2014 Method . decomposition_group ( K :: AnticNumberField , P :: NfOrdIdl , m :: Map ) -> Grp , GrpToGrp Given a prime ideal P of a number field K and a map m return from automorphism_group(K) , return the decompositon group of P as a subgroup of the domain of m . source # ramification_group \u2014 Method . ramification_group ( K :: AnticNumberField , P :: NfOrdIdl , m :: Map ) -> Grp , GrpToGrp Given a prime ideal P of a number field K and a map m return from automorphism_group(K) , return the ramification group of P as a subgroup of the domain of m . source # inertia_subgroup \u2014 Method . inertia_subgroup ( K :: AnticNumberField , P :: NfOrdIdl , m :: Map ) -> Grp , GrpToGrp Given a prime ideal P of a number field K and a map m return from automorphism_group(K) , return the intertia subgroup of P as a subgroup of the domain of m . source Infinite places # infinite_places \u2014 Method . infinite_places ( K :: NumField ) -> Vector { Plc } This function returns all infinite places of K . Examples julia> Qx , x = QQ [ \"x\" ]; julia> K , a = NumberField ( x ^ 2 - 2 , \"a\" ); julia> infinite_places ( K ) 2-element Vector{InfPlc}: Real place of Number field over Rational Field with defining polynomial x^2 - 2 corresponding to the root [-1.414213562373095049 +/- 3.90e-19] Real place of Number field over Rational Field with defining polynomial x^2 - 2 corresponding to the root [1.414213562373095049 +/- 3.90e-19] source # real_places \u2014 Method . real_places ( K :: AnticNumberField ) -> Vector { InfPlc } This function returns all infinite real places of K . source # complex_places \u2014 Method . complex_places ( K :: AnticNumberField ) -> Vector { InfPlc } This function returns all infinite complex places of K . source # isreal \u2014 Method . isreal ( P :: Plc ) Return whether the embedding into \\mathbf{C} defined by P is real or not. source # iscomplex \u2014 Method . iscomplex ( P :: Plc ) -> Bool Return whether the embedding into \\mathbf{C} defined by P is complex or not. source # infinite_places_uniformizers \u2014 Method . infinite_places_uniformizers ( K :: AnticNumberField ) Returns a dictionary having as keys the real places of K and the values are uniformizers for the corresponding real place. A uniformizer of a real place P is an element of the field which is negative at P and positive at all the other real places. source Miscellaneous # norm_equation \u2014 Method . norm_equation ( K :: AnticNumerField , a ) -> nf_elem For a an integer or rational, try to find T \\in K s.th. N(T) = a . Raises an error if unsuccessful. source # lorenz_module \u2014 Method . lorenz_module ( k :: AnticNumberField , n :: Int ) -> NfOrdIdl Finds an ideal A s.th. for all positive units e = 1 \\bmod A we have that e is an n -th power. Uses Lorenz, number theory, 9.3.1. If containing is set, it has to be an integral ideal. The resulting ideal will be a multiple of this. source # kummer_failure \u2014 Method . kummer_failure ( x :: nf_elem , M :: Int , N :: Int ) -> Int Computes the quotient of N and [K(\\zeta_M, \\sqrt[N](x))\\colon K(\\zeta_M)] , where K is the field containing x and N divides M . source # isdefining_polynomial_nice \u2014 Method . isdefining_polynomial_nice ( K :: AnticNumberField ) Tests if the defining polynomial of K is integral and monic. source","title":"Number field operations"},{"location":"number_fields/fields/#number-field-operations","text":"","title":"Number field operations"},{"location":"number_fields/fields/#creation-of-number-fields","text":"General number fields can be created using the function NumberField , of which number_field is an alias. To create a simple number field given by a defining polynomial or a non-simple number field given by defining polynomials, the following functions can be used. # NumberField \u2014 Method . NumberField ( f :: Poly { NumFieldElem }, s :: String ; cached :: Bool = false , check :: Bool = false ) -> NumField , NumFieldElem Given an irreducible polynomial f \\in K[x] over some number field K , this function creates the simple number field L = K[x]/(f) and returns (L, b) , where b is the class of x in L . The string s is used only for printing the primitive element b . check : Controls whether irreducibility of f is checked. cached : Controls whether the result is cached. Examples julia> K , a = quadratic_field ( 5 ); julia> Kt , t = K [ \"t\" ]; julia> L , b = NumberField ( t ^ 3 - 3 , \"b\" ); source # NumberField \u2014 Method . NumberField ( f :: Vector { PolyElem { <: NumFieldElem }}, s :: String = \"_ \\$ \" , check = true ) -> NumField , Vector { NumFieldElem } Given a list f_1, \\ldots, f_n of univariate polynomials in K[x] over some number field K , constructs the extension K[x_1, \\ldots, x_n]/(f_1(x_1), \\ldots, f_n(x_n)) . Examples julia> Qx , x = QQ [ \"x\" ]; julia> K , a = NumberField ([ x ^ 2 - 2 , x ^ 2 - 3 ], \"a\" ) (Non-simple number field with defining polynomials fmpq_mpoly[x1^2 - 2, x2^2 - 3], NfAbsNSElem[a1, a2]) source Tip Many of the constructors have arguments of type Symbol or AbstractString . If used, they define the appearance in printing, and printing only. The named parameter check can be true or false , the default being true . This parameter controls whether the polynomials defining the number field are tested for irreducibility or not. Given that this can be potentially very time consuming if the degree if large, one can disable this test. Note however, that the behaviour of Hecke is undefined if a reducible polynomial is used to define a field . The named boolean parameter cached can be used to disable caching. Two number fields defined using the same polynomial from the identical polynomial ring and the same (identical) symbol/string will be identical if cached == true and different if cached == false . For frequently used number fields like quadratic fields, cyclotomic fields or radical extensions, the following functions are provided: # cyclotomic_field \u2014 Method . cyclotomic_field ( n :: Int ) -> AnticNumberField , nf_elem The cyclotomic field defined by the n -th cyclotomic polynomial. Examples julia> cyclotomic_field ( 10 ) (Cyclotomic field of order 10, z_10) source # quadratic_field \u2014 Method . quadratic_field ( d :: IntegerUnion ) -> AnticNumberField , nf_elem Returns the field with defining polynomial x^2 - d . Examples julia> quadratic_field ( 5 ) (Real quadratic field defined by x^2 - 5, sqrt(5)) source # wildanger_field \u2014 Method . wildanger_field ( n :: Int , B :: fmpz ) -> AnticNumberField , nf_elem Returns the field with defining polynomial x^n + \\sum_{i=0}^{n-1} (-1)^{n-i}Bx^i . These fields tend to have non-trivial class groups. Examples julia> wildanger_field ( 3 , ZZ ( 10 ), \"a\" ) (Number field over Rational Field with defining polynomial x^3 - 10*x^2 + 10*x - 10, a) source # radical_extension \u2014 Method . radical_extension ( n :: Int , a :: NumFieldElem , s = \"_$\" ; check = true , cached = true ) -> NumField , NumFieldElem Given an element a of a number field K and an integer n , create the simple extension of K with the defining polynomial x^n - a . Examples julia> radical_extension ( 5 , QQ ( 2 ), \"a\" ) (Number field over Rational Field with defining polynomial x^5 - 2, a) source # rationals_as_number_field \u2014 Method . rationals_as_number_field () -> AnticNumberField , nf_elem Returns the rational numbers as the number field defined by x - 1 . Examples julia> rationals_as_number_field () (Number field over Rational Field with defining polynomial x - 1, 1) source","title":"Creation of number fields"},{"location":"number_fields/fields/#basic-properties","text":"# basis \u2014 Method . basis ( L :: SimpleNumField ) -> Vector { NumFieldElem } Returns the canonical basis of a simple extension L/K , that is, the elements 1,a,\\dotsc,a^{d - 1} , where d is the degree of K and a the primitive element. Examples julia> Qx , x = QQ [ \"x\" ]; julia> K , a = NumberField ( x ^ 2 - 2 , \"a\" ); julia> basis ( K ) 2-element Vector{nf_elem}: 1 a source # basis \u2014 Method . basis ( L :: NonSimpleNumField ) -> Vector { NumFieldElem } Returns the canonical basis of a non-simple extension L/K . If L = K(a_1,\\dotsc,a_n) where each a_i has degree d_i , then the basis will be a_1^{i_1}\\dotsm a_d^{i_d} with 0 \\leq i_j \\leq d_j - 1 for 1 \\leq j \\leq n . Examples julia> Qx , x = QQ [ \"x\" ]; julia> K , ( a1 , a2 ) = NumberField ([ x ^ 2 - 2 , x ^ 2 - 3 ], \"a\" ); julia> basis ( K ) 4-element Vector{NfAbsNSElem}: 1 a1 a2 a1*a2 source # absolute_basis \u2014 Method . absolute_basis ( K :: NumField ) -> Vector { NumFieldElem } Returns an array of elements that form a basis of K (as a vector space) over the rationals. source # defining_polynomial \u2014 Method . defining_polynomial ( L :: SimpleNumField ) -> PolyElem Given a simple number field L/K , constructed as L = K[x]/(f) , this function returns f . source # defining_polynomials \u2014 Method . defining_polynomials ( L :: NonSimpleNumField ) -> Vector { PolyElem } Given a non-simple number field L/K , constructed as L = K[x]/(f_1,\\dotsc,f_r) , return the vector containing the f_i 's. source # absolute_primitive_element \u2014 Method . absolute_primitive_element ( K :: NumField ) -> NumFieldElem Given a number field K , this function returns an element \\gamma \\in K such that K = \\mathbf{Q}(\\gamma) . source # component \u2014 Method . component ( L :: NonSimpleNumField , i :: Int ) -> SimpleNumField , Map Given a non-simple extension L/K , this function returns the simple number field corresponding to the i -th component of L together with its embedding. source # base_field \u2014 Method . base_field ( L :: NumField ) -> NumField Given a number field L/K this function returns the base field K . For absolute extensions this returns \\mathbf{Q} . source","title":"Basic properties"},{"location":"number_fields/fields/#invariants","text":"# degree \u2014 Method . degree ( L :: NumField ) -> Int Given a number field L/K , this function returns the degree of L over K . Examples julia> Qx , x = QQ [ \"x\" ]; julia> K , a = NumberField ( x ^ 2 - 2 , \"a\" ); julia> degree ( K ) 2 source # absolute_degree \u2014 Method . absolute_degree ( L :: NumField ) -> Int Given a number field L/K , this function returns the degree of L over \\mathbf Q . source # signature \u2014 Method . signature ( K :: NumField ) Return the signature of the number field of K . Examples julia> Qx , x = QQ [ \"x\" ]; julia> K , a = NumberField ( x ^ 2 - 2 , \"a\" ); julia> signature ( K ) (2, 0) source # unit_group_rank \u2014 Method . unit_group_rank ( K :: NumField ) -> Int Return the rank of the unit group of any order of K . source # class_number \u2014 Method . class_number ( K :: AnticNumberField ) -> fmpz Returns the class number of K . source # relative_class_number \u2014 Method . relative_class_number ( K :: AnticNumberField ) -> fmpz Returns the relative class number of K . The field must be a CM-field. source # regulator \u2014 Method . regulator ( K :: AnticNumberField ) Computes the regulator of K , i.e. the discriminant of the unit lattice for the maximal order of K . source # discriminant \u2014 Method . discriminant ( L :: SimpleNumField ) -> NumFieldElem The discriminant of the defining polynomial of L , not the discriminant of the maximal order of L . source # absolute_discriminant \u2014 Method . absolute_discriminant ( L :: SimpleNumField , QQ ) -> fmpq The absolute discriminant of the defining polynomial of L , not the discriminant of the maximal order of L . This is the norm of the discriminant times the d -th power of the discriminant of the base field, where d is the degree of L . source","title":"Invariants"},{"location":"number_fields/fields/#predicates","text":"# issimple \u2014 Method . issimple ( L :: NumField ) -> Bool Given a number field L/K this function returns whether L is simple, that is, whether L/K is defined by a univariate polynomial. source # isabsolute \u2014 Method . isabsolute ( L :: NumField ) -> Bool Returns whether L is an absolute extension, that is, whether the base field of L is \\mathbf{Q} . source # istotally_real \u2014 Method . istotally_real ( K :: NumberField ) -> Bool Returns true if and only if K is totally real, that is, if all roots of the defining polynomial are real. source # istotally_complex \u2014 Method . istotally_complex ( K :: AnticNumberField ) -> Bool Returns true if and only if K is totally complex, that is, if all roots of the defining polynomial are not real. source # iscm_field \u2014 Method . iscm_field ( K :: AnticNumberField ) -> Bool , NfToNfMor Given a number field K , this function returns true and the complex conjugation if the field is CM, false and the identity otherwise. source # iskummer_extension \u2014 Method . iskummer_extension ( L :: SimpleNumField ) -> Bool Tests if L/K is a Kummer extension, that is, if the defining polynomial is of the form x^n - b for some b \\in K and if K contains the n -th roots of unity. source # isradical_extension \u2014 Method . isradical_extension ( L :: SimpleNumField ) -> Bool Tests if L/K is pure, that is, if the defining polynomial is of the form x^n - b for some b \\in K . source # islinearly_disjoint \u2014 Method . islinearly_disjoint ( K :: SimpleNumField , L :: SimpleNumField ) -> Bool Given two number fields K and L with the same base field k , this function returns whether K and L are linear disjoint over k . source # isweakly_ramified \u2014 Method . isweakly_ramified ( K :: AnticNumberField , P :: NfOrdIdl ) -> Bool Given a prime ideal P of a number field K , return whether P is weakly ramified, that is, whether the second ramification group is trivial. source # istamely_ramified \u2014 Method . istamely_ramified ( K :: AnticNumberField ) -> Bool Returns whether the number field K is tamely ramified. source # istamely_ramified \u2014 Method . istamely_ramified ( O :: NfOrd , p :: Union { Int , fmpz }) -> Bool Returns whether the integer p is tamely ramified in \\mathcal O . It is assumed that p is prime. source # isabelian \u2014 Method . isabelian ( L :: NumField ) -> Bool Check if the number field L/K is abelian over K . The function is probabilistic and assumes GRH. source","title":"Predicates"},{"location":"number_fields/fields/#subfields","text":"# issubfield \u2014 Method . issubfield ( K :: SimpleNumField , L :: SimpleNumField ) -> Bool , Map Returns true and an injection from K to L if K is a subfield of L . Otherwise the function returns false and a morphism mapping everything to 0 . source # subfields \u2014 Method . subfields ( L :: SimpleNumField ) -> Vector { Tuple { NumField , Map }} Given a simple extension L/K , returns all subfields of L containing K as tuples (k, \\iota) consisting of a simple extension k and an embedding \\iota k \\to K . source # principal_subfields \u2014 Method . principal_subfields ( L :: SimpleNumField ) -> Vector { Tuple { NumField , Map }} Return the principal subfields of L as pairs consisting of a subfield k and an embedding k \\to L . source # compositum \u2014 Method . compositum ( K :: AnticNumberField , L :: AnticNumberField ) -> AnticNumberField , Map , Map Assuming L is normal (which is not checked), compute the compositum C of the 2 fields together with the embedding of K \\to C and L \\to C . source # embedding \u2014 Method . embedding ( k :: NumField , K :: NumField ) -> Map Assuming k is known to be a subfield of K , return the embedding map. source # normal_closure \u2014 Method . normal_closure ( K :: AnticNumberField ) -> AnticNumberField , NfToNfMor The normal closure of K together with the embedding map. source # relative_simple_extension \u2014 Method . relative_simple_extension ( K :: NumField , k :: NumField ) -> NfRel Given two fields K\\supset k , it returns K as a simple relative extension L of k and an isomorphism L \\to K . source # issubfield_normal \u2014 Method . issubfield_normal ( K :: AnticNumberField , L :: AnticNumberField ) -> Bool , NfToNfMor Returns true and an injection from K to L if K is a subfield of L . Otherwise the function returns \"false\" and a morphism mapping everything to 0. This function assumes that K is normal. source","title":"Subfields"},{"location":"number_fields/fields/#conversion","text":"# simplify \u2014 Method . simplify ( K :: AnticNumberField ; canonical :: Bool = false ) -> AnticNumberField , NfToNfMor Tries to find an isomorphic field L given by a \"simpler\" defining polynomial. By default, \"simple\" is defined to be of smaller index, testing is done only using a LLL-basis of the maximal order. If canonical is set to true , then a canonical defining polynomial is found, where canonical is using the definition of PARI's polredabs , which is described in http://beta.lmfdb.org/knowledge/show/nf.polredabs. Both versions require a LLL reduced basis for the maximal order. source # absolute_simple_field \u2014 Method . absolute_simple_field ( K :: NumField ) -> NumField , Map Given a number field K , this function returns an absolute simple number field M/\\mathbf{Q} together with a \\mathbf{Q} -linear isomorphism M \\to K . source # simple_extension \u2014 Method . simple_extension ( L :: NonSimpleNumField ) -> SimpleNumField , Map Given a non-simple extension L/K , this function computes a simple extension M/K and a K -linear isomorphism M \\to L . source # simplified_simple_extension \u2014 Method . simplified_simple_extension ( L :: NonSimpleNumField ) -> SimpleNumField , Map Given a non-simple extension L/K , this function returns an isomorphic simple number field with a \"small\" defining equation together with the isomorphism. source","title":"Conversion"},{"location":"number_fields/fields/#morphisms","text":"# isisomorphic \u2014 Method . isisomorphic ( K :: SimpleNumField , L :: SimpleNumField ) -> Bool , Map Returns true and an isomorphism from K to L if K and L are isomorphic. Otherwise the function returns false and a morphism mapping everything to 0 . source # isinvolution \u2014 Method . isinvolution ( f :: NfToNfMor ) -> Bool Returns true if f is an involution, i.e. if f^2 is the identity, false otherwise. source # fixed_field \u2014 Method . fixed_field ( K :: SimpleNumField , sigma :: Map ; simplify :: Bool = true ) -> NumberField , NfToNfMor Given a number field K and an automorphism \\sigma of K , this function returns the fixed field of \\sigma as a pair (L, i) consisting of a number field L and an embedding of L into K . By default, the function tries to find a small defining polynomial of L . This can be disabled by setting simplify = false . source # automorphisms \u2014 Method . automorphisms ( L :: NumField ) -> Vector { NumFieldMor } Given a number field L/K , return a list of all K -automorphisms of L . source # automorphism_group \u2014 Method . automorphism_group ( K :: NumField ) -> GenGrp , GrpGenToNfMorSet Given a number field K , this function returns a group G and a map from G to the automorphisms of K . source # complex_conjugation \u2014 Method . complex_conjugation ( K :: AnticNumberField ) Given a totally complex normal number field, this function returns an automorphism which is the restriction of complex conjugation at one embedding. source","title":"Morphisms"},{"location":"number_fields/fields/#galois-theory","text":"# normal_basis \u2014 Method . normal_basis ( L :: NumField ) -> NumFieldElem Given a normal number field L/K , this function returns an element a of L , such that the orbit of a under the Galois group of L/K is an K -basis of L . source # decomposition_group \u2014 Method . decomposition_group ( K :: AnticNumberField , P :: NfOrdIdl , m :: Map ) -> Grp , GrpToGrp Given a prime ideal P of a number field K and a map m return from automorphism_group(K) , return the decompositon group of P as a subgroup of the domain of m . source # ramification_group \u2014 Method . ramification_group ( K :: AnticNumberField , P :: NfOrdIdl , m :: Map ) -> Grp , GrpToGrp Given a prime ideal P of a number field K and a map m return from automorphism_group(K) , return the ramification group of P as a subgroup of the domain of m . source # inertia_subgroup \u2014 Method . inertia_subgroup ( K :: AnticNumberField , P :: NfOrdIdl , m :: Map ) -> Grp , GrpToGrp Given a prime ideal P of a number field K and a map m return from automorphism_group(K) , return the intertia subgroup of P as a subgroup of the domain of m . source","title":"Galois theory"},{"location":"number_fields/fields/#infinite-places","text":"# infinite_places \u2014 Method . infinite_places ( K :: NumField ) -> Vector { Plc } This function returns all infinite places of K . Examples julia> Qx , x = QQ [ \"x\" ]; julia> K , a = NumberField ( x ^ 2 - 2 , \"a\" ); julia> infinite_places ( K ) 2-element Vector{InfPlc}: Real place of Number field over Rational Field with defining polynomial x^2 - 2 corresponding to the root [-1.414213562373095049 +/- 3.90e-19] Real place of Number field over Rational Field with defining polynomial x^2 - 2 corresponding to the root [1.414213562373095049 +/- 3.90e-19] source # real_places \u2014 Method . real_places ( K :: AnticNumberField ) -> Vector { InfPlc } This function returns all infinite real places of K . source # complex_places \u2014 Method . complex_places ( K :: AnticNumberField ) -> Vector { InfPlc } This function returns all infinite complex places of K . source # isreal \u2014 Method . isreal ( P :: Plc ) Return whether the embedding into \\mathbf{C} defined by P is real or not. source # iscomplex \u2014 Method . iscomplex ( P :: Plc ) -> Bool Return whether the embedding into \\mathbf{C} defined by P is complex or not. source # infinite_places_uniformizers \u2014 Method . infinite_places_uniformizers ( K :: AnticNumberField ) Returns a dictionary having as keys the real places of K and the values are uniformizers for the corresponding real place. A uniformizer of a real place P is an element of the field which is negative at P and positive at all the other real places. source","title":"Infinite places"},{"location":"number_fields/fields/#miscellaneous","text":"# norm_equation \u2014 Method . norm_equation ( K :: AnticNumerField , a ) -> nf_elem For a an integer or rational, try to find T \\in K s.th. N(T) = a . Raises an error if unsuccessful. source # lorenz_module \u2014 Method . lorenz_module ( k :: AnticNumberField , n :: Int ) -> NfOrdIdl Finds an ideal A s.th. for all positive units e = 1 \\bmod A we have that e is an n -th power. Uses Lorenz, number theory, 9.3.1. If containing is set, it has to be an integral ideal. The resulting ideal will be a multiple of this. source # kummer_failure \u2014 Method . kummer_failure ( x :: nf_elem , M :: Int , N :: Int ) -> Int Computes the quotient of N and [K(\\zeta_M, \\sqrt[N](x))\\colon K(\\zeta_M)] , where K is the field containing x and N divides M . source # isdefining_polynomial_nice \u2014 Method . isdefining_polynomial_nice ( K :: AnticNumberField ) Tests if the defining polynomial of K is integral and monic. source","title":"Miscellaneous"},{"location":"number_fields/internal/","text":"Internals Types of number fields Number fields, in Hecke, come in several different types: AnticNumberField : a finite simple extension of the rational numbers \\mathbf{Q} NfAbsNS : a finite extension of \\mathbf{Q} given by several polynomials. We will refer to this as a non-simple field - even though mathematically we can find a primitive elements. NfRel : a finite simple extension of a number field. This is actually parametried by the (element) type of the coefficient field. The complete type of an extension of an absolute field ( AnticNumberField ) is NfRel{nf_elem} . The next extension thus will be NfRel{NfRelElem{nf_elem}} . NfRelNS : extensions of number fields given by several polynomials. This too will be refered to as a non-simple field. The simple types AnticNumberField and NfRel are also calle simple fields in the rest of this document, NfRel and NfRelNS are referred to as relative extensions while AnticNumberField and NfAbsNS are called absolute. Internally, simple fields are essentially just (univariate) polynomial quotients in a dense representation, while non-simple fields are multivariate quotient rings, thus have a sparse presentation. In general, simple fields allow much faster arithmetic, while the non-simple fields give easy access to large degree fields. Absolute simple fields The most basic number field type is that of AnticNumberField . Internally this is essentially represented as a unvariate quotient with the arithmetic provided by the C-library antic with the binding provided by Nemo.","title":"Internals"},{"location":"number_fields/internal/#internals","text":"","title":"Internals"},{"location":"number_fields/internal/#types-of-number-fields","text":"Number fields, in Hecke, come in several different types: AnticNumberField : a finite simple extension of the rational numbers \\mathbf{Q} NfAbsNS : a finite extension of \\mathbf{Q} given by several polynomials. We will refer to this as a non-simple field - even though mathematically we can find a primitive elements. NfRel : a finite simple extension of a number field. This is actually parametried by the (element) type of the coefficient field. The complete type of an extension of an absolute field ( AnticNumberField ) is NfRel{nf_elem} . The next extension thus will be NfRel{NfRelElem{nf_elem}} . NfRelNS : extensions of number fields given by several polynomials. This too will be refered to as a non-simple field. The simple types AnticNumberField and NfRel are also calle simple fields in the rest of this document, NfRel and NfRelNS are referred to as relative extensions while AnticNumberField and NfAbsNS are called absolute. Internally, simple fields are essentially just (univariate) polynomial quotients in a dense representation, while non-simple fields are multivariate quotient rings, thus have a sparse presentation. In general, simple fields allow much faster arithmetic, while the non-simple fields give easy access to large degree fields.","title":"Types of number fields"},{"location":"number_fields/internal/#absolute-simple-fields","text":"The most basic number field type is that of AnticNumberField . Internally this is essentially represented as a unvariate quotient with the arithmetic provided by the C-library antic with the binding provided by Nemo.","title":"Absolute simple fields"},{"location":"number_fields/intro/","text":"Introduction By definition, mathematically a number field is just a finite extension of the rational \\mathbf{Q} . In Hecke, a number field L is recursively defined as being the field of rational numbers \\mathbf{Q} or a finite extension of a number field K . In the second case, the extension can be defined in the one of the following two ways: We have L = K[x]/(f) , where f \\in K[x] is an irreducible polynomial ( simple extension ), or We have L = K[x_1,\\dotsc,x_n]/(f_1(x_1),\\dotsc,f_n(x_n)) , where f_1,\\dotsc,f_n \\in K[x] are univariate polynomials ( non-simple extension ). In both cases we refer to K as the base field of the number field L . Another useful dichotomy comes from the type of the base field. We call L an absolute number field, if the base field is equal to the rational numbers \\mathbf{Q} .","title":"Introduction"},{"location":"number_fields/intro/#introduction","text":"By definition, mathematically a number field is just a finite extension of the rational \\mathbf{Q} . In Hecke, a number field L is recursively defined as being the field of rational numbers \\mathbf{Q} or a finite extension of a number field K . In the second case, the extension can be defined in the one of the following two ways: We have L = K[x]/(f) , where f \\in K[x] is an irreducible polynomial ( simple extension ), or We have L = K[x_1,\\dotsc,x_n]/(f_1(x_1),\\dotsc,f_n(x_n)) , where f_1,\\dotsc,f_n \\in K[x] are univariate polynomials ( non-simple extension ). In both cases we refer to K as the base field of the number field L . Another useful dichotomy comes from the type of the base field. We call L an absolute number field, if the base field is equal to the rational numbers \\mathbf{Q} .","title":"Introduction"},{"location":"orders/elements/","text":"Elements Elements in orders have two representations: they can be viewed as elements in the \\mathbf Z^n giving the coefficients wrt to the order basis where they are elements in. On the other hand, as every order is in a field, they also have a representation as number field elements. Since, asymptotically, operations are more efficient in the field (due to fast polynomial arithmetic) than in the order, the primary representation is that as a field element. Creation Elements are constructed either as linear combinations of basis elements or via explicit coercion. Elements will be of type NfAbsOrdElem , the type if actually parametrized by the type of the surrounding field and the type of the field elements. E.g. the type of any element in any order of an absolute simple field will be NfAbsOrdElem{AnticNumberField,nf_elem} # NfAbsOrd \u2014 Type . ( O :: NumFieldOrd )( a :: IntegerUnion ) -> NumFieldOrdElem Given an element a of type fmpz or Integer , this function coerces the element into \\mathcal O . source (O::NfAbsOrd)(arr::Vector{fmpz}) Returns the element of \\mathcal O with coefficient vector arr . source Basic properties # parent \u2014 Method . parent ( a :: NumFieldOrdElem ) -> NumFieldOrd Returns the order of which a is an element. source # elem_in_nf \u2014 Method . elem_in_nf ( a :: NumFieldOrdElem ) -> NumFieldElem Returns the element a considered as an element of the ambient number field. source # coordinates \u2014 Method . coordinates ( a :: NfAbsOrdElem ) -> Vector { fmpz } Returns the coefficient vector of a with respect to the basis of the order. source # discriminant \u2014 Method . discriminant ( B :: Vector { NumFieldOrdElem }) Returns the discriminant of the family B of algebraic numbers, i.e. det((tr(B[i]*B[j]))_{i, j})^2 . source discriminant(E::EllCrv{T}) -> T Computes the discriminant of E . source discriminant(O::AlgssRelOrd) Returns the discriminant of O . source # == \u2014 Method . == ( x :: NumFieldOrdElem , y :: NumFieldOrdElem ) -> Bool Returns whether x and y are equal. source Arithmetic All the usual arithmetic operatinos are defined: -(::NUmFieldOrdElem) +(::NumFieldOrdElem, ::NumFieldOrdElem) -(::NumFieldOrdElem, ::NumFieldOrdElem) *(::NumFieldOrdElem, ::NumFieldOrdElem) ^(::NumFieldOrdElem, ::Int) mod(::NfAbsOrdElem, ::Int) mod_sym(::NumFieldOrdElem, ::fmpz) powermod(::NfAbsOrdElem, ::fmpz, ::Int) Miscellaneous # representation_matrix \u2014 Method . representation_matrix ( a :: NfAbsOrdElem ) -> fmpz_mat Returns the representation matrix of the element a . source # representation_matrix \u2014 Method . representation_matrix ( a :: NfAbsOrdElem , K :: AnticNumberField ) -> FakeFmpqMat Returns the representation matrix of the element a considered as an element of the ambient number field K . It is assumed that K is the ambient number field of the order of a . source # tr \u2014 Method . tr ( a :: NumFieldOrdElem ) Returns the trace of a as an element of the base ring. source # norm \u2014 Method . norm ( a :: NumFieldOrdElem ) Returns the norm of a as an element in the base ring. source # absolute_norm \u2014 Method . absolute_norm ( a :: NumFieldOrdElem ) -> fmpz Return the absolute norm as an integer. source # absolute_tr \u2014 Method . absolute_tr ( a :: NumFieldOrdElem ) -> fmpz Return the absolute trace as an integer. source # rand \u2014 Method . rand ( O :: NfOrd , n :: IntegerUnion ) -> NfAbsOrdElem Computes a coefficient vector with entries uniformly distributed in \\{-n,\\dotsc,-1,0,1,\\dotsc,n\\} and returns the corresponding element of the order \\mathcal O . source # minkowski_map \u2014 Method . minkowski_map ( a :: NumFieldOrdElem , abs_tol :: Int ) -> Vector { arb } Returns the image of a under the Minkowski embedding. Every entry of the array returned is of type arb with radius less then 2^-abs_tol . source # conjugates_arb \u2014 Method . conjugates_arb ( x :: NumFieldOrdElem , abs_tol :: Int ) -> Vector { acb } Compute the conjugates of x as elements of type acb . Recall that we order the complex conjugates \\sigma_{r+1}(x),...,\\sigma_{r+2s}(x) such that \\sigma_{i}(x) = \\overline{\\sigma_{i + s}(x)} for r + 2 \\leq i \\leq r + s . Every entry y of the array returned satisfies radius(real(y)) < 2^-abs_tol , radius(imag(y)) < 2^-abs_tol respectively. source # conjugates_arb_log \u2014 Method . conjugates_arb_log ( x :: NumFieldOrdElem , abs_tol :: Int ) -> Vector { arb } Returns the elements (\\log(\\lvert \\sigma_1(x) \\rvert),\\dotsc,\\log(\\lvert\\sigma_r(x) \\rvert), \\dotsc,2\\log(\\lvert \\sigma_{r+1}(x) \\rvert),\\dotsc, 2\\log(\\lvert \\sigma_{r+s}(x)\\rvert)) as elements of type arb radius less then 2^-abs_tol . source # t2 \u2014 Method . t2 ( x :: NumFieldOrdElem , abs_tol :: Int = 32 ) -> arb Return the T_2 -norm of x . The radius of the result will be less than 2^-abs_tol . source # minpoly \u2014 Method . minpoly ( a :: NfAbsOrdElem ) -> fmpz_poly The minimal polynomial of a . source # charpoly \u2014 Method . charpoly ( a :: NfAbsOrdElem ) -> fmpz_poly charpoly ( a :: NfAbsOrdElem , FlintZZ ) -> fmpz_poly The characteristic polynomial of a . source # factor \u2014 Method . factor ( a :: NfOrdElem ) -> Fac { NfOrdElem } Computes a factorization of a into irreducible elements. The return value is a factorization fac , which satisfies a = unit(fac) * prod(p^e for (p, e) in fac) . The function requires that a is non-zero and that all prime ideals containing a are principal, which is for example satisfied if class group of the order of a is trivial. source # denominator \u2014 Method . denominator ( a :: NumFieldElem , O :: NfOrd ) -> fmpz Returns the smallest positive integer k such that k \\cdot a is contained in \\mathcal O . source # discriminant \u2014 Method . discriminant ( B :: Vector { NumFieldOrdElem }) Returns the discriminant of the family B of algebraic numbers, i.e. det((tr(B[i]*B[j]))_{i, j})^2 . source discriminant(E::EllCrv{T}) -> T Computes the discriminant of E . source discriminant(O::AlgssRelOrd) Returns the discriminant of O . source","title":"Elements"},{"location":"orders/elements/#elements","text":"Elements in orders have two representations: they can be viewed as elements in the \\mathbf Z^n giving the coefficients wrt to the order basis where they are elements in. On the other hand, as every order is in a field, they also have a representation as number field elements. Since, asymptotically, operations are more efficient in the field (due to fast polynomial arithmetic) than in the order, the primary representation is that as a field element.","title":"Elements"},{"location":"orders/elements/#creation","text":"Elements are constructed either as linear combinations of basis elements or via explicit coercion. Elements will be of type NfAbsOrdElem , the type if actually parametrized by the type of the surrounding field and the type of the field elements. E.g. the type of any element in any order of an absolute simple field will be NfAbsOrdElem{AnticNumberField,nf_elem} # NfAbsOrd \u2014 Type . ( O :: NumFieldOrd )( a :: IntegerUnion ) -> NumFieldOrdElem Given an element a of type fmpz or Integer , this function coerces the element into \\mathcal O . source (O::NfAbsOrd)(arr::Vector{fmpz}) Returns the element of \\mathcal O with coefficient vector arr . source","title":"Creation"},{"location":"orders/elements/#basic-properties","text":"# parent \u2014 Method . parent ( a :: NumFieldOrdElem ) -> NumFieldOrd Returns the order of which a is an element. source # elem_in_nf \u2014 Method . elem_in_nf ( a :: NumFieldOrdElem ) -> NumFieldElem Returns the element a considered as an element of the ambient number field. source # coordinates \u2014 Method . coordinates ( a :: NfAbsOrdElem ) -> Vector { fmpz } Returns the coefficient vector of a with respect to the basis of the order. source # discriminant \u2014 Method . discriminant ( B :: Vector { NumFieldOrdElem }) Returns the discriminant of the family B of algebraic numbers, i.e. det((tr(B[i]*B[j]))_{i, j})^2 . source discriminant(E::EllCrv{T}) -> T Computes the discriminant of E . source discriminant(O::AlgssRelOrd) Returns the discriminant of O . source # == \u2014 Method . == ( x :: NumFieldOrdElem , y :: NumFieldOrdElem ) -> Bool Returns whether x and y are equal. source","title":"Basic properties"},{"location":"orders/elements/#arithmetic","text":"All the usual arithmetic operatinos are defined: -(::NUmFieldOrdElem) +(::NumFieldOrdElem, ::NumFieldOrdElem) -(::NumFieldOrdElem, ::NumFieldOrdElem) *(::NumFieldOrdElem, ::NumFieldOrdElem) ^(::NumFieldOrdElem, ::Int) mod(::NfAbsOrdElem, ::Int) mod_sym(::NumFieldOrdElem, ::fmpz) powermod(::NfAbsOrdElem, ::fmpz, ::Int)","title":"Arithmetic"},{"location":"orders/elements/#miscellaneous","text":"# representation_matrix \u2014 Method . representation_matrix ( a :: NfAbsOrdElem ) -> fmpz_mat Returns the representation matrix of the element a . source # representation_matrix \u2014 Method . representation_matrix ( a :: NfAbsOrdElem , K :: AnticNumberField ) -> FakeFmpqMat Returns the representation matrix of the element a considered as an element of the ambient number field K . It is assumed that K is the ambient number field of the order of a . source # tr \u2014 Method . tr ( a :: NumFieldOrdElem ) Returns the trace of a as an element of the base ring. source # norm \u2014 Method . norm ( a :: NumFieldOrdElem ) Returns the norm of a as an element in the base ring. source # absolute_norm \u2014 Method . absolute_norm ( a :: NumFieldOrdElem ) -> fmpz Return the absolute norm as an integer. source # absolute_tr \u2014 Method . absolute_tr ( a :: NumFieldOrdElem ) -> fmpz Return the absolute trace as an integer. source # rand \u2014 Method . rand ( O :: NfOrd , n :: IntegerUnion ) -> NfAbsOrdElem Computes a coefficient vector with entries uniformly distributed in \\{-n,\\dotsc,-1,0,1,\\dotsc,n\\} and returns the corresponding element of the order \\mathcal O . source # minkowski_map \u2014 Method . minkowski_map ( a :: NumFieldOrdElem , abs_tol :: Int ) -> Vector { arb } Returns the image of a under the Minkowski embedding. Every entry of the array returned is of type arb with radius less then 2^-abs_tol . source # conjugates_arb \u2014 Method . conjugates_arb ( x :: NumFieldOrdElem , abs_tol :: Int ) -> Vector { acb } Compute the conjugates of x as elements of type acb . Recall that we order the complex conjugates \\sigma_{r+1}(x),...,\\sigma_{r+2s}(x) such that \\sigma_{i}(x) = \\overline{\\sigma_{i + s}(x)} for r + 2 \\leq i \\leq r + s . Every entry y of the array returned satisfies radius(real(y)) < 2^-abs_tol , radius(imag(y)) < 2^-abs_tol respectively. source # conjugates_arb_log \u2014 Method . conjugates_arb_log ( x :: NumFieldOrdElem , abs_tol :: Int ) -> Vector { arb } Returns the elements (\\log(\\lvert \\sigma_1(x) \\rvert),\\dotsc,\\log(\\lvert\\sigma_r(x) \\rvert), \\dotsc,2\\log(\\lvert \\sigma_{r+1}(x) \\rvert),\\dotsc, 2\\log(\\lvert \\sigma_{r+s}(x)\\rvert)) as elements of type arb radius less then 2^-abs_tol . source # t2 \u2014 Method . t2 ( x :: NumFieldOrdElem , abs_tol :: Int = 32 ) -> arb Return the T_2 -norm of x . The radius of the result will be less than 2^-abs_tol . source # minpoly \u2014 Method . minpoly ( a :: NfAbsOrdElem ) -> fmpz_poly The minimal polynomial of a . source # charpoly \u2014 Method . charpoly ( a :: NfAbsOrdElem ) -> fmpz_poly charpoly ( a :: NfAbsOrdElem , FlintZZ ) -> fmpz_poly The characteristic polynomial of a . source # factor \u2014 Method . factor ( a :: NfOrdElem ) -> Fac { NfOrdElem } Computes a factorization of a into irreducible elements. The return value is a factorization fac , which satisfies a = unit(fac) * prod(p^e for (p, e) in fac) . The function requires that a is non-zero and that all prime ideals containing a are principal, which is for example satisfied if class group of the order of a is trivial. source # denominator \u2014 Method . denominator ( a :: NumFieldElem , O :: NfOrd ) -> fmpz Returns the smallest positive integer k such that k \\cdot a is contained in \\mathcal O . source # discriminant \u2014 Method . discriminant ( B :: Vector { NumFieldOrdElem }) Returns the discriminant of the family B of algebraic numbers, i.e. det((tr(B[i]*B[j]))_{i, j})^2 . source discriminant(E::EllCrv{T}) -> T Computes the discriminant of E . source discriminant(O::AlgssRelOrd) Returns the discriminant of O . source","title":"Miscellaneous"},{"location":"orders/frac_ideals/","text":"Fractional ideals A fractional ideal in the number field K is a Z_K -module A such that there exists an integer d>0 wich dA is an (integral) ideal in Z_K . Due to the Dedekind property of Z_K , the ideals for a multiplicative group. Fractional ideals are represented as an integral ideal and an additional denominator. They are of type NfOrdFracIdl . Creation # fractional_ideal \u2014 Method . fractional_ideal ( O :: NfAbsOrd , A :: fmpz_mat , b :: fmpz , A_in_hnf :: Bool = false ) -> NfAbsOrdFracIdl Creates the fractional ideal of \\mathcal O with basis matrix A/b . If A_in_hnf is set, then it is assumed that A is already in lower left HNF. source # fractional_ideal \u2014 Method . fractional_ideal ( O :: NfAbsOrd , A :: fmpz_mat , b :: fmpz , A_in_hnf :: Bool = false ) -> NfAbsOrdFracIdl Creates the fractional ideal of \\mathcal O with basis matrix A/b . If A_in_hnf is set, then it is assumed that A is already in lower left HNF. source # fractional_ideal \u2014 Method . fractional_ideal ( O :: NfAbsOrd , A :: FakeFmpqMat , A_in_hnf :: Bool = false ) -> NfAbsOrdFracIdl Creates the fractional ideal of \\mathcal O with basis matrix A . If A_in_hnf is set, then it is assumed that the numerator of A is already in lower left HNF. source # fractional_ideal \u2014 Method . fractional_ideal ( O :: NfOrd , I :: NfAbsOrdIdl ) -> NfOrdFracIdl The fractional ideal of O generated by a Z -basis of I . source fractional_ideal(O::NfAbsOrd, I::NfAbsOrdIdl) -> NfAbsOrdFracIdl Turns the ideal I into a fractional ideal of \\mathcal O . source # fractional_ideal \u2014 Method . fractional_ideal ( O :: NfAbsOrd , I :: NfAbsOrdIdl , b :: fmpz ) -> NfAbsOrdFracIdl Creates the fractional ideal I/b of \\mathcal O . source # fractional_ideal \u2014 Method . fractional_ideal ( O :: NfAbsOrd , a :: nf_elem ) -> NfAbsOrdFracIdl Creates the principal fractional ideal (a) of \\mathcal O . source # fractional_ideal \u2014 Method . fractional_ideal ( O :: NfAbsOrd , a :: NfAbsOrdElem ) -> NfAbsOrdFracIdl Creates the principal fractional ideal (a) of \\mathcal O . source # inv \u2014 Method . inv ( A :: NfAbsOrdIdl ) -> NfOrdFracIdl Computes the inverse of A , that is, the fractional ideal B such that AB = \\mathcal O_K . source Arithmetic All the normal operations are provided as well. # inv \u2014 Method . inv ( A :: NfAbsOrdFracIdl ) -> NfAbsOrdFracIdl Returns the fractional ideal B such that AB = \\mathcal O . source # integral_split \u2014 Method . integral_split ( A :: NfAbsOrdFracIdl ) -> NfAbsOrdIdl , NfAbsOrdIdl Computes the unique coprime integral ideals N and D s.th. A = ND^{-1} source # numerator \u2014 Method . numerator ( a :: NfRelOrdFracIdl ) -> NfRelOrdIdl Returns the ideal d*a where d is the denominator of a . source # denominator \u2014 Method . denominator ( a :: NfRelOrdFracIdl ) -> fmpz Returns the smallest positive integer d such that da is contained in the order of a . source Miscaellenous # order \u2014 Method . order ( a :: NfAbsOrdFracIdl ) -> NfAbsOrd The order that was used to define the ideal a . source # basis_matrix \u2014 Method . basis_matrix ( I :: NfAbsOrdFracIdl ) -> FakeFmpqMat Returns the basis matrix of I with respect to the basis of the order. source # basis_mat_inv \u2014 Method . basis_mat_inv ( O :: NfAbsOrd ) -> FakeFmpqMat Returns the inverse of the basis matrix of \\mathcal O . source basis_mat_inv(A::NfAbsOrdIdl) -> fmpz_mat Returns the inverse basis matrix of A . source basis_mat_inv(I::NfAbsOrdFracIdl) -> FakeFmpqMat Returns the inverse of the basis matrix of I . source # basis \u2014 Method . basis ( I :: NfAbsOrdFracIdl ) -> Vector { nf_elem } Returns the \\mathbf Z -basis of I . source # norm \u2014 Method . norm ( I :: NfAbsOrdFracIdl ) -> fmpq Returns the norm of I . source norm(a::NfRelOrdIdl) -> NfOrdIdl Returns the norm of a . source norm(a::NfRelOrdFracIdl{T, S}) -> S Returns the norm of a . source norm(a::AlgAssAbsOrdIdl, O::AlgAssAbsOrd; copy::Bool = true) -> fmpq Returns the norm of a considered as an (possibly fractional) ideal of O . source norm(a::AlgAssRelOrdIdl{S, T, U}, O::AlgAssRelOrd{S, T, U}; copy::Bool = true) where { S, T, U } -> T Returns the norm of a considered as an (possibly fractional) ideal of O . source","title":"Fractional Ideals"},{"location":"orders/frac_ideals/#fractional-ideals","text":"A fractional ideal in the number field K is a Z_K -module A such that there exists an integer d>0 wich dA is an (integral) ideal in Z_K . Due to the Dedekind property of Z_K , the ideals for a multiplicative group. Fractional ideals are represented as an integral ideal and an additional denominator. They are of type NfOrdFracIdl .","title":"Fractional ideals"},{"location":"orders/frac_ideals/#creation","text":"# fractional_ideal \u2014 Method . fractional_ideal ( O :: NfAbsOrd , A :: fmpz_mat , b :: fmpz , A_in_hnf :: Bool = false ) -> NfAbsOrdFracIdl Creates the fractional ideal of \\mathcal O with basis matrix A/b . If A_in_hnf is set, then it is assumed that A is already in lower left HNF. source # fractional_ideal \u2014 Method . fractional_ideal ( O :: NfAbsOrd , A :: fmpz_mat , b :: fmpz , A_in_hnf :: Bool = false ) -> NfAbsOrdFracIdl Creates the fractional ideal of \\mathcal O with basis matrix A/b . If A_in_hnf is set, then it is assumed that A is already in lower left HNF. source # fractional_ideal \u2014 Method . fractional_ideal ( O :: NfAbsOrd , A :: FakeFmpqMat , A_in_hnf :: Bool = false ) -> NfAbsOrdFracIdl Creates the fractional ideal of \\mathcal O with basis matrix A . If A_in_hnf is set, then it is assumed that the numerator of A is already in lower left HNF. source # fractional_ideal \u2014 Method . fractional_ideal ( O :: NfOrd , I :: NfAbsOrdIdl ) -> NfOrdFracIdl The fractional ideal of O generated by a Z -basis of I . source fractional_ideal(O::NfAbsOrd, I::NfAbsOrdIdl) -> NfAbsOrdFracIdl Turns the ideal I into a fractional ideal of \\mathcal O . source # fractional_ideal \u2014 Method . fractional_ideal ( O :: NfAbsOrd , I :: NfAbsOrdIdl , b :: fmpz ) -> NfAbsOrdFracIdl Creates the fractional ideal I/b of \\mathcal O . source # fractional_ideal \u2014 Method . fractional_ideal ( O :: NfAbsOrd , a :: nf_elem ) -> NfAbsOrdFracIdl Creates the principal fractional ideal (a) of \\mathcal O . source # fractional_ideal \u2014 Method . fractional_ideal ( O :: NfAbsOrd , a :: NfAbsOrdElem ) -> NfAbsOrdFracIdl Creates the principal fractional ideal (a) of \\mathcal O . source # inv \u2014 Method . inv ( A :: NfAbsOrdIdl ) -> NfOrdFracIdl Computes the inverse of A , that is, the fractional ideal B such that AB = \\mathcal O_K . source","title":"Creation"},{"location":"orders/frac_ideals/#arithmetic","text":"All the normal operations are provided as well. # inv \u2014 Method . inv ( A :: NfAbsOrdFracIdl ) -> NfAbsOrdFracIdl Returns the fractional ideal B such that AB = \\mathcal O . source # integral_split \u2014 Method . integral_split ( A :: NfAbsOrdFracIdl ) -> NfAbsOrdIdl , NfAbsOrdIdl Computes the unique coprime integral ideals N and D s.th. A = ND^{-1} source # numerator \u2014 Method . numerator ( a :: NfRelOrdFracIdl ) -> NfRelOrdIdl Returns the ideal d*a where d is the denominator of a . source # denominator \u2014 Method . denominator ( a :: NfRelOrdFracIdl ) -> fmpz Returns the smallest positive integer d such that da is contained in the order of a . source","title":"Arithmetic"},{"location":"orders/frac_ideals/#miscaellenous","text":"# order \u2014 Method . order ( a :: NfAbsOrdFracIdl ) -> NfAbsOrd The order that was used to define the ideal a . source # basis_matrix \u2014 Method . basis_matrix ( I :: NfAbsOrdFracIdl ) -> FakeFmpqMat Returns the basis matrix of I with respect to the basis of the order. source # basis_mat_inv \u2014 Method . basis_mat_inv ( O :: NfAbsOrd ) -> FakeFmpqMat Returns the inverse of the basis matrix of \\mathcal O . source basis_mat_inv(A::NfAbsOrdIdl) -> fmpz_mat Returns the inverse basis matrix of A . source basis_mat_inv(I::NfAbsOrdFracIdl) -> FakeFmpqMat Returns the inverse of the basis matrix of I . source # basis \u2014 Method . basis ( I :: NfAbsOrdFracIdl ) -> Vector { nf_elem } Returns the \\mathbf Z -basis of I . source # norm \u2014 Method . norm ( I :: NfAbsOrdFracIdl ) -> fmpq Returns the norm of I . source norm(a::NfRelOrdIdl) -> NfOrdIdl Returns the norm of a . source norm(a::NfRelOrdFracIdl{T, S}) -> S Returns the norm of a . source norm(a::AlgAssAbsOrdIdl, O::AlgAssAbsOrd; copy::Bool = true) -> fmpq Returns the norm of a considered as an (possibly fractional) ideal of O . source norm(a::AlgAssRelOrdIdl{S, T, U}, O::AlgAssRelOrd{S, T, U}; copy::Bool = true) where { S, T, U } -> T Returns the norm of a considered as an (possibly fractional) ideal of O . source","title":"Miscaellenous"},{"location":"orders/ideals/","text":"Ideals (Integral) ideals in orders are always free Z -module of the same rank as the order, hence have a representation via a Z -basis. This can be made unique by normalising the corresponding matrix to be in reduced row echelon form (HNF). For ideals in maximal orders Z_K , we also have a second presentation coming from the Z_K module structure and the fact that Z_K is a Dedekind ring: ideals can be generated by 2 elements, one of which can be any non-zero element in the ideal. For efficiency, we will choose the 1st generator to be an integer. Ideals here are of type NfAbsOrdIdl , which is, similar to the elements above, also indexed by the type of the field and their elements: NfAbsOrdIdl{AnticNumberField,nf_elem} for ideals in simple absolute fields. Different to elements, the parent of an ideal is teh set of all ideals in the ring, of type NfAbsOrdIdlSet . Creation # ideal \u2014 Method . ideal ( O :: NfOrd , a :: fmpz ) -> NfAbsOrdIdl ideal ( O :: NfOrd , a :: Integer ) -> NfAbsOrdIdl Returns the ideal of \\mathcal O which is generated by a . source # ideal \u2014 Method . ideal ( O :: NfOrd , x :: fmpz_mat , check :: Bool = false , x_in_hnf :: Bool = false ) -> NfAbsOrdIdl Creates the ideal of \\mathcal O with basis matrix x . If check is set, then it is checked whether x defines an ideal (expensive). If x_in_hnf is set, then it is assumed that x is already in lower left HNF. source # ideal \u2014 Method . ideal ( O :: NfOrd , x :: NfOrdElem ) -> NfAbsOrdIdl Creates the principal ideal (x) of \\mathcal O . source # ideal \u2014 Method . ideal ( O :: NfOrd , x :: fmpz , y :: NfOrdElem ) -> NfAbsOrdIdl ideal ( O :: NfOrd , x :: Integer , y :: NfOrdElem ) -> NfAbsOrdIdl Creates the ideal (x, y) of \\mathcal O . source # ideal \u2014 Method . ideal ( O :: NfOrd , x :: fmpz , y :: NfOrdElem ) -> NfAbsOrdIdl ideal ( O :: NfOrd , x :: Integer , y :: NfOrdElem ) -> NfAbsOrdIdl Creates the ideal (x, y) of \\mathcal O . source # ideal \u2014 Method . ideal ( O :: NfOrd , a :: fmpz ) -> NfAbsOrdIdl ideal ( O :: NfOrd , a :: Integer ) -> NfAbsOrdIdl Returns the ideal of \\mathcal O which is generated by a . source # ideal \u2014 Method . ideal ( O :: NfOrd , x :: NfOrdElem ) -> NfAbsOrdIdl Creates the principal ideal (x) of \\mathcal O . source # * \u2014 Method . * ( O :: NfOrd , x :: NfOrdElem ) -> NfAbsOrdIdl * ( x :: NfAbsOrdElem , O :: NfAbsOrd ) -> NfAbsOrdIdl Returns the principal ideal (x) of \\mathcal O . source # factor \u2014 Method . factor ( A :: NfOrdIdl ) -> Dict { NfOrdIdl , Int } Computes the prime ideal factorization A as a dictionary, the keys being the prime ideal divisors: If lp = factor_dict(A) , then keys(lp) are the prime ideal divisors of A and lp[P] is the P -adic valuation of A for all P in keys(lp) . source # factor \u2014 Method . factor ( a :: nf_elem , I :: NfOrdIdlSet ) -> Dict { NfOrdIdl , fmpz } Factors the principal ideal generated by a . source # coprime_base \u2014 Method . coprime_base ( A :: Vector { NfOrdIdl }) -> Vector { NfOrdIdl } coprime_base ( A :: Vector { NfOrdElem }) -> Vector { NfOrdIdl } A coprime base for the (principal) ideals in A , i.e. the returned array generated multiplicatively the same ideals as the input and are pairwise coprime. source Arithmetic All the usual operations are supported: == , + , * divexact , divides lcm , gcd in # intersect \u2014 Method . intersect ( x :: NfOrdIdl , y :: NfOrdIdl ) -> NfOrdIdl Returns x \\cap y . source # colon \u2014 Method . colon ( a :: NfAbsOrdIdl , b :: NfAbsOrdIdl ) -> NfOrdFracIdl The ideal (a:b) = \\{x \\in K | xb \\subseteq a\\} = \\hom(b, a) where K is the number field. source # in \u2014 Method . in ( x :: NumFieldOrdElem , y :: NumFieldOrdIdl ) in ( x :: NumFieldElem , y :: NumFieldOrdIdl ) in ( x :: fmpz , y :: NumFieldOrdIdl ) Returns whether x is contained in y . source # ispower \u2014 Method . ispower ( A :: NfAbsOrdIdl , n :: Int ) -> Bool , NfAbsOrdIdl ispower ( A :: NfOrdFracIdl , n :: Int ) -> Bool , NfOrdFracIdl Computes, if possible, an ideal B s.th. B^n==A holds. In this case, true and B are returned. source # ispower \u2014 Method . ispower ( I :: NfAbsOrdIdl ) -> Int , NfAbsOrdIdl ispower ( a :: NfOrdFracIdl ) -> Int , NfOrdFracIdl Writes a = r^e with e maximal. Note: 1 = 1^0 . source # isinvertible \u2014 Method . isinvertible ( A :: NfAbsOrdIdl ) -> Bool , NfOrdFracIdl Returns true and an inverse of A or false and an ideal B such that A*B \\subsetneq order(A) , if A is not invertible. source # isone \u2014 Method . isone ( A :: NfAbsOrdIdl ) -> Bool isunit ( A :: NfAbsOrdIdl ) -> Bool Tests if A is the trivial ideal generated by 1 . source Class Group The group of invertable ideals in any order forms a group and the principal ideals a subgroup. The finite quotient is called class group for maximal orders and Picard group or ring class group in general. # class_group \u2014 Method . class_group ( O :: NfOrd ; bound = - 1 , method = 3 , redo = false , large = 1000 ) -> GrpAbFinGen , Map Returns a group A and a map f from A to the set of ideals of O . The inverse of the map is the projection onto the group of ideals modulo the group of principal ideals. redo allows to trigger a re-computation, thus avoiding the cache. bound , when given, is the bound for the factor base. source # narrow_class_group \u2014 Method . narrow_class_group ( O :: NfOrd ) -> GrpAbFinGen , Map Computes the narrow (or strict) class group of O , ie. the group of invertable ideals modulo principal ideals generated by elements that are positive at all real places. source # picard_group \u2014 Method . picard_group ( O :: NfOrd ) -> GrpAbFinGen , MapClassGrp Returns the Picard group of O and a map from the group in the set of (invertible) ideals of O . source # ring_class_group \u2014 Method . ring_class_group ( O :: NfAbsOrd ) The ring class group (Picard group) of O . source julia> k , a = wildanger_field ( 3 , 13 ); julia> zk = maximal_order ( k ); julia> c , mc = class_group ( zk ) (GrpAb: Z/9, ClassGroup map of Set of ideals of Maximal order of Number field over Rational Field with defining polynomial x^3 - 13*x^2 + 13*x - 13 with basis nf_elem[1, _$, 1//2*_$^2 + 1//2] ) julia> lp = prime_ideals_up_to ( zk , 20 ); julia> [ mc \\ I for I = lp ] 10-element Vector{GrpAbFinGenElem}: Element of GrpAb: Z/9 with components [1] Element of GrpAb: Z/9 with components [4] Element of GrpAb: Z/9 with components [4] Element of GrpAb: Z/9 with components [5] Element of GrpAb: Z/9 with components [3] Element of GrpAb: Z/9 with components [2] Element of GrpAb: Z/9 with components [7] Element of GrpAb: Z/9 with components [1] Element of GrpAb: Z/9 with components [0] Element of GrpAb: Z/9 with components [2] julia> mc ( c [ 1 ]) <2, 7//2*_$^2 + 3*_$ + 3//2> Norm: 2 Minimum: 2 two normal wrt: 2 julia> order ( c [ 1 ]) 9 julia> mc ( c [ 1 ]) ^ Int ( order ( c [ 1 ])) <512, 60694820553551325838165//2*_$^2 - 30119530271281908295539*_$ + 65711602995885832267701//2> Norm: 512 two normal wrt: 2 julia> mc \\ ans Element of GrpAb: Z/9 with components [0] The class group, or more precisely the information used to compute it also allows for principal ideal testing and related tasks. In general, due to the size of the objetcs, the fac_elem versions are more effcient. # isprincipal \u2014 Method . isprincipal ( A :: NfOrdIdl ) -> Bool , NfOrdElem isprincipal ( A :: NfOrdFracIdl ) -> Bool , NfOrdElem Tests if A is principal and returns (\\mathtt{true}, \\alpha) if A = \\langle \\alpha\\rangle or (\\mathtt{false}, 1) otherwise. source # isprincipal_fac_elem \u2014 Method . isprincipal_fac_elem ( A :: NfOrdIdl ) -> Bool , FacElem { nf_elem , NumberField } Tests if A is principal and returns (\\mathtt{true}, \\alpha) if A = \\langle \\alpha\\rangle or (\\mathtt{false}, 1) otherwise. The generator will be in factored form. source # power_class \u2014 Method . power_class ( A :: NfOrdIdl , e :: fmpz ) -> NfOrdIdl Computes a (small) ideal in the same class as A^e . source # power_product_class \u2014 Method . power_product_class ( A :: Vector { NfOrdIdl }, e :: Vector { fmpz }) -> NfOrdIdl Computes a (small) ideal in the same class as \\prod A_i^{e_i} . source # power_reduce \u2014 Method . power_reduce ( A :: NfOrdIdl , e :: fmpz ) -> NfOrdIdl , FacElem { nf_elem } Computes B and \\alpha in factored form, such that \\alpha B = A^e B has small norm. source # class_group_ideal_relation \u2014 Method . class_group_ideal_relation ( I :: NfOrdIdl , c :: ClassGrpCtx ) -> nf_elem , SRow { fmpz } Finds a number field element \\alpha such that \\alpha I factors over the factor base in c . source # factor_base_bound_grh \u2014 Method . factor_base_bound_grh ( O :: NfOrd ) -> Int Returns an integer B , such that under GRH the ideal class group of \\mathcal O is generated by the prime ideals of norm bounded by B . source # factor_base_bound_bach \u2014 Method . factor_base_bound_bach ( O :: NfOrd ) -> Int Use the theorem of Bach to find B such that under GRH the ideal class group of \\mathcal O is generated by the prime ideals of norm bounded by B . source # prime_ideals_up_to \u2014 Function . prime_ideals_up_to ( O :: NfOrd , B :: Int ; degree_limit :: Int = 0 , index_divisors :: Bool = true ) -> Vector { NfOrdIdl } Computes the prime ideals \\mathcal O with norm up to B . If degree_limit is a nonzero integer k , then prime ideals \\mathfrak p with \\deg(\\mathfrak p) > k will be discarded. If 'index_divisors' is set to false, only primes not dividing the index of the order will be computed. source prime_ideals_up_to(O::NfOrd, B::Int; complete::Bool = false, degree_limit::Int = 0, F::Function, bad::fmpz) Computes the prime ideals \\mathcal O with norm up to B . If degree_limit is a nonzero integer k , then prime ideals \\mathfrak p with \\deg(\\mathfrak p) > k will be discarded. The function F must be a function on prime numbers not dividing bad such that F(p) = \\deg(\\mathfrak p) for all prime ideals \\mathfrak p lying above p . source julia> I = mc ( c [ 1 ]) <2, 7//2*_$^2 + 3*_$ + 3//2> Norm: 2 Minimum: 2 two normal wrt: 2 julia> Hecke . isprincipal ( I ) (false, 1) julia> I = I ^ Int ( order ( c [ 1 ])) <512, 60694820553551325838165//2*_$^2 - 30119530271281908295539*_$ + 65711602995885832267701//2> Norm: 512 two normal wrt: 2 julia> Hecke . isprincipal ( I ) (true, 1//2*_$^2 - 3*_$ + 9//2) julia> Hecke . isprincipal_fac_elem ( I ) (true, Factored element with data Dict{nf_elem, fmpz}(1//2*_$^2 - 3*_$ + 9//2 => 1)) The computation of S -units is also tied to the class group: # torsion_units \u2014 Method . torsion_units ( O :: NfOrd ) -> Vector { NfOrdElem } Given an order O , compute the torsion units of O . source # torsion_unit_group \u2014 Method . torsion_unit_group ( O :: NfOrd ) -> GrpAb , Map Given an order \\mathcal O , returns the torsion units as an abelian group G together with a map G \\to \\mathcal O^\\times . source # torsion_units_generator \u2014 Method . torsion_units_generator ( O :: NfOrd ) -> NfOrdElem Given an order O , compute a generator of the torsion units of O . source # torsion_units_gen_order \u2014 Method . torsion_units_gen_order ( O :: NfOrd ) -> NfOrdElem Given an order O , compute a generator of the torsion units of O as well as its order. source # unit_group \u2014 Method . unit_group ( O :: NfOrd ) -> GrpAbFinGen , Map Returns a group U and an isomorphism map f \\colon U \\to \\mathcal O^\\times . A set of fundamental units of \\mathcal O can be obtained via [ f(U[1+i]) for i in 1:unit_group_rank(O) ] . f(U[1]) will give a generator for the torsion subgroup. source # unit_group_fac_elem \u2014 Method . unit_group_fac_elem ( O :: NfOrd ) -> GrpAbFinGen , Map Returns a group U and an isomorphism map f \\colon U \\to \\mathcal O^\\times . A set of fundamental units of \\mathcal O can be obtained via [ f(U[1+i]) for i in 1:unit_group_rank(O) ] . f(U[1]) will give a generator for the torsion subgroup. All elements will be returned in factored form. source # sunit_group \u2014 Method . sunit_group ( I :: Vector { NfOrdIdl }) -> GrpAb , Map For an array I of (coprime prime) ideals, find the S -unit group defined by I , ie. the group of non-zero field elements which are only divisible by ideals in I . source # sunit_group_fac_elem \u2014 Method . sunit_group_fac_elem ( I :: Vector { NfOrdIdl }) -> GrpAb , Map For an array I of (coprime prime) ideals, find the S -unit group defined by I , ie. the group of non-zero field elements which are only divisible by ideals in I . The map will return elements in factored form. source # sunit_mod_units_group_fac_elem \u2014 Method . sunit_mod_units_group_fac_elem ( I :: Vector { NfOrdIdl }) -> GrpAb , Map For an array I of (coprime prime) ideals, find the S -unit group defined by I , ie. the group of non-zero field elements which are only divisible by ideals in I modulo the units of the field. The map will return elements in factored form. source julia> u , mu = unit_group ( zk ) (GrpAb: Z/2 x Z, UnitGroup map of Maximal order of Number field over Rational Field with defining polynomial x^3 - 13*x^2 + 13*x - 13 with basis nf_elem[1, _$, 1//2*_$^2 + 1//2] ) julia> mu ( u [ 2 ]) -_$^2 + _$ - 1 julia> u , mu = unit_group_fac_elem ( zk ) (GrpAb: Z/2 x Z, UnitGroup map of Factored elements over Number field over Rational Field with defining polynomial x^3 - 13*x^2 + 13*x - 13 ) julia> mu ( u [ 2 ]) Factored element with data Dict{nf_elem, fmpz}(_$^2 + 1 => 1, 3 => -1, _$ - 3 => -1, 3*_$^2 - 40*_$ + 51 => -1, -3*_$^2 + 29*_$ + 4 => 1) julia> evaluate ( ans ) -_$^2 + _$ - 1 julia> lp = factor ( 6 * zk ) Dict{NfOrdIdl, Int64} with 4 entries: <3, _$^2 + 1> => 1 <2, 3//2*_$^2 + _$ + 3//2> => 1 <2, 7//2*_$^2 + 2*_$ + 3//2> => 2 <3, _$ - 1> => 1 julia> s , ms = Hecke . sunit_group ( collect ( keys ( lp ))) (GrpAb: Z/2 x Z^(5), SUnits map of Number field over Rational Field with defining polynomial x^3 - 13*x^2 + 13*x - 13 for NfOrdIdl[<3, _$^2 + 1> Norm: 9 Minimum: 3 basis_matrix [3 0 0; 0 3 0; 0 0 1] two normal wrt: 3, <2, 3//2*_$^2 + _$ + 3//2> Norm: 2 Minimum: 2 basis_matrix [2 0 0; 1 1 0; 1 0 1] two normal wrt: 2, <2, 7//2*_$^2 + 2*_$ + 3//2> Norm: 2 Minimum: 2 basis_matrix [2 0 0; 1 1 0; 0 0 1] two normal wrt: 2, <3, _$ - 1> Norm: 3 Minimum: 3 basis_matrix [3 0 0; 2 1 0; 2 0 1] two normal wrt: 3] ) julia> ms ( s [ 4 ]) 1//2*_$^2 - 6*_$ - 1//2 julia> norm ( ans ) -18 julia> factor ( numerator ( ans )) -1 * 2 * 3^2 Miscaellenous # order \u2014 Method . order ( I :: NumFieldOrdIdl ) -> NfOrd Returns the order of I . source # order \u2014 Method . order ( a :: NfAbsOrdFracIdl ) -> NfAbsOrd The order that was used to define the ideal a . source # order \u2014 Method . order ( I :: NumFieldOrdIdl ) -> NfOrd Returns the order of I . source # order \u2014 Method . order ( a :: NfRelOrdFracIdl ) -> NfRelOrd Returns the order of a . source # nf \u2014 Method . nf ( x :: NumFieldOrdIdl ) -> AnticNumberField Returns the number field, of which x is an integral ideal. source # basis \u2014 Method . basis ( A :: NfAbsOrdIdl ) -> Vector { NfOrdElem } Returns the basis of A . source basis ( I :: NfAbsOrdFracIdl ) -> Vector { nf_elem } Returns the \\mathbf Z -basis of I . source # lll_basis \u2014 Method . lll_basis ( I :: NumFieldOrdIdl ) -> Vector { NumFieldElem } A basis for I that is reduced using the LLL algorithm for the Minkowski metric. source # basis_matrix \u2014 Method . basis_matrix ( A :: NfAbsOrdIdl ) -> fmpz_mat Returns the basis matrix of A . source # basis_mat_inv \u2014 Method . basis_mat_inv ( O :: NfAbsOrd ) -> FakeFmpqMat Returns the inverse of the basis matrix of \\mathcal O . source basis_mat_inv(A::NfAbsOrdIdl) -> fmpz_mat Returns the inverse basis matrix of A . source # assure_has_basis_mat_inv \u2014 Method . basis_mat_inv ( A :: NfAbsOrdIdl ) -> FakeFmpqMat Returns the inverse of the basis matrix of A . source # has_basis \u2014 Method . has_basis ( A :: NfAbsOrdIdl ) -> Bool Returns whether A has a basis already computed. source # has_basis_matrix \u2014 Method . has_basis_matrix ( A :: NfAbsOrdIdl ) -> Bool Returns whether A knows its basis matrix. source # has_2_elem \u2014 Method . has_2_elem ( A :: NfAbsOrdIdl ) -> Bool Returns whether A is generated by two elements. source # has_2_elem_normal \u2014 Method . has_2_elem_normal ( A :: NfAbsOrdIdl ) -> Bool Returns whether A has normal two element generators. source # has_weakly_normal \u2014 Method . has_weakly_normal ( A :: NfAbsOrdIdl ) -> Bool Returns whether A has weakly normal two element generators. source # has_princ_gen_special \u2014 Method . has_princ_gen_special ( A :: NfAbsOrdIdl ) -> Bool Returns whether A knows if it is generated by a rational integer. source # principal_generator \u2014 Method . principal_generator ( A :: NfOrdIdl ) -> NfOrdElem For a principal ideal A , find a generator. source # principal_generator_fac_elem \u2014 Method . principal_generator_fac_elem ( A :: NfOrdIdl ) -> FacElem { nf_elem , NumberField } For a principal ideal A , find a generator in factored form. source # minimum \u2014 Method . minimum ( A :: NfAbsOrdIdl ) -> fmpz Returns the smallest nonnegative element in A \\cap \\mathbf Z . source minimum ( A :: NfRelOrdIdl ) -> NfOrdIdl minimum ( A :: NfRelOrdIdl ) -> NfRelOrdIdl Returns the ideal A \\cap O where O is the maximal order of the coefficient ideals of A . source # minimum \u2014 Method . minimum ( A :: NfRelOrdIdl ) -> NfOrdIdl minimum ( A :: NfRelOrdIdl ) -> NfRelOrdIdl Returns the ideal A \\cap O where O is the maximal order of the coefficient ideals of A . source # minimum \u2014 Method . minimum ( A :: NfAbsOrdIdl ) -> fmpz Returns the smallest nonnegative element in A \\cap \\mathbf Z . source # has_minimum \u2014 Method . has_minimum ( A :: NfAbsOrdIdl ) -> Bool Returns whether A knows its mininum. source # norm \u2014 Method . norm ( A :: NfAbsOrdIdl ) -> fmpz Returns the norm of A , that is, the cardinality of \\mathcal O/A , where \\mathcal O is the order of A . source norm(a::NfRelOrdIdl) -> NfOrdIdl Returns the norm of a . source norm(a::NfRelOrdFracIdl{T, S}) -> S Returns the norm of a . source norm(a::AlgAssAbsOrdIdl, O::AlgAssAbsOrd; copy::Bool = true) -> fmpq Returns the norm of a considered as an (possibly fractional) ideal of O . source norm(a::AlgAssRelOrdIdl{S, T, U}, O::AlgAssRelOrd{S, T, U}; copy::Bool = true) where { S, T, U } -> T Returns the norm of a considered as an (possibly fractional) ideal of O . source # has_norm \u2014 Method . has_norm ( A :: NfAbsOrdIdl ) -> Bool Returns whether A knows its norm. source # idempotents \u2014 Method . idempotents ( x :: NfOrdIdl , y :: NfOrdIdl ) -> NfOrdElem , NfOrdElem Returns a tuple (e, f) consisting of elements e in x , f in y such that 1 = e + f . If the ideals are not coprime, an error is raised. source # isprime \u2014 Method . isprime ( A :: NfOrdIdl ) -> Bool Returns whether A is a prime ideal. source # isprime_known \u2014 Method . isprime_known ( A :: NfOrdIdl ) -> Bool Returns whether A knows if it is prime. source # isramified \u2014 Method . isramified ( O :: NfOrd , p :: Int ) -> Bool Returns whether the integer p is ramified in \\mathcal O . It is assumed that p is prime. source # ramification_index \u2014 Method . ramification_index ( P :: NfOrdIdl ) -> Int The ramification index of the prime-ideal P . source # degree \u2014 Method . degree ( P :: NfOrdIdl ) -> Int The inertia degree of the prime-ideal P . source # valuation \u2014 Method . valuation ( a :: NumFieldElem , p :: NfOrdIdl ) -> fmpz Computes the \\mathfrak p -adic valuation of a , that is, the largest i such that a is contained in \\mathfrak p^i . source # valuation \u2014 Method . valuation ( a :: nf_elem , p :: NfOrdIdl ) -> fmpz valuation ( a :: NfOrdElem , p :: NfOrdIdl ) -> fmpz valuation ( a :: fmpz , p :: NfOrdIdl ) -> fmpz Computes the \\mathfrak p -adic valuation of a , that is, the largest i such that a is contained in \\mathfrak p^i . source # valuation \u2014 Method . valuation ( A :: NfOrdIdl , p :: NfOrdIdl ) -> fmpz Computes the \\mathfrak p -adic valuation of A , that is, the largest i such that A is contained in \\mathfrak p^i . source # valuation \u2014 Method . valuation ( a :: Integer , p :: NfOrdIdl ) -> fmpz Computes the \\mathfrak p -adic valuation of a , that is, the largest i such that a is contained in \\mathfrak p^i . source # valuation \u2014 Method . valuation ( a :: nf_elem , p :: NfOrdIdl ) -> fmpz valuation ( a :: NfOrdElem , p :: NfOrdIdl ) -> fmpz valuation ( a :: fmpz , p :: NfOrdIdl ) -> fmpz Computes the \\mathfrak p -adic valuation of a , that is, the largest i such that a is contained in \\mathfrak p^i . source # valuation \u2014 Method . valuation ( A :: NfAbsOrdFracIdl , p :: NfAbsOrdIdl ) The valuation of A at p . source # idempotents \u2014 Method . idempotents ( x :: NfOrdIdl , y :: NfOrdIdl ) -> NfOrdElem , NfOrdElem Returns a tuple (e, f) consisting of elements e in x , f in y such that 1 = e + f . If the ideals are not coprime, an error is raised. source Quotient Rings # quo \u2014 Method . quo ( O :: NfOrd , I :: NfOrdIdl ) -> NfOrdQuoRing , Map quo ( O :: AlgAssAbsOrd , I :: AlgAssAbsOrdIdl ) -> AbsOrdQuoRing , Map The quotient ring O/I as a ring together with the section M: O/I \\to O . The pointwise inverse of M is the canonical projection O\\to O/I . source # ResidueRing \u2014 Method . ResidueRing ( O :: NfOrd , I :: NfOrdIdl ) -> NfOrdQuoRing ResidueRing ( O :: AlgAssAbsOrd , I :: AlgAssAbsOrdIdl ) -> AbsOrdQuoRing The quotient ring O modulo I as a new ring. source # ResidueField \u2014 Method . ResidueField ( O :: NfOrd , P :: NfOrdIdl , check :: Bool = true ) -> Field , Map Returns the residue field of the prime ideal P together with the projection map. If check is true, the ideal is checked for being prime. source # mod \u2014 Method . mod ( x :: NfOrdElem , I :: NfAbsOrdIdl ) Returns the unique element y of the ambient order of x with x \\equiv y \\bmod I and the following property: If a_1,\\dotsc,a_d \\in \\mathbf{Z}_{\\geq 1} are the diagonal entries of the unique HNF basis matrix of I and (b_1,\\dotsc,b_d) is the coefficient vector of y , then 0 \\leq b_i < a_i for 1 \\leq i \\leq d . source # crt \u2014 Method . crt ( r1 :: NfOrdElem , i1 :: NfOrdIdl , r2 :: NfOrdElem , i2 :: NfOrdIdl ) -> NfOrdElem Find x such that x \\equiv r_1 \\bmod i_1 and x \\equiv r_2 \\bmod i_2 using idempotents . source # euler_phi \u2014 Method . euler_phi ( A :: NfOrdIdl ) -> fmpz The ideal version of the totient function returns the size of the unit group of the residue ring modulo the ideal. source # multiplicative_group \u2014 Method . multiplicative_group ( Q :: NfOrdQuoRing ) -> GrpAbFinGen , Map { GrpAbFinGen , NfOrdQuoRing } unit_group ( Q :: NfOrdQuoRing ) -> GrpAbFinGen , Map { GrpAbFinGen , NfOrdQuoRing } Returns the unit group of Q as an abstract group A and an isomorphism map f \\colon A \\to Q^\\times . source # multiplicative_group_generators \u2014 Method . multiplicative_group_generators ( Q :: NfOrdQuoRing ) -> Vector { NfOrdQuoRingElem } Return a set of generators for Q^\\times . source","title":"Ideals"},{"location":"orders/ideals/#ideals","text":"(Integral) ideals in orders are always free Z -module of the same rank as the order, hence have a representation via a Z -basis. This can be made unique by normalising the corresponding matrix to be in reduced row echelon form (HNF). For ideals in maximal orders Z_K , we also have a second presentation coming from the Z_K module structure and the fact that Z_K is a Dedekind ring: ideals can be generated by 2 elements, one of which can be any non-zero element in the ideal. For efficiency, we will choose the 1st generator to be an integer. Ideals here are of type NfAbsOrdIdl , which is, similar to the elements above, also indexed by the type of the field and their elements: NfAbsOrdIdl{AnticNumberField,nf_elem} for ideals in simple absolute fields. Different to elements, the parent of an ideal is teh set of all ideals in the ring, of type NfAbsOrdIdlSet .","title":"Ideals"},{"location":"orders/ideals/#creation","text":"# ideal \u2014 Method . ideal ( O :: NfOrd , a :: fmpz ) -> NfAbsOrdIdl ideal ( O :: NfOrd , a :: Integer ) -> NfAbsOrdIdl Returns the ideal of \\mathcal O which is generated by a . source # ideal \u2014 Method . ideal ( O :: NfOrd , x :: fmpz_mat , check :: Bool = false , x_in_hnf :: Bool = false ) -> NfAbsOrdIdl Creates the ideal of \\mathcal O with basis matrix x . If check is set, then it is checked whether x defines an ideal (expensive). If x_in_hnf is set, then it is assumed that x is already in lower left HNF. source # ideal \u2014 Method . ideal ( O :: NfOrd , x :: NfOrdElem ) -> NfAbsOrdIdl Creates the principal ideal (x) of \\mathcal O . source # ideal \u2014 Method . ideal ( O :: NfOrd , x :: fmpz , y :: NfOrdElem ) -> NfAbsOrdIdl ideal ( O :: NfOrd , x :: Integer , y :: NfOrdElem ) -> NfAbsOrdIdl Creates the ideal (x, y) of \\mathcal O . source # ideal \u2014 Method . ideal ( O :: NfOrd , x :: fmpz , y :: NfOrdElem ) -> NfAbsOrdIdl ideal ( O :: NfOrd , x :: Integer , y :: NfOrdElem ) -> NfAbsOrdIdl Creates the ideal (x, y) of \\mathcal O . source # ideal \u2014 Method . ideal ( O :: NfOrd , a :: fmpz ) -> NfAbsOrdIdl ideal ( O :: NfOrd , a :: Integer ) -> NfAbsOrdIdl Returns the ideal of \\mathcal O which is generated by a . source # ideal \u2014 Method . ideal ( O :: NfOrd , x :: NfOrdElem ) -> NfAbsOrdIdl Creates the principal ideal (x) of \\mathcal O . source # * \u2014 Method . * ( O :: NfOrd , x :: NfOrdElem ) -> NfAbsOrdIdl * ( x :: NfAbsOrdElem , O :: NfAbsOrd ) -> NfAbsOrdIdl Returns the principal ideal (x) of \\mathcal O . source # factor \u2014 Method . factor ( A :: NfOrdIdl ) -> Dict { NfOrdIdl , Int } Computes the prime ideal factorization A as a dictionary, the keys being the prime ideal divisors: If lp = factor_dict(A) , then keys(lp) are the prime ideal divisors of A and lp[P] is the P -adic valuation of A for all P in keys(lp) . source # factor \u2014 Method . factor ( a :: nf_elem , I :: NfOrdIdlSet ) -> Dict { NfOrdIdl , fmpz } Factors the principal ideal generated by a . source # coprime_base \u2014 Method . coprime_base ( A :: Vector { NfOrdIdl }) -> Vector { NfOrdIdl } coprime_base ( A :: Vector { NfOrdElem }) -> Vector { NfOrdIdl } A coprime base for the (principal) ideals in A , i.e. the returned array generated multiplicatively the same ideals as the input and are pairwise coprime. source","title":"Creation"},{"location":"orders/ideals/#arithmetic","text":"All the usual operations are supported: == , + , * divexact , divides lcm , gcd in # intersect \u2014 Method . intersect ( x :: NfOrdIdl , y :: NfOrdIdl ) -> NfOrdIdl Returns x \\cap y . source # colon \u2014 Method . colon ( a :: NfAbsOrdIdl , b :: NfAbsOrdIdl ) -> NfOrdFracIdl The ideal (a:b) = \\{x \\in K | xb \\subseteq a\\} = \\hom(b, a) where K is the number field. source # in \u2014 Method . in ( x :: NumFieldOrdElem , y :: NumFieldOrdIdl ) in ( x :: NumFieldElem , y :: NumFieldOrdIdl ) in ( x :: fmpz , y :: NumFieldOrdIdl ) Returns whether x is contained in y . source # ispower \u2014 Method . ispower ( A :: NfAbsOrdIdl , n :: Int ) -> Bool , NfAbsOrdIdl ispower ( A :: NfOrdFracIdl , n :: Int ) -> Bool , NfOrdFracIdl Computes, if possible, an ideal B s.th. B^n==A holds. In this case, true and B are returned. source # ispower \u2014 Method . ispower ( I :: NfAbsOrdIdl ) -> Int , NfAbsOrdIdl ispower ( a :: NfOrdFracIdl ) -> Int , NfOrdFracIdl Writes a = r^e with e maximal. Note: 1 = 1^0 . source # isinvertible \u2014 Method . isinvertible ( A :: NfAbsOrdIdl ) -> Bool , NfOrdFracIdl Returns true and an inverse of A or false and an ideal B such that A*B \\subsetneq order(A) , if A is not invertible. source # isone \u2014 Method . isone ( A :: NfAbsOrdIdl ) -> Bool isunit ( A :: NfAbsOrdIdl ) -> Bool Tests if A is the trivial ideal generated by 1 . source","title":"Arithmetic"},{"location":"orders/ideals/#class-group","text":"The group of invertable ideals in any order forms a group and the principal ideals a subgroup. The finite quotient is called class group for maximal orders and Picard group or ring class group in general. # class_group \u2014 Method . class_group ( O :: NfOrd ; bound = - 1 , method = 3 , redo = false , large = 1000 ) -> GrpAbFinGen , Map Returns a group A and a map f from A to the set of ideals of O . The inverse of the map is the projection onto the group of ideals modulo the group of principal ideals. redo allows to trigger a re-computation, thus avoiding the cache. bound , when given, is the bound for the factor base. source # narrow_class_group \u2014 Method . narrow_class_group ( O :: NfOrd ) -> GrpAbFinGen , Map Computes the narrow (or strict) class group of O , ie. the group of invertable ideals modulo principal ideals generated by elements that are positive at all real places. source # picard_group \u2014 Method . picard_group ( O :: NfOrd ) -> GrpAbFinGen , MapClassGrp Returns the Picard group of O and a map from the group in the set of (invertible) ideals of O . source # ring_class_group \u2014 Method . ring_class_group ( O :: NfAbsOrd ) The ring class group (Picard group) of O . source julia> k , a = wildanger_field ( 3 , 13 ); julia> zk = maximal_order ( k ); julia> c , mc = class_group ( zk ) (GrpAb: Z/9, ClassGroup map of Set of ideals of Maximal order of Number field over Rational Field with defining polynomial x^3 - 13*x^2 + 13*x - 13 with basis nf_elem[1, _$, 1//2*_$^2 + 1//2] ) julia> lp = prime_ideals_up_to ( zk , 20 ); julia> [ mc \\ I for I = lp ] 10-element Vector{GrpAbFinGenElem}: Element of GrpAb: Z/9 with components [1] Element of GrpAb: Z/9 with components [4] Element of GrpAb: Z/9 with components [4] Element of GrpAb: Z/9 with components [5] Element of GrpAb: Z/9 with components [3] Element of GrpAb: Z/9 with components [2] Element of GrpAb: Z/9 with components [7] Element of GrpAb: Z/9 with components [1] Element of GrpAb: Z/9 with components [0] Element of GrpAb: Z/9 with components [2] julia> mc ( c [ 1 ]) <2, 7//2*_$^2 + 3*_$ + 3//2> Norm: 2 Minimum: 2 two normal wrt: 2 julia> order ( c [ 1 ]) 9 julia> mc ( c [ 1 ]) ^ Int ( order ( c [ 1 ])) <512, 60694820553551325838165//2*_$^2 - 30119530271281908295539*_$ + 65711602995885832267701//2> Norm: 512 two normal wrt: 2 julia> mc \\ ans Element of GrpAb: Z/9 with components [0] The class group, or more precisely the information used to compute it also allows for principal ideal testing and related tasks. In general, due to the size of the objetcs, the fac_elem versions are more effcient. # isprincipal \u2014 Method . isprincipal ( A :: NfOrdIdl ) -> Bool , NfOrdElem isprincipal ( A :: NfOrdFracIdl ) -> Bool , NfOrdElem Tests if A is principal and returns (\\mathtt{true}, \\alpha) if A = \\langle \\alpha\\rangle or (\\mathtt{false}, 1) otherwise. source # isprincipal_fac_elem \u2014 Method . isprincipal_fac_elem ( A :: NfOrdIdl ) -> Bool , FacElem { nf_elem , NumberField } Tests if A is principal and returns (\\mathtt{true}, \\alpha) if A = \\langle \\alpha\\rangle or (\\mathtt{false}, 1) otherwise. The generator will be in factored form. source # power_class \u2014 Method . power_class ( A :: NfOrdIdl , e :: fmpz ) -> NfOrdIdl Computes a (small) ideal in the same class as A^e . source # power_product_class \u2014 Method . power_product_class ( A :: Vector { NfOrdIdl }, e :: Vector { fmpz }) -> NfOrdIdl Computes a (small) ideal in the same class as \\prod A_i^{e_i} . source # power_reduce \u2014 Method . power_reduce ( A :: NfOrdIdl , e :: fmpz ) -> NfOrdIdl , FacElem { nf_elem } Computes B and \\alpha in factored form, such that \\alpha B = A^e B has small norm. source # class_group_ideal_relation \u2014 Method . class_group_ideal_relation ( I :: NfOrdIdl , c :: ClassGrpCtx ) -> nf_elem , SRow { fmpz } Finds a number field element \\alpha such that \\alpha I factors over the factor base in c . source # factor_base_bound_grh \u2014 Method . factor_base_bound_grh ( O :: NfOrd ) -> Int Returns an integer B , such that under GRH the ideal class group of \\mathcal O is generated by the prime ideals of norm bounded by B . source # factor_base_bound_bach \u2014 Method . factor_base_bound_bach ( O :: NfOrd ) -> Int Use the theorem of Bach to find B such that under GRH the ideal class group of \\mathcal O is generated by the prime ideals of norm bounded by B . source # prime_ideals_up_to \u2014 Function . prime_ideals_up_to ( O :: NfOrd , B :: Int ; degree_limit :: Int = 0 , index_divisors :: Bool = true ) -> Vector { NfOrdIdl } Computes the prime ideals \\mathcal O with norm up to B . If degree_limit is a nonzero integer k , then prime ideals \\mathfrak p with \\deg(\\mathfrak p) > k will be discarded. If 'index_divisors' is set to false, only primes not dividing the index of the order will be computed. source prime_ideals_up_to(O::NfOrd, B::Int; complete::Bool = false, degree_limit::Int = 0, F::Function, bad::fmpz) Computes the prime ideals \\mathcal O with norm up to B . If degree_limit is a nonzero integer k , then prime ideals \\mathfrak p with \\deg(\\mathfrak p) > k will be discarded. The function F must be a function on prime numbers not dividing bad such that F(p) = \\deg(\\mathfrak p) for all prime ideals \\mathfrak p lying above p . source julia> I = mc ( c [ 1 ]) <2, 7//2*_$^2 + 3*_$ + 3//2> Norm: 2 Minimum: 2 two normal wrt: 2 julia> Hecke . isprincipal ( I ) (false, 1) julia> I = I ^ Int ( order ( c [ 1 ])) <512, 60694820553551325838165//2*_$^2 - 30119530271281908295539*_$ + 65711602995885832267701//2> Norm: 512 two normal wrt: 2 julia> Hecke . isprincipal ( I ) (true, 1//2*_$^2 - 3*_$ + 9//2) julia> Hecke . isprincipal_fac_elem ( I ) (true, Factored element with data Dict{nf_elem, fmpz}(1//2*_$^2 - 3*_$ + 9//2 => 1)) The computation of S -units is also tied to the class group: # torsion_units \u2014 Method . torsion_units ( O :: NfOrd ) -> Vector { NfOrdElem } Given an order O , compute the torsion units of O . source # torsion_unit_group \u2014 Method . torsion_unit_group ( O :: NfOrd ) -> GrpAb , Map Given an order \\mathcal O , returns the torsion units as an abelian group G together with a map G \\to \\mathcal O^\\times . source # torsion_units_generator \u2014 Method . torsion_units_generator ( O :: NfOrd ) -> NfOrdElem Given an order O , compute a generator of the torsion units of O . source # torsion_units_gen_order \u2014 Method . torsion_units_gen_order ( O :: NfOrd ) -> NfOrdElem Given an order O , compute a generator of the torsion units of O as well as its order. source # unit_group \u2014 Method . unit_group ( O :: NfOrd ) -> GrpAbFinGen , Map Returns a group U and an isomorphism map f \\colon U \\to \\mathcal O^\\times . A set of fundamental units of \\mathcal O can be obtained via [ f(U[1+i]) for i in 1:unit_group_rank(O) ] . f(U[1]) will give a generator for the torsion subgroup. source # unit_group_fac_elem \u2014 Method . unit_group_fac_elem ( O :: NfOrd ) -> GrpAbFinGen , Map Returns a group U and an isomorphism map f \\colon U \\to \\mathcal O^\\times . A set of fundamental units of \\mathcal O can be obtained via [ f(U[1+i]) for i in 1:unit_group_rank(O) ] . f(U[1]) will give a generator for the torsion subgroup. All elements will be returned in factored form. source # sunit_group \u2014 Method . sunit_group ( I :: Vector { NfOrdIdl }) -> GrpAb , Map For an array I of (coprime prime) ideals, find the S -unit group defined by I , ie. the group of non-zero field elements which are only divisible by ideals in I . source # sunit_group_fac_elem \u2014 Method . sunit_group_fac_elem ( I :: Vector { NfOrdIdl }) -> GrpAb , Map For an array I of (coprime prime) ideals, find the S -unit group defined by I , ie. the group of non-zero field elements which are only divisible by ideals in I . The map will return elements in factored form. source # sunit_mod_units_group_fac_elem \u2014 Method . sunit_mod_units_group_fac_elem ( I :: Vector { NfOrdIdl }) -> GrpAb , Map For an array I of (coprime prime) ideals, find the S -unit group defined by I , ie. the group of non-zero field elements which are only divisible by ideals in I modulo the units of the field. The map will return elements in factored form. source julia> u , mu = unit_group ( zk ) (GrpAb: Z/2 x Z, UnitGroup map of Maximal order of Number field over Rational Field with defining polynomial x^3 - 13*x^2 + 13*x - 13 with basis nf_elem[1, _$, 1//2*_$^2 + 1//2] ) julia> mu ( u [ 2 ]) -_$^2 + _$ - 1 julia> u , mu = unit_group_fac_elem ( zk ) (GrpAb: Z/2 x Z, UnitGroup map of Factored elements over Number field over Rational Field with defining polynomial x^3 - 13*x^2 + 13*x - 13 ) julia> mu ( u [ 2 ]) Factored element with data Dict{nf_elem, fmpz}(_$^2 + 1 => 1, 3 => -1, _$ - 3 => -1, 3*_$^2 - 40*_$ + 51 => -1, -3*_$^2 + 29*_$ + 4 => 1) julia> evaluate ( ans ) -_$^2 + _$ - 1 julia> lp = factor ( 6 * zk ) Dict{NfOrdIdl, Int64} with 4 entries: <3, _$^2 + 1> => 1 <2, 3//2*_$^2 + _$ + 3//2> => 1 <2, 7//2*_$^2 + 2*_$ + 3//2> => 2 <3, _$ - 1> => 1 julia> s , ms = Hecke . sunit_group ( collect ( keys ( lp ))) (GrpAb: Z/2 x Z^(5), SUnits map of Number field over Rational Field with defining polynomial x^3 - 13*x^2 + 13*x - 13 for NfOrdIdl[<3, _$^2 + 1> Norm: 9 Minimum: 3 basis_matrix [3 0 0; 0 3 0; 0 0 1] two normal wrt: 3, <2, 3//2*_$^2 + _$ + 3//2> Norm: 2 Minimum: 2 basis_matrix [2 0 0; 1 1 0; 1 0 1] two normal wrt: 2, <2, 7//2*_$^2 + 2*_$ + 3//2> Norm: 2 Minimum: 2 basis_matrix [2 0 0; 1 1 0; 0 0 1] two normal wrt: 2, <3, _$ - 1> Norm: 3 Minimum: 3 basis_matrix [3 0 0; 2 1 0; 2 0 1] two normal wrt: 3] ) julia> ms ( s [ 4 ]) 1//2*_$^2 - 6*_$ - 1//2 julia> norm ( ans ) -18 julia> factor ( numerator ( ans )) -1 * 2 * 3^2","title":"Class Group"},{"location":"orders/ideals/#miscaellenous","text":"# order \u2014 Method . order ( I :: NumFieldOrdIdl ) -> NfOrd Returns the order of I . source # order \u2014 Method . order ( a :: NfAbsOrdFracIdl ) -> NfAbsOrd The order that was used to define the ideal a . source # order \u2014 Method . order ( I :: NumFieldOrdIdl ) -> NfOrd Returns the order of I . source # order \u2014 Method . order ( a :: NfRelOrdFracIdl ) -> NfRelOrd Returns the order of a . source # nf \u2014 Method . nf ( x :: NumFieldOrdIdl ) -> AnticNumberField Returns the number field, of which x is an integral ideal. source # basis \u2014 Method . basis ( A :: NfAbsOrdIdl ) -> Vector { NfOrdElem } Returns the basis of A . source basis ( I :: NfAbsOrdFracIdl ) -> Vector { nf_elem } Returns the \\mathbf Z -basis of I . source # lll_basis \u2014 Method . lll_basis ( I :: NumFieldOrdIdl ) -> Vector { NumFieldElem } A basis for I that is reduced using the LLL algorithm for the Minkowski metric. source # basis_matrix \u2014 Method . basis_matrix ( A :: NfAbsOrdIdl ) -> fmpz_mat Returns the basis matrix of A . source # basis_mat_inv \u2014 Method . basis_mat_inv ( O :: NfAbsOrd ) -> FakeFmpqMat Returns the inverse of the basis matrix of \\mathcal O . source basis_mat_inv(A::NfAbsOrdIdl) -> fmpz_mat Returns the inverse basis matrix of A . source # assure_has_basis_mat_inv \u2014 Method . basis_mat_inv ( A :: NfAbsOrdIdl ) -> FakeFmpqMat Returns the inverse of the basis matrix of A . source # has_basis \u2014 Method . has_basis ( A :: NfAbsOrdIdl ) -> Bool Returns whether A has a basis already computed. source # has_basis_matrix \u2014 Method . has_basis_matrix ( A :: NfAbsOrdIdl ) -> Bool Returns whether A knows its basis matrix. source # has_2_elem \u2014 Method . has_2_elem ( A :: NfAbsOrdIdl ) -> Bool Returns whether A is generated by two elements. source # has_2_elem_normal \u2014 Method . has_2_elem_normal ( A :: NfAbsOrdIdl ) -> Bool Returns whether A has normal two element generators. source # has_weakly_normal \u2014 Method . has_weakly_normal ( A :: NfAbsOrdIdl ) -> Bool Returns whether A has weakly normal two element generators. source # has_princ_gen_special \u2014 Method . has_princ_gen_special ( A :: NfAbsOrdIdl ) -> Bool Returns whether A knows if it is generated by a rational integer. source # principal_generator \u2014 Method . principal_generator ( A :: NfOrdIdl ) -> NfOrdElem For a principal ideal A , find a generator. source # principal_generator_fac_elem \u2014 Method . principal_generator_fac_elem ( A :: NfOrdIdl ) -> FacElem { nf_elem , NumberField } For a principal ideal A , find a generator in factored form. source # minimum \u2014 Method . minimum ( A :: NfAbsOrdIdl ) -> fmpz Returns the smallest nonnegative element in A \\cap \\mathbf Z . source minimum ( A :: NfRelOrdIdl ) -> NfOrdIdl minimum ( A :: NfRelOrdIdl ) -> NfRelOrdIdl Returns the ideal A \\cap O where O is the maximal order of the coefficient ideals of A . source # minimum \u2014 Method . minimum ( A :: NfRelOrdIdl ) -> NfOrdIdl minimum ( A :: NfRelOrdIdl ) -> NfRelOrdIdl Returns the ideal A \\cap O where O is the maximal order of the coefficient ideals of A . source # minimum \u2014 Method . minimum ( A :: NfAbsOrdIdl ) -> fmpz Returns the smallest nonnegative element in A \\cap \\mathbf Z . source # has_minimum \u2014 Method . has_minimum ( A :: NfAbsOrdIdl ) -> Bool Returns whether A knows its mininum. source # norm \u2014 Method . norm ( A :: NfAbsOrdIdl ) -> fmpz Returns the norm of A , that is, the cardinality of \\mathcal O/A , where \\mathcal O is the order of A . source norm(a::NfRelOrdIdl) -> NfOrdIdl Returns the norm of a . source norm(a::NfRelOrdFracIdl{T, S}) -> S Returns the norm of a . source norm(a::AlgAssAbsOrdIdl, O::AlgAssAbsOrd; copy::Bool = true) -> fmpq Returns the norm of a considered as an (possibly fractional) ideal of O . source norm(a::AlgAssRelOrdIdl{S, T, U}, O::AlgAssRelOrd{S, T, U}; copy::Bool = true) where { S, T, U } -> T Returns the norm of a considered as an (possibly fractional) ideal of O . source # has_norm \u2014 Method . has_norm ( A :: NfAbsOrdIdl ) -> Bool Returns whether A knows its norm. source # idempotents \u2014 Method . idempotents ( x :: NfOrdIdl , y :: NfOrdIdl ) -> NfOrdElem , NfOrdElem Returns a tuple (e, f) consisting of elements e in x , f in y such that 1 = e + f . If the ideals are not coprime, an error is raised. source # isprime \u2014 Method . isprime ( A :: NfOrdIdl ) -> Bool Returns whether A is a prime ideal. source # isprime_known \u2014 Method . isprime_known ( A :: NfOrdIdl ) -> Bool Returns whether A knows if it is prime. source # isramified \u2014 Method . isramified ( O :: NfOrd , p :: Int ) -> Bool Returns whether the integer p is ramified in \\mathcal O . It is assumed that p is prime. source # ramification_index \u2014 Method . ramification_index ( P :: NfOrdIdl ) -> Int The ramification index of the prime-ideal P . source # degree \u2014 Method . degree ( P :: NfOrdIdl ) -> Int The inertia degree of the prime-ideal P . source # valuation \u2014 Method . valuation ( a :: NumFieldElem , p :: NfOrdIdl ) -> fmpz Computes the \\mathfrak p -adic valuation of a , that is, the largest i such that a is contained in \\mathfrak p^i . source # valuation \u2014 Method . valuation ( a :: nf_elem , p :: NfOrdIdl ) -> fmpz valuation ( a :: NfOrdElem , p :: NfOrdIdl ) -> fmpz valuation ( a :: fmpz , p :: NfOrdIdl ) -> fmpz Computes the \\mathfrak p -adic valuation of a , that is, the largest i such that a is contained in \\mathfrak p^i . source # valuation \u2014 Method . valuation ( A :: NfOrdIdl , p :: NfOrdIdl ) -> fmpz Computes the \\mathfrak p -adic valuation of A , that is, the largest i such that A is contained in \\mathfrak p^i . source # valuation \u2014 Method . valuation ( a :: Integer , p :: NfOrdIdl ) -> fmpz Computes the \\mathfrak p -adic valuation of a , that is, the largest i such that a is contained in \\mathfrak p^i . source # valuation \u2014 Method . valuation ( a :: nf_elem , p :: NfOrdIdl ) -> fmpz valuation ( a :: NfOrdElem , p :: NfOrdIdl ) -> fmpz valuation ( a :: fmpz , p :: NfOrdIdl ) -> fmpz Computes the \\mathfrak p -adic valuation of a , that is, the largest i such that a is contained in \\mathfrak p^i . source # valuation \u2014 Method . valuation ( A :: NfAbsOrdFracIdl , p :: NfAbsOrdIdl ) The valuation of A at p . source # idempotents \u2014 Method . idempotents ( x :: NfOrdIdl , y :: NfOrdIdl ) -> NfOrdElem , NfOrdElem Returns a tuple (e, f) consisting of elements e in x , f in y such that 1 = e + f . If the ideals are not coprime, an error is raised. source","title":"Miscaellenous"},{"location":"orders/ideals/#quotient-rings","text":"# quo \u2014 Method . quo ( O :: NfOrd , I :: NfOrdIdl ) -> NfOrdQuoRing , Map quo ( O :: AlgAssAbsOrd , I :: AlgAssAbsOrdIdl ) -> AbsOrdQuoRing , Map The quotient ring O/I as a ring together with the section M: O/I \\to O . The pointwise inverse of M is the canonical projection O\\to O/I . source # ResidueRing \u2014 Method . ResidueRing ( O :: NfOrd , I :: NfOrdIdl ) -> NfOrdQuoRing ResidueRing ( O :: AlgAssAbsOrd , I :: AlgAssAbsOrdIdl ) -> AbsOrdQuoRing The quotient ring O modulo I as a new ring. source # ResidueField \u2014 Method . ResidueField ( O :: NfOrd , P :: NfOrdIdl , check :: Bool = true ) -> Field , Map Returns the residue field of the prime ideal P together with the projection map. If check is true, the ideal is checked for being prime. source # mod \u2014 Method . mod ( x :: NfOrdElem , I :: NfAbsOrdIdl ) Returns the unique element y of the ambient order of x with x \\equiv y \\bmod I and the following property: If a_1,\\dotsc,a_d \\in \\mathbf{Z}_{\\geq 1} are the diagonal entries of the unique HNF basis matrix of I and (b_1,\\dotsc,b_d) is the coefficient vector of y , then 0 \\leq b_i < a_i for 1 \\leq i \\leq d . source # crt \u2014 Method . crt ( r1 :: NfOrdElem , i1 :: NfOrdIdl , r2 :: NfOrdElem , i2 :: NfOrdIdl ) -> NfOrdElem Find x such that x \\equiv r_1 \\bmod i_1 and x \\equiv r_2 \\bmod i_2 using idempotents . source # euler_phi \u2014 Method . euler_phi ( A :: NfOrdIdl ) -> fmpz The ideal version of the totient function returns the size of the unit group of the residue ring modulo the ideal. source # multiplicative_group \u2014 Method . multiplicative_group ( Q :: NfOrdQuoRing ) -> GrpAbFinGen , Map { GrpAbFinGen , NfOrdQuoRing } unit_group ( Q :: NfOrdQuoRing ) -> GrpAbFinGen , Map { GrpAbFinGen , NfOrdQuoRing } Returns the unit group of Q as an abstract group A and an isomorphism map f \\colon A \\to Q^\\times . source # multiplicative_group_generators \u2014 Method . multiplicative_group_generators ( Q :: NfOrdQuoRing ) -> Vector { NfOrdQuoRingElem } Return a set of generators for Q^\\times . source","title":"Quotient Rings"},{"location":"orders/introduction/","text":"Introduction This chapter deals with number fields and orders there of. We follow the common terminology and conventions as e.g. used in Coh93 , Coh00 , PZ97 or Mar18 . If K is a number field, then an order \\mathcal O of K is a subring of the ring of integers \\mathcal O_K of K , which is free of rank [K : \\mathbf Q] as a \\mathbf Z -module. Depending on whether K is an absolute field or relative field, orders are treated differently. As far as possible, the interaction and the interface for orders of absolute number fields and of relative number fields is the same. Orders of absolute number fields Assume that K is defined as an absolute field. An order \\mathcal O of such a field are constructed (implicitely) by specifying a \\mathbf Z -basis, which is refered to as the basis of \\mathcal O . If (\\omega_1,\\dotsc,\\omega_d) is the basis of \\mathcal O and (\\alpha_1,\\dotsc,\\alpha_d) the basis of K , then the matrix B \\in \\operatorname{Mat}_{d \\times d}(\\mathbf Q) with \\begin{pmatrix} \\omega_1 \\\\ \\vdots \\\\ \\omega_d \\end{pmatrix} = B \\begin{pmatrix} \\alpha_1 \\\\ \\vdots \\\\ \\alpha_d \\end{pmatrix} is the basis matrix of K . If K = \\mathbf{Q}(\\alpha) = \\mathbf{Q}[x]/(f) is simple with f \\in \\mathbf{Z}[x] , then natural order \\mathbf Z[\\alpha] = \\mathbf{Z}[x]/(f) is called the equation order of K . Orders of relative number fields Orders in non-absolute number fields, that is, relative extensions, are represented differently. Let L/K be a finite extension of number fields, then currently we require any order in L to contain \\mathcal O_K , the ring of integers of K . In this case, an order \\mathcal O in L is a finitly generated torsion-free module over the Dedekind domain \\mathcal O_K . As a ring, the order \\mathcal O is unitary and has L as a fraction field. Due to \\mathcal O_K in general not being a principal ideal domain, the module structure is more complicated and requires so called pseudo-matrices. See here for details on pseudo-matrices, or Coh00 , Chapter 1 for an introduction. In short, \\mathcal O is represented as \\sum \\mathfrak a_i \\omega_i with fractional \\mathcal O_K ideals \\mathfrak a_i\\subset K and K -linear independent elements \\omega_i\\in L . In general it is impossible to have both \\mathfrak a_i integral and \\omega_i \\in \\mathcal O , thus coefficients will not be integral and/or generators not in the structure. Examples Usually, to create an order, one starts with a field (or a polynomial): julia> Qx , x = PolynomialRing ( QQ , \"x\" ); julia> K , a = NumberField ( x ^ 2 - 10 , \"a\" ); julia> E = EquationOrder ( K ) Maximal order of Number field over Rational Field with defining polynomial x^2 - 10 with basis nf_elem[1, a] julia> Z_K = MaximalOrder ( K ) Maximal order of Number field over Rational Field with defining polynomial x^2 - 10 with basis nf_elem[1, a] julia> conductor ( E ) <no 2-elts present> basis_matrix [1 0; 0 1] julia> E == Z_K true Once orders are created, we can play with elements and ideals: julia> lp = prime_decomposition ( Z_K , 2 ) 1-element Vector{Tuple{NfOrdIdl, Int64}}: (<2, a> Norm: 2 Minimum: 2 two normal wrt: 2, 2) julia> p = lp [ 1 ][ 1 ] <2, a> Norm: 2 Minimum: 2 two normal wrt: 2 julia> isprincipal ( p ) (false, 1) julia> fl , alpha = isprincipal ( p ^ 2 ) (true, -2) julia> norm ( alpha ) 4 It is possible to work with residue fields as well: julia> Fp , mFp = ResidueField ( Z_K , p ) (Finite field of degree 1 over F_2, Map with following data Domain: ======= Maximal order of Number field over Rational Field with defining polynomial x^2 - 10 with basis nf_elem[1, a] Codomain: ========= Finite field of degree 1 over F_2 ) julia> [ mFp ( x ) for x = basis ( Z_K )] 2-element Vector{fq}: 1 0","title":"Introduction"},{"location":"orders/introduction/#introduction","text":"This chapter deals with number fields and orders there of. We follow the common terminology and conventions as e.g. used in Coh93 , Coh00 , PZ97 or Mar18 . If K is a number field, then an order \\mathcal O of K is a subring of the ring of integers \\mathcal O_K of K , which is free of rank [K : \\mathbf Q] as a \\mathbf Z -module. Depending on whether K is an absolute field or relative field, orders are treated differently. As far as possible, the interaction and the interface for orders of absolute number fields and of relative number fields is the same.","title":"Introduction"},{"location":"orders/introduction/#orders-of-absolute-number-fields","text":"Assume that K is defined as an absolute field. An order \\mathcal O of such a field are constructed (implicitely) by specifying a \\mathbf Z -basis, which is refered to as the basis of \\mathcal O . If (\\omega_1,\\dotsc,\\omega_d) is the basis of \\mathcal O and (\\alpha_1,\\dotsc,\\alpha_d) the basis of K , then the matrix B \\in \\operatorname{Mat}_{d \\times d}(\\mathbf Q) with \\begin{pmatrix} \\omega_1 \\\\ \\vdots \\\\ \\omega_d \\end{pmatrix} = B \\begin{pmatrix} \\alpha_1 \\\\ \\vdots \\\\ \\alpha_d \\end{pmatrix} is the basis matrix of K . If K = \\mathbf{Q}(\\alpha) = \\mathbf{Q}[x]/(f) is simple with f \\in \\mathbf{Z}[x] , then natural order \\mathbf Z[\\alpha] = \\mathbf{Z}[x]/(f) is called the equation order of K .","title":"Orders of absolute number fields"},{"location":"orders/introduction/#orders-of-relative-number-fields","text":"Orders in non-absolute number fields, that is, relative extensions, are represented differently. Let L/K be a finite extension of number fields, then currently we require any order in L to contain \\mathcal O_K , the ring of integers of K . In this case, an order \\mathcal O in L is a finitly generated torsion-free module over the Dedekind domain \\mathcal O_K . As a ring, the order \\mathcal O is unitary and has L as a fraction field. Due to \\mathcal O_K in general not being a principal ideal domain, the module structure is more complicated and requires so called pseudo-matrices. See here for details on pseudo-matrices, or Coh00 , Chapter 1 for an introduction. In short, \\mathcal O is represented as \\sum \\mathfrak a_i \\omega_i with fractional \\mathcal O_K ideals \\mathfrak a_i\\subset K and K -linear independent elements \\omega_i\\in L . In general it is impossible to have both \\mathfrak a_i integral and \\omega_i \\in \\mathcal O , thus coefficients will not be integral and/or generators not in the structure.","title":"Orders of relative number fields"},{"location":"orders/introduction/#examples","text":"Usually, to create an order, one starts with a field (or a polynomial): julia> Qx , x = PolynomialRing ( QQ , \"x\" ); julia> K , a = NumberField ( x ^ 2 - 10 , \"a\" ); julia> E = EquationOrder ( K ) Maximal order of Number field over Rational Field with defining polynomial x^2 - 10 with basis nf_elem[1, a] julia> Z_K = MaximalOrder ( K ) Maximal order of Number field over Rational Field with defining polynomial x^2 - 10 with basis nf_elem[1, a] julia> conductor ( E ) <no 2-elts present> basis_matrix [1 0; 0 1] julia> E == Z_K true Once orders are created, we can play with elements and ideals: julia> lp = prime_decomposition ( Z_K , 2 ) 1-element Vector{Tuple{NfOrdIdl, Int64}}: (<2, a> Norm: 2 Minimum: 2 two normal wrt: 2, 2) julia> p = lp [ 1 ][ 1 ] <2, a> Norm: 2 Minimum: 2 two normal wrt: 2 julia> isprincipal ( p ) (false, 1) julia> fl , alpha = isprincipal ( p ^ 2 ) (true, -2) julia> norm ( alpha ) 4 It is possible to work with residue fields as well: julia> Fp , mFp = ResidueField ( Z_K , p ) (Finite field of degree 1 over F_2, Map with following data Domain: ======= Maximal order of Number field over Rational Field with defining polynomial x^2 - 10 with basis nf_elem[1, a] Codomain: ========= Finite field of degree 1 over F_2 ) julia> [ mFp ( x ) for x = basis ( Z_K )] 2-element Vector{fq}: 1 0","title":"Examples"},{"location":"orders/orders/","text":"Orders Orders, that is, unitary subrings that are free \\mathbf{Z} -modules of rank equal to the degree of the number field, are at the core of the arithmetic of number fields. In Hecke, orders are always represented using the module structure, be it the \\mathbf{Z} -module structure for orders of absolute numbers fields, or the structure as a module over the maximal order of the base field in the case of relative number fields. In this chapter we mainly deal with orders of absolute fields. However, many functions apply in same way to relative extensions. There are more general definitions of orders in number fields available, but those are (currently) not implemented in Hecke. Among all orders in a fixed field, there is a unique maximal order, called the maximal order , or ring of integers of the number field. It is well known that this is the only order that is a Dedekind domain, hence has a rich ideal structure as well. The maximal order is also the integral closure of \\mathbf{Z} in the number field and can also be interpreted as a normalization of any other order. Creation and basic properties # Order \u2014 Method . Order ( B :: Vector { nf_elem }; check :: Bool = true , cached :: Bool = true , isbasis :: Bool = false ) -> NfOrd Order ( K :: AnticNumberField , B :: Vector { nf_elem }; check :: Bool = true , cached :: Bool = true , isbasis :: Bool = false ) -> NfOrd Returns the order generated by B . If check is set, it is checked whether B defines an order. If isbasis is set, then elements are assumed to form a \\mathbf{Z} -basis. source # Order \u2014 Method . Order ( K :: AnticNumberField , A :: FakeFmpqMat ; check :: Bool = true ) -> NfOrd Returns the order which has basis matrix A with respect to the power basis of K . If check is set, it is checked whether A defines an order. source # Order \u2014 Method . Order ( K :: AnticNumberField , A :: fmpz_mat , check :: Bool = true ) -> NfOrd Returns the order which has basis matrix A with respect to the power basis of K . If check is set, it is checked whether A defines an order. source Order(A::AbsAlgAss{<: NumFieldElem}, M::PMat{<: NumFieldElem, T}) -> AlgAssRelOrd Returns the order of A with basis pseudo-matrix M . source # EquationOrder \u2014 Method . EquationOrder ( K :: NumberField ) -> NumFieldOrd equation_order ( K :: NumberField ) -> NumFieldOrd Returns the equation order of the number field K . source # MaximalOrder \u2014 Method . MaximalOrder ( K :: NumField { fmpq }; discriminant :: fmpz , ramified_primes :: Vector { fmpz }) -> NfAbsOrd Returns the maximal order of K . Additional information can be supplied if they are already known, as the ramified primes or the discriminant of the maximal order. Example julia> Qx , x = FlintQQ [ \"x\" ]; julia> K , a = NumberField ( x ^ 3 + 2 , \"a\" ); julia> O = MaximalOrder ( K ); source # MaximalOrder \u2014 Method . MaximalOrder ( O :: NfAbsOrd ; index_divisors :: Vector { fmpz }, discriminant :: fmpz , ramified_primes :: Vector { fmpz }) -> NfAbsOrd Returns the maximal order of the number field that contains O . Additional information can be supplied if they are already known, as the ramified primes, the discriminant of the maximal order or a set of integers dividing the index of O in the maximal order. source MaximalOrder(O::AlgAssAbsOrd) Given an order O , this function returns a maximal order containing O . source MaximalOrder(A::AbsAlgAss{fmpq}) -> AlgAssAbsOrd Returns a maximal order of A . source # lll \u2014 Method . lll ( M :: NfAbsOrd ) -> NfAbsOrd The same order, but with the basis now being LLL reduced wrt. the Minkowski metric. source # any_order \u2014 Method . any_order ( K :: NumberField ) Return some order in K . In case the defining polynomial for K is monic and integral, this just returns the equation order. In the other case \\mathbb Z[\\alpha]\\cap \\mathbb Z[1/\\alpha] is returned. source Example julia> Qx , x = PolynomialRing ( FlintQQ , \"x\" ); julia> K , a = NumberField ( x ^ 2 - 2 , \"a\" ); julia> O = EquationOrder ( K ) Order of Number field over Rational Field with defining polynomial x^2 - 2 with Z-basis NfOrdElem[1, a] # parent \u2014 Method . parent ( O :: NfAbsOrd ) -> NfOrdSet Returns the parent of \\mathcal O , that is, the set of orders of the ambient number field. source # signature \u2014 Method . signature ( O :: NumFieldOrd ) -> Tuple { Int , Int } Returns the signature of the ambient number field of \\mathcal O . source # nf \u2014 Method . nf ( O :: NumFieldOrd ) -> NumField Returns the ambient number field of \\mathcal O . source # basis \u2014 Method . basis ( O :: NfAbsOrd ) -> Vector { NfAbsOrdElem } Returns the \\mathbf Z -basis of \\mathcal O . source basis ( I :: NfAbsOrdFracIdl ) -> Vector { nf_elem } Returns the \\mathbf Z -basis of I . source # lll_basis \u2014 Method . lll_basis ( M :: NumFieldOrd ) -> Vector { NumFieldElem } A basis for M that is reduced using the LLL algorithm for the Minkowski metric. source # basis \u2014 Method . basis ( O :: NfOrd , K :: AnticNumberField ) -> Vector { nf_elem } Returns the \\mathbf Z -basis elements of \\mathcal O as elements of the ambient number field. source # pseudo_basis \u2014 Method . pseudo_basis ( O :: NfRelOrd { T , S }) -> Vector { Tuple { NumFieldElem { T }, S }} Returns the pseudo-basis of \\mathcal O . source # basis_pmatrix \u2014 Method . basis_pmatrix ( O :: NfRelOrd ) -> PMat Returns the basis pseudo-matrix of \\mathcal O with respect to the power basis of the ambient number field. source # basis_nf \u2014 Method . basis_nf ( O :: NfRelOrd ) -> Vector { NumFieldElem } Returns the elements of the pseudo-basis of \\mathcal O as elements of the ambient number field. source # inv_coeff_ideals \u2014 Method . inv_coeff_ideals ( O :: NfRelOrd { T , S }) -> Vector { S } Returns the inverses of the coefficient ideals of the pseudo basis of O . source # basis_matrix \u2014 Method . basis_matrix ( O :: NfAbsOrd ) -> FakeFmpqMat Returns the basis matrix of \\mathcal O with respect to the basis of the ambient number field. source # basis_mat_inv \u2014 Method . basis_mat_inv ( O :: NfAbsOrd ) -> FakeFmpqMat Returns the inverse of the basis matrix of \\mathcal O . source basis_mat_inv(A::NfAbsOrdIdl) -> fmpz_mat Returns the inverse basis matrix of A . source # gen_index \u2014 Method . gen_index ( O :: NfOrd ) -> fmpq Returns the generalized index of \\mathcal O with respect to the equation order of the ambient number field. source # isindex_divisor \u2014 Method . isindex_divisor ( O :: NfOrd , d :: fmpz ) -> Bool isindex_divisor ( O :: NfOrd , d :: Int ) -> Bool Returns whether d is a divisor of the index of \\mathcal O . It is assumed that \\mathcal O contains the equation order of the ambient number field. source # minkowski_matrix \u2014 Method . minkowski_matrix ( O :: NfAbsOrd , abs_tol :: Int = 64 ) -> arb_mat Returns the Minkowski matrix of \\mathcal O . Thus if \\mathcal O has degree d , then the result is a matrix in \\operatorname{Mat}_{d\\times d}(\\mathbf R) . The entries of the matrix are real balls of type arb with radius less then 2^-abs_tol . source # in \u2014 Method . in ( a :: NumFieldElem , O :: NumFieldOrd ) -> Bool Checks whether a lies in \\mathcal O . source # norm_change_const \u2014 Method . norm_change_const ( O :: NfOrd ) -> ( Float64 , Float64 ) Returns (c_1, c_2) \\in \\mathbf R_{>0}^2 such that for all x = \\sum_{i=1}^d x_i \\omega_i \\in \\mathcal O we have T_2(x) \\leq c_1 \\cdot \\sum_i^d x_i^2 and \\sum_i^d x_i^2 \\leq c_2 \\cdot T_2(x) , where (\\omega_i)_i is the \\mathbf Z -basis of \\mathcal O . source # trace_matrix \u2014 Method . trace_matrix ( O :: NfAbsOrd ) -> fmpz_mat Returns the trace matrix of \\mathcal O , that is, the matrix (\\operatorname{tr}_{K/\\mathbf Q}(b_i \\cdot b_j))_{1 \\leq i, j \\leq d} . source # + \u2014 Method . + ( R :: NfOrd , S :: NfOrd ) -> NfOrd Given two orders R , S of K , this function returns the smallest order containing both R and S . It is assumed that R , S contain the ambient equation order and have coprime index. source # poverorder \u2014 Method . poverorder ( O :: NfOrd , p :: fmpz ) -> NfOrd poverorder ( O :: NfOrd , p :: Integer ) -> NfOrd This function tries to find an order that is locally larger than \\mathcal O at the prime p : If p divides the index [ \\mathcal O_K : \\mathcal O] , this function will return an order R such that v_p([ \\mathcal O_K : R]) < v_p([ \\mathcal O_K : \\mathcal O]) . Otherwise \\mathcal O is returned. source # poverorders \u2014 Method . poverorders ( O , p ) -> Vector { Ord } Returns all p -overorders of O , that is all overorders M , such that the index of O in M is a p -power. source # pmaximal_overorder \u2014 Method . pmaximal_overorder ( O :: NfOrd , p :: fmpz ) -> NfOrd pmaximal_overorder ( O :: NfOrd , p :: Integer ) -> NfOrd This function finds a p -maximal order R containing \\mathcal O . That is, the index [ \\mathcal O_K : R] is not divisible by p . source # pradical \u2014 Method . pradical ( O :: NfOrd , p :: { fmpz | Integer }) -> NfAbsOrdIdl Given a prime number p , this function returns the p -radical \\sqrt{p\\mathcal O} of \\mathcal O , which is just \\{ x \\in \\mathcal O \\mid \\exists k \\in \\mathbf Z_{\\geq 0} \\colon x^k \\in p\\mathcal O \\} . It is not checked that p is prime. source # pradical \u2014 Method . pradical ( O :: NfRelOrd , P :: NfOrdIdl ) -> NfRelOrdIdl Given a prime ideal P , this function returns the P -radical \\sqrt{P\\mathcal O} of \\mathcal O , which is just \\{ x \\in \\mathcal O \\mid \\exists k \\in \\mathbf Z_{\\geq 0} \\colon x^k \\in P\\mathcal O \\} . It is not checked that P is prime. source # ring_of_multipliers \u2014 Method . ring_of_multipliers ( I :: NfAbsOrdIdl ) -> NfAbsOrd Computes the order (I : I) , which is the set of all x \\in K with xI \\subseteq I . source Invariants # discriminant \u2014 Method . discriminant ( O :: NfOrd ) -> fmpz Returns the discriminant of \\mathcal O . source discriminant(E::EllCrv{T}) -> T Computes the discriminant of E . source discriminant(O::AlgssRelOrd) Returns the discriminant of O . source # discriminant \u2014 Method . discriminant ( O :: NfOrd ) -> fmpz Returns the discriminant of \\mathcal O . source # reduced_discriminant \u2014 Method . reduced_discriminant ( O :: NfOrd ) -> fmpz Returns the reduced discriminant, that is, the largest elementary divisor of the trace matrix of \\mathcal O . source # degree \u2014 Method . degree ( O :: NumFieldOrd ) -> Int Returns the degree of \\mathcal O . source # index \u2014 Method . index ( O :: NfOrd ) -> fmpz Assuming that the order \\mathcal O contains the equation order \\mathbf Z[\\alpha] of the ambient number field, this function returns the index [ \\mathcal O : \\mathbf Z] . source # different \u2014 Method . different ( R :: NfAbsOrd ) -> NfAbsOrdIdl The differnt ideal of R , that is, the ideal generated by all differents of elements in R . For Gorenstein orders, this is also the inverse ideal of the co-different. source # codifferent \u2014 Method . codifferent ( R :: NfAbsOrd ) -> NfOrdIdl The codiffernt ideal of R , i.e. the trace-dual of R . source # isgorenstein \u2014 Method . isgorenstein ( O :: NfOrd ) -> Bool Return whether the order \\mathcal{O} is Gorenstein. source # isbass \u2014 Method . isbass ( O :: NfOrd ) -> Bool Return whether the order \\mathcal{O} is Bass. source # isequation_order \u2014 Method . isequation_order ( O :: NumFieldOrd ) -> Bool Returns whether \\mathcal O is the equation order of the ambient number field K . source # zeta_log_residue \u2014 Method . zeta_log_residue ( O :: NfOrd , error :: Float64 ) -> arb Computes the residue of the zeta function of \\mathcal O at 1 . The output will be an element of type arb with radius less then error . source # ramified_primes \u2014 Method . ramified_primes ( O :: NfAbsOrd ) -> Vector { fmpz } Returns the list of prime numbers that divide \\operatorname{disc}(\\mathcal O) . source Arithmetic Progress and intermediate results of the functions mentioned here can be obtained via verbose_level , supported are ClassGroup UnitGroup All of the functions have a very similar interface: they return an abelian group and a map converting elements of the group into the objects required. The maps also allow a point-wise inverse to server as the discrete logarithm map. For more information on abelian group, see here , for ideals, here . torsion_unit_group(::NfOrd) unit_group(::NfOrd) unit_group_fac_elem(::NfOrd) sunit_group(::Vector{NfOrdIdl}) sunit_group_fac_elem(::Vector{NfOrdIdl}) sunit_mod_units_group_fac_elem(::Vector{NfOrdIdl}) class_group(::NfOrd) picard_group(::NfOrd) narrow_class_group(::NfOrd) For the processing of units, there are a couple of helper functions also available: # isindependent \u2014 Function . isindependent { T }( x :: Vector { T }) Given an array of non-zero units in a number field, returns whether they are multiplicatively independent. source Predicates # iscontained \u2014 Method . iscontained ( R :: NfAbsOrd , S :: NfAbsOrd ) -> Bool Checks if R is contained in S . source # ismaximal \u2014 Method . ismaximal ( R :: NfAbsOrd ) -> Bool Tests if the order R is maximal. This might trigger the computation of the maximal order. source","title":"Basics"},{"location":"orders/orders/#orders","text":"Orders, that is, unitary subrings that are free \\mathbf{Z} -modules of rank equal to the degree of the number field, are at the core of the arithmetic of number fields. In Hecke, orders are always represented using the module structure, be it the \\mathbf{Z} -module structure for orders of absolute numbers fields, or the structure as a module over the maximal order of the base field in the case of relative number fields. In this chapter we mainly deal with orders of absolute fields. However, many functions apply in same way to relative extensions. There are more general definitions of orders in number fields available, but those are (currently) not implemented in Hecke. Among all orders in a fixed field, there is a unique maximal order, called the maximal order , or ring of integers of the number field. It is well known that this is the only order that is a Dedekind domain, hence has a rich ideal structure as well. The maximal order is also the integral closure of \\mathbf{Z} in the number field and can also be interpreted as a normalization of any other order.","title":"Orders"},{"location":"orders/orders/#creation-and-basic-properties","text":"# Order \u2014 Method . Order ( B :: Vector { nf_elem }; check :: Bool = true , cached :: Bool = true , isbasis :: Bool = false ) -> NfOrd Order ( K :: AnticNumberField , B :: Vector { nf_elem }; check :: Bool = true , cached :: Bool = true , isbasis :: Bool = false ) -> NfOrd Returns the order generated by B . If check is set, it is checked whether B defines an order. If isbasis is set, then elements are assumed to form a \\mathbf{Z} -basis. source # Order \u2014 Method . Order ( K :: AnticNumberField , A :: FakeFmpqMat ; check :: Bool = true ) -> NfOrd Returns the order which has basis matrix A with respect to the power basis of K . If check is set, it is checked whether A defines an order. source # Order \u2014 Method . Order ( K :: AnticNumberField , A :: fmpz_mat , check :: Bool = true ) -> NfOrd Returns the order which has basis matrix A with respect to the power basis of K . If check is set, it is checked whether A defines an order. source Order(A::AbsAlgAss{<: NumFieldElem}, M::PMat{<: NumFieldElem, T}) -> AlgAssRelOrd Returns the order of A with basis pseudo-matrix M . source # EquationOrder \u2014 Method . EquationOrder ( K :: NumberField ) -> NumFieldOrd equation_order ( K :: NumberField ) -> NumFieldOrd Returns the equation order of the number field K . source # MaximalOrder \u2014 Method . MaximalOrder ( K :: NumField { fmpq }; discriminant :: fmpz , ramified_primes :: Vector { fmpz }) -> NfAbsOrd Returns the maximal order of K . Additional information can be supplied if they are already known, as the ramified primes or the discriminant of the maximal order. Example julia> Qx , x = FlintQQ [ \"x\" ]; julia> K , a = NumberField ( x ^ 3 + 2 , \"a\" ); julia> O = MaximalOrder ( K ); source # MaximalOrder \u2014 Method . MaximalOrder ( O :: NfAbsOrd ; index_divisors :: Vector { fmpz }, discriminant :: fmpz , ramified_primes :: Vector { fmpz }) -> NfAbsOrd Returns the maximal order of the number field that contains O . Additional information can be supplied if they are already known, as the ramified primes, the discriminant of the maximal order or a set of integers dividing the index of O in the maximal order. source MaximalOrder(O::AlgAssAbsOrd) Given an order O , this function returns a maximal order containing O . source MaximalOrder(A::AbsAlgAss{fmpq}) -> AlgAssAbsOrd Returns a maximal order of A . source # lll \u2014 Method . lll ( M :: NfAbsOrd ) -> NfAbsOrd The same order, but with the basis now being LLL reduced wrt. the Minkowski metric. source # any_order \u2014 Method . any_order ( K :: NumberField ) Return some order in K . In case the defining polynomial for K is monic and integral, this just returns the equation order. In the other case \\mathbb Z[\\alpha]\\cap \\mathbb Z[1/\\alpha] is returned. source","title":"Creation and basic properties"},{"location":"orders/orders/#example","text":"julia> Qx , x = PolynomialRing ( FlintQQ , \"x\" ); julia> K , a = NumberField ( x ^ 2 - 2 , \"a\" ); julia> O = EquationOrder ( K ) Order of Number field over Rational Field with defining polynomial x^2 - 2 with Z-basis NfOrdElem[1, a] # parent \u2014 Method . parent ( O :: NfAbsOrd ) -> NfOrdSet Returns the parent of \\mathcal O , that is, the set of orders of the ambient number field. source # signature \u2014 Method . signature ( O :: NumFieldOrd ) -> Tuple { Int , Int } Returns the signature of the ambient number field of \\mathcal O . source # nf \u2014 Method . nf ( O :: NumFieldOrd ) -> NumField Returns the ambient number field of \\mathcal O . source # basis \u2014 Method . basis ( O :: NfAbsOrd ) -> Vector { NfAbsOrdElem } Returns the \\mathbf Z -basis of \\mathcal O . source basis ( I :: NfAbsOrdFracIdl ) -> Vector { nf_elem } Returns the \\mathbf Z -basis of I . source # lll_basis \u2014 Method . lll_basis ( M :: NumFieldOrd ) -> Vector { NumFieldElem } A basis for M that is reduced using the LLL algorithm for the Minkowski metric. source # basis \u2014 Method . basis ( O :: NfOrd , K :: AnticNumberField ) -> Vector { nf_elem } Returns the \\mathbf Z -basis elements of \\mathcal O as elements of the ambient number field. source # pseudo_basis \u2014 Method . pseudo_basis ( O :: NfRelOrd { T , S }) -> Vector { Tuple { NumFieldElem { T }, S }} Returns the pseudo-basis of \\mathcal O . source # basis_pmatrix \u2014 Method . basis_pmatrix ( O :: NfRelOrd ) -> PMat Returns the basis pseudo-matrix of \\mathcal O with respect to the power basis of the ambient number field. source # basis_nf \u2014 Method . basis_nf ( O :: NfRelOrd ) -> Vector { NumFieldElem } Returns the elements of the pseudo-basis of \\mathcal O as elements of the ambient number field. source # inv_coeff_ideals \u2014 Method . inv_coeff_ideals ( O :: NfRelOrd { T , S }) -> Vector { S } Returns the inverses of the coefficient ideals of the pseudo basis of O . source # basis_matrix \u2014 Method . basis_matrix ( O :: NfAbsOrd ) -> FakeFmpqMat Returns the basis matrix of \\mathcal O with respect to the basis of the ambient number field. source # basis_mat_inv \u2014 Method . basis_mat_inv ( O :: NfAbsOrd ) -> FakeFmpqMat Returns the inverse of the basis matrix of \\mathcal O . source basis_mat_inv(A::NfAbsOrdIdl) -> fmpz_mat Returns the inverse basis matrix of A . source # gen_index \u2014 Method . gen_index ( O :: NfOrd ) -> fmpq Returns the generalized index of \\mathcal O with respect to the equation order of the ambient number field. source # isindex_divisor \u2014 Method . isindex_divisor ( O :: NfOrd , d :: fmpz ) -> Bool isindex_divisor ( O :: NfOrd , d :: Int ) -> Bool Returns whether d is a divisor of the index of \\mathcal O . It is assumed that \\mathcal O contains the equation order of the ambient number field. source # minkowski_matrix \u2014 Method . minkowski_matrix ( O :: NfAbsOrd , abs_tol :: Int = 64 ) -> arb_mat Returns the Minkowski matrix of \\mathcal O . Thus if \\mathcal O has degree d , then the result is a matrix in \\operatorname{Mat}_{d\\times d}(\\mathbf R) . The entries of the matrix are real balls of type arb with radius less then 2^-abs_tol . source # in \u2014 Method . in ( a :: NumFieldElem , O :: NumFieldOrd ) -> Bool Checks whether a lies in \\mathcal O . source # norm_change_const \u2014 Method . norm_change_const ( O :: NfOrd ) -> ( Float64 , Float64 ) Returns (c_1, c_2) \\in \\mathbf R_{>0}^2 such that for all x = \\sum_{i=1}^d x_i \\omega_i \\in \\mathcal O we have T_2(x) \\leq c_1 \\cdot \\sum_i^d x_i^2 and \\sum_i^d x_i^2 \\leq c_2 \\cdot T_2(x) , where (\\omega_i)_i is the \\mathbf Z -basis of \\mathcal O . source # trace_matrix \u2014 Method . trace_matrix ( O :: NfAbsOrd ) -> fmpz_mat Returns the trace matrix of \\mathcal O , that is, the matrix (\\operatorname{tr}_{K/\\mathbf Q}(b_i \\cdot b_j))_{1 \\leq i, j \\leq d} . source # + \u2014 Method . + ( R :: NfOrd , S :: NfOrd ) -> NfOrd Given two orders R , S of K , this function returns the smallest order containing both R and S . It is assumed that R , S contain the ambient equation order and have coprime index. source # poverorder \u2014 Method . poverorder ( O :: NfOrd , p :: fmpz ) -> NfOrd poverorder ( O :: NfOrd , p :: Integer ) -> NfOrd This function tries to find an order that is locally larger than \\mathcal O at the prime p : If p divides the index [ \\mathcal O_K : \\mathcal O] , this function will return an order R such that v_p([ \\mathcal O_K : R]) < v_p([ \\mathcal O_K : \\mathcal O]) . Otherwise \\mathcal O is returned. source # poverorders \u2014 Method . poverorders ( O , p ) -> Vector { Ord } Returns all p -overorders of O , that is all overorders M , such that the index of O in M is a p -power. source # pmaximal_overorder \u2014 Method . pmaximal_overorder ( O :: NfOrd , p :: fmpz ) -> NfOrd pmaximal_overorder ( O :: NfOrd , p :: Integer ) -> NfOrd This function finds a p -maximal order R containing \\mathcal O . That is, the index [ \\mathcal O_K : R] is not divisible by p . source # pradical \u2014 Method . pradical ( O :: NfOrd , p :: { fmpz | Integer }) -> NfAbsOrdIdl Given a prime number p , this function returns the p -radical \\sqrt{p\\mathcal O} of \\mathcal O , which is just \\{ x \\in \\mathcal O \\mid \\exists k \\in \\mathbf Z_{\\geq 0} \\colon x^k \\in p\\mathcal O \\} . It is not checked that p is prime. source # pradical \u2014 Method . pradical ( O :: NfRelOrd , P :: NfOrdIdl ) -> NfRelOrdIdl Given a prime ideal P , this function returns the P -radical \\sqrt{P\\mathcal O} of \\mathcal O , which is just \\{ x \\in \\mathcal O \\mid \\exists k \\in \\mathbf Z_{\\geq 0} \\colon x^k \\in P\\mathcal O \\} . It is not checked that P is prime. source # ring_of_multipliers \u2014 Method . ring_of_multipliers ( I :: NfAbsOrdIdl ) -> NfAbsOrd Computes the order (I : I) , which is the set of all x \\in K with xI \\subseteq I . source","title":"Example"},{"location":"orders/orders/#invariants","text":"# discriminant \u2014 Method . discriminant ( O :: NfOrd ) -> fmpz Returns the discriminant of \\mathcal O . source discriminant(E::EllCrv{T}) -> T Computes the discriminant of E . source discriminant(O::AlgssRelOrd) Returns the discriminant of O . source # discriminant \u2014 Method . discriminant ( O :: NfOrd ) -> fmpz Returns the discriminant of \\mathcal O . source # reduced_discriminant \u2014 Method . reduced_discriminant ( O :: NfOrd ) -> fmpz Returns the reduced discriminant, that is, the largest elementary divisor of the trace matrix of \\mathcal O . source # degree \u2014 Method . degree ( O :: NumFieldOrd ) -> Int Returns the degree of \\mathcal O . source # index \u2014 Method . index ( O :: NfOrd ) -> fmpz Assuming that the order \\mathcal O contains the equation order \\mathbf Z[\\alpha] of the ambient number field, this function returns the index [ \\mathcal O : \\mathbf Z] . source # different \u2014 Method . different ( R :: NfAbsOrd ) -> NfAbsOrdIdl The differnt ideal of R , that is, the ideal generated by all differents of elements in R . For Gorenstein orders, this is also the inverse ideal of the co-different. source # codifferent \u2014 Method . codifferent ( R :: NfAbsOrd ) -> NfOrdIdl The codiffernt ideal of R , i.e. the trace-dual of R . source # isgorenstein \u2014 Method . isgorenstein ( O :: NfOrd ) -> Bool Return whether the order \\mathcal{O} is Gorenstein. source # isbass \u2014 Method . isbass ( O :: NfOrd ) -> Bool Return whether the order \\mathcal{O} is Bass. source # isequation_order \u2014 Method . isequation_order ( O :: NumFieldOrd ) -> Bool Returns whether \\mathcal O is the equation order of the ambient number field K . source # zeta_log_residue \u2014 Method . zeta_log_residue ( O :: NfOrd , error :: Float64 ) -> arb Computes the residue of the zeta function of \\mathcal O at 1 . The output will be an element of type arb with radius less then error . source # ramified_primes \u2014 Method . ramified_primes ( O :: NfAbsOrd ) -> Vector { fmpz } Returns the list of prime numbers that divide \\operatorname{disc}(\\mathcal O) . source","title":"Invariants"},{"location":"orders/orders/#arithmetic","text":"Progress and intermediate results of the functions mentioned here can be obtained via verbose_level , supported are ClassGroup UnitGroup All of the functions have a very similar interface: they return an abelian group and a map converting elements of the group into the objects required. The maps also allow a point-wise inverse to server as the discrete logarithm map. For more information on abelian group, see here , for ideals, here . torsion_unit_group(::NfOrd) unit_group(::NfOrd) unit_group_fac_elem(::NfOrd) sunit_group(::Vector{NfOrdIdl}) sunit_group_fac_elem(::Vector{NfOrdIdl}) sunit_mod_units_group_fac_elem(::Vector{NfOrdIdl}) class_group(::NfOrd) picard_group(::NfOrd) narrow_class_group(::NfOrd) For the processing of units, there are a couple of helper functions also available: # isindependent \u2014 Function . isindependent { T }( x :: Vector { T }) Given an array of non-zero units in a number field, returns whether they are multiplicatively independent. source","title":"Arithmetic"},{"location":"orders/orders/#predicates","text":"# iscontained \u2014 Method . iscontained ( R :: NfAbsOrd , S :: NfAbsOrd ) -> Bool Checks if R is contained in S . source # ismaximal \u2014 Method . ismaximal ( R :: NfAbsOrd ) -> Bool Tests if the order R is maximal. This might trigger the computation of the maximal order. source","title":"Predicates"},{"location":"pmat/introduction/","text":"Introduction This chapter deals with pseudo-matrices. We follow the common terminology and conventions introduced in Coh00 , however, we operate on rows, not on columns. Let R be a Dedekind domain, typically, the maximal order of some number field K , further fix some finite dimensional K -vectorspace V (with some basis), frequently K^n or the K -structure of some extension of K . Since in general R is not a PID, the R -modules in V are usually not free, but still projective. Any finitely generated R -module M\\subset V can be represented as a pseudo-matrix PMat as follows: The structure theory of R -modules gives the existence of (fractional) R -ideals \\mathfrak A_i and elements \\omega_i\\in V such that M = \\sum \\mathfrak A_i \\omega_i and the sum is direct. Following Cohen we call modules of the form \\mathfrak A\\omega for some ideal \\mathfrak A and \\omega \\in V a pseudo element . A system (\\mathfrak A_i, \\omega_i) is called a pseudo-generating system for M if \\langle \\mathfrak A_i\\omega_i|i\\langle = M . A pseudo-generating system is called a pseudo-basis if the \\omega_i are K -linear independent. A pseudo-matrix X is a tuple containing a vector of ideals \\mathfrak A_i ( 1\\le i\\le r ) and a matrix U\\in K^{r\\times n} . The i -th row together with the i -th ideal defines a pseudo-element, thus an R -module, all of them together generate a module M . A pseudo-matrix X=((\\mathfrak A_i)_i, U) is said to be in pseudo-hnf if U is essentially upper triangular. Similar to the classical hnf, there is an algorithm that transforms any pseudo-matrix into one in pseudo-hnf while maintaining the module. Creation In general to create a PMat one has to specify a matrix and a vector of ideals: # PseudoMatrix \u2014 Method . PseudoMatrix ( m :: Generic . Mat { nf_elem }, c :: Vector { NfOrdIdl }) -> PMat { nf_elem , NfOrdFracIdl } Returns the (row) pseudo matrix representing the Z_k -module \\sum c_i m_i where c_i are the ideals in c and m_i the rows of M . source # PseudoMatrix \u2014 Method . PseudoMatrix ( m :: Generic . Mat { NfOrdElem }, c :: Vector { NfOrdIdl }) -> PMat { nf_elem , NfOrdFracIdl } Returns the (row) pseudo matrix representing the Z_k -module \\sum c_i m_i where c_i are the ideals in c and m_i the rows of M . source # PseudoMatrix \u2014 Method . PseudoMatrix ( m :: Generic . Mat { NfOrdElem }) -> PMat { nf_elem , NfOrdFracIdl } Returns the free (row) pseudo matrix representing the Z_k -module \\sum Z_k m_i where m_i are the rows of M . source (Those functions are also available as pseudo_matrix ) Operations # coefficient_ideals \u2014 Method . coefficient_ideals ( M :: PMat ) Returns the vector of coefficient ideals. source # matrix \u2014 Method . matrix ( M :: PMat ) Returns the matrix part of the PMat . source # base_ring \u2014 Method . base_ring ( M :: PMat ) The PMat M defines an R -module for soem maximal order R . This function returns the R that was used to defined M . source # pseudo_hnf \u2014 Method . pseudo_hnf ( P :: PMat ) Transforms P into pseudo-Hermite form as defined by Cohen. Essentially the matrix part of P will be upper triangular with some technical normalisation for the off-diagonal elements. This operation preserves the module. A optional second argument can be secified as a symbols, indicating the desiered shape of the echelon form. Possible are :upperright (the default) and :lowerleft source # pseudo_hnf_with_transform \u2014 Method . pseudo_hnf_with_transform ( P :: PMat ) Transforms P into pseudo-Hermite form as defined by Cohen. Essentially the matrix part of P will be upper triangular with some technical normalisation for the off-diagonal elements. This operation preserves the module. The used transformation is returned as a second return value. A optional second argument can be secified as a symbols, indicating the desiered shape of the echelon form. Possible are :upperright (the default) and :lowerleft source Examples","title":"Pseudo-Matrices"},{"location":"pmat/introduction/#introduction","text":"This chapter deals with pseudo-matrices. We follow the common terminology and conventions introduced in Coh00 , however, we operate on rows, not on columns. Let R be a Dedekind domain, typically, the maximal order of some number field K , further fix some finite dimensional K -vectorspace V (with some basis), frequently K^n or the K -structure of some extension of K . Since in general R is not a PID, the R -modules in V are usually not free, but still projective. Any finitely generated R -module M\\subset V can be represented as a pseudo-matrix PMat as follows: The structure theory of R -modules gives the existence of (fractional) R -ideals \\mathfrak A_i and elements \\omega_i\\in V such that M = \\sum \\mathfrak A_i \\omega_i and the sum is direct. Following Cohen we call modules of the form \\mathfrak A\\omega for some ideal \\mathfrak A and \\omega \\in V a pseudo element . A system (\\mathfrak A_i, \\omega_i) is called a pseudo-generating system for M if \\langle \\mathfrak A_i\\omega_i|i\\langle = M . A pseudo-generating system is called a pseudo-basis if the \\omega_i are K -linear independent. A pseudo-matrix X is a tuple containing a vector of ideals \\mathfrak A_i ( 1\\le i\\le r ) and a matrix U\\in K^{r\\times n} . The i -th row together with the i -th ideal defines a pseudo-element, thus an R -module, all of them together generate a module M . A pseudo-matrix X=((\\mathfrak A_i)_i, U) is said to be in pseudo-hnf if U is essentially upper triangular. Similar to the classical hnf, there is an algorithm that transforms any pseudo-matrix into one in pseudo-hnf while maintaining the module.","title":"Introduction"},{"location":"pmat/introduction/#creation","text":"In general to create a PMat one has to specify a matrix and a vector of ideals: # PseudoMatrix \u2014 Method . PseudoMatrix ( m :: Generic . Mat { nf_elem }, c :: Vector { NfOrdIdl }) -> PMat { nf_elem , NfOrdFracIdl } Returns the (row) pseudo matrix representing the Z_k -module \\sum c_i m_i where c_i are the ideals in c and m_i the rows of M . source # PseudoMatrix \u2014 Method . PseudoMatrix ( m :: Generic . Mat { NfOrdElem }, c :: Vector { NfOrdIdl }) -> PMat { nf_elem , NfOrdFracIdl } Returns the (row) pseudo matrix representing the Z_k -module \\sum c_i m_i where c_i are the ideals in c and m_i the rows of M . source # PseudoMatrix \u2014 Method . PseudoMatrix ( m :: Generic . Mat { NfOrdElem }) -> PMat { nf_elem , NfOrdFracIdl } Returns the free (row) pseudo matrix representing the Z_k -module \\sum Z_k m_i where m_i are the rows of M . source (Those functions are also available as pseudo_matrix )","title":"Creation"},{"location":"pmat/introduction/#operations","text":"# coefficient_ideals \u2014 Method . coefficient_ideals ( M :: PMat ) Returns the vector of coefficient ideals. source # matrix \u2014 Method . matrix ( M :: PMat ) Returns the matrix part of the PMat . source # base_ring \u2014 Method . base_ring ( M :: PMat ) The PMat M defines an R -module for soem maximal order R . This function returns the R that was used to defined M . source # pseudo_hnf \u2014 Method . pseudo_hnf ( P :: PMat ) Transforms P into pseudo-Hermite form as defined by Cohen. Essentially the matrix part of P will be upper triangular with some technical normalisation for the off-diagonal elements. This operation preserves the module. A optional second argument can be secified as a symbols, indicating the desiered shape of the echelon form. Possible are :upperright (the default) and :lowerleft source # pseudo_hnf_with_transform \u2014 Method . pseudo_hnf_with_transform ( P :: PMat ) Transforms P into pseudo-Hermite form as defined by Cohen. Essentially the matrix part of P will be upper triangular with some technical normalisation for the off-diagonal elements. This operation preserves the module. The used transformation is returned as a second return value. A optional second argument can be secified as a symbols, indicating the desiered shape of the echelon form. Possible are :upperright (the default) and :lowerleft source","title":"Operations"},{"location":"pmat/introduction/#examples","text":"","title":"Examples"},{"location":"quad_forms/basics/","text":"Basics Creation of spaces # quadratic_space \u2014 Method . quadratic_space ( K :: NumField , n :: Int ) -> QuadSpace Create the quadratic space over K with dimension n and Gram matrix equal to the identity matrix. source # quadratic_space \u2014 Method . quadratic_space ( K :: NumField , G :: Int ) -> QuadSpace Create the quadratic space over K with Gram matrix G . The matrix G must be square and symmetric. source Attributes # rank \u2014 Method . rank ( V :: AbsSpace ) -> Int Return the rank of the quadratic space V . source # dim \u2014 Method . dim ( V :: AbsSpace ) -> Int Return the dimension of the space V . source # gram_matrix \u2014 Method . gram_matrix ( V :: AbsSpace ) -> MatElem Return the Gram matrix of V . source # involution \u2014 Method . involution ( V :: AbsSpace ) -> NumField Return the involution of V . source # isregular \u2014 Method . isregular ( V :: AbsSpace ) -> Bool Return whether V is regular, that is, if the Gram matrix has full rank. source # det \u2014 Method . det ( V :: AbsSpace ) -> FieldElem Returns the determinant of the space V as an element of the fixed field. source # discriminant \u2014 Method . discriminant ( V :: AbsSpace ) -> FieldElem Returns the discriminant of the space V as an element of the fixed field. source Inner products and diagonalization # gram_matrix \u2014 Method . gram_matrix ( V :: AbsSpace , M :: MatElem ) -> MatElem Returns the gram matrix of the rows of M . source # gram_matrix \u2014 Method . gram_matrix ( V :: AbsSpace , S :: Vector { Vector }) -> MatElem Returns the gram matrix of the sequence S . source # inner_product \u2014 Method . inner_product ( V :: AbsSpace , v :: Vector , w :: Vector ) -> FieldElem Returns the inner product of v and w with respect to V . source # orthogonal_basis \u2014 Method . orthogonal_basis ( V :: AbsSpace ) -> MatElem Returns a matrix M , such that the rows of M form an orthgonal basis of V . source # diagonal \u2014 Method . diagonal ( V :: AbsSpace ) -> Vector { FieldElem } Returns a vector of elements a_1,\\dotsc,a_n such that V is isometric to the diagonal space \\langle a_1,\\dotsc,a_n \\rangle . The elements will be contained in the fixed field of V . source Equivalence # hasse_invariant \u2014 Method . hasse_invariant ( V :: QuadSpace , p :: Union { InfPlc , NfOrdIdl }) -> Int Returns the Hasse invariant of the quadratic space V at p . This is equal to the product of local Hilbert symbols (a_i, a_j)_p , i < j , where V is isometric to \\langle a_1,\\dotsc,a_n\\rangle . source # witt_invariant \u2014 Method . witt_invariant ( V :: QuadSpace , p :: Union { InfPlc , NfOrdIdl }) -> Int Returns the Witt invariant of the quadratic space V at p . See [Definition 3.2.1, Kir16]. source # isequivalent \u2014 Method . isequivalent ( L :: AbsSpace , M :: AbsSpace , p :: Union { InfPlc , NfOrdIdl }) -> Bool Returns whether L and M are equivalent over the completion at p . source # invariants \u2014 Method . invariants ( M :: QuadSpace ) -> FieldElem , Dict { NfOrdIdl , Int }, Vector { Tuple { InfPlc , Int }} Returns a tuple (n, k, d, H, I) of invariants of M , which determine the equivalence class completely. Here n is the dimension. The dimension of the kernel is k . The element d is the determinant of a Gram matrix of the non-degenerate part, H contains the non-trivial Hasse invariants and I contains for each real place the negative index of inertia. Note that d is determined only modulo squares. source # isequivalent \u2014 Method . isequivalent ( M :: QuadSpace , L :: QuadSpace ) -> Bool Tests if M and L are equivalent. source","title":"Basics"},{"location":"quad_forms/basics/#basics","text":"","title":"Basics"},{"location":"quad_forms/basics/#creation-of-spaces","text":"# quadratic_space \u2014 Method . quadratic_space ( K :: NumField , n :: Int ) -> QuadSpace Create the quadratic space over K with dimension n and Gram matrix equal to the identity matrix. source # quadratic_space \u2014 Method . quadratic_space ( K :: NumField , G :: Int ) -> QuadSpace Create the quadratic space over K with Gram matrix G . The matrix G must be square and symmetric. source","title":"Creation of spaces"},{"location":"quad_forms/basics/#attributes","text":"# rank \u2014 Method . rank ( V :: AbsSpace ) -> Int Return the rank of the quadratic space V . source # dim \u2014 Method . dim ( V :: AbsSpace ) -> Int Return the dimension of the space V . source # gram_matrix \u2014 Method . gram_matrix ( V :: AbsSpace ) -> MatElem Return the Gram matrix of V . source # involution \u2014 Method . involution ( V :: AbsSpace ) -> NumField Return the involution of V . source # isregular \u2014 Method . isregular ( V :: AbsSpace ) -> Bool Return whether V is regular, that is, if the Gram matrix has full rank. source # det \u2014 Method . det ( V :: AbsSpace ) -> FieldElem Returns the determinant of the space V as an element of the fixed field. source # discriminant \u2014 Method . discriminant ( V :: AbsSpace ) -> FieldElem Returns the discriminant of the space V as an element of the fixed field. source","title":"Attributes"},{"location":"quad_forms/basics/#inner-products-and-diagonalization","text":"# gram_matrix \u2014 Method . gram_matrix ( V :: AbsSpace , M :: MatElem ) -> MatElem Returns the gram matrix of the rows of M . source # gram_matrix \u2014 Method . gram_matrix ( V :: AbsSpace , S :: Vector { Vector }) -> MatElem Returns the gram matrix of the sequence S . source # inner_product \u2014 Method . inner_product ( V :: AbsSpace , v :: Vector , w :: Vector ) -> FieldElem Returns the inner product of v and w with respect to V . source # orthogonal_basis \u2014 Method . orthogonal_basis ( V :: AbsSpace ) -> MatElem Returns a matrix M , such that the rows of M form an orthgonal basis of V . source # diagonal \u2014 Method . diagonal ( V :: AbsSpace ) -> Vector { FieldElem } Returns a vector of elements a_1,\\dotsc,a_n such that V is isometric to the diagonal space \\langle a_1,\\dotsc,a_n \\rangle . The elements will be contained in the fixed field of V . source","title":"Inner products and diagonalization"},{"location":"quad_forms/basics/#equivalence","text":"# hasse_invariant \u2014 Method . hasse_invariant ( V :: QuadSpace , p :: Union { InfPlc , NfOrdIdl }) -> Int Returns the Hasse invariant of the quadratic space V at p . This is equal to the product of local Hilbert symbols (a_i, a_j)_p , i < j , where V is isometric to \\langle a_1,\\dotsc,a_n\\rangle . source # witt_invariant \u2014 Method . witt_invariant ( V :: QuadSpace , p :: Union { InfPlc , NfOrdIdl }) -> Int Returns the Witt invariant of the quadratic space V at p . See [Definition 3.2.1, Kir16]. source # isequivalent \u2014 Method . isequivalent ( L :: AbsSpace , M :: AbsSpace , p :: Union { InfPlc , NfOrdIdl }) -> Bool Returns whether L and M are equivalent over the completion at p . source # invariants \u2014 Method . invariants ( M :: QuadSpace ) -> FieldElem , Dict { NfOrdIdl , Int }, Vector { Tuple { InfPlc , Int }} Returns a tuple (n, k, d, H, I) of invariants of M , which determine the equivalence class completely. Here n is the dimension. The dimension of the kernel is k . The element d is the determinant of a Gram matrix of the non-degenerate part, H contains the non-trivial Hasse invariants and I contains for each real place the negative index of inertia. Note that d is determined only modulo squares. source # isequivalent \u2014 Method . isequivalent ( M :: QuadSpace , L :: QuadSpace ) -> Bool Tests if M and L are equivalent. source","title":"Equivalence"},{"location":"quad_forms/introduction/","text":"Introduction This chapter deals with quadratic and Hermitian spaces and lattices there of. Definitions and vocabulary We begin by collecting the necessary definitions and vocabulary. The terminology follows mainly [Kir16] Quadratic and Hermitian spaces Let E be a number field. A quadratic space is a finite-dimensional vector space V over E together with a bilinear morphism \\Phi \\colon V \\times V \\to E . We will always work with an implicit canonical basis e_1,\\dotsc,e_n of V . In view of this, quadratic spaces are in bijection with symmetric matrices over E . If V is a quadratic space, we call the matrix G = (\\Phi(e_i, e_j))_{1 \\leq i, j \\leq n} \\in E^{n \\times n} the Gram matrix of V . Let E/K be an extension of number fields of degree two with non-trivial automorphism \\overline{\\phantom{x}} E \\to E . A Hermitian space is a finite-dimensional vector space V over E together with a sesquilinear (with respect to the involution \\overline{\\phantom{x}} ) morphism \\Phi \\colon V \\times V \\to K . We will always work with an implicit canonical basis e_1,\\dotsc,e_n of V . In view of this, Hermitian spaces are in bijection with Hermitian matrices over E . If V is a Hermitian space, we call the matrix G = (\\Phi(e_i, e_j))_{1 \\leq i, j \\leq n} \\in E^{n \\times n} the Gram matrix of V . We call \\overline{\\phantom{x}} the involution of V . In both cases we refer to the field E as the base ring V . In this chapter we will refer to quadratic and Hermitian spaces also just as spaces . For Hermitian lattices, the field K will be refered to as the fixed field of V . Quadratic and Hermitian lattices Let V be a space (either quadratic or Hermitian) with base field E . A finitely generated \\mathcal O_E -submodule L of V is called a quadratic lattice or Hermitian lattice respectively. We call V the ambient space of L and L\\otimes_{\\mathcal O_E} E the rational span of L . The ring \\mathcal O_E will be referred to as the base ring of L . References Many of the implemented algorithms for computing with quadratic and hermitian lattices over number fields are based on the Magma implementation of Markus Kirschmer, which can be found here . [Kir16] : Definite quadratic and hermitian forms with small class number. Habilitationsschrift. RWTH Aachen University, 2016, pdf","title":"Introduction"},{"location":"quad_forms/introduction/#introduction","text":"This chapter deals with quadratic and Hermitian spaces and lattices there of.","title":"Introduction"},{"location":"quad_forms/introduction/#definitions-and-vocabulary","text":"We begin by collecting the necessary definitions and vocabulary. The terminology follows mainly [Kir16]","title":"Definitions and vocabulary"},{"location":"quad_forms/introduction/#quadratic-and-hermitian-spaces","text":"Let E be a number field. A quadratic space is a finite-dimensional vector space V over E together with a bilinear morphism \\Phi \\colon V \\times V \\to E . We will always work with an implicit canonical basis e_1,\\dotsc,e_n of V . In view of this, quadratic spaces are in bijection with symmetric matrices over E . If V is a quadratic space, we call the matrix G = (\\Phi(e_i, e_j))_{1 \\leq i, j \\leq n} \\in E^{n \\times n} the Gram matrix of V . Let E/K be an extension of number fields of degree two with non-trivial automorphism \\overline{\\phantom{x}} E \\to E . A Hermitian space is a finite-dimensional vector space V over E together with a sesquilinear (with respect to the involution \\overline{\\phantom{x}} ) morphism \\Phi \\colon V \\times V \\to K . We will always work with an implicit canonical basis e_1,\\dotsc,e_n of V . In view of this, Hermitian spaces are in bijection with Hermitian matrices over E . If V is a Hermitian space, we call the matrix G = (\\Phi(e_i, e_j))_{1 \\leq i, j \\leq n} \\in E^{n \\times n} the Gram matrix of V . We call \\overline{\\phantom{x}} the involution of V . In both cases we refer to the field E as the base ring V . In this chapter we will refer to quadratic and Hermitian spaces also just as spaces . For Hermitian lattices, the field K will be refered to as the fixed field of V .","title":"Quadratic and Hermitian spaces"},{"location":"quad_forms/introduction/#quadratic-and-hermitian-lattices","text":"Let V be a space (either quadratic or Hermitian) with base field E . A finitely generated \\mathcal O_E -submodule L of V is called a quadratic lattice or Hermitian lattice respectively. We call V the ambient space of L and L\\otimes_{\\mathcal O_E} E the rational span of L . The ring \\mathcal O_E will be referred to as the base ring of L .","title":"Quadratic and Hermitian lattices"},{"location":"quad_forms/introduction/#references","text":"Many of the implemented algorithms for computing with quadratic and hermitian lattices over number fields are based on the Magma implementation of Markus Kirschmer, which can be found here . [Kir16] : Definite quadratic and hermitian forms with small class number. Habilitationsschrift. RWTH Aachen University, 2016, pdf","title":"References"},{"location":"quad_forms/lattices/","text":"Quadratic and hermitian lattices Creation of lattices # quadratic_lattice \u2014 Method . quadratic_lattice ( K :: NumField , B :: MatElem ; gram_ambient_space = F ) -> QuadLat Given a number field K and a matrix B , returns the quadratic lattice spanned by the rows of B inside the quadratic space over K with gram matrix F . If F is not supplied, the gram matrix of the ambient space will be the identity matrix. source # quadratic_lattice \u2014 Method . quadratic_lattice ( K :: NumField , B :: PMat ; gram_ambient_space = F ) -> QuadLat Given a number field K and a pseudo-matrix B , returns the quadratic lattice spanned by the pseudo-matrix B inside the quadratic space over K with gram matrix F . If F is not supplied, the gram matrix of the ambient space will be the identity matrix. source # hermitian_lattice \u2014 Method . hermitian_lattice ( K :: NumField , B :: MatElem ; gram_ambient_space = F ) -> HermLat Given a number field K and a matrix B , returns the hermitian lattice spanned by the rows of B inside the hermitian space over K with gram matrix F . If F is not supplied, the gram matrix of the ambient space will be the identity matrix. source # hermitian_lattice \u2014 Method . hermitian_lattice ( K :: NumField , B :: PMat ; gram_ambient_space = F ) -> HermLat Given a number field K and a pseudo-matrix B , returns the hermitian lattice spanned by the pseudo-matrix B inside the hermitian space over K with gram matrix F . If F is not supplied, the gram matrix of the ambient space will be the identity matrix. source Basic invariants # ambient_space \u2014 Method . ambient_space ( L :: AbsLat ) -> AbsSpace Returns the ambient space of L . If the ambient space is not known, an error is raised. source # rational_span \u2014 Method . rational_span ( L :: AbsLat ) -> AbsSpace Returns the rational span of L . source # diagonal \u2014 Method . diagonal ( A :: Mat { T }) -> Vector { T } Returns the diagonal of A as an array. source # fixed_field \u2014 Method . fixed_field ( L :: AbsLat ) -> NumField Returns the fixed field of the involution of L . source # involution \u2014 Method . involution ( L :: AbsLat ) -> Map Returns the involution of the rational span of L . source # rank \u2014 Method . rank ( L :: AbsLat ) -> Int Returns the rank of L , that is the dimension of the rational span of L . source # degree \u2014 Method . degree ( L :: AbsLat ) -> Int Returns the dimension of the ambient space of L . source # generators \u2014 Method . generators ( L :: AbsLat ; minimal = false ) -> Vector { Vector } Returns a set of generators of L over the base ring of L . If minimal == true , the number of generators is minimal. Note that computing minimal generators is expensive. source # discriminant \u2014 Method . discriminant ( L :: AbsLat ) -> NfOrdFracIdl Returns the discriminant of L , that is, the generalized index ideal [L^\\# : L] . source # pseudo_matrix \u2014 Method . pseudo_matrix ( L :: AbsLat ) -> PMat Returns the basis pseudo-matrix of L . source # coefficient_ideals \u2014 Method . coefficient_ideals ( L :: AbsLat ) -> Vector { NfOrdIdl } Returns the coefficient ideals of the pseudo-basis of L . source # absolute_basis \u2014 Method . absolute_basis ( L :: AbsLat ) -> Vector Returns a \\mathbf{Z} -basis of L . source # absolute_basis_matrix \u2014 Method . absolute_basis_matrix ( L :: AbsLat ) -> MatElem Returns a \\mathbf{Z} -basis matrix of L . source Rational invariants # hasse_invariant \u2014 Method . hasse_invariant ( L :: AbsLat , p :: Union { InfPlc , NfOrdIdl }) -> Int Returns the Hasse invariant of the rational span of L at p . The lattice must be quadratic. source # witt_invariant \u2014 Method . witt_invariant ( L :: AbsLat , p :: Union { InfPlc , NfOrdIdl }) -> Int Returns the Witt invariant of the rational span of L at p . The lattice must be quadratic. source # isrationally_equivalent \u2014 Method . isrationally_equivalent ( L :: AbsLat , M :: AbsLat , p :: Union { InfPlc , NfOrdIdl }) -> Bool Returns whether the rational spans of L and M are equivalent over the completion at \\mathfrak p . source # isrationally_equivalent \u2014 Method . isrationally_equivalent ( L :: AbsLat , M :: AbsLat ) -> Bool Returns whether the rational spans of L and M are equivalent. source Definiteness # ispositive_definite \u2014 Method . ispositive_definite ( L :: AbsLat ) -> Bool Returns whether the rational span of L is positive definite. source # isnegative_definite \u2014 Method . isnegative_definite ( L :: AbsLat ) -> Bool Returns whether the rational span of L is negative definite. source # isdefinite \u2014 Method . isdefinite ( L :: AbsLat ) -> Bool Returns whether the rational span of L is definite. source # can_scale_totally_positive \u2014 Method . can_scale_totally_positive ( L :: AbsLat ) -> Bool , NumFieldElem Returns whether there is a totally positive rescaled lattice of L . If so, the second return value is an element a such that L^a is totally positive. source Module operations # * \u2014 Method . * ( a :: NumFieldElem , M :: AbsLat ) -> AbsLat Returns the lattice aM inside the ambient space of M . source # * \u2014 Method . * ( a :: NfOrdIdl , M :: AbsLat ) -> AbsLat Returns the lattice aM inside the ambient space of M . source # * \u2014 Method . * ( a :: NfOrdFracIdl , M :: AbsLat ) -> AbsLat Returns the lattice aM inside the ambient space of M . source # rescale \u2014 Method . rescale ( L :: AbsLat , a :: NumFieldElem ) -> AbsLat Returns the rescaled lattice L^a . Note that this has a different ambient space than L . source # dual \u2014 Method . dual ( L :: AbsLat ) -> AbsLat Returns the dual lattice of L . source Invariants # norm \u2014 Method . norm ( L :: AbsLat ) -> NfOrdFracIdl Returns the norm of L . This is a fractional ideal of the fixed field of L . source # scale \u2014 Method . scale ( L :: AbsLat ) -> NfOrdFracIdl Returns the scale of L . source # isintegral \u2014 Method . isintegral ( L :: AbsLat ) -> Bool Returns whether the lattice L is integral. source # volume \u2014 Method . volume ( L :: AbsLat ) -> NfOrdFracIdl Returns the volume of L . source # ismodular \u2014 Method . ismodular ( L :: AbsLat ) -> Bool , NfOrdFracIdl Returns whether L is modular. In this case, the second return value is a fractional ideal \\mathfrak a such that \\mathfrak a L^\\# = L , where L^\\# is the dual of L . source Local properties # local_basis_matrix \u2014 Method . local_basis_matrix ( L :: AbsLat , p :: NfOrdIdl ; type = :any ) -> MatElem Given a prime ideal \\mathfrak p and a lattice L , this function returns a basis matrix of lattice M such that M_{\\mathfrak{p}} = L_{\\mathfrak{p}} . If type == :submodule , the lattice L will be a sublattice of M . If type == :supermodule , the lattice L will be a superlattice of M . If type == :any , there may not be any containment relation between M and L . source # jordan_decomposition \u2014 Method . jordan_decomposition ( L :: AbsLat , p :: NfOrdIdl ) -> Vector { MatElem }, Vector { MatElem }, Vector { Int } Returns a Jordan decomposition of the completion of L at \\mathfrak p . The return value consists of three lists (M_i)_i , (G_i)_i and (s_i)_i of the same length r . The completions of the row spans of the matrices M_i yield a Jordan decomposition of L_{\\mathfrak{p}} into modular sublattices L_i with gram matrices G_i and scale of \\mathfrak{p} -adic valuation s_i . source # islocally_isometric \u2014 Method . islocally_isometric ( L :: AbsLat , M :: AbsLat , p :: NfOrdIdl ) -> Bool Returns whether the completions of L and M at the prime ideal \\mathfrak{p} are locally isometric. source Genera Creation of genera from lattices # genus \u2014 Method . genus ( L :: HermLat , p :: NfOrdIdl ) -> LocalGenusHerm Returns the genus of L at the prime ideal \\mathfrak p . See [Kir16, Definition 8.3.1]. source # genus \u2014 Method . genus ( L :: HermLat ) -> GenusHerm Given a Hermitian lattice, return the genus it belongs to. source Properties of genera # rank \u2014 Method . rank ( G :: LocalGenusHerm ) -> Int Given a genus symbol G , return the rank of a lattice in G . source # rank \u2014 Method . rank ( G :: LocalGenusHerm , i :: Int ) Given a genus symbol for Hermitian lattices over E/K , return the rank of the i th Jordan block of G . source # ranks \u2014 Method . ranks ( G :: LocalGenusHerm ) Given a genus symbol for Hermitian lattices over E/K , return the ranks of the Jordan blocks of G . source # det \u2014 Method . det ( G :: LocalGenusHerm ) -> Int Given a genus symbol G , return the determinant of a lattice in G . This will be 1 or -1 depending on whether the determinant is a local norm or not. source # det_representative \u2014 Method . det_representative ( G :: LocalGenusHerm ) -> NumFieldElem Return a representative for the norm class of the determinant of G . source # gram_matrix \u2014 Method . gram_matrix ( G :: LocalGenusHerm ) Return a matrix M , such that a lattice with Gram matrix M is an element of the given genus. source # primes \u2014 Method . primes ( G :: GenusHerm ) -> Vector { NfOrdIdl } Return the primes of a global genus symbol. source Check if lattice is contained in genus # in \u2014 Method . in ( L :: HermLat , G :: LocalGenusHerm ) -> Bool Test if the lattice L is contained in the local genus G . source # in \u2014 Method . in ( L :: HermLat , G :: GenusHerm ) -> Bool Test if the lattice L is contained in the genus G . source Creating representatives # representative \u2014 Method . representative ( G :: LocalGenusHerm ) -> HermLat Given a local genus, return a Hermitian lattice contained in this genus. source","title":"Lattices"},{"location":"quad_forms/lattices/#quadratic-and-hermitian-lattices","text":"","title":"Quadratic and hermitian lattices"},{"location":"quad_forms/lattices/#creation-of-lattices","text":"# quadratic_lattice \u2014 Method . quadratic_lattice ( K :: NumField , B :: MatElem ; gram_ambient_space = F ) -> QuadLat Given a number field K and a matrix B , returns the quadratic lattice spanned by the rows of B inside the quadratic space over K with gram matrix F . If F is not supplied, the gram matrix of the ambient space will be the identity matrix. source # quadratic_lattice \u2014 Method . quadratic_lattice ( K :: NumField , B :: PMat ; gram_ambient_space = F ) -> QuadLat Given a number field K and a pseudo-matrix B , returns the quadratic lattice spanned by the pseudo-matrix B inside the quadratic space over K with gram matrix F . If F is not supplied, the gram matrix of the ambient space will be the identity matrix. source # hermitian_lattice \u2014 Method . hermitian_lattice ( K :: NumField , B :: MatElem ; gram_ambient_space = F ) -> HermLat Given a number field K and a matrix B , returns the hermitian lattice spanned by the rows of B inside the hermitian space over K with gram matrix F . If F is not supplied, the gram matrix of the ambient space will be the identity matrix. source # hermitian_lattice \u2014 Method . hermitian_lattice ( K :: NumField , B :: PMat ; gram_ambient_space = F ) -> HermLat Given a number field K and a pseudo-matrix B , returns the hermitian lattice spanned by the pseudo-matrix B inside the hermitian space over K with gram matrix F . If F is not supplied, the gram matrix of the ambient space will be the identity matrix. source","title":"Creation of lattices"},{"location":"quad_forms/lattices/#basic-invariants","text":"# ambient_space \u2014 Method . ambient_space ( L :: AbsLat ) -> AbsSpace Returns the ambient space of L . If the ambient space is not known, an error is raised. source # rational_span \u2014 Method . rational_span ( L :: AbsLat ) -> AbsSpace Returns the rational span of L . source # diagonal \u2014 Method . diagonal ( A :: Mat { T }) -> Vector { T } Returns the diagonal of A as an array. source # fixed_field \u2014 Method . fixed_field ( L :: AbsLat ) -> NumField Returns the fixed field of the involution of L . source # involution \u2014 Method . involution ( L :: AbsLat ) -> Map Returns the involution of the rational span of L . source # rank \u2014 Method . rank ( L :: AbsLat ) -> Int Returns the rank of L , that is the dimension of the rational span of L . source # degree \u2014 Method . degree ( L :: AbsLat ) -> Int Returns the dimension of the ambient space of L . source # generators \u2014 Method . generators ( L :: AbsLat ; minimal = false ) -> Vector { Vector } Returns a set of generators of L over the base ring of L . If minimal == true , the number of generators is minimal. Note that computing minimal generators is expensive. source # discriminant \u2014 Method . discriminant ( L :: AbsLat ) -> NfOrdFracIdl Returns the discriminant of L , that is, the generalized index ideal [L^\\# : L] . source # pseudo_matrix \u2014 Method . pseudo_matrix ( L :: AbsLat ) -> PMat Returns the basis pseudo-matrix of L . source # coefficient_ideals \u2014 Method . coefficient_ideals ( L :: AbsLat ) -> Vector { NfOrdIdl } Returns the coefficient ideals of the pseudo-basis of L . source # absolute_basis \u2014 Method . absolute_basis ( L :: AbsLat ) -> Vector Returns a \\mathbf{Z} -basis of L . source # absolute_basis_matrix \u2014 Method . absolute_basis_matrix ( L :: AbsLat ) -> MatElem Returns a \\mathbf{Z} -basis matrix of L . source","title":"Basic invariants"},{"location":"quad_forms/lattices/#rational-invariants","text":"# hasse_invariant \u2014 Method . hasse_invariant ( L :: AbsLat , p :: Union { InfPlc , NfOrdIdl }) -> Int Returns the Hasse invariant of the rational span of L at p . The lattice must be quadratic. source # witt_invariant \u2014 Method . witt_invariant ( L :: AbsLat , p :: Union { InfPlc , NfOrdIdl }) -> Int Returns the Witt invariant of the rational span of L at p . The lattice must be quadratic. source # isrationally_equivalent \u2014 Method . isrationally_equivalent ( L :: AbsLat , M :: AbsLat , p :: Union { InfPlc , NfOrdIdl }) -> Bool Returns whether the rational spans of L and M are equivalent over the completion at \\mathfrak p . source # isrationally_equivalent \u2014 Method . isrationally_equivalent ( L :: AbsLat , M :: AbsLat ) -> Bool Returns whether the rational spans of L and M are equivalent. source","title":"Rational invariants"},{"location":"quad_forms/lattices/#definiteness","text":"# ispositive_definite \u2014 Method . ispositive_definite ( L :: AbsLat ) -> Bool Returns whether the rational span of L is positive definite. source # isnegative_definite \u2014 Method . isnegative_definite ( L :: AbsLat ) -> Bool Returns whether the rational span of L is negative definite. source # isdefinite \u2014 Method . isdefinite ( L :: AbsLat ) -> Bool Returns whether the rational span of L is definite. source # can_scale_totally_positive \u2014 Method . can_scale_totally_positive ( L :: AbsLat ) -> Bool , NumFieldElem Returns whether there is a totally positive rescaled lattice of L . If so, the second return value is an element a such that L^a is totally positive. source","title":"Definiteness"},{"location":"quad_forms/lattices/#module-operations","text":"# * \u2014 Method . * ( a :: NumFieldElem , M :: AbsLat ) -> AbsLat Returns the lattice aM inside the ambient space of M . source # * \u2014 Method . * ( a :: NfOrdIdl , M :: AbsLat ) -> AbsLat Returns the lattice aM inside the ambient space of M . source # * \u2014 Method . * ( a :: NfOrdFracIdl , M :: AbsLat ) -> AbsLat Returns the lattice aM inside the ambient space of M . source # rescale \u2014 Method . rescale ( L :: AbsLat , a :: NumFieldElem ) -> AbsLat Returns the rescaled lattice L^a . Note that this has a different ambient space than L . source # dual \u2014 Method . dual ( L :: AbsLat ) -> AbsLat Returns the dual lattice of L . source","title":"Module operations"},{"location":"quad_forms/lattices/#invariants","text":"# norm \u2014 Method . norm ( L :: AbsLat ) -> NfOrdFracIdl Returns the norm of L . This is a fractional ideal of the fixed field of L . source # scale \u2014 Method . scale ( L :: AbsLat ) -> NfOrdFracIdl Returns the scale of L . source # isintegral \u2014 Method . isintegral ( L :: AbsLat ) -> Bool Returns whether the lattice L is integral. source # volume \u2014 Method . volume ( L :: AbsLat ) -> NfOrdFracIdl Returns the volume of L . source # ismodular \u2014 Method . ismodular ( L :: AbsLat ) -> Bool , NfOrdFracIdl Returns whether L is modular. In this case, the second return value is a fractional ideal \\mathfrak a such that \\mathfrak a L^\\# = L , where L^\\# is the dual of L . source","title":"Invariants"},{"location":"quad_forms/lattices/#local-properties","text":"# local_basis_matrix \u2014 Method . local_basis_matrix ( L :: AbsLat , p :: NfOrdIdl ; type = :any ) -> MatElem Given a prime ideal \\mathfrak p and a lattice L , this function returns a basis matrix of lattice M such that M_{\\mathfrak{p}} = L_{\\mathfrak{p}} . If type == :submodule , the lattice L will be a sublattice of M . If type == :supermodule , the lattice L will be a superlattice of M . If type == :any , there may not be any containment relation between M and L . source # jordan_decomposition \u2014 Method . jordan_decomposition ( L :: AbsLat , p :: NfOrdIdl ) -> Vector { MatElem }, Vector { MatElem }, Vector { Int } Returns a Jordan decomposition of the completion of L at \\mathfrak p . The return value consists of three lists (M_i)_i , (G_i)_i and (s_i)_i of the same length r . The completions of the row spans of the matrices M_i yield a Jordan decomposition of L_{\\mathfrak{p}} into modular sublattices L_i with gram matrices G_i and scale of \\mathfrak{p} -adic valuation s_i . source # islocally_isometric \u2014 Method . islocally_isometric ( L :: AbsLat , M :: AbsLat , p :: NfOrdIdl ) -> Bool Returns whether the completions of L and M at the prime ideal \\mathfrak{p} are locally isometric. source","title":"Local properties"},{"location":"quad_forms/lattices/#genera","text":"","title":"Genera"},{"location":"quad_forms/lattices/#creation-of-genera-from-lattices","text":"# genus \u2014 Method . genus ( L :: HermLat , p :: NfOrdIdl ) -> LocalGenusHerm Returns the genus of L at the prime ideal \\mathfrak p . See [Kir16, Definition 8.3.1]. source # genus \u2014 Method . genus ( L :: HermLat ) -> GenusHerm Given a Hermitian lattice, return the genus it belongs to. source","title":"Creation of genera from lattices"},{"location":"quad_forms/lattices/#properties-of-genera","text":"# rank \u2014 Method . rank ( G :: LocalGenusHerm ) -> Int Given a genus symbol G , return the rank of a lattice in G . source # rank \u2014 Method . rank ( G :: LocalGenusHerm , i :: Int ) Given a genus symbol for Hermitian lattices over E/K , return the rank of the i th Jordan block of G . source # ranks \u2014 Method . ranks ( G :: LocalGenusHerm ) Given a genus symbol for Hermitian lattices over E/K , return the ranks of the Jordan blocks of G . source # det \u2014 Method . det ( G :: LocalGenusHerm ) -> Int Given a genus symbol G , return the determinant of a lattice in G . This will be 1 or -1 depending on whether the determinant is a local norm or not. source # det_representative \u2014 Method . det_representative ( G :: LocalGenusHerm ) -> NumFieldElem Return a representative for the norm class of the determinant of G . source # gram_matrix \u2014 Method . gram_matrix ( G :: LocalGenusHerm ) Return a matrix M , such that a lattice with Gram matrix M is an element of the given genus. source # primes \u2014 Method . primes ( G :: GenusHerm ) -> Vector { NfOrdIdl } Return the primes of a global genus symbol. source","title":"Properties of genera"},{"location":"quad_forms/lattices/#check-if-lattice-is-contained-in-genus","text":"# in \u2014 Method . in ( L :: HermLat , G :: LocalGenusHerm ) -> Bool Test if the lattice L is contained in the local genus G . source # in \u2014 Method . in ( L :: HermLat , G :: GenusHerm ) -> Bool Test if the lattice L is contained in the genus G . source","title":"Check if lattice is contained in genus"},{"location":"quad_forms/lattices/#creating-representatives","text":"# representative \u2014 Method . representative ( G :: LocalGenusHerm ) -> HermLat Given a local genus, return a Hermitian lattice contained in this genus. source","title":"Creating representatives"},{"location":"sparse/intro/","text":"Sparse linear algebra Introduction This chapter deals with sparse linear algebra over commutative rings and fields. Sparse linear algebra, that is, linear algebra with sparse matrices, plays an important role in various algorithms in algebraic number theory. For example, it is one of the key ingredients in the computation of class groups and discrete logarithms using index calculus methods. Sparse rows Building blocks for sparse matrices are sparse rows, which are modelled by objects of type \\texttt{SRow}. More precisely, the type is of parametrized form objects of type SRow . More precisely, the type is of parametrized form SRow{T} , where T is the element type of the base ring R . For example, SRow{fmpz} is the type for sparse rows over the integers. It is important to note that sparse rows do not have a fixed number of columns, that is, they represent elements of \\{ (x_i)_i \\in R^{\\mathbb{N}} \\mid x_i = 0 \\text{ for almost all }i\\} . In particular any two sparse rows over the same base ring can be added. Creation # sparse_row \u2014 Method . sparse_row ( R :: Ring , J :: Vector { Tuple { Int , T }}) -> SRow { T } Constructs the sparse row (a_i)_i with a_{i_j} = x_j , where J = (i_j, x_j)_j . The elements x_i must belong to the ring R . source # sparse_row \u2014 Method . sparse_row ( R :: Ring , J :: Vector { Tuple { Int , T }}) -> SRow { T } Constructs the sparse row (a_i)_i with a_{i_j} = x_j , where J = (i_j, x_j)_j . The elements x_i must belong to the ring R . source sparse_row(R::Ring, J::Vector{Tuple{Int, Int}}) -> SRow Constructs the sparse row (a_i)_i over R with a_{i_j} = x_j , where J = (i_j, x_j)_j . source # sparse_row \u2014 Method . sparse_row ( R :: Ring , J :: Vector { Int }, V :: Vector { T }) -> SRow { T } Constructs the sparse row (a_i)_i over R with a_{i_j} = x_j , where J = (i_j)_j and V = (x_j)_j . source Basic operations Rows support the usual operations: + , - , == multiplication by scalars div , divexact # getindex \u2014 Method . getindex ( A :: SRow , j :: Int ) -> RingElem Given a sparse row (a_i)_{i} and an index j return a_j . source # add_scaled_row \u2014 Method . add_scaled_row ( A :: SRow { T }, B :: SRow { T }, c :: T ) -> SRow { T } Returns the row c A + B . source # add_scaled_row \u2014 Method . add_scaled_row ( A :: SRow { T }, B :: SRow { T }, c :: T ) -> SRow { T } Returns the row c A + B . source # transform_row \u2014 Method . transform_row ( A :: SRow { T }, B :: SRow { T }, i :: Int , j :: Int , a :: T , b :: T , c :: T , d :: T ) Returns the tuple (aA + bB, cA + dB) . source # length \u2014 Method . length ( A :: SRow ) Returns the number of nonzero entries of A . source Change of base ring # change_base_ring \u2014 Method . change_base_ring ( R :: Ring , A :: SRow ) -> SRow Create a new sparse row by coercing all elements into the ring R . source Maximum, minimum and 2-norm # maximum \u2014 Method . maximum ( A :: SRow { T }) -> T Returns the largest entry of A . source # maximum \u2014 Method . maximum ( A :: SRow { T }) -> T Returns the largest entry of A . source # minimum \u2014 Method . minimum ( A :: NfRelOrdIdl ) -> NfOrdIdl minimum ( A :: NfRelOrdIdl ) -> NfRelOrdIdl Returns the ideal A \\cap O where O is the maximal order of the coefficient ideals of A . source minimum ( A :: SRow { T }) -> T Returns the smallest entry of A . source # minimum \u2014 Method . minimum ( A :: SRow { T }) -> T Returns the smallest entry of A . source # norm2 \u2014 Method . norm2 ( A :: SRow { T } -> T Returns A \\cdot A^t . source Functionality for integral sparse rows # lift \u2014 Method . lift ( A :: SRow { nmod }) -> SRow { fmpz } Return the sparse row obtained by lifting all entries in A . source # mod! \u2014 Method . mod! ( A :: SRow { fmpz }, n :: fmpz ) -> SRow { fmpz } Inplace reduction of all entries of A modulo n to the positive residue system. source # mod_sym! \u2014 Method . mod_sym! ( A :: SRow { fmpz }, n :: fmpz ) -> SRow { fmpz } Inplace reduction of all entries of A modulo n to the symmetric residue system. source # mod_sym! \u2014 Method . mod_sym! ( A :: SRow { fmpz }, n :: Integer ) -> SRow { fmpz } Inplace reduction of all entries of A modulo n to the symmetric residue system. source # maximum \u2014 Method . maximum ( abs , A :: SRow { fmpz }) -> fmpz Returns the largest, in absolute value, entry of A . source Sparse matrices Let R be a commutative ring. Sparse matrices with base ring R are modelled by objects of type SMat . More precisely, the type is of parametrized form SRow{T} , where T is the element type of the base ring. For example, SMat{fmpz} is the type for sparse matrices over the integers. In constrast to sparse rows, sparse matrices have a fixed number of rows and columns, that is, they represent elements of the matrices space \\mathrm{Mat}_{n\\times m}(R) . Internally, sparse matrices are implemented as an array of sparse rows. As a consequence, unlike their dense counterparts, sparse matrices have a mutable number of rows and it is very performant to add additional rows. Construction # sparse_matrix \u2014 Method . sparse_matrix ( R :: Ring ) -> SMat Return an empty sparse matrix with base ring R . source Sparse matrices can also be created from dense matrices as well as from julia arrays: # sparse_matrix \u2014 Method . sparse_matrix ( A :: MatElem ; keepzrows :: Bool = true ) Constructs the sparse matrix corresponding to the dense matrix A . If keepzrows is false, then the constructor will drop any zero row of A . source # sparse_matrix \u2014 Method . sparse_matrix ( R :: Ring , A :: Matrix { T }) -> SMat Constructs the sparse matrix over R corresponding to A . source # sparse_matrix \u2014 Method . sparse_matrix ( R :: Ring , A :: Matrix { T }) -> SMat Constructs the sparse matrix over R corresponding to A . source The normal way however, is to add rows: # push! \u2014 Method . push! ( A :: SMat { T }, B :: SRow { T }) where T Appends the sparse row B to A . source Sparse matrices can also be concatenated to form larger ones: # vcat! \u2014 Method . vcat! ( A :: SMat , B :: SMat ) -> SMat Vertically joins A and B inplace, that is, the rows of B are appended to A . source # vcat \u2014 Method . vcat ( A :: SMat , B :: SMat ) -> SMat Vertically joins A and B . source # hcat! \u2014 Method . hcat! ( A :: SMat , B :: SMat ) -> SMat Horizontally concatenates A and B , inplace, changing A . source # hcat \u2014 Method . hcat ( A :: SMat , B :: SMat ) -> SMat Horizontally concatenates A and B . source (Normal julia cat is also supported) There are special constructors: # identity_matrix \u2014 Method . identity_matrix ( :: Type { SMat }, R :: Ring , n :: Int ) Return a sparse n times n identity matrix over R . source # zero_matrix \u2014 Method . zero_matrix ( :: Type { SMat }, R :: Ring , n :: Int ) Return a sparse n times n zero matrix over R . source # zero_matrix \u2014 Method . zero_matrix ( :: Type { SMat }, R :: Ring , n :: Int , m :: Int ) Return a sparse n times m zero matrix over R . source Slices: # sub \u2014 Method . sub ( A :: SMat , r :: UnitRange , c :: UnitRange ) -> SMat Return the submatrix of A , where the rows correspond to r and the columns correspond to c . source Transpose: # transpose \u2014 Method . transpose ( A :: SMat ) -> SMat Returns the transpose of A . source Elementary Properties # sparsity \u2014 Method . sparsity ( A :: SMat ) -> Float64 Return the sparsity of A , that is, the number of zero-valued elements divided by the number of all elements. source # density \u2014 Method . density ( A :: SMat ) -> Float64 Return the density of A , that is, the number of nonzero-valued elements divided by the number of all elements. source # nnz \u2014 Method . nnz ( A :: SMat ) -> Int Return the number of non-zero entries of A . source # nrows \u2014 Method . nrows ( A :: SMat ) -> Int Return the number of rows of A . source # ncols \u2014 Method . ncols ( A :: SMat ) -> Int Return the number of columns of A . source # isone \u2014 Method . isone ( A :: SMat ) Tests if A is an identity matrix. source # iszero \u2014 Method . iszero ( A :: SMat ) Tests if A is a zero matrix. source # isupper_triangular \u2014 Method . isupper_triangular ( A :: SMat ) Returns true if and only if A is upper (right) triangular. source # maximum \u2014 Method . maximum ( A :: SMat { T }) -> T Finds the largest entry of A . source # minimum \u2014 Method . minimum ( A :: SMat { T }) -> T Finds the smallest entry of A . source # maximum \u2014 Method . maximum ( abs , A :: SMat { fmpz }) -> fmpz Finds the largest, in absolute value, entry of A . source # elementary_divisors \u2014 Method . elementary_divisors ( A :: SMat { fmpz }) -> Vector { fmpz } The elementary divisors of A , i.e. the diagonal elements of the Smith normal form of A . source # solve_dixon_sf \u2014 Method . solve_dixon_sf ( A :: SMat { fmpz }, b :: SRow { fmpz }, is_int :: Bool = false ) -> SRow { fmpz }, fmpz solve_dixon_sf ( A :: SMat { fmpz }, B :: SMat { fmpz }, is_int :: Bool = false ) -> SMat { fmpz }, fmpz For a sparse square matrix A of full rank and a sparse matrix (row), find a sparse matrix (row) x and an integer d s.th. x A = bd holds. The algorithm is a Dixon-based linear p-adic lifting method. If \\code{is_int} is given, then d is assumed to be 1 . In this case rational reconstruction is avoided. source # hadamard_bound2 \u2014 Method . hadamard_bound2 ( A :: SMat { T }) -> T The square of the product of the norms of the rows of A . source # echelon_with_transform \u2014 Method . echelon_with_transform ( A :: SMat { nmod }) -> SMat , SMat Find a unimodular matrix T and an upper-triangular E s.th. TA = E holds. source # reduce_full \u2014 Method . reduce_full ( A :: SMat { fmpz }, g :: SRow { fmpz }, trafo = Val { false }) -> SRow { fmpz }, Vector { Int } Reduces g modulo A and assumes that A is upper triangular. The second return value is the array of pivot elements of A that changed. If trafo is set to Val{true} , then additionally an array of transformations is returned. source # hnf! \u2014 Method . hnf! ( A :: SMat { fmpz }) Inplace transform of A into upper right Hermite normal form. source # hnf \u2014 Method . hnf ( A :: SMat { fmpz }) -> SMat { fmpz } Return the upper right Hermite normal form of A . source # snf \u2014 Method . snf ( A :: SMat { fmpz }) The Smith normal form (snf) of A . source # hnf_extend! \u2014 Method . hnf_extend! ( A :: SMat { fmpz }, b :: SMat { fmpz }, offset :: Int = 0 ) -> SMat { fmpz } Given a matrix A in HNF, extend this to get the HNF of the concatenation with b . source # isdiagonal \u2014 Method . isdiagonal ( A :: SMat ) -> Bool True iff only the i-th entry in the i-th row is non-zero. source # det \u2014 Method . det ( A :: SMat { fmpz }) The determinant of A using a modular algorithm. Uses the dense (nmod_mat) determinant on A for various primes p . source # det_mc \u2014 Method . det_mc ( A :: SMat { fmpz }) Computes the determinant of A using a LasVegas style algorithm, i.e. the result is not proven to be correct. Uses the dense (nmod_mat) determinant on A for various primes p . source # valence_mc \u2014 Method . valence_mc { T }( A :: SMat { T }; extra_prime = 2 , trans = Vector { SMatSLP_add_row { T }}()) -> T Uses a Monte-Carlo algorithm to compute the valence of A . The valence is the valence of the minimal polynomial f of transpose(A)*A , thus the last non-zero coefficient, typically f(0) . The valence is computed modulo various primes until the computation stabilises for extra_prime many. trans , if given, is a SLP (straight-line-program) in GL(n, Z). Then the valence of trans * A is computed instead. source # saturate \u2014 Method . saturate ( A :: SMat { fmpz }) -> SMat { fmpz } Computes the saturation of A , that is, a basis for \\mathbf{Q}\\otimes M \\meet \\mathbf{Z}^n , where M is the row span of A and n the number of rows of A . Equivalently, return TA for an invertible rational matrix T , such that TA is integral and the elementary divisors of TA are all trivial. source # hnf_kannan_bachem \u2014 Method . hnf_kannan_bachem ( A :: SMat { fmpz }) -> SMat { fmpz } Compute the Hermite normal form of A using the Kannan-Bachem algorithm. source # diagonal_form \u2014 Method . diagonal_form ( A :: SMat { fmpz }) -> SMat { fmpz } A matrix D that is diagonal and obtained via unimodular row and column operations. Like a snf without the divisibility condition. source Manipulation/ Access # getindex \u2014 Method . getindex ( A :: SMat , i :: Int , j :: Int ) Given a sparse matrix A = (a_{ij})_{i, j} , return the entry a_{ij} . source # getindex \u2014 Method . getindex ( A :: SMat , i :: Int ) -> SRow Given a sparse matrix A and an index i , return the i -th row of A . source # setindex! \u2014 Method . setindex! ( A :: SMat , b :: SRow , i :: Int ) Given a sparse matrix A , a sparse row b and an index i , set the i -th row of A equal to b . source # swap_rows! \u2014 Method . swap_rows! ( A :: SMat { T }, i :: Int , j :: Int ) Swap the i -th and j -th row of A inplace. source # swap_cols! \u2014 Method . swap_cols! ( A :: SMat , i :: Int , j :: Int ) Swap the i -th and j -th column of A inplace. source # scale_row! \u2014 Method . scale_row! ( A :: SMat { T }, i :: Int , c :: T ) Multiply the i -th row of A by c inplace. source # add_scaled_col! \u2014 Method . add_scaled_col! ( A :: SMat { T }, i :: Int , j :: Int , c :: T ) Add c times the i -th column to the j -th column of A inplace, that is, A_j \\rightarrow A_j + c \\cdot A_i , where (A_i)_i denote the columns of A . source # add_scaled_row! \u2014 Method . add_scaled_row! ( A :: SMat { T }, i :: Int , j :: Int , c :: T ) Add c times the i -th row to the j -th row of A inplace, that is, A_j \\rightarrow A_j + c \\cdot A_i , where (A_i)_i denote the rows of A . source # transform_row! \u2014 Method . transform_row! ( A :: SMat { T }, i :: Int , j :: Int , a :: T , b :: T , c :: T , d :: T ) Applies the transformation (A_i, A_j) \\rightarrow (aA_i + bA_j, cA_i + dA_j) to A , where (A_i)_i are the rows of A . source # diagonal \u2014 Method . diagonal ( A :: SMat ) -> fmpz [] The diagonal elements of A in an array. source # reverse_rows! \u2014 Method . reverse_rows! ( A :: SMat ) Inplace inversion of the rows of A . source # mod_sym! \u2014 Method . mod_sym! ( A :: SMat { fmpz }, n :: fmpz ) Inplace reduction of all entries of A modulo n to the symmetric residue system. source # find_row_starting_with \u2014 Method . find_row_starting_with ( A :: SMat , p :: Int ) -> Int Tries to find the index i such that A_{i,p} \\neq 0 and A_{i, p-j} = 0 for all j > 1 . It is assumed that A is upper triangular. If such an index does not exist, find the smallest index larger. source # reduce \u2014 Method . reduce ( A :: SMat { fmpz }, g :: SRow { fmpz }, m :: fmpz ) -> SRow { fmpz } Given an upper triangular matrix A over the integers, a sparse row g and an integer m , this function reduces g modulo A and returns g modulo m with respect to the symmetric residue system. source # reduce \u2014 Method . reduce ( A :: SMat { fmpz }, g :: SRow { fmpz }) -> SRow { fmpz } Given an upper triangular matrix A over a field and a sparse row g , this function reduces g modulo A . source <a id='reduce-Union{Tuple{T}, Tuple{SMat{T}, SRow{T}}} where T<:FieldElement' href='#reduce-Union{Tuple{T}, Tuple{SMat{T}, SRow{T}}} where T<:FieldElement'># reduce \u2014 Method . reduce ( A :: SMat { T }, g :: SRow { T }) -> SRow { T } Given an upper triangular matrix A over a field and a sparse row g , this function reduces g modulo A . source # rand_row \u2014 Method . rand_row ( A :: SMat ) -> SRow Return a random row of the sparse matrix A . source Changing of the ring: # map_entries \u2014 Method . map_entries ( f , A :: SMat ) -> SMat Given a sparse matrix A and a callable object f , this function will construct a new sparse matrix by applying f to all elements of A . source # change_base_ring \u2014 Method . change_base_ring ( R :: Ring , A :: SMat ) Create a new sparse matrix by coercing all elements into the ring R . source Arithmetic Matrices support the usual operatation as well + , - , == , * div , divexact by scalars multiplication by scalars Various products: # mul \u2014 Method . mul ( A :: SMat { T }, b :: AbstractVector { T }) -> Vector { T } Return the product A \\cdot b as a dense vector. source # mul \u2014 Method . mul ( A :: SMat { T }, b :: AbstractMatrix { T }) -> Matrix { T } Return the product A \\cdot b as a dense array. source # mul \u2014 Method . mul ( A :: SMat { T }, b :: MatElem { T }) -> MatElem Return the product A \\cdot b as a dense matrix. source # mul \u2014 Method . mul ( A :: SRow , B :: SMat ) -> SRow Return the product A\\cdot B as a sparse row. source Other: # sparse \u2014 Method . sparse ( A :: SMat ) -> SparseMatrixCSC The same matrix, but as a sparse matrix of julia type SparseMatrixCSC . source # fmpz_mat \u2014 Method . fmpz_mat ( A :: SMat { fmpz }) The same matrix A , but as an fmpz_mat . source <a id='fmpz_mat-Union{Tuple{SMat{T}}, Tuple{T}} where T<:Integer' href='#fmpz_mat-Union{Tuple{SMat{T}}, Tuple{T}} where T<:Integer'># fmpz_mat \u2014 Method . fmpz_mat ( A :: SMat { T }) where { T <: Integer } The same matrix A , but as an fmpz_mat . Requires a conversion from the base ring of A to \\mathbb ZZ . source # Array \u2014 Method . Array ( A :: SMat { T }) -> Matrix { T } The same matrix, but as a two-dimensional julia array. source","title":"Sparse Linear Algebra"},{"location":"sparse/intro/#sparse-linear-algebra","text":"","title":"Sparse linear algebra"},{"location":"sparse/intro/#introduction","text":"This chapter deals with sparse linear algebra over commutative rings and fields. Sparse linear algebra, that is, linear algebra with sparse matrices, plays an important role in various algorithms in algebraic number theory. For example, it is one of the key ingredients in the computation of class groups and discrete logarithms using index calculus methods.","title":"Introduction"},{"location":"sparse/intro/#sparse-rows","text":"Building blocks for sparse matrices are sparse rows, which are modelled by objects of type \\texttt{SRow}. More precisely, the type is of parametrized form objects of type SRow . More precisely, the type is of parametrized form SRow{T} , where T is the element type of the base ring R . For example, SRow{fmpz} is the type for sparse rows over the integers. It is important to note that sparse rows do not have a fixed number of columns, that is, they represent elements of \\{ (x_i)_i \\in R^{\\mathbb{N}} \\mid x_i = 0 \\text{ for almost all }i\\} . In particular any two sparse rows over the same base ring can be added.","title":"Sparse rows"},{"location":"sparse/intro/#creation","text":"# sparse_row \u2014 Method . sparse_row ( R :: Ring , J :: Vector { Tuple { Int , T }}) -> SRow { T } Constructs the sparse row (a_i)_i with a_{i_j} = x_j , where J = (i_j, x_j)_j . The elements x_i must belong to the ring R . source # sparse_row \u2014 Method . sparse_row ( R :: Ring , J :: Vector { Tuple { Int , T }}) -> SRow { T } Constructs the sparse row (a_i)_i with a_{i_j} = x_j , where J = (i_j, x_j)_j . The elements x_i must belong to the ring R . source sparse_row(R::Ring, J::Vector{Tuple{Int, Int}}) -> SRow Constructs the sparse row (a_i)_i over R with a_{i_j} = x_j , where J = (i_j, x_j)_j . source # sparse_row \u2014 Method . sparse_row ( R :: Ring , J :: Vector { Int }, V :: Vector { T }) -> SRow { T } Constructs the sparse row (a_i)_i over R with a_{i_j} = x_j , where J = (i_j)_j and V = (x_j)_j . source","title":"Creation"},{"location":"sparse/intro/#basic-operations","text":"Rows support the usual operations: + , - , == multiplication by scalars div , divexact # getindex \u2014 Method . getindex ( A :: SRow , j :: Int ) -> RingElem Given a sparse row (a_i)_{i} and an index j return a_j . source # add_scaled_row \u2014 Method . add_scaled_row ( A :: SRow { T }, B :: SRow { T }, c :: T ) -> SRow { T } Returns the row c A + B . source # add_scaled_row \u2014 Method . add_scaled_row ( A :: SRow { T }, B :: SRow { T }, c :: T ) -> SRow { T } Returns the row c A + B . source # transform_row \u2014 Method . transform_row ( A :: SRow { T }, B :: SRow { T }, i :: Int , j :: Int , a :: T , b :: T , c :: T , d :: T ) Returns the tuple (aA + bB, cA + dB) . source # length \u2014 Method . length ( A :: SRow ) Returns the number of nonzero entries of A . source","title":"Basic operations"},{"location":"sparse/intro/#change-of-base-ring","text":"# change_base_ring \u2014 Method . change_base_ring ( R :: Ring , A :: SRow ) -> SRow Create a new sparse row by coercing all elements into the ring R . source","title":"Change of base ring"},{"location":"sparse/intro/#maximum-minimum-and-2-norm","text":"# maximum \u2014 Method . maximum ( A :: SRow { T }) -> T Returns the largest entry of A . source # maximum \u2014 Method . maximum ( A :: SRow { T }) -> T Returns the largest entry of A . source # minimum \u2014 Method . minimum ( A :: NfRelOrdIdl ) -> NfOrdIdl minimum ( A :: NfRelOrdIdl ) -> NfRelOrdIdl Returns the ideal A \\cap O where O is the maximal order of the coefficient ideals of A . source minimum ( A :: SRow { T }) -> T Returns the smallest entry of A . source # minimum \u2014 Method . minimum ( A :: SRow { T }) -> T Returns the smallest entry of A . source # norm2 \u2014 Method . norm2 ( A :: SRow { T } -> T Returns A \\cdot A^t . source","title":"Maximum, minimum and 2-norm"},{"location":"sparse/intro/#functionality-for-integral-sparse-rows","text":"# lift \u2014 Method . lift ( A :: SRow { nmod }) -> SRow { fmpz } Return the sparse row obtained by lifting all entries in A . source # mod! \u2014 Method . mod! ( A :: SRow { fmpz }, n :: fmpz ) -> SRow { fmpz } Inplace reduction of all entries of A modulo n to the positive residue system. source # mod_sym! \u2014 Method . mod_sym! ( A :: SRow { fmpz }, n :: fmpz ) -> SRow { fmpz } Inplace reduction of all entries of A modulo n to the symmetric residue system. source # mod_sym! \u2014 Method . mod_sym! ( A :: SRow { fmpz }, n :: Integer ) -> SRow { fmpz } Inplace reduction of all entries of A modulo n to the symmetric residue system. source # maximum \u2014 Method . maximum ( abs , A :: SRow { fmpz }) -> fmpz Returns the largest, in absolute value, entry of A . source","title":"Functionality for integral sparse rows"},{"location":"sparse/intro/#sparse-matrices","text":"Let R be a commutative ring. Sparse matrices with base ring R are modelled by objects of type SMat . More precisely, the type is of parametrized form SRow{T} , where T is the element type of the base ring. For example, SMat{fmpz} is the type for sparse matrices over the integers. In constrast to sparse rows, sparse matrices have a fixed number of rows and columns, that is, they represent elements of the matrices space \\mathrm{Mat}_{n\\times m}(R) . Internally, sparse matrices are implemented as an array of sparse rows. As a consequence, unlike their dense counterparts, sparse matrices have a mutable number of rows and it is very performant to add additional rows.","title":"Sparse matrices"},{"location":"sparse/intro/#construction","text":"# sparse_matrix \u2014 Method . sparse_matrix ( R :: Ring ) -> SMat Return an empty sparse matrix with base ring R . source Sparse matrices can also be created from dense matrices as well as from julia arrays: # sparse_matrix \u2014 Method . sparse_matrix ( A :: MatElem ; keepzrows :: Bool = true ) Constructs the sparse matrix corresponding to the dense matrix A . If keepzrows is false, then the constructor will drop any zero row of A . source # sparse_matrix \u2014 Method . sparse_matrix ( R :: Ring , A :: Matrix { T }) -> SMat Constructs the sparse matrix over R corresponding to A . source # sparse_matrix \u2014 Method . sparse_matrix ( R :: Ring , A :: Matrix { T }) -> SMat Constructs the sparse matrix over R corresponding to A . source The normal way however, is to add rows: # push! \u2014 Method . push! ( A :: SMat { T }, B :: SRow { T }) where T Appends the sparse row B to A . source Sparse matrices can also be concatenated to form larger ones: # vcat! \u2014 Method . vcat! ( A :: SMat , B :: SMat ) -> SMat Vertically joins A and B inplace, that is, the rows of B are appended to A . source # vcat \u2014 Method . vcat ( A :: SMat , B :: SMat ) -> SMat Vertically joins A and B . source # hcat! \u2014 Method . hcat! ( A :: SMat , B :: SMat ) -> SMat Horizontally concatenates A and B , inplace, changing A . source # hcat \u2014 Method . hcat ( A :: SMat , B :: SMat ) -> SMat Horizontally concatenates A and B . source (Normal julia cat is also supported) There are special constructors: # identity_matrix \u2014 Method . identity_matrix ( :: Type { SMat }, R :: Ring , n :: Int ) Return a sparse n times n identity matrix over R . source # zero_matrix \u2014 Method . zero_matrix ( :: Type { SMat }, R :: Ring , n :: Int ) Return a sparse n times n zero matrix over R . source # zero_matrix \u2014 Method . zero_matrix ( :: Type { SMat }, R :: Ring , n :: Int , m :: Int ) Return a sparse n times m zero matrix over R . source Slices: # sub \u2014 Method . sub ( A :: SMat , r :: UnitRange , c :: UnitRange ) -> SMat Return the submatrix of A , where the rows correspond to r and the columns correspond to c . source Transpose: # transpose \u2014 Method . transpose ( A :: SMat ) -> SMat Returns the transpose of A . source","title":"Construction"},{"location":"sparse/intro/#elementary-properties","text":"# sparsity \u2014 Method . sparsity ( A :: SMat ) -> Float64 Return the sparsity of A , that is, the number of zero-valued elements divided by the number of all elements. source # density \u2014 Method . density ( A :: SMat ) -> Float64 Return the density of A , that is, the number of nonzero-valued elements divided by the number of all elements. source # nnz \u2014 Method . nnz ( A :: SMat ) -> Int Return the number of non-zero entries of A . source # nrows \u2014 Method . nrows ( A :: SMat ) -> Int Return the number of rows of A . source # ncols \u2014 Method . ncols ( A :: SMat ) -> Int Return the number of columns of A . source # isone \u2014 Method . isone ( A :: SMat ) Tests if A is an identity matrix. source # iszero \u2014 Method . iszero ( A :: SMat ) Tests if A is a zero matrix. source # isupper_triangular \u2014 Method . isupper_triangular ( A :: SMat ) Returns true if and only if A is upper (right) triangular. source # maximum \u2014 Method . maximum ( A :: SMat { T }) -> T Finds the largest entry of A . source # minimum \u2014 Method . minimum ( A :: SMat { T }) -> T Finds the smallest entry of A . source # maximum \u2014 Method . maximum ( abs , A :: SMat { fmpz }) -> fmpz Finds the largest, in absolute value, entry of A . source # elementary_divisors \u2014 Method . elementary_divisors ( A :: SMat { fmpz }) -> Vector { fmpz } The elementary divisors of A , i.e. the diagonal elements of the Smith normal form of A . source # solve_dixon_sf \u2014 Method . solve_dixon_sf ( A :: SMat { fmpz }, b :: SRow { fmpz }, is_int :: Bool = false ) -> SRow { fmpz }, fmpz solve_dixon_sf ( A :: SMat { fmpz }, B :: SMat { fmpz }, is_int :: Bool = false ) -> SMat { fmpz }, fmpz For a sparse square matrix A of full rank and a sparse matrix (row), find a sparse matrix (row) x and an integer d s.th. x A = bd holds. The algorithm is a Dixon-based linear p-adic lifting method. If \\code{is_int} is given, then d is assumed to be 1 . In this case rational reconstruction is avoided. source # hadamard_bound2 \u2014 Method . hadamard_bound2 ( A :: SMat { T }) -> T The square of the product of the norms of the rows of A . source # echelon_with_transform \u2014 Method . echelon_with_transform ( A :: SMat { nmod }) -> SMat , SMat Find a unimodular matrix T and an upper-triangular E s.th. TA = E holds. source # reduce_full \u2014 Method . reduce_full ( A :: SMat { fmpz }, g :: SRow { fmpz }, trafo = Val { false }) -> SRow { fmpz }, Vector { Int } Reduces g modulo A and assumes that A is upper triangular. The second return value is the array of pivot elements of A that changed. If trafo is set to Val{true} , then additionally an array of transformations is returned. source # hnf! \u2014 Method . hnf! ( A :: SMat { fmpz }) Inplace transform of A into upper right Hermite normal form. source # hnf \u2014 Method . hnf ( A :: SMat { fmpz }) -> SMat { fmpz } Return the upper right Hermite normal form of A . source # snf \u2014 Method . snf ( A :: SMat { fmpz }) The Smith normal form (snf) of A . source # hnf_extend! \u2014 Method . hnf_extend! ( A :: SMat { fmpz }, b :: SMat { fmpz }, offset :: Int = 0 ) -> SMat { fmpz } Given a matrix A in HNF, extend this to get the HNF of the concatenation with b . source # isdiagonal \u2014 Method . isdiagonal ( A :: SMat ) -> Bool True iff only the i-th entry in the i-th row is non-zero. source # det \u2014 Method . det ( A :: SMat { fmpz }) The determinant of A using a modular algorithm. Uses the dense (nmod_mat) determinant on A for various primes p . source # det_mc \u2014 Method . det_mc ( A :: SMat { fmpz }) Computes the determinant of A using a LasVegas style algorithm, i.e. the result is not proven to be correct. Uses the dense (nmod_mat) determinant on A for various primes p . source # valence_mc \u2014 Method . valence_mc { T }( A :: SMat { T }; extra_prime = 2 , trans = Vector { SMatSLP_add_row { T }}()) -> T Uses a Monte-Carlo algorithm to compute the valence of A . The valence is the valence of the minimal polynomial f of transpose(A)*A , thus the last non-zero coefficient, typically f(0) . The valence is computed modulo various primes until the computation stabilises for extra_prime many. trans , if given, is a SLP (straight-line-program) in GL(n, Z). Then the valence of trans * A is computed instead. source # saturate \u2014 Method . saturate ( A :: SMat { fmpz }) -> SMat { fmpz } Computes the saturation of A , that is, a basis for \\mathbf{Q}\\otimes M \\meet \\mathbf{Z}^n , where M is the row span of A and n the number of rows of A . Equivalently, return TA for an invertible rational matrix T , such that TA is integral and the elementary divisors of TA are all trivial. source # hnf_kannan_bachem \u2014 Method . hnf_kannan_bachem ( A :: SMat { fmpz }) -> SMat { fmpz } Compute the Hermite normal form of A using the Kannan-Bachem algorithm. source # diagonal_form \u2014 Method . diagonal_form ( A :: SMat { fmpz }) -> SMat { fmpz } A matrix D that is diagonal and obtained via unimodular row and column operations. Like a snf without the divisibility condition. source","title":"Elementary Properties"},{"location":"sparse/intro/#manipulation-access","text":"# getindex \u2014 Method . getindex ( A :: SMat , i :: Int , j :: Int ) Given a sparse matrix A = (a_{ij})_{i, j} , return the entry a_{ij} . source # getindex \u2014 Method . getindex ( A :: SMat , i :: Int ) -> SRow Given a sparse matrix A and an index i , return the i -th row of A . source # setindex! \u2014 Method . setindex! ( A :: SMat , b :: SRow , i :: Int ) Given a sparse matrix A , a sparse row b and an index i , set the i -th row of A equal to b . source # swap_rows! \u2014 Method . swap_rows! ( A :: SMat { T }, i :: Int , j :: Int ) Swap the i -th and j -th row of A inplace. source # swap_cols! \u2014 Method . swap_cols! ( A :: SMat , i :: Int , j :: Int ) Swap the i -th and j -th column of A inplace. source # scale_row! \u2014 Method . scale_row! ( A :: SMat { T }, i :: Int , c :: T ) Multiply the i -th row of A by c inplace. source # add_scaled_col! \u2014 Method . add_scaled_col! ( A :: SMat { T }, i :: Int , j :: Int , c :: T ) Add c times the i -th column to the j -th column of A inplace, that is, A_j \\rightarrow A_j + c \\cdot A_i , where (A_i)_i denote the columns of A . source # add_scaled_row! \u2014 Method . add_scaled_row! ( A :: SMat { T }, i :: Int , j :: Int , c :: T ) Add c times the i -th row to the j -th row of A inplace, that is, A_j \\rightarrow A_j + c \\cdot A_i , where (A_i)_i denote the rows of A . source # transform_row! \u2014 Method . transform_row! ( A :: SMat { T }, i :: Int , j :: Int , a :: T , b :: T , c :: T , d :: T ) Applies the transformation (A_i, A_j) \\rightarrow (aA_i + bA_j, cA_i + dA_j) to A , where (A_i)_i are the rows of A . source # diagonal \u2014 Method . diagonal ( A :: SMat ) -> fmpz [] The diagonal elements of A in an array. source # reverse_rows! \u2014 Method . reverse_rows! ( A :: SMat ) Inplace inversion of the rows of A . source # mod_sym! \u2014 Method . mod_sym! ( A :: SMat { fmpz }, n :: fmpz ) Inplace reduction of all entries of A modulo n to the symmetric residue system. source # find_row_starting_with \u2014 Method . find_row_starting_with ( A :: SMat , p :: Int ) -> Int Tries to find the index i such that A_{i,p} \\neq 0 and A_{i, p-j} = 0 for all j > 1 . It is assumed that A is upper triangular. If such an index does not exist, find the smallest index larger. source # reduce \u2014 Method . reduce ( A :: SMat { fmpz }, g :: SRow { fmpz }, m :: fmpz ) -> SRow { fmpz } Given an upper triangular matrix A over the integers, a sparse row g and an integer m , this function reduces g modulo A and returns g modulo m with respect to the symmetric residue system. source # reduce \u2014 Method . reduce ( A :: SMat { fmpz }, g :: SRow { fmpz }) -> SRow { fmpz } Given an upper triangular matrix A over a field and a sparse row g , this function reduces g modulo A . source <a id='reduce-Union{Tuple{T}, Tuple{SMat{T}, SRow{T}}} where T<:FieldElement' href='#reduce-Union{Tuple{T}, Tuple{SMat{T}, SRow{T}}} where T<:FieldElement'># reduce \u2014 Method . reduce ( A :: SMat { T }, g :: SRow { T }) -> SRow { T } Given an upper triangular matrix A over a field and a sparse row g , this function reduces g modulo A . source # rand_row \u2014 Method . rand_row ( A :: SMat ) -> SRow Return a random row of the sparse matrix A . source Changing of the ring: # map_entries \u2014 Method . map_entries ( f , A :: SMat ) -> SMat Given a sparse matrix A and a callable object f , this function will construct a new sparse matrix by applying f to all elements of A . source # change_base_ring \u2014 Method . change_base_ring ( R :: Ring , A :: SMat ) Create a new sparse matrix by coercing all elements into the ring R . source","title":"Manipulation/ Access"},{"location":"sparse/intro/#arithmetic","text":"Matrices support the usual operatation as well + , - , == , * div , divexact by scalars multiplication by scalars Various products: # mul \u2014 Method . mul ( A :: SMat { T }, b :: AbstractVector { T }) -> Vector { T } Return the product A \\cdot b as a dense vector. source # mul \u2014 Method . mul ( A :: SMat { T }, b :: AbstractMatrix { T }) -> Matrix { T } Return the product A \\cdot b as a dense array. source # mul \u2014 Method . mul ( A :: SMat { T }, b :: MatElem { T }) -> MatElem Return the product A \\cdot b as a dense matrix. source # mul \u2014 Method . mul ( A :: SRow , B :: SMat ) -> SRow Return the product A\\cdot B as a sparse row. source Other: # sparse \u2014 Method . sparse ( A :: SMat ) -> SparseMatrixCSC The same matrix, but as a sparse matrix of julia type SparseMatrixCSC . source # fmpz_mat \u2014 Method . fmpz_mat ( A :: SMat { fmpz }) The same matrix A , but as an fmpz_mat . source <a id='fmpz_mat-Union{Tuple{SMat{T}}, Tuple{T}} where T<:Integer' href='#fmpz_mat-Union{Tuple{SMat{T}}, Tuple{T}} where T<:Integer'># fmpz_mat \u2014 Method . fmpz_mat ( A :: SMat { T }) where { T <: Integer } The same matrix A , but as an fmpz_mat . Requires a conversion from the base ring of A to \\mathbb ZZ . source # Array \u2014 Method . Array ( A :: SMat { T }) -> Matrix { T } The same matrix, but as a two-dimensional julia array. source","title":"Arithmetic"}]}