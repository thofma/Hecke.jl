```@meta
CurrentModule = Hecke
CollapsedDocStrings = true
DocTestSetup = Hecke.doctestsetup()
```
# [Ideals](@id NfOrdIdlLink2)


(Integral) ideals in orders are always free $Z$-module of the same rank as the
order, hence have a representation via a $Z$-basis. This can be made unique
by normalising the corresponding matrix to be in reduced row echelon form
(HNF).

For ideals in maximal orders $Z_K$, we also have a second presentation coming
from the $Z_K$ module structure and the fact that $Z_K$ is a Dedekind ring:
ideals can be generated by 2 elements, one of which can be any non-zero
element in the ideal.

For efficiency, we will choose the 1st generator to be an integer.

Ideals here are of type `AbsNumFieldOrderIdeal`, which is, similar to the elements
above, also indexed by the type of the field and their elements:
`AbsNumFieldOrderIdeal{AbsSimpleNumField,AbsSimpleNumFieldElem}` for ideals in
simple absolute fields.

Different to elements, the `parent`of an ideal is the set of all ideals
in the ring, of type `AbsNumFieldOrderIdealSet`.

## Creation

```@docs
ideal(::AbsSimpleNumFieldOrder, ::ZZRingElem)
ideal(::AbsSimpleNumFieldOrder, ::ZZMatrix)
ideal(::AbsSimpleNumFieldOrder, ::AbsSimpleNumFieldOrderElem)
ideal(::AbsSimpleNumFieldOrder, ::ZZRingElem, ::AbsSimpleNumFieldOrderElem)
ideal(::AbsNumFieldOrder, ::ZZRingElem, ::AbsNumFieldOrderElem)
ideal(::AbsNumFieldOrder, ::ZZRingElem)
ideal(::AbsNumFieldOrder, ::AbsNumFieldOrderElem)

*(::AbsSimpleNumFieldOrder, ::AbsSimpleNumFieldOrderElem)
factor(::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem})
factor(::AbsNumFieldOrderIdealSet{AbsSimpleNumField, AbsSimpleNumFieldElem}, ::AbsSimpleNumFieldElem)
coprime_base(::Vector{AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}})
```

## Arithmetic

All the usual operations are supported:

- `==`, `+`, `*`
- `divexact`, `divides`
- `lcm`, `gcd`
- `in`

```@docs
intersect(::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}, ::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem})
colon(::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}, ::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem})
in(::AbsSimpleNumFieldOrderElem, ::AbsNumFieldOrderIdeal)
is_power(::AbsNumFieldOrderIdeal, ::Int)
is_power(::AbsNumFieldOrderIdeal)
is_invertible(::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem})
isone(::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem})
```

## Class Group

The group of invertible ideals in any order forms a group and the principal
ideals a subgroup.  The finite quotient is called class group for maximal orders
and Picard group
or ring class group in general.

```@docs
class_group(::AbsSimpleNumFieldOrder)
narrow_class_group(::AbsSimpleNumFieldOrder)
picard_group(::AbsSimpleNumFieldOrder)
ring_class_group(::AbsNumFieldOrder)
```

```jldoctest 2; filter = r".*"
julia> k, a = wildanger_field(3, 13);

julia> zk = maximal_order(k);

julia> c, mc = class_group(zk)
(Z/9, ClassGroup map of
Set of ideals of zk)

julia> lp = prime_ideals_up_to(zk, 20);

julia> [ mc \ I for I = lp]
10-element Vector{FinGenAbGroupElem}:
 [1]
 [4]
 [4]
 [5]
 [3]
 [2]
 [7]
 [1]
 [0]
 [2]

julia> mc(c[1])
<2, 3//2*_$^2 + 2*_$ + 5//2>
Norm: 2
Minimum: 2
two normal wrt: 2

julia> order(c[1])
9

julia> mc(c[1])^Int(order(c[1]))
<512, 43959719112139289493//2*_$^2 - 21814811847856022656*_$ + 47593247393471446019//2>
Norm: 512
Minimum: 512
two normal wrt: 2

julia> mc \ ans
Abelian group element [0]
```


The class group, or more precisely the information used to compute it
also allows for principal ideal testing and related tasks.
In general, due to the size of the objects, the ```fac_elem``` versions are
more efficient.

```@docs
is_principal(::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem})
is_principal_with_data(::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem})
is_principal_fac_elem(::AbsNumFieldOrderIdeal{AbsSimpleNumField,AbsSimpleNumFieldElem})
power_class(::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem},::ZZRingElem)
power_product_class(::Vector{AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}}, ::Vector{ZZRingElem})
power_reduce(::AbsNumFieldOrderIdeal{AbsSimpleNumField,AbsSimpleNumFieldElem},::ZZRingElem)
class_group_ideal_relation(::AbsNumFieldOrderIdeal{AbsSimpleNumField,AbsSimpleNumFieldElem}, ::Hecke.ClassGrpCtx)
factor_base_bound_grh(::AbsSimpleNumFieldOrder)
factor_base_bound_bach(::AbsSimpleNumFieldOrder)
prime_ideals_up_to
```

```jldoctest 2; filter = r".*"
julia> I = mc(c[1])
<2, 3//2*_$^2 + 2*_$ + 5//2>
Norm: 2
Minimum: 2
two normal wrt: 2

julia> is_principal(I)
false

julia> I = I^Int(order(c[1]))
<512, 43959719112139289493//2*_$^2 - 21814811847856022656*_$ + 47593247393471446019//2>
Norm: 512
Minimum: 512
two normal wrt: 2

julia> is_principal(I)
true

julia> is_principal_fac_elem(I)
(true, (_$ + 29)^2*5^-3*(1//2*_$^2 - 6*_$ + 5//2)^2*(1//2*_$^2 - 6*_$ + 7//2)^2*31^-2*(19//2*_$^2 - 117*_$ + 117//2)^2*(_$ - 4)^-2*(_$^2 + _$ + 2)^3*(_$ + 5)^-3*(_$^2 + 1)^-3*3^1*(10*_$^2 - 91*_$ - 156)^-2*(_$ + 1)^1*(3//2*_$^2 + 1//2)^2*(_$ + 6)^2*1^-1)
```

The computation of $S$-units is also tied to the class group:

```@docs
torsion_units(::AbsSimpleNumFieldOrder)
torsion_unit_group(::AbsSimpleNumFieldOrder)
torsion_units_generator(::AbsSimpleNumFieldOrder)
Hecke.torsion_units_gen_order(::AbsSimpleNumFieldOrder)
unit_group(::AbsSimpleNumFieldOrder)
unit_group_fac_elem(::AbsSimpleNumFieldOrder)
sunit_group(::Vector{AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}})
sunit_group_fac_elem(::Vector{AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}})
sunit_mod_units_group_fac_elem(::Vector{AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}})
```

```jldoctest 2; filter = r".*"
julia> u, mu = unit_group(zk)
(Z/2 x Z, UnitGroup map of Maximal order of number field of degree 3 over QQ
with basis [1, _$, 1//2*_$^2 + 1//2]
)

julia> mu(u[2])
_$ - 12

julia> u, mu = unit_group_fac_elem(zk)
(Z/2 x Z, UnitGroup map of Factored elements over Number field of degree 3 over QQ
)

julia> mu(u[2])
(19//2*_$^2 - 117*_$ + 117//2)^1*(_$^2 + 1)^-1*(1//2*_$^2 - 6*_$ + 5//2)^1*(1//2*_$^2 - 6*_$ + 7//2)^1*(10*_$^2 - 91*_$ - 156)^-1

julia> evaluate(ans)
_$ - 12

julia> lp = factor(6*zk)
Dict{AbsSimpleNumFieldOrderIdeal, Int64} with 4 entries:
  <3, _$ + 5>                  => 1
  <3, _$^2 + 1>                => 1
  <2, 3//2*_$^2 + 7//2>        => 2
  <2, 5//2*_$^2 + 3*_$ + 5//2> => 1

julia> s, ms = Hecke.sunit_group(collect(keys(lp)))
(Z/2 x Z^(5), SUnits  map of k for AbsSimpleNumFieldOrderIdeal[<3, _$ + 5>
Norm: 3
Minimum: 3
basis_matrix
[3 0 0; 2 1 0; 2 0 1]
two normal wrt: 3, <3, _$^2 + 1>
Norm: 9
Minimum: 3
basis_matrix
[3 0 0; 0 3 0; 0 0 1]
two normal wrt: 3, <2, 3//2*_$^2 + 7//2>
Norm: 2
Minimum: 2
basis_matrix
[2 0 0; 1 1 0; 0 0 1]
two normal wrt: 2, <2, 5//2*_$^2 + 3*_$ + 5//2>
Norm: 2
Minimum: 2
basis_matrix
[2 0 0; 1 1 0; 1 0 1]
two normal wrt: 2]
)

julia> ms(s[4])
-1//2*_$^2 + 6*_$ + 5//2

julia> norm(ans)
144

julia> factor(numerator(ans))
1 * 2^4 * 3^2
```

## Miscellaneous

```@docs
order(::AbsNumFieldOrderIdeal)
order(::AbsNumFieldOrderFractionalIdeal)
order(::RelNumFieldOrderIdeal)
order(::RelNumFieldOrderFractionalIdeal)
nf(::AbsNumFieldOrderIdeal)
basis(::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem})
Hecke.lll_basis(::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem})
basis_matrix(::AbsNumFieldOrderIdeal)
basis_mat_inv(::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem})
Hecke.has_princ_gen_special(::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem})
Hecke.principal_generator(::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem})
Hecke.principal_generator_fac_elem(::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem})
minimum(::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem})
minimum(::RelNumFieldOrderIdeal)
minimum(::AbsNumFieldOrderIdeal)
has_minimum(::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem})
norm(::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem})
Hecke.has_norm(::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem})
idempotents(::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}, ::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem})
is_prime(::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem})
Hecke.is_prime_known(::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem})
is_ramified(::AbsSimpleNumFieldOrder, ::Union{Int, ZZRingElem})
ramification_index(::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem})
degree(::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem})
valuation(::AbsSimpleNumFieldElem, ::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem})
valuation(::AbsSimpleNumFieldOrderElem, ::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem})
valuation(::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}, ::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem})
valuation(::Integer, ::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem})
valuation(::ZZRingElem, ::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem})
valuation(::AbsSimpleNumFieldOrderFractionalIdeal, ::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem})
idempotents(::AbsNumFieldOrderIdeal, ::AbsNumFieldOrderIdeal)
```

## Quotient Rings

```@docs
quo(::Union{AbsNumFieldOrder, AlgAssAbsOrd}, ::Union{AbsNumFieldOrderIdeal, AlgAssAbsOrdIdl})
residue_ring(::AbsSimpleNumFieldOrder, ::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem})
residue_field(::AbsSimpleNumFieldOrder, ::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}, ::Bool)
mod(::AbsSimpleNumFieldOrderElem, ::AbsNumFieldOrderIdeal)
crt(::AbsSimpleNumFieldOrderElem, ::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}, ::AbsSimpleNumFieldOrderElem, ::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem})
euler_phi(::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem})
Hecke.multiplicative_group(::AbsSimpleNumFieldOrderQuoRing)
Hecke.multiplicative_group_generators(::AbsSimpleNumFieldOrderQuoRing)
```

