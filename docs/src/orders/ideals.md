# [Ideals](@id NfOrdIdlLink)
```@meta
CurrentModule = Hecke
```


(Integral) ideals in orders are always free $Z$-module of the same rank as the
order, hence have a representation via a $Z$-basis. This can be made unique
by normalising the corresponding matrix to be in reduced row echelon form
(HNF).

For ideals in maximal orders $Z_K$, we also have a second presentation coming
from the $Z_K$ module structure and the fact that $Z_K$ is a Dedekind ring:
ideals can be generated by 2 elements, one of which can be any non-zero
element in the ideal.

For efficiency, we will choose the 1st generator to be an integer.

Ideals here are of type `NfAbsOrdIdl`, which is, similar to the elements
above, also indexed by the type of the field and their elements:
`NfAbsOrdIdl{AnticNumberField,nf_elem}` for ideals in
simple absolute fields.

Different to elements, the `parent`of an ideal is teh set of all ideals
in the ring, of type `NfAbsOrdIdlSet`.

## Creation

```@docs
ideal(::NfOrd, ::fmpz)
ideal(::NfOrd, ::fmpz_mat)
ideal(::NfOrd, ::NfOrdElem)
ideal(::NfOrd, ::fmpz, ::NfOrdElem)
ideal(::NfAbsOrd, ::fmpz, ::NfAbsOrdElem)
ideal(::NfAbsOrd, ::fmpz)
ideal(::NfAbsOrd, ::NfAbsOrdElem)

*(::NfOrd, ::NfOrdElem)
factor(::NfOrdIdl)
factor(::nf_elem, ::NfOrdIdlSet)
coprime_base(::Vector{NfOrdIdl})
```

## Arithmetic

All the usual operations are supported:

- `==`, `+`, `*`
- `divexact`, `divides`
- `lcm`, `gcd`
- `in`

```@docs
intersect(::NfOrdIdl, ::NfOrdIdl)
colon(::NfOrdIdl, ::NfOrdIdl)
in(::NfOrdElem, ::NfAbsOrdIdl)
is_power(::NfAbsOrdIdl, ::Int)
is_power(::NfAbsOrdIdl)
is_invertible(::NfOrdIdl)
isone(::NfOrdIdl)
```

## Class Group

The group of invertable ideals in any order forms a group and the principal
ideals a subgroup.  The finite quotient is called class group for maximal orders
and Picard group
or ring class group in general.

```@docs
class_group(::NfOrd)
narrow_class_group(::NfOrd)
picard_group(::NfOrd)
ring_class_group(::NfAbsOrd)
```

```@repl 2
using Hecke # hide
k, a = wildanger_field(3, 13);
zk = maximal_order(k);
c, mc = class_group(zk)
lp = prime_ideals_up_to(zk, 20);
[ mc \ I for I = lp]
mc(c[1])
order(c[1])
mc(c[1])^Int(order(c[1]))
mc \ ans
```


The class group, or more precisely the information used to compute it
also allows for principal ideal testing and related tasks.
In general, due to the size of the objetcs, the ```fac_elem``` versions are
more effcient.

```@docs
Hecke.is_principal(::NfOrdIdl)
is_principal_fac_elem(::NfAbsOrdIdl{AnticNumberField,nf_elem})
power_class(::NfOrdIdl,::fmpz)
power_product_class(::Vector{NfOrdIdl}, ::Vector{fmpz})
power_reduce(::NfAbsOrdIdl{AnticNumberField,nf_elem},::fmpz)
class_group_ideal_relation(::NfAbsOrdIdl{AnticNumberField,nf_elem}, ::Hecke.ClassGrpCtx)
factor_base_bound_grh(::NfOrd)
factor_base_bound_bach(::NfOrd)
prime_ideals_up_to
```

```@repl 2
I = mc(c[1])
Hecke.is_principal(I)
I = I^Int(order(c[1]))
Hecke.is_principal(I)
Hecke.is_principal_fac_elem(I)
```

The computation of $S$-units is also tied to the class group:

```@docs
torsion_units(::NfOrd)
torsion_unit_group(::NfOrd)
torsion_units_generator(::NfOrd)
Hecke.torsion_units_gen_order(::NfOrd)
unit_group(::NfOrd)
unit_group_fac_elem(::NfOrd)
sunit_group(::Vector{NfOrdIdl})
sunit_group_fac_elem(::Vector{NfOrdIdl})
sunit_mod_units_group_fac_elem(::Vector{NfOrdIdl})
```

```@repl 2
u, mu = unit_group(zk)
mu(u[2])
u, mu = unit_group_fac_elem(zk)
mu(u[2])
evaluate(ans)
lp = factor(6*zk)
s, ms = Hecke.sunit_group(collect(keys(lp)))
ms(s[4])
norm(ans)
factor(numerator(ans))
```

## Miscaellenous

```@docs
order(::NfAbsOrdIdl)
order(::NfAbsOrdFracIdl)
order(::NfRelOrdIdl)
order(::NfRelOrdFracIdl)
nf(::NfAbsOrdIdl)
basis(::NfOrdIdl)
Hecke.lll_basis(::NfOrdIdl)
basis_matrix(::NfAbsOrdIdl)
basis_mat_inv(::NfOrdIdl)
Hecke.assure_has_basis_mat_inv(::NfOrdIdl)
Hecke.has_basis(::NfOrdIdl)
Hecke.has_basis_matrix(::NfOrdIdl)
Hecke.has_2_elem(::NfOrdIdl)
Hecke.has_2_elem_normal(::NfOrdIdl)
Hecke.has_weakly_normal(::NfOrdIdl)
Hecke.has_princ_gen_special(::NfOrdIdl)
Hecke.principal_generator(::NfOrdIdl)
Hecke.principal_generator_fac_elem(::NfOrdIdl)
minimum(::NfOrdIdl)
minimum(::NfRelOrdIdl)
minimum(::NfAbsOrdIdl)
has_minimum(::NfOrdIdl)
norm(::NfOrdIdl)
Hecke.has_norm(::NfOrdIdl)
idempotents(::NfOrdIdl, ::NfOrdIdl)
is_prime(::NfOrdIdl)
Hecke.is_prime_known(::NfOrdIdl)
is_ramified(::NfOrd, ::Union{Int, fmpz})
ramification_index(::NfOrdIdl)
degree(::NfOrdIdl)
valuation(::nf_elem, ::NfOrdIdl)
valuation(::NfOrdElem, ::NfOrdIdl)
valuation(::NfOrdIdl, ::NfOrdIdl)
valuation(::Integer, ::NfOrdIdl)
valuation(::fmpz, ::NfOrdIdl)
valuation(::NfOrdFracIdl, ::NfOrdIdl)
idempotents(::NfAbsOrdIdl, ::NfAbsOrdIdl)
```

## Quotient Rings

```@docs
quo(::Union{NfAbsOrd, AlgAssAbsOrd}, ::Union{NfAbsOrdIdl, AlgAssAbsOrdIdl})
ResidueRing(::NfOrd, ::NfOrdIdl)
ResidueField(::NfOrd, ::NfOrdIdl, ::Bool)
mod(::NfOrdElem, ::NfAbsOrdIdl)
crt(::NfOrdElem, ::NfOrdIdl, ::NfOrdElem, ::NfOrdIdl)
euler_phi(::NfOrdIdl)
Hecke.multiplicative_group(::NfOrdQuoRing)
Hecke.multiplicative_group_generators(::NfOrdQuoRing)
```

