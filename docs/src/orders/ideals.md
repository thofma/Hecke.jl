# [Ideals](@id NfOrdIdlLink)
```@meta
CurrentModule = Hecke
```


(Integral) ideals in orders are always free $Z$-module of the same rank as the
order, hence have a representation via a $Z$-basis. This can be made unique
by normalising the corresponding matrix to be in reduced row echelon form
(HNF).

For ideals in maximal orders $Z_K$, we also have a second presentation coming
from the $Z_K$ module structure and the fact that $Z_K$ is a Dedekind ring:
ideals can be generated by 2 elements, one of which can be any non-zero
element in the ideal.

For efficiency, we will choose the 1st generator to be an integer.

Ideals here are of type `AbsNumFieldOrderIdeal`, which is, similar to the elements
above, also indexed by the type of the field and their elements:
`AbsNumFieldOrderIdeal{AbsSimpleNumField,AbsSimpleNumFieldElem}` for ideals in
simple absolute fields.

Different to elements, the `parent`of an ideal is the set of all ideals
in the ring, of type `AbsNumFieldOrderIdealSet`.

## Creation

```@docs; canonical=false
ideal(::AbsSimpleNumFieldOrder, ::ZZRingElem)
ideal(::AbsSimpleNumFieldOrder, ::ZZMatrix)
ideal(::AbsSimpleNumFieldOrder, ::AbsSimpleNumFieldOrderElem)
ideal(::AbsSimpleNumFieldOrder, ::ZZRingElem, ::AbsSimpleNumFieldOrderElem)
ideal(::AbsNumFieldOrder, ::ZZRingElem, ::AbsNumFieldOrderElem)
ideal(::AbsNumFieldOrder, ::ZZRingElem)
ideal(::AbsNumFieldOrder, ::AbsNumFieldOrderElem)

*(::AbsSimpleNumFieldOrder, ::AbsSimpleNumFieldOrderElem)
factor(::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem})
factor(::AbsNumFieldOrderIdealSet{AbsSimpleNumField, AbsSimpleNumFieldElem}, ::AbsSimpleNumFieldElem)
coprime_base(::Vector{AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}})
```

## Arithmetic

All the usual operations are supported:

- `==`, `+`, `*`
- `divexact`, `divides`
- `lcm`, `gcd`
- `in`

```@docs; canonical=false
intersect(::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}, ::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem})
colon(::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}, ::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem})
in(::AbsSimpleNumFieldOrderElem, ::AbsNumFieldOrderIdeal)
is_power(::AbsNumFieldOrderIdeal, ::Int)
is_power(::AbsNumFieldOrderIdeal)
is_invertible(::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem})
isone(::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem})
```

## Class Group

The group of invertable ideals in any order forms a group and the principal
ideals a subgroup.  The finite quotient is called class group for maximal orders
and Picard group
or ring class group in general.

```@docs; canonical=false
class_group(::AbsSimpleNumFieldOrder)
narrow_class_group(::AbsSimpleNumFieldOrder)
picard_group(::AbsSimpleNumFieldOrder)
ring_class_group(::AbsNumFieldOrder)
```

```@repl 2
using Hecke # hide
k, a = wildanger_field(3, 13);
zk = maximal_order(k);
c, mc = class_group(zk)
lp = prime_ideals_up_to(zk, 20);
[ mc \ I for I = lp]
mc(c[1])
order(c[1])
mc(c[1])^Int(order(c[1]))
mc \ ans
```


The class group, or more precisely the information used to compute it
also allows for principal ideal testing and related tasks.
In general, due to the size of the objects, the ```fac_elem``` versions are
more efficient.

```@docs; canonical=false
is_principal(::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem})
is_principal_with_data(::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem})
is_principal_fac_elem(::AbsNumFieldOrderIdeal{AbsSimpleNumField,AbsSimpleNumFieldElem})
power_class(::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem},::ZZRingElem)
power_product_class(::Vector{AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}}, ::Vector{ZZRingElem})
power_reduce(::AbsNumFieldOrderIdeal{AbsSimpleNumField,AbsSimpleNumFieldElem},::ZZRingElem)
class_group_ideal_relation(::AbsNumFieldOrderIdeal{AbsSimpleNumField,AbsSimpleNumFieldElem}, ::Hecke.ClassGrpCtx)
factor_base_bound_grh(::AbsSimpleNumFieldOrder)
factor_base_bound_bach(::AbsSimpleNumFieldOrder)
prime_ideals_up_to
```

```@repl 2
I = mc(c[1])
is_principal(I)
I = I^Int(order(c[1]))
is_principal(I)
is_principal_fac_elem(I)
```

The computation of $S$-units is also tied to the class group:

```@docs; canonical=false
torsion_units(::AbsSimpleNumFieldOrder)
torsion_unit_group(::AbsSimpleNumFieldOrder)
torsion_units_generator(::AbsSimpleNumFieldOrder)
Hecke.torsion_units_gen_order(::AbsSimpleNumFieldOrder)
unit_group(::AbsSimpleNumFieldOrder)
unit_group_fac_elem(::AbsSimpleNumFieldOrder)
sunit_group(::Vector{AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}})
sunit_group_fac_elem(::Vector{AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}})
sunit_mod_units_group_fac_elem(::Vector{AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}})
```

```@repl 2
u, mu = unit_group(zk)
mu(u[2])
u, mu = unit_group_fac_elem(zk)
mu(u[2])
evaluate(ans)
lp = factor(6*zk)
s, ms = Hecke.sunit_group(collect(keys(lp)))
ms(s[4])
norm(ans)
factor(numerator(ans))
```

## Miscaellenous

```@docs; canonical=false
order(::AbsNumFieldOrderIdeal)
order(::AbsNumFieldOrderFractionalIdeal)
order(::RelNumFieldOrderIdeal)
order(::RelNumFieldOrderFractionalIdeal)
nf(::AbsNumFieldOrderIdeal)
basis(::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem})
Hecke.lll_basis(::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem})
basis_matrix(::AbsNumFieldOrderIdeal)
basis_mat_inv(::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem})
Hecke.has_princ_gen_special(::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem})
Hecke.principal_generator(::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem})
Hecke.principal_generator_fac_elem(::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem})
minimum(::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem})
minimum(::RelNumFieldOrderIdeal)
minimum(::AbsNumFieldOrderIdeal)
has_minimum(::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem})
norm(::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem})
Hecke.has_norm(::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem})
idempotents(::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}, ::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem})
is_prime(::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem})
Hecke.is_prime_known(::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem})
is_ramified(::AbsSimpleNumFieldOrder, ::Union{Int, ZZRingElem})
ramification_index(::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem})
degree(::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem})
valuation(::AbsSimpleNumFieldElem, ::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem})
valuation(::AbsSimpleNumFieldOrderElem, ::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem})
valuation(::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}, ::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem})
valuation(::Integer, ::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem})
valuation(::ZZRingElem, ::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem})
valuation(::AbsSimpleNumFieldOrderFractionalIdeal, ::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem})
idempotents(::AbsNumFieldOrderIdeal, ::AbsNumFieldOrderIdeal)
```

## Quotient Rings

```@docs; canonical=false
quo(::Union{AbsNumFieldOrder, AlgAssAbsOrd}, ::Union{AbsNumFieldOrderIdeal, AlgAssAbsOrdIdl})
residue_ring(::AbsSimpleNumFieldOrder, ::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem})
residue_field(::AbsSimpleNumFieldOrder, ::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}, ::Bool)
mod(::AbsSimpleNumFieldOrderElem, ::AbsNumFieldOrderIdeal)
crt(::AbsSimpleNumFieldOrderElem, ::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem}, ::AbsSimpleNumFieldOrderElem, ::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem})
euler_phi(::AbsNumFieldOrderIdeal{AbsSimpleNumField, AbsSimpleNumFieldElem})
Hecke.multiplicative_group(::AbsSimpleNumFieldOrderQuoRing)
Hecke.multiplicative_group_generators(::AbsSimpleNumFieldOrderQuoRing)
```

