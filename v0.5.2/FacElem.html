<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Factored Elements · Hecke</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/><script data-outdated-warner="">function maybeAddWarning () {
    const head = document.getElementsByTagName('head')[0];

    // Add a noindex meta tag (unless one exists) so that search engines don't index this version of the docs.
    if (document.body.querySelector('meta[name="robots"]') === null) {
        const meta = document.createElement('meta');
        meta.name = 'robots';
        meta.content = 'noindex';

        head.appendChild(meta);
    };

    // Add a stylesheet to avoid inline styling
    const style = document.createElement('style');
    style.type = 'text/css';
    style.appendChild(document.createTextNode('.outdated-warning-overlay {  position: fixed;  top: 0;  left: 0;  right: 0;  box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);  z-index: 999;  background-color: #ffaba7;  color: rgba(0, 0, 0, 0.7);  border-bottom: 3px solid #da0b00;  padding: 10px 35px;  text-align: center;  font-size: 15px; }  .outdated-warning-overlay .outdated-warning-closer {    position: absolute;    top: calc(50% - 10px);    right: 18px;    cursor: pointer;    width: 12px; }  .outdated-warning-overlay a {    color: #2e63b8; }    .outdated-warning-overlay a:hover {      color: #363636; }'));
    head.appendChild(style);

    const div = document.createElement('div');
    div.classList.add('outdated-warning-overlay');
    const closer = document.createElement('div');
    closer.classList.add('outdated-warning-closer');

    // Icon by font-awesome (license: https://fontawesome.com/license, link: https://fontawesome.com/icons/times?style=solid)
    closer.innerHTML = '<svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="times" class="svg-inline--fa fa-times fa-w-11" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 352 512"><path fill="currentColor" d="M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z"></path></svg>';
    closer.addEventListener('click', function () {
        document.body.removeChild(div);
    });
    let href = '/stable';
    if (window.documenterBaseURL) {
        href = window.documenterBaseURL + '/../stable';
    }
    div.innerHTML = 'This documentation is not for the latest version. <br> <a href="' + href + '" target="_self">Go to the latest documentation</a>.';
    div.appendChild(closer);
    document.body.appendChild(div);
};

if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', maybeAddWarning);
} else {
    maybeAddWarning();
};
</script>
</head><body><nav class="toc"><h1>Hecke</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Hecke</a></li><li><a class="toctext" href="number_fields/intro.html">Number Fields</a></li><li><span class="toctext">Orders</span><ul><li><a class="toctext" href="orders/introduction.html">Introduction</a></li><li><a class="toctext" href="orders/orders.html">Orders</a></li><li><a class="toctext" href="orders/elements.html">Elements</a></li><li><a class="toctext" href="orders/ideals.html">Ideals</a></li><li><a class="toctext" href="orders/frac_ideals.html">Fractional ideals</a></li></ul></li><li><a class="toctext" href="abelian/introduction.html">Abelian Groups</a></li><li><a class="toctext" href="class_fields/intro.html">Class Field Theory</a></li><li><a class="toctext" href="sparse/intro.html">Sparse linear algebra</a></li><li class="current"><a class="toctext" href="FacElem.html">Factored Elements</a><ul class="internal"><li><a class="toctext" href="#Construction-1">Construction</a></li><li><a class="toctext" href="#Conversion-1">Conversion</a></li><li><a class="toctext" href="#Special-functions-1">Special functions</a></li><li><a class="toctext" href="#Miscellaneous-1">Miscellaneous</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href="FacElem.html">Factored Elements</a></li></ul><a class="edit-page" href="https://github.com/thofma/Hecke.jl/blob/master/docs/src/FacElem.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Factored Elements</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Factored-Elements-1" href="#Factored-Elements-1">Factored Elements</a></h1><p>In many applications in number theory related to the multiplicative structure of number fields, interesting elements, e.g. units, are extremely large when written wrt. to a fxied basis for the field: for the fundamental unit in <span>$Q[\sqrt d]$</span> it is known that the coefficients wrt. the canonical basis <span>$1, \sqrt d$</span> can have <span>$O(\exp \sqrt d)$</span> many digits. All currently known, fast methods construct those elements as power products of smaller elements, allowing the computer to handle them.</p><p>Mathematically, one can think of factored elements to formally live in the ring <span>$Z[K]$</span> the group ring of the non-zero field elements. Thus elements are of the form $ \prod a<em>i^{e</em>i}$ where <span>$a_i$</span> are elements in <span>$K$</span>, typically <em>small</em> and the <span>$e_i\in Z$</span> are frequently  large exponents. We refer to the <span>$a_i$</span> as the <em>base</em> and the <span>$e_i$</span> as the  <em>exponents</em> of the factored element.</p><p>Since <span>$K$</span> is, in general, no PID, this presentation is non-unique, elements in this form can easily be multiplied, raised to large powers, but in general not compared and not added.</p><p>In Hecke, this is caputured more generally by the type <code>FacElem</code>,  parametrized by the type of the elements in the base and the type of their  parent.</p><p>Important special cases are</p><ul><li><code>FacElem{fmpz, FlintIntegerRing}</code>, factored integers</li><li><code>FacElem{nf_elem, AnticNumberField}</code>, factored algerbaic numbers</li><li><code>FacElem{NfAbsOrdIdl, NfAbsOrdIdlSet}</code>, factored ideals</li></ul><p>It should be noted that an object of type `<span>$FacElem{fmpz, FlintIntegerRing}$</span>  will, in general, not represent an integer as the exponents can be negative.</p><h2><a class="nav-anchor" id="Construction-1" href="#Construction-1">Construction</a></h2><p>In general one can define factored elements by giving 2 arrays, the  base and the exponent, or a dictionary containing the pairs:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hecke.FacElem" href="#Hecke.FacElem"><code>Hecke.FacElem</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">FacElem{B}(base::Array{B, 1}, exp::Array{fmpz, 1}) -&gt; FacElem{B}</code></pre><blockquote><p>Returns the element <span>$\prod b_i^{e_i}$</span>, un-expanded.</p></blockquote></div><div><pre><code class="language-none">FacElem{B}(d::Dict{B, fmpz}) -&gt; FacElem{B}
FacElem{B}(d::Dict{B, Integer}) -&gt; FacElem{B}</code></pre><blockquote><p>Returns the element <span>$\prod b^{d[p]}$</span>, un-expanded.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hecke.FacElem-Tuple{nf_elem}" href="#Hecke.FacElem-Tuple{nf_elem}"><code>Hecke.FacElem</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">FacElem{B}(base::Array{B, 1}, exp::Array{fmpz, 1}) -&gt; FacElem{B}</code></pre><blockquote><p>Returns the element <span>$\prod b_i^{e_i}$</span>, un-expanded.</p></blockquote></div><div><pre><code class="language-none">FacElem{B}(d::Dict{B, fmpz}) -&gt; FacElem{B}
FacElem{B}(d::Dict{B, Integer}) -&gt; FacElem{B}</code></pre><blockquote><p>Returns the element <span>$\prod b^{d[p]}$</span>, un-expanded.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hecke.ideal-Tuple{NfAbsOrd{AnticNumberField,nf_elem},FacElem{nf_elem,AnticNumberField}}" href="#Hecke.ideal-Tuple{NfAbsOrd{AnticNumberField,nf_elem},FacElem{nf_elem,AnticNumberField}}"><code>Hecke.ideal</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none"> ideal(O::NfOrd, a::FacElem{nf_elem, AnticNumberField)</code></pre><blockquote><p>The factored fractional ideal <span>$a*O$</span>.</p></blockquote></div></section><h2><a class="nav-anchor" id="Conversion-1" href="#Conversion-1">Conversion</a></h2><p>The process of computing the value defined by a factored element is available as <code>evaluate</code>. Depending on the types involved this can be very efficient.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractAlgebra.Generic.evaluate-Union{Tuple{FacElem{fmpz,S}}, Tuple{S}} where S" href="#AbstractAlgebra.Generic.evaluate-Union{Tuple{FacElem{fmpz,S}}, Tuple{S}} where S"><code>AbstractAlgebra.Generic.evaluate</code></a> — <span class="docstring-category">Method</span>.</div><div><hr/><p>evaluate{T}(x::FacElem{T}) -&gt; T</p><blockquote><p>Expands or evaluates the factored element, i.e. actually computes the value.  Does &quot;square-and-multiply&quot; on the exponent vectors.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractAlgebra.Generic.evaluate-Tuple{FacElem{fmpq,S} where S}" href="#AbstractAlgebra.Generic.evaluate-Tuple{FacElem{fmpq,S} where S}"><code>AbstractAlgebra.Generic.evaluate</code></a> — <span class="docstring-category">Method</span>.</div><div><hr/><pre><code class="language-none">evaluate(x::FacElem{fmpq}) -&gt; fmpq
evaluate(x::FacElem{fmpz}) -&gt; fmpz</code></pre><blockquote><p>Expands or evaluates the factored element, i.e. actually computes the the element.  Works by first obtaining a simplified version of the power product into coprime base elements.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractAlgebra.Generic.evaluate-Union{Tuple{FacElem{T,S} where S}, Tuple{T}} where T" href="#AbstractAlgebra.Generic.evaluate-Union{Tuple{FacElem{T,S} where S}, Tuple{T}} where T"><code>AbstractAlgebra.Generic.evaluate</code></a> — <span class="docstring-category">Method</span>.</div><div><hr/><p>evaluate{T}(x::FacElem{T}) -&gt; T</p><blockquote><p>Expands or evaluates the factored element, i.e. actually computes the value.  Does &quot;square-and-multiply&quot; on the exponent vectors.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hecke.evaluate_naive-Union{Tuple{FacElem{T,S} where S}, Tuple{T}} where T" href="#Hecke.evaluate_naive-Union{Tuple{FacElem{T,S} where S}, Tuple{T}} where T"><code>Hecke.evaluate_naive</code></a> — <span class="docstring-category">Method</span>.</div><div><hr/><p>evaluate_naive{T}(x::FacElem{T}) -&gt; T</p><blockquote><p>Expands or evaluates the factored element, i.e. actually computes the value. Uses the obvious naive algorithm. Faster for input in finite rings.</p></blockquote></div></section><h2><a class="nav-anchor" id="Special-functions-1" href="#Special-functions-1">Special functions</a></h2><p>In the case where the parent of the base allows for efficient gcd computation, power products can be made unique:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hecke.simplify-Tuple{FacElem{NfAbsOrdIdl{AnticNumberField,nf_elem},Hecke.NfAbsOrdIdlSet{AnticNumberField,nf_elem}}}" href="#Hecke.simplify-Tuple{FacElem{NfAbsOrdIdl{AnticNumberField,nf_elem},Hecke.NfAbsOrdIdlSet{AnticNumberField,nf_elem}}}"><code>Hecke.simplify</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">simplify(x::FacElem{NfOrdIdl, NfOrdIdlSet}) -&gt; FacElem
simplify(x::FacElem{NfOrdFracIdl, NfOrdFracIdlSet}) -&gt; FacElem</code></pre><blockquote><p>Uses <code>coprime_base</code> to obtain a simplified version of <span>$x$</span>, ie. in the simplified version all base ideals will be pariwise coprime but not neccessarily prime!.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hecke.simplify-Tuple{FacElem{fmpq,S} where S}" href="#Hecke.simplify-Tuple{FacElem{fmpq,S} where S}"><code>Hecke.simplify</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">simplify(x::FacElem{fmpq}) -&gt; FacElem{fmpq}
simplify(x::FacElem{fmpz}) -&gt; FacElem{fmpz}</code></pre><blockquote><p>Simplfies the factored element, i.e. arranges for the base to be coprime.</p></blockquote></div></section><p>The simplified version can then be used further:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isone-Tuple{FacElem{fmpq,S} where S}" href="#Base.isone-Tuple{FacElem{fmpq,S} where S}"><code>Base.isone</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">isone(x::FacElem{fmpq}) -&gt; Bool
isone(x::FacElem{fmpz}) -&gt; Bool</code></pre><blockquote><p>Tests if <span>$x$</span> represents <span>$1$</span> without an evaluation.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hecke.factor_coprime-Tuple{FacElem{fmpz,S} where S}" href="#Hecke.factor_coprime-Tuple{FacElem{fmpz,S} where S}"><code>Hecke.factor_coprime</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">factor_coprime(x::FacElem{fmpz}) -&gt; Fac{fmpz}</code></pre><blockquote><p>Computed a partial factorisation of <span>$x$</span>, ie. writes <span>$x$</span> as a product of pariwise coprime integers.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hecke.factor_coprime-Tuple{FacElem{NfAbsOrdIdl{AnticNumberField,nf_elem},Hecke.NfAbsOrdIdlSet{AnticNumberField,nf_elem}}}" href="#Hecke.factor_coprime-Tuple{FacElem{NfAbsOrdIdl{AnticNumberField,nf_elem},Hecke.NfAbsOrdIdlSet{AnticNumberField,nf_elem}}}"><code>Hecke.factor_coprime</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">factor_coprime(x::FacElem{NfOrdIdl, NfOrdIdlSet}) -&gt; Dict{NfOrdIdl, Int}</code></pre><blockquote><p>Computed a partial factorisation of <span>$x$</span>, ie. writes <span>$x$</span> as a product of pariwise coprime integral ideals.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hecke.factor_coprime-Tuple{FacElem{Hecke.NfOrdFracIdl,Hecke.NfOrdFracIdlSet}}" href="#Hecke.factor_coprime-Tuple{FacElem{Hecke.NfOrdFracIdl,Hecke.NfOrdFracIdlSet}}"><code>Hecke.factor_coprime</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none"> factor_coprime(Q::FacElem{NfOrdFracIdl, NfOrdFracIdlSet}) -&gt; Dict{NfOrdIdl, Int}</code></pre><blockquote><p>A coprime factorisation of <span>$Q$</span>: each ideal in <span>$Q$</span> is split using \code{integral_split} and then a coprime basis is computed. This does {\bf not} use any factorisation.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hecke.factor_coprime-Tuple{FacElem{nf_elem,AnticNumberField},Hecke.NfAbsOrdIdlSet{AnticNumberField,nf_elem}}" href="#Hecke.factor_coprime-Tuple{FacElem{nf_elem,AnticNumberField},Hecke.NfAbsOrdIdlSet{AnticNumberField,nf_elem}}"><code>Hecke.factor_coprime</code></a> — <span class="docstring-category">Method</span>.</div><div><p>factor<em>coprime(a::FacElem{nf</em>elem, AnticNumberField}, I::NfOrdIdlSet) -&gt; Dict{NfOrdIdl, fmpz}</p><blockquote><p>Factors the rincipal ideal generated by <span>$a$</span> into coprimes by computing a coprime basis from the principal ideals in the factorisation of <span>$a$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hecke.factor-Tuple{FacElem{Hecke.NfOrdFracIdl,Hecke.NfOrdFracIdlSet}}" href="#Hecke.factor-Tuple{FacElem{Hecke.NfOrdFracIdl,Hecke.NfOrdFracIdlSet}}"><code>Hecke.factor</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none"> factor(Q::FacElem{NfOrdFracIdl, NfOrdFracIdlSet}) -&gt; Dict{NfOrdIdl, Int}</code></pre><blockquote><p>The factorisation of <span>$Q$</span>, by refining a coprime factorisation.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hecke.factor-Tuple{FacElem{nf_elem,AnticNumberField},Hecke.NfAbsOrdIdlSet{AnticNumberField,nf_elem}}" href="#Hecke.factor-Tuple{FacElem{nf_elem,AnticNumberField},Hecke.NfAbsOrdIdlSet{AnticNumberField,nf_elem}}"><code>Hecke.factor</code></a> — <span class="docstring-category">Method</span>.</div><div><p>factor(a::FacElem{nf_elem, AnticNumberField}, I::NfOrdIdlSet) -&gt; Dict{NfOrdIdl, fmpz}</p><blockquote><p>Factors the principal ideal generated by <span>$a$</span> by refinind a coprime factorisation.</p></blockquote></div></section><p>For factorised algebraic numbers a unique simplification is not possible, however, this allows still do obtain partial results:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hecke.compact_presentation" href="#Hecke.compact_presentation"><code>Hecke.compact_presentation</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">compact_presentation(a::FacElem{nf_elem, AnticNumberField}, n::Int = 2; decom, arb_prec = 100, short_prec = 1000) -&gt; FacElem</code></pre><blockquote><p>Computes a presentation <span>$a = \prod a_i^{n_i}$</span> where all the exponents <span>$n_i$</span> are powers of <span>$n$</span> and, the elements <span>$a$</span> are &quot;small&quot;, generically, they have a norm bounded by <span>$d^{n/2}$</span> where <span>$d$</span> is the discriminant of the maximal order. As the algorithm needs the factorisation of the principal ideal generated by <span>$a$</span>, it can be passed in in \code{decom}.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hecke.signs-Tuple{Union{FacElem{nf_elem,AnticNumberField}, nf_elem}}" href="#Hecke.signs-Tuple{Union{FacElem{nf_elem,AnticNumberField}, nf_elem}}"><code>Hecke.signs</code></a> — <span class="docstring-category">Method</span>.</div><div><hr/><pre><code class="language-none">signs(a::nf_elem)          -&gt; Dict{InfPlc, Int}
signs(a::FacElem{nf_elem}) -&gt; Dict{InfPlc, Int}</code></pre><blockquote><p>This function returns a dictionary of the signs of <span>$a$</span> at all infinite places of the ambient number field. The keys are infinite places of the ambient number field. The value is <span>$1$</span> if the sign is positive and <span>$-1$</span> if the sign is negative.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hecke.signs-Tuple{Union{FacElem{nf_elem,AnticNumberField}, nf_elem},Array{InfPlc,1}}" href="#Hecke.signs-Tuple{Union{FacElem{nf_elem,AnticNumberField}, nf_elem},Array{InfPlc,1}}"><code>Hecke.signs</code></a> — <span class="docstring-category">Method</span>.</div><div><hr/><pre><code class="language-none">signs(a::nf_elem, l::Vector{InfPlc})          -&gt; Dict{InfPlc, Int}
signs(a::FacElem{nf_elem}, l::Vector{InfPlc}) -&gt; Dict{InfPlc, Int}</code></pre><blockquote><p>This function returns a dictionary of the signs of <span>$a$</span> at places in <span>$l$</span>. The keys are the elements of <span>$l$</span>. The value is <span>$1$</span> if the sign is positive and <span>$-1$</span> if the sign is negative. The result will contain as many signs as there are real places contained in <span>$l$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.sign-Tuple{Union{FacElem{nf_elem,AnticNumberField}, nf_elem},InfPlc}" href="#Base.sign-Tuple{Union{FacElem{nf_elem,AnticNumberField}, nf_elem},InfPlc}"><code>Base.sign</code></a> — <span class="docstring-category">Method</span>.</div><div><hr/><pre><code class="language-none">sign(a::nf_elem, P::InfPlc)          -&gt; Int
sign(a::FacElem{nf_elem}, P::InfPlc) -&gt; Int</code></pre><blockquote><p>This function returns the sign of <span>$a$</span> at the place <span>$P$</span>. The value is <span>$1$</span> if the sign is positive and <span>$-1$</span> if the sign is negative.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nemo.ispositive-Tuple{Union{FacElem{nf_elem,AnticNumberField}, nf_elem},InfPlc}" href="#Nemo.ispositive-Tuple{Union{FacElem{nf_elem,AnticNumberField}, nf_elem},InfPlc}"><code>Nemo.ispositive</code></a> — <span class="docstring-category">Method</span>.</div><div><hr/><pre><code class="language-none">ispositive(a::nf_elem, P::InfPlc)          -&gt; Bool
ispositive(a::FacElem{nf_elem}, P::InfPlc) -&gt; Bool</code></pre><blockquote><p>Returns whether the element <span>$a$</span> is positive at the embedding corresponding to <span>$P$</span>. The place <span>$P$</span> must be real.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nemo.ispositive-Tuple{Union{FacElem{nf_elem,AnticNumberField}, nf_elem},Array{InfPlc,1}}" href="#Nemo.ispositive-Tuple{Union{FacElem{nf_elem,AnticNumberField}, nf_elem},Array{InfPlc,1}}"><code>Nemo.ispositive</code></a> — <span class="docstring-category">Method</span>.</div><div><hr/><pre><code class="language-none">ispositive(a::nf_elem, l::Vector{InfPlc})          -&gt; Bool
ispositive(a::FacElem{nf_elem}, l::Vector{InfPlc}) -&gt; Bool</code></pre><blockquote><p>Returns whether the element <span>$a$</span> is positive at the embeddings corresponding to the real places of <span>$l$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hecke.istotally_positive-Tuple{Union{FacElem{nf_elem,AnticNumberField}, nf_elem}}" href="#Hecke.istotally_positive-Tuple{Union{FacElem{nf_elem,AnticNumberField}, nf_elem}}"><code>Hecke.istotally_positive</code></a> — <span class="docstring-category">Method</span>.</div><div><hr/><pre><code class="language-none">istotally_positive(a::nf_elem)          -&gt; Bool
istotally_positive(a::FacElem{nf_elem}) -&gt; Bool</code></pre><blockquote><p>Returns whether the element <span>$a$</span> is totally positive, that is, whether it is positive at all places of the ambient number field.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractAlgebra.Generic.valuation-Tuple{FacElem{nf_elem,AnticNumberField},NfAbsOrdIdl{AnticNumberField,nf_elem}}" href="#AbstractAlgebra.Generic.valuation-Tuple{FacElem{nf_elem,AnticNumberField},NfAbsOrdIdl{AnticNumberField,nf_elem}}"><code>AbstractAlgebra.Generic.valuation</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">valuation(a::FacElem{nf_elem, AnticNumberField}, P::NfOrdIdl) -&gt; fmpz</code></pre><blockquote><p>The valuation of <span>$a$</span> at <span>$P$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractAlgebra.Generic.valuation-Tuple{FacElem{NfAbsOrdIdl{AnticNumberField,nf_elem},Hecke.NfAbsOrdIdlSet{AnticNumberField,nf_elem}},NfAbsOrdIdl{AnticNumberField,nf_elem}}" href="#AbstractAlgebra.Generic.valuation-Tuple{FacElem{NfAbsOrdIdl{AnticNumberField,nf_elem},Hecke.NfAbsOrdIdlSet{AnticNumberField,nf_elem}},NfAbsOrdIdl{AnticNumberField,nf_elem}}"><code>AbstractAlgebra.Generic.valuation</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">valuation(A::FacElem{NfOrdFracIdl, NfOrdFracIdlSet}, p::NfOrdIdl)
valuation(A::FacElem{NfOrdIdl, NfOrdIdlSet}, p::NfOrdIdl)</code></pre><blockquote><p>The valuation of <span>$A$</span> at <span>$P$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hecke.evaluate_mod-Tuple{FacElem{nf_elem,AnticNumberField},Hecke.NfOrdFracIdl}" href="#Hecke.evaluate_mod-Tuple{FacElem{nf_elem,AnticNumberField},Hecke.NfOrdFracIdl}"><code>Hecke.evaluate_mod</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">evaluate_mod(a::FacElem{nf_elem, AnticNumberField}, B::NfOrdFracIdl) -&gt; nf_elem</code></pre><blockquote><p>Evaluates <span>$a$</span> using CRT and small primes. Assumes that the ideal generated by <span>$a$</span> is in fact <span>$B$</span>. Useful in cases where <span>$a$</span> has huge exponents, but the evaluated element is actually &quot;small&quot;.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hecke.pure_extension-Tuple{Int64,FacElem{nf_elem,AnticNumberField}}" href="#Hecke.pure_extension-Tuple{Int64,FacElem{nf_elem,AnticNumberField}}"><code>Hecke.pure_extension</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">pure_extension(n::Int, gen::FacElem{nf_elem, AnticNumberField}) -&gt; NfRel{nf_elem}, NfRelElem
pure_extension(n::Int, gen::nf_elem) -&gt; NfRel{nf_elem}, NfRelElem</code></pre><blockquote><p>Create the field extension with the defining polynomial <span>$x^n-gen$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hecke.reduce_ideal2-Tuple{FacElem{NfAbsOrdIdl{AnticNumberField,nf_elem},Hecke.NfAbsOrdIdlSet{AnticNumberField,nf_elem}}}" href="#Hecke.reduce_ideal2-Tuple{FacElem{NfAbsOrdIdl{AnticNumberField,nf_elem},Hecke.NfAbsOrdIdlSet{AnticNumberField,nf_elem}}}"><code>Hecke.reduce_ideal2</code></a> — <span class="docstring-category">Method</span>.</div><div><hr/><pre><code class="language-none">reduce_ideal2(A::FacElem{NfOrdIdl}) -&gt; NfOrdIdl, FacElem{nf_elem}</code></pre><blockquote><p>Computes <span>$B$</span> and <span>$\alpha$</span> in factored form, such that <span>$\alpha B = A$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hecke.modular_proj-Tuple{FacElem{nf_elem,AnticNumberField},Hecke.modular_env}" href="#Hecke.modular_proj-Tuple{FacElem{nf_elem,AnticNumberField},Hecke.modular_env}"><code>Hecke.modular_proj</code></a> — <span class="docstring-category">Method</span>.</div><div><hr/><p>modular<em>proj(a::FacElem{nf</em>elem, AnticNumberField}, me::modular<em>env) -&gt; Array{fq</em>nmod, 1}</p><blockquote><p>Given an algebraic number <span>$a$</span> in factored form and data \code{me} as computed by \code{modular_init}, project <span>$a$</span> onto the residue class fields.</p></blockquote></div></section><h2><a class="nav-anchor" id="Miscellaneous-1" href="#Miscellaneous-1">Miscellaneous</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hecke.max_exp-Tuple{FacElem}" href="#Hecke.max_exp-Tuple{FacElem}"><code>Hecke.max_exp</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">max_exp(a::FacElem)</code></pre><blockquote><p>Finds the largest exponent in the factored element <span>$a$</span></p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hecke.min_exp-Tuple{FacElem}" href="#Hecke.min_exp-Tuple{FacElem}"><code>Hecke.min_exp</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">min_exp(a::FacElem)</code></pre><blockquote><p>Finds the smallest exponent in the factored element <span>$a$</span></p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hecke.maxabs_exp-Tuple{FacElem}" href="#Hecke.maxabs_exp-Tuple{FacElem}"><code>Hecke.maxabs_exp</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">maxabs_exp(a::FacElem)</code></pre><blockquote><p>Finds the largest exponent by absolute value the factored element <span>$a$</span></p></blockquote></div></section><footer><hr/><a class="previous" href="sparse/intro.html"><span class="direction">Previous</span><span class="title">Sparse linear algebra</span></a></footer></article></body></html>
