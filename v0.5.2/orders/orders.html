<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Orders · Hecke</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><script data-outdated-warner="">function maybeAddWarning () {
    const head = document.getElementsByTagName('head')[0];

    // Add a noindex meta tag (unless one exists) so that search engines don't index this version of the docs.
    if (document.body.querySelector('meta[name="robots"]') === null) {
        const meta = document.createElement('meta');
        meta.name = 'robots';
        meta.content = 'noindex';

        head.appendChild(meta);
    };

    // Add a stylesheet to avoid inline styling
    const style = document.createElement('style');
    style.type = 'text/css';
    style.appendChild(document.createTextNode('.outdated-warning-overlay {  position: fixed;  top: 0;  left: 0;  right: 0;  box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);  z-index: 999;  background-color: #ffaba7;  color: rgba(0, 0, 0, 0.7);  border-bottom: 3px solid #da0b00;  padding: 10px 35px;  text-align: center;  font-size: 15px; }  .outdated-warning-overlay .outdated-warning-closer {    position: absolute;    top: calc(50% - 10px);    right: 18px;    cursor: pointer;    width: 12px; }  .outdated-warning-overlay a {    color: #2e63b8; }    .outdated-warning-overlay a:hover {      color: #363636; }'));
    head.appendChild(style);

    const div = document.createElement('div');
    div.classList.add('outdated-warning-overlay');
    const closer = document.createElement('div');
    closer.classList.add('outdated-warning-closer');

    // Icon by font-awesome (license: https://fontawesome.com/license, link: https://fontawesome.com/icons/times?style=solid)
    closer.innerHTML = '<svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="times" class="svg-inline--fa fa-times fa-w-11" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 352 512"><path fill="currentColor" d="M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z"></path></svg>';
    closer.addEventListener('click', function () {
        document.body.removeChild(div);
    });
    let href = '/stable';
    if (window.documenterBaseURL) {
        href = window.documenterBaseURL + '/../stable';
    }
    div.innerHTML = 'This documentation is not for the latest version. <br> <a href="' + href + '" target="_self">Go to the latest documentation</a>.';
    div.appendChild(closer);
    document.body.appendChild(div);
};

if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', maybeAddWarning);
} else {
    maybeAddWarning();
};
</script>
</head><body><nav class="toc"><h1>Hecke</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Hecke</a></li><li><a class="toctext" href="../number_fields/intro.html">Number Fields</a></li><li><span class="toctext">Orders</span><ul><li><a class="toctext" href="introduction.html">Introduction</a></li><li class="current"><a class="toctext" href="orders.html">Orders</a><ul class="internal"><li><a class="toctext" href="#Creation-and-basic-properties-1">Creation and basic properties</a></li></ul></li><li><a class="toctext" href="elements.html">Elements</a></li><li><a class="toctext" href="ideals.html">Ideals</a></li><li><a class="toctext" href="frac_ideals.html">Fractional ideals</a></li></ul></li><li><a class="toctext" href="../abelian/introduction.html">Abelian Groups</a></li><li><a class="toctext" href="../class_fields/intro.html">Class Field Theory</a></li><li><a class="toctext" href="../sparse/intro.html">Sparse linear algebra</a></li><li><a class="toctext" href="../FacElem.html">Factored Elements</a></li></ul></nav><article id="docs"><header><nav><ul><li>Orders</li><li><a href="orders.html">Orders</a></li></ul><a class="edit-page" href="https://github.com/thofma/Hecke.jl/blob/master/docs/src/orders/orders.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Orders</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Orders-1" href="#Orders-1">Orders</a></h1><p>Orders, ie. unitary subrings that are free <span>$Z$</span>-modules of rank equal to the degree of the number field, are at the core of the arithmetic of number fields. In Hecke, orders are always represented using the module structure, be it the <span>$Z$</span>-module structure for orders in absolute fields, of the structure as a module over the maximal order of the base field in the case of relative extensions. In this chapter we only deal with orders in absolute fields. There are more general definitions of orders in number fields available, but those are (currently) not implemented in Hecke.</p><p>Among all orders in a fixed field, there is a unique maximal one, called the maximal order, or ring of integers of the field. It is well known that this is the only order that is a Dedekind domain, hence has a rich ideal structure as well. The maximal order is also the integral closure of <span>$Z$</span> in the number field and can also be interpreted as a normalisation of any other order.</p><h2><a class="nav-anchor" id="Creation-and-basic-properties-1" href="#Creation-and-basic-properties-1">Creation and basic properties</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hecke.Order-Tuple{AnticNumberField,Array{nf_elem,1}}" href="#Hecke.Order-Tuple{AnticNumberField,Array{nf_elem,1}}"><code>Hecke.Order</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">Order(B::Array{nf_elem, 1}, check::Bool = true) -&gt; NfOrd</code></pre><p>Returns the order with <span>$\mathbf Z$</span>-basis <span>$B$</span>. If <code>check</code> is set, it is checked whether <span>$B$</span> defines an order.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hecke.Order-Tuple{AnticNumberField,FakeFmpqMat}" href="#Hecke.Order-Tuple{AnticNumberField,FakeFmpqMat}"><code>Hecke.Order</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">Order(K::AnticNumberField, A::FakeFmpqMat, check::Bool = true) -&gt; NfOrd</code></pre><p>Returns the order which has basis matrix <span>$A$</span> with respect to the power basis of <span>$K$</span>. If <code>check</code> is set, it is checked whether <span>$A$</span> defines an order.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hecke.Order-Tuple{Hecke.NfOrdFracIdl}" href="#Hecke.Order-Tuple{Hecke.NfOrdFracIdl}"><code>Hecke.Order</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">Order(K::AnticNumberField, A::fmpz_mat, check::Bool = true) -&gt; NfOrd</code></pre><p>Returns the order which has basis matrix <span>$A$</span> with respect to the power basis of <span>$K$</span>. If <code>check</code> is set, it is checked whether <span>$A$</span> defines an order.</p></div><div><pre><code class="language-none">Order(A::NfOrdFracIdl) -&gt; NfOrd</code></pre><p>Returns the fractional ideal <span>$A$</span> as an order of the ambient number field.</p></div><div><hr/><pre><code class="language-none">  Order(K::RelativeExtension, M::PMat) -&gt; NfRelOrd</code></pre><blockquote><p>Returns the order which has basis pseudo-matrix <span>$M$</span> with respect to the power basis of <span>$K$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hecke.EquationOrder-Tuple{AnticNumberField}" href="#Hecke.EquationOrder-Tuple{AnticNumberField}"><code>Hecke.EquationOrder</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">EquationOrder(K::AnticNumberField) -&gt; NfOrd</code></pre><blockquote><p>Returns the equation order of the number field <span>$K$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hecke.MaximalOrder-Tuple{AnticNumberField}" href="#Hecke.MaximalOrder-Tuple{AnticNumberField}"><code>Hecke.MaximalOrder</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">maximal_order(K::AnticNumberField) -&gt; NfOrd
ring_of_integers(K::AnticNumberField) -&gt; NfOrd</code></pre><blockquote><p>Returns the maximal order of <span>$K$</span>.</p></blockquote><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; Qx, xx = FlintQQ[&quot;x&quot;];
julia&gt; K, a = NumberField(x^3 + 2, &quot;a&quot;);
julia&gt; O = MaximalOrder(K);</code></pre></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hecke.MaximalOrder-Tuple{NfAbsOrd{AnticNumberField,nf_elem}}" href="#Hecke.MaximalOrder-Tuple{NfAbsOrd{AnticNumberField,nf_elem}}"><code>Hecke.MaximalOrder</code></a> — <span class="docstring-category">Method</span>.</div><div><hr/><pre><code class="language-none">maximal_order(O::NfOrd) -&gt; NfOrd
MaximalOrder(O::NfOrd) -&gt; NfOrd</code></pre><p>Returns the maximal overorder of <span>$O$</span>.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hecke.maximal_order-Tuple{AnticNumberField}" href="#Hecke.maximal_order-Tuple{AnticNumberField}"><code>Hecke.maximal_order</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">maximal_order(K::AnticNumberField) -&gt; NfOrd
ring_of_integers(K::AnticNumberField) -&gt; NfOrd</code></pre><blockquote><p>Returns the maximal order of <span>$K$</span>.</p></blockquote><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; Qx, xx = FlintQQ[&quot;x&quot;];
julia&gt; K, a = NumberField(x^3 + 2, &quot;a&quot;);
julia&gt; O = MaximalOrder(K);</code></pre></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nemo.lll-Tuple{NfAbsOrd{AnticNumberField,nf_elem}}" href="#Nemo.lll-Tuple{NfAbsOrd{AnticNumberField,nf_elem}}"><code>Nemo.lll</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">lll(M::NfOrd) -&gt; NfOrd</code></pre><blockquote><p>The same order, but with the basis now being LLL reduced wrt. the Minkowski metric.</p></blockquote></div></section><p>By Chistov&#39;s fundamental theorem, the computation of the maximal order is basically as hard as the factorisation of the discriminant. In order to help the computer, Hecke also provides the following signatures:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hecke.maximal_order-Tuple{AnticNumberField,Array{fmpz,1}}" href="#Hecke.maximal_order-Tuple{AnticNumberField,Array{fmpz,1}}"><code>Hecke.maximal_order</code></a> — <span class="docstring-category">Method</span>.</div><div><hr/><pre><code class="language-none">MaximalOrder(K::AnticNumberField, primes::Array{fmpz, 1}) -&gt; NfOrd
maximal_order(K::AnticNumberField, primes::Array{fmpz, 1}) -&gt; NfOrd
ring_of_integers(K::AnticNumberField, primes::Array{fmpz, 1}) -&gt; NfOrd</code></pre><p>Assuming that <span>$primes$</span> contains all the prime numbers at which the equation order <span>$\mathbf{Z}[\alpha]$</span> of <span>$K = \mathbf{Q}(\alpha)$</span> is not maximal, this function returns the maximal order of <span>$K$</span>.</p></div></section><p>It is also possible the execute the steps individually:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hecke.pradical-Tuple{NfAbsOrd{AnticNumberField,nf_elem},fmpz}" href="#Hecke.pradical-Tuple{NfAbsOrd{AnticNumberField,nf_elem},fmpz}"><code>Hecke.pradical</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">pradical(O::NfOrd, p::{fmpz|Integer}) -&gt; NfAbsOrdIdl</code></pre><blockquote><p>Given a prime number <span>$p$</span>, this function returns the <span>$p$</span>-radical <span>$\sqrt{p\mathcal O}$</span> of <span>$\mathcal O$</span>, which is just <span>$\{ x \in \mathcal O \mid \exists k \in \mathbf Z_{\geq 0} \colon x^k \in p\mathcal O \}$</span>. It is not checked that <span>$p$</span> is prime.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hecke.ring_of_multipliers-Tuple{NfAbsOrdIdl{AnticNumberField,nf_elem}}" href="#Hecke.ring_of_multipliers-Tuple{NfAbsOrdIdl{AnticNumberField,nf_elem}}"><code>Hecke.ring_of_multipliers</code></a> — <span class="docstring-category">Method</span>.</div><div><hr/><pre><code class="language-none">ring_of_multipliers(I::NfAbsOrdIdl) -&gt; NfOrd</code></pre><blockquote><p>Computes the order <span>$(I : I)$</span>, which is the set of all <span>$x \in K$</span> with <span>$xI \subseteq I$</span>.</p></blockquote></div></section><h3><a class="nav-anchor" id="Example-1" href="#Example-1">Example</a></h3><pre><code class="language-julia-repl">
julia&gt; Qx, x = PolynomialRing(FlintQQ, &quot;x&quot;);

julia&gt; K, a = NumberField(x^2 - 2, &quot;a&quot;);

julia&gt; O = EquationOrder(K)
Order of Number field over Rational Field with defining polynomial x^2-2
with Z-basis NfAbsOrdElem{AnticNumberField,nf_elem}[1, a]</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.parent-Tuple{NfAbsOrd{AnticNumberField,nf_elem}}" href="#Base.parent-Tuple{NfAbsOrd{AnticNumberField,nf_elem}}"><code>Base.parent</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">parent(O::NfOrd) -&gt; NfOrdSet</code></pre><p>Returns the parent of <span>$\mathcal O$</span>, that is, the set of orders of the ambient number field.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hecke.isequation_order-Tuple{NfAbsOrd{AnticNumberField,nf_elem}}" href="#Hecke.isequation_order-Tuple{NfAbsOrd{AnticNumberField,nf_elem}}"><code>Hecke.isequation_order</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">isequation_order(O::NfOrd) -&gt; Bool</code></pre><p>Returns whether <span>$\mathcal O$</span> is the equation order of the ambient number field.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nemo.signature-Tuple{NfAbsOrd{AnticNumberField,nf_elem}}" href="#Nemo.signature-Tuple{NfAbsOrd{AnticNumberField,nf_elem}}"><code>Nemo.signature</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">signature(O::NfOrd) -&gt; Tuple{Int, Int}</code></pre><p>Returns the signature of the ambient number field of <span>$\mathcal O$</span>.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hecke.nf-Tuple{NfAbsOrd{AnticNumberField,nf_elem}}" href="#Hecke.nf-Tuple{NfAbsOrd{AnticNumberField,nf_elem}}"><code>Hecke.nf</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">nf(O::NfOrd) -&gt; AnticNumberField</code></pre><p>Returns the ambient number field of <span>$\mathcal O$</span>.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractAlgebra.Generic.degree-Tuple{NfAbsOrd{AnticNumberField,nf_elem}}" href="#AbstractAlgebra.Generic.degree-Tuple{NfAbsOrd{AnticNumberField,nf_elem}}"><code>AbstractAlgebra.Generic.degree</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">degree(O::NfOrd) -&gt; Int</code></pre><p>Returns the degree of <span>$\mathcal O$</span>.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hecke.basis-Tuple{NfAbsOrd{AnticNumberField,nf_elem}}" href="#Hecke.basis-Tuple{NfAbsOrd{AnticNumberField,nf_elem}}"><code>Hecke.basis</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">basis(O::NfOrd) -&gt; Array{NfOrdElem, 1}</code></pre><p>Returns the <span>$\mathbf Z$</span>-basis of <span>$\mathcal O$</span>.</p></div><div><hr/><pre><code class="language-none">basis(A::NfAbsOrdIdl) -&gt; Array{NfOrdElem, 1}</code></pre><blockquote><p>Returns the basis of A.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hecke.basis-Tuple{NfAbsOrd{AnticNumberField,nf_elem},AnticNumberField}" href="#Hecke.basis-Tuple{NfAbsOrd{AnticNumberField,nf_elem},AnticNumberField}"><code>Hecke.basis</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">basis(O::NfOrd, K::AnticNumberField) -&gt; Array{nf_elem, 1}</code></pre><p>Returns the <span>$\mathbf Z$</span>-basis elements of <span>$\mathcal O$</span> as elements of the ambient number field.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hecke.basis_mat-Tuple{NfAbsOrd{AnticNumberField,nf_elem}}" href="#Hecke.basis_mat-Tuple{NfAbsOrd{AnticNumberField,nf_elem}}"><code>Hecke.basis_mat</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">basis_mat(O::NfOrd) -&gt; FakeFmpqMat</code></pre><p>Returns the basis matrix of <span>$\mathcal O$</span> with respect to the power basis of the ambient number field.</p></div><div><hr/><pre><code class="language-none">basis_mat(A::NfAbsOrdIdl) -&gt; fmpz_mat</code></pre><blockquote><p>Returns the basis matrix of <span>$A$</span>.</p></blockquote></div><div><hr/><pre><code class="language-none">  basis_mat(O::NfRelOrd{T, S}) -&gt; Generic.Mat{T}</code></pre><blockquote><p>Returns the basis matrix of <span>$\mathcal O$</span> with respect to the power basis of the ambient number field.</p></blockquote></div><div><hr/><pre><code class="language-none">  basis_mat(a::NfRelOrdIdl{T, S}) -&gt; Generic.Mat{T}
  basis_mat(a::NfRelOrdFracIdl{T, S}) -&gt; Generic.Mat{T}</code></pre><blockquote><p>Returns the basis matrix of <span>$a$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hecke.basis_mat_inv-Tuple{NfAbsOrd{AnticNumberField,nf_elem}}" href="#Hecke.basis_mat_inv-Tuple{NfAbsOrd{AnticNumberField,nf_elem}}"><code>Hecke.basis_mat_inv</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">basis_mat_inv(O::NfOrd) -&gt; FakeFmpqMat</code></pre><p>Returns the inverse of the basis matrix of <span>$\mathcal O$</span>.</p></div><div><hr/><pre><code class="language-none">basis_mat_inv(A::NfAbsOrdIdl) -&gt; fmpz_mat</code></pre><blockquote><p>Returns the inverse basis matrix of <span>$A$</span>.</p></blockquote></div><div><hr/><pre><code class="language-none">  basis_mat_inv(O::NfRelOrd{T, S}) -&gt; Generic.Mat{T}</code></pre><blockquote><p>Returns the inverse of the basis matrix of <span>$\mathcal O$</span>.</p></blockquote></div><div><hr/><pre><code class="language-none">  basis_mat_inv(a::NfRelOrdIdl{T, S}) -&gt; Generic.Mat{T}
  basis_mat_inv(a::NfRelOrdFracIdl{T, S}) -&gt; Generic.Mat{T}</code></pre><blockquote><p>Returns the inverse of the basis matrix of <span>$a$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractAlgebra.Generic.discriminant-Tuple{NfAbsOrd{AnticNumberField,nf_elem}}" href="#AbstractAlgebra.Generic.discriminant-Tuple{NfAbsOrd{AnticNumberField,nf_elem}}"><code>AbstractAlgebra.Generic.discriminant</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">discriminant(O::NfOrd) -&gt; fmpz</code></pre><p>Returns the discriminant of <span>$\mathcal O$</span>.</p></div><div><hr/><pre><code class="language-none">discriminant(B::Array{NfAbsOrdElem, 1}) -&gt; fmpz</code></pre><blockquote><p>Returns the discriminant of the family <span>$B$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hecke.gen_index-Tuple{NfAbsOrd{AnticNumberField,nf_elem}}" href="#Hecke.gen_index-Tuple{NfAbsOrd{AnticNumberField,nf_elem}}"><code>Hecke.gen_index</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">gen_index(O::NfOrd) -&gt; fmpq</code></pre><p>Returns the generalized index of <span>$\mathcal O$</span> with respect to the equation order of the ambient number field.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hecke.index-Tuple{NfAbsOrd{AnticNumberField,nf_elem}}" href="#Hecke.index-Tuple{NfAbsOrd{AnticNumberField,nf_elem}}"><code>Hecke.index</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">index(O::NfOrd) -&gt; fmpz</code></pre><p>Assuming that the order <span>$\mathcal O$</span> contains the equation order <span>$\mathbf Z[\alpha]$</span> of the ambient number field, this function returns the index <span>$[ \mathcal O : \mathbf Z]$</span>.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hecke.isindex_divisor-Tuple{NfAbsOrd{AnticNumberField,nf_elem},fmpz}" href="#Hecke.isindex_divisor-Tuple{NfAbsOrd{AnticNumberField,nf_elem},fmpz}"><code>Hecke.isindex_divisor</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">isindex_divisor(O::NfOrd, d::fmpz) -&gt; Bool
isindex_divisor(O::NfOrd, d::Int) -&gt; Bool</code></pre><p>Returns whether <span>$d$</span> is a divisor of the index of <span>$\mathcal O$</span>. It is assumed that <span>$\mathcal O$</span> contains the equation order of the ambient number field.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hecke.minkowski_mat-Tuple{NfAbsOrd{AnticNumberField,nf_elem},Int64}" href="#Hecke.minkowski_mat-Tuple{NfAbsOrd{AnticNumberField,nf_elem},Int64}"><code>Hecke.minkowski_mat</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">minkowski_mat(O::NfOrd, abs_tol::Int = 64) -&gt; arb_mat</code></pre><p>Returns the Minkowski matrix of <span>$\mathcal O$</span>.  Thus if <span>$\mathcal O$</span> has degree <span>$d$</span>, then the result is a matrix in <span>$\operatorname{Mat}_{d\times d}(\mathbf R)$</span>. The entries of the matrix are real balls of type <code>arb</code> with radius less then <code>2^-abs_tol</code>.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.in-Tuple{nf_elem,NfAbsOrd{AnticNumberField,nf_elem}}" href="#Base.in-Tuple{nf_elem,NfAbsOrd{AnticNumberField,nf_elem}}"><code>Base.in</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">in(a::nf_elem, O::NfOrd) -&gt; Bool</code></pre><p>Checks whether <span>$a$</span> lies in <span>$\mathcal O$</span>.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.denominator-Tuple{nf_elem,NfAbsOrd{AnticNumberField,nf_elem}}" href="#Base.denominator-Tuple{nf_elem,NfAbsOrd{AnticNumberField,nf_elem}}"><code>Base.denominator</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">denominator(a::nf_elem, O::NfOrd) -&gt; fmpz</code></pre><p>Returns the smallest positive integer <span>$k$</span> such that <span>$k \cdot a$</span> is contained in <span>$\mathcal O$</span>.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hecke.norm_change_const-Tuple{NfAbsOrd{AnticNumberField,nf_elem}}" href="#Hecke.norm_change_const-Tuple{NfAbsOrd{AnticNumberField,nf_elem}}"><code>Hecke.norm_change_const</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">norm_change_const(O::NfOrd) -&gt; (Float64, Float64)</code></pre><p>Returns <span>$(c_1, c_2) \in \mathbf R_{&gt;0}^2$</span> such that for all <span>$x = \sum_{i=1}^d x_i \omega_i \in \mathcal O$</span> we have <span>$T_2(x) \leq c_1 \cdot \sum_i^d x_i^2$</span> and <span>$\sum_i^d x_i^2 \leq c_2 \cdot T_2(x)$</span>, where <span>$(\omega_i)_i$</span> is the <span>$\mathbf Z$</span>-basis of <span>$\mathcal O$</span>.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hecke.trace_matrix-Tuple{NfAbsOrd{AnticNumberField,nf_elem}}" href="#Hecke.trace_matrix-Tuple{NfAbsOrd{AnticNumberField,nf_elem}}"><code>Hecke.trace_matrix</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">trace_matrix(O::NfOrd) -&gt; fmpz_mat</code></pre><p>Returns the trace matrix of <code>\mathcal O</code>, that is, the matrix <span>$(\operatorname{tr}_{K/\mathbf Q}(b_i \cdot b_j))_{1 \leq i, j \leq d}$</span>.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:+-Tuple{NfAbsOrd{AnticNumberField,nf_elem},NfAbsOrd{AnticNumberField,nf_elem}}" href="#Base.:+-Tuple{NfAbsOrd{AnticNumberField,nf_elem},NfAbsOrd{AnticNumberField,nf_elem}}"><code>Base.:+</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">+(R::NfOrd, S::NfOrd) -&gt; NfOrd</code></pre><p>Given two orders <span>$R$</span>, <span>$S$</span> of <span>$K$</span>, this function returns the smallest order containing both <span>$R$</span> and <span>$S$</span>. It is assumed that <span>$R$</span>, <span>$S$</span> contain the ambient equation order and have coprime index.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hecke.poverorder-Tuple{NfAbsOrd{AnticNumberField,nf_elem},fmpz}" href="#Hecke.poverorder-Tuple{NfAbsOrd{AnticNumberField,nf_elem},fmpz}"><code>Hecke.poverorder</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">poverorder(O::NfOrd, p::fmpz) -&gt; NfOrd
poverorder(O::NfOrd, p::Integer) -&gt; NfOrd</code></pre><p>This function tries to find an order that is locally larger than <span>$\mathcal O$</span> at the prime <span>$p$</span>: If <span>$p$</span> divides the index <span>$[ \mathcal O_K : \mathcal O]$</span>, this function will return an order <span>$R$</span> such that <span>$v_p([ \mathcal O_K : R]) &lt; v_p([ \mathcal O_K : \mathcal O])$</span>. Otherwise <span>$\mathcal O$</span> is returned.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hecke.pmaximal_overorder-Tuple{NfAbsOrd{AnticNumberField,nf_elem},fmpz}" href="#Hecke.pmaximal_overorder-Tuple{NfAbsOrd{AnticNumberField,nf_elem},fmpz}"><code>Hecke.pmaximal_overorder</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">pmaximal_overorder(O::NfOrd, p::fmpz) -&gt; NfOrd
pmaximal_overorder(O::NfOrd, p::Integer) -&gt; NfOrd</code></pre><p>This function finds a <span>$p$</span>-maximal order <span>$R$</span> containing <span>$\mathcal O$</span>. That is, the index <span>$[ \mathcal O_K : R]$</span> is not dividible by <span>$p$</span>.</p></div></section><footer><hr/><a class="previous" href="introduction.html"><span class="direction">Previous</span><span class="title">Introduction</span></a><a class="next" href="elements.html"><span class="direction">Next</span><span class="title">Elements</span></a></footer></article></body></html>
