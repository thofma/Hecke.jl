{
    "docs": [
        {
            "location": "/", 
            "text": "Hecke\n\n\nBuilds\n\n\n \n\n\n\n\nAbout\n\n\nHecke is a software package for algebraic number theory maintained by Claus Fieker and Tommy Hofmann. It is written in \njulia\n and is based on the computer algebra package \nNemo\n.\n\n\n\n\nhttps://github.com/thofma/Hecke.jl\n (Source code)\n\n\nhttp://thofma.github.io/Hecke.jl/latest/\n (Online documentation)\n\n\n\n\nSo far, Hecke provides the following features:\n\n\n\n\nOrders (including element and ideal arithmetic) in number fields\n\n\nComputation of maximal orders\n\n\nVerified residue computations of Dedekind zeta functions\n\n\nFactor base creation and relations search in number fields\n\n\nLattice enumeration\n\n\nSparse linear algebra\n\n\n\n\n\n\nInstallation\n\n\nTo use Hecke, a julia version of 0.6 or higher is necessary (the latest stable julia version will do). Please see \nhttp://julialang.org/downloads\n for instructions on how to obtain julia for your system. Once a suitable julia version is installed, use the following steps at the julia prompt to install Hecke:\n\n\njulia\n \nPkg\n.\nadd\n(\nHecke\n)\n\n\n\n\n\n\n\n\nQuick start\n\n\nHere is a quick example of using Hecke:\n\n\njulia\n \nusing\n \nHecke\n\n\n...\n\n\n\nWelcome\n \nto\n \n\n  \n_\n    \n_\n           \n_\n        \n \n|\n \n|\n  \n|\n \n|\n         \n|\n \n|\n       \n \n|\n \n|\n__\n|\n \n|\n \n___\n  \n___\n|\n \n|\n \n_____\n \n \n|\n  \n__\n  \n|/\n \n_\n \n\\/\n \n__\n|\n \n|/\n \n/\n \n_\n \n\\\n\n \n|\n \n|\n  \n|\n \n|\n  \n__\n/\n \n(\n__\n|\n   \n  \n__\n/\n\n \n|\n_\n|\n  \n|\n_\n|\\\n___\n|\\\n___\n|\n_\n|\\\n_\n\\\n___\n|\n\n\n\nVersion\n \n0.3\n.\n0\n \n...\n \n \n...\n \nwhich\n \ncomes\n \nwith\n \nabsolutely\n \nno\n \nwarrant\n \nwhatsoever\n\n\n(\nc\n)\n \n2015\n \nby\n \nClaus\n \nFieker\n \nand\n \nTommy\n \nHofmann\n\n\n\njulia\n \nQx\n,\n \nx\n \n=\n \nPolynomialRing\n(\nFlintQQ\n,\n \nx\n);\n\n\njulia\n \nf\n \n=\n \nx\n^\n3\n \n+\n \n2\n;\n\n\njulia\n \nK\n,\n \na\n \n=\n \nNumberField\n(\nf\n,\n \na\n);\n\n\njulia\n \nO\n \n=\n \nmaximal_order\n(\nK\n);\n\n\njulia\n \nO\n\n\nMaximal\n \norder\n \nof\n \nNumber\n \nfield\n \nover\n \nRational\n \nField\n \nwith\n \ndefining\n \npolynomial\n \nx\n^\n3\n \n+\n \n2\n \n\nwith\n \nbasis\n \n[\n1\n,\na\n,\na\n^\n2\n]\n\n\n\n\n\n\n\n\nDocumentation\n\n\nThe online documentation can be found here: \nhttp://thofma.github.io/Hecke.jl/latest/\n\n\nThe documentation of the single functions can also be accessed at the julia prompt. Here is an example:\n\n\nhelp?\n signature\nsearch: signature\n\n  ----------------------------------------------------------------------------\n\n  signature(O::NfMaximalOrder) -\n Tuple{Int, Int}\n\n  |  Returns the signature of the ambient number field of \\mathcal O.", 
            "title": "Home"
        }, 
        {
            "location": "/#hecke", 
            "text": "Builds", 
            "title": "Hecke"
        }, 
        {
            "location": "/#about", 
            "text": "Hecke is a software package for algebraic number theory maintained by Claus Fieker and Tommy Hofmann. It is written in  julia  and is based on the computer algebra package  Nemo .   https://github.com/thofma/Hecke.jl  (Source code)  http://thofma.github.io/Hecke.jl/latest/  (Online documentation)   So far, Hecke provides the following features:   Orders (including element and ideal arithmetic) in number fields  Computation of maximal orders  Verified residue computations of Dedekind zeta functions  Factor base creation and relations search in number fields  Lattice enumeration  Sparse linear algebra", 
            "title": "About"
        }, 
        {
            "location": "/#installation", 
            "text": "To use Hecke, a julia version of 0.6 or higher is necessary (the latest stable julia version will do). Please see  http://julialang.org/downloads  for instructions on how to obtain julia for your system. Once a suitable julia version is installed, use the following steps at the julia prompt to install Hecke:  julia   Pkg . add ( Hecke )", 
            "title": "Installation"
        }, 
        {
            "location": "/#quick-start", 
            "text": "Here is a quick example of using Hecke:  julia   using   Hecke  ...  Welcome   to  \n\n   _      _             _         \n  |   |    |   |           |   |        \n  |   | __ |   |   ___    ___ |   |   _____  \n  |    __    |/   _   \\/   __ |   |/   /   _   \\ \n  |   |    |   |    __ /   ( __ |        __ / \n  | _ |    | _ |\\ ___ |\\ ___ | _ |\\ _ \\ ___ |  Version   0.3 . 0   ...  \n  ...   which   comes   with   absolutely   no   warrant   whatsoever  ( c )   2015   by   Claus   Fieker   and   Tommy   Hofmann  julia   Qx ,   x   =   PolynomialRing ( FlintQQ ,   x );  julia   f   =   x ^ 3   +   2 ;  julia   K ,   a   =   NumberField ( f ,   a );  julia   O   =   maximal_order ( K );  julia   O  Maximal   order   of   Number   field   over   Rational   Field   with   defining   polynomial   x ^ 3   +   2   with   basis   [ 1 , a , a ^ 2 ]", 
            "title": "Quick start"
        }, 
        {
            "location": "/#documentation", 
            "text": "The online documentation can be found here:  http://thofma.github.io/Hecke.jl/latest/  The documentation of the single functions can also be accessed at the julia prompt. Here is an example:  help?  signature\nsearch: signature\n\n  ----------------------------------------------------------------------------\n\n  signature(O::NfMaximalOrder) -  Tuple{Int, Int}\n\n  |  Returns the signature of the ambient number field of \\mathcal O.", 
            "title": "Documentation"
        }, 
        {
            "location": "/toc/", 
            "text": "Table of contents\n\n\nbla", 
            "title": "Table of contents"
        }, 
        {
            "location": "/toc/#table-of-contents", 
            "text": "bla", 
            "title": "Table of contents"
        }, 
        {
            "location": "/orders/introduction/", 
            "text": "Introduction\n\n\nThis chapter deals with absolute number fields and orders there of. \n\n\n\n\nDefinitions and vocabulary\n\n\nWe begin by collecting the necessary definitions and vocabulary.  This is in particular important for everything related to embeddings of number fields into archimdean fields, since they are at least two (slighlty) different normalizations. \n\n\n\n\nNumber fields\n\n\nBy an absolute number field we mean finite extensions of \n\\mathbf Q\n, which is of type \nAnticNumberField\n and whose elements are of type \nnf_elem\n. Such an absolute number field \nK\n is always given in the form \nK = \\mathbf Q(\\alpha) = \\mathbf Q[X]/(f)\n, where \nf \\in \\mathbf Q[X]\n is an irreducible polynomial.  We call \n(1,\\alpha,\\alpha^2,\\dotsc,\\alpha^{d-1})\n, where \nd\n is the degree \n[K : \\mathbf Q]\n the \npower basis\n of \nK\n. If \n\\beta\n is any element of \nK\n, then the \nrepresentation matrix\n of \n\\beta\n is the matrix representing \nK \\to K, \\gamma \\mapsto \\beta \\gamma\n with respect to the power basis, that is,\n\n\n\n\n \\beta \\cdot (1,\\alpha,\\dotsc,\\alpha^{d-1}) = M_\\alpha (1, \\alpha, \\dotsc, \\alpha^{d-1}). \n\n\n\n\nLet \n(r,s)\n be the signature of \nK\n, that is, \nK\n has \nr\n real embeddings \n\\sigma_i \\colon K \\to \\mathbf{R}\n, \n1 \\leq i \\leq r\n, and \n2s\n complex embeddings \n\\sigma_i \\colon K \\to \\mathbf{C}\n, \n1 \\leq i \\leq 2s\n. In Hecke the complex embeddings are always ordered such that \n\\sigma_i = \\overline{\\sigma_{i+s}}\n for \nr + 1 \\leq i \\leq r + s\n. The \n\\mathbf{Q}\n-linear function \n K \\longrightarrow \\mathbf R^{d}, \\ \\alpha \\longmapsto (\\sigma_1(\\alpha),\\dotsc,\\sigma_r(\\alpha),\\sqrt{2}\\operatorname{Re}(\\sigma_{r+1}(\\alpha)),\\sqrt{2}\\operatorname{Im}(\\sigma_{r+1}(\\alpha)),\\dotsc,\\sqrt{2}\\operatorname{Re}(\\sigma_{r+s}(\\alpha)),\\sqrt{2}\\operatorname{Im}(\\sigma_{r+s}(\\alpha)) \n is called the \nMinkowski map\n (or \nMinkowski embedding\n).\n\n\n\n\nOrders\n\n\nIf \nK = \\mathbf Q(\\alpha)\n is an absolute number field, then an \norder\n \n\\mathcal O\n of \nK\n is a subring of the ring of integers \n\\mathcal O_K\n, which is free of rank \n[ K : \\mathbf Q]\n as a \n\\mathbf Z\n-module. The natural order \n\\mathbf Z[\\alpha]\n is called the \nequation order\n of \nK\n. In Hecke orders of absolute number fields are constructed (implicitely) by specifying a \n\\mathbf Z\n-basis, which is refered to as the \nbasis\n of \n\\mathcal O\n. If \n(\\omega_1,\\dotsc,\\omega_d)\n is the basis of \n\\mathcal O\n, then the matrix \nB \\in \\operatorname{Mat}_{d \\times d}(\\mathbf Q)\n with\n\n\n\n\n \\begin{pmatrix} \\omega_1 \\\\ \\vdots \\\\ \\omega_d \\end{pmatrix} = B \\begin{pmatrix} 1 \\\\ \\vdots \\\\ \\alpha^{d - 1} \\end{pmatrix} \n\n\n\n\nis called the \nbasis matrix\n of \n\\mathcal O\n. We call \n\\det(B)\n the \ngeneralized index\n of \n\\mathcal O\n.  In case \n\\mathbf Z[\\alpha] \\subseteq \\mathcal O\n, the determinant \n\\det(B)^{-1}\n is in fact equal to \n[ \\mathcal O : \\mathbf Z[\\alpha]]\n and is called the \nindex\n of \n\\mathcal O\n. The matrix \n \\begin{pmatrix}  \\sigma_1(\\omega_1) & \\dotsc & \\sigma_r(\\omega_1) & \\sqrt{2}\\operatorname{Re}(\\sigma_{r+1}(\\omega_1)) & \\sqrt{2}\\operatorname{Im}(\\sigma_{r+1}(\\omega_1)) & \\dotsc & \\sqrt{2}\\operatorname{Im}(\\sigma_{r+s}(\\omega_1)) \\\\\n\\sigma_1(\\omega_2) & \\dotsc & \\sigma_r(\\omega_2) & \\sqrt{2}\\operatorname{Re}(\\sigma_{r+1}(\\omega_2)) & \\sqrt{2}\\operatorname{Im}(\\sigma_{r+1}(\\omega_2)) & \\dotsc  & \\sqrt{2}\\operatorname{Im}(\\sigma_{r+s}(\\omega_2)) \\\\\n\\vdots & \\dotsc & \\vdots & \\vdots & \\dotsc & \\vdots & \\vdots\\\\\n\\sigma_1(\\omega_d) & \\dotsc & \\sigma_r(\\omega_d) & \\sqrt{2}\\operatorname{Re}(\\sigma_{r+1}(\\omega_d)) & \\sqrt{2}\\operatorname{Im}(\\sigma_{r+2}(\\omega_d)) & \\dotsc & \\sqrt{2}\\operatorname{Im}(\\sigma_{r+s}(\\omega_d)) \\end{pmatrix} \\in \\operatorname{Mat}_{d\\times d}(\\mathbf R). \n is called the \nMinkowski matrix\n of \n\\mathcal O\n.\n\n\n\n\nIdeals\n\n\n\n\nFractional ideals\n\n\n\n\nTypes", 
            "title": "Introduction"
        }, 
        {
            "location": "/orders/introduction/#introduction", 
            "text": "This chapter deals with absolute number fields and orders there of.", 
            "title": "Introduction"
        }, 
        {
            "location": "/orders/introduction/#definitions-and-vocabulary", 
            "text": "We begin by collecting the necessary definitions and vocabulary.  This is in particular important for everything related to embeddings of number fields into archimdean fields, since they are at least two (slighlty) different normalizations.", 
            "title": "Definitions and vocabulary"
        }, 
        {
            "location": "/orders/introduction/#number-fields", 
            "text": "By an absolute number field we mean finite extensions of  \\mathbf Q , which is of type  AnticNumberField  and whose elements are of type  nf_elem . Such an absolute number field  K  is always given in the form  K = \\mathbf Q(\\alpha) = \\mathbf Q[X]/(f) , where  f \\in \\mathbf Q[X]  is an irreducible polynomial.  We call  (1,\\alpha,\\alpha^2,\\dotsc,\\alpha^{d-1}) , where  d  is the degree  [K : \\mathbf Q]  the  power basis  of  K . If  \\beta  is any element of  K , then the  representation matrix  of  \\beta  is the matrix representing  K \\to K, \\gamma \\mapsto \\beta \\gamma  with respect to the power basis, that is,    \\beta \\cdot (1,\\alpha,\\dotsc,\\alpha^{d-1}) = M_\\alpha (1, \\alpha, \\dotsc, \\alpha^{d-1}).    Let  (r,s)  be the signature of  K , that is,  K  has  r  real embeddings  \\sigma_i \\colon K \\to \\mathbf{R} ,  1 \\leq i \\leq r , and  2s  complex embeddings  \\sigma_i \\colon K \\to \\mathbf{C} ,  1 \\leq i \\leq 2s . In Hecke the complex embeddings are always ordered such that  \\sigma_i = \\overline{\\sigma_{i+s}}  for  r + 1 \\leq i \\leq r + s . The  \\mathbf{Q} -linear function   K \\longrightarrow \\mathbf R^{d}, \\ \\alpha \\longmapsto (\\sigma_1(\\alpha),\\dotsc,\\sigma_r(\\alpha),\\sqrt{2}\\operatorname{Re}(\\sigma_{r+1}(\\alpha)),\\sqrt{2}\\operatorname{Im}(\\sigma_{r+1}(\\alpha)),\\dotsc,\\sqrt{2}\\operatorname{Re}(\\sigma_{r+s}(\\alpha)),\\sqrt{2}\\operatorname{Im}(\\sigma_{r+s}(\\alpha))   is called the  Minkowski map  (or  Minkowski embedding ).", 
            "title": "Number fields"
        }, 
        {
            "location": "/orders/introduction/#orders", 
            "text": "If  K = \\mathbf Q(\\alpha)  is an absolute number field, then an  order   \\mathcal O  of  K  is a subring of the ring of integers  \\mathcal O_K , which is free of rank  [ K : \\mathbf Q]  as a  \\mathbf Z -module. The natural order  \\mathbf Z[\\alpha]  is called the  equation order  of  K . In Hecke orders of absolute number fields are constructed (implicitely) by specifying a  \\mathbf Z -basis, which is refered to as the  basis  of  \\mathcal O . If  (\\omega_1,\\dotsc,\\omega_d)  is the basis of  \\mathcal O , then the matrix  B \\in \\operatorname{Mat}_{d \\times d}(\\mathbf Q)  with    \\begin{pmatrix} \\omega_1 \\\\ \\vdots \\\\ \\omega_d \\end{pmatrix} = B \\begin{pmatrix} 1 \\\\ \\vdots \\\\ \\alpha^{d - 1} \\end{pmatrix}    is called the  basis matrix  of  \\mathcal O . We call  \\det(B)  the  generalized index  of  \\mathcal O .  In case  \\mathbf Z[\\alpha] \\subseteq \\mathcal O , the determinant  \\det(B)^{-1}  is in fact equal to  [ \\mathcal O : \\mathbf Z[\\alpha]]  and is called the  index  of  \\mathcal O . The matrix   \\begin{pmatrix}  \\sigma_1(\\omega_1) & \\dotsc & \\sigma_r(\\omega_1) & \\sqrt{2}\\operatorname{Re}(\\sigma_{r+1}(\\omega_1)) & \\sqrt{2}\\operatorname{Im}(\\sigma_{r+1}(\\omega_1)) & \\dotsc & \\sqrt{2}\\operatorname{Im}(\\sigma_{r+s}(\\omega_1)) \\\\\n\\sigma_1(\\omega_2) & \\dotsc & \\sigma_r(\\omega_2) & \\sqrt{2}\\operatorname{Re}(\\sigma_{r+1}(\\omega_2)) & \\sqrt{2}\\operatorname{Im}(\\sigma_{r+1}(\\omega_2)) & \\dotsc  & \\sqrt{2}\\operatorname{Im}(\\sigma_{r+s}(\\omega_2)) \\\\\n\\vdots & \\dotsc & \\vdots & \\vdots & \\dotsc & \\vdots & \\vdots\\\\\n\\sigma_1(\\omega_d) & \\dotsc & \\sigma_r(\\omega_d) & \\sqrt{2}\\operatorname{Re}(\\sigma_{r+1}(\\omega_d)) & \\sqrt{2}\\operatorname{Im}(\\sigma_{r+2}(\\omega_d)) & \\dotsc & \\sqrt{2}\\operatorname{Im}(\\sigma_{r+s}(\\omega_d)) \\end{pmatrix} \\in \\operatorname{Mat}_{d\\times d}(\\mathbf R).   is called the  Minkowski matrix  of  \\mathcal O .", 
            "title": "Orders"
        }, 
        {
            "location": "/orders/introduction/#ideals", 
            "text": "", 
            "title": "Ideals"
        }, 
        {
            "location": "/orders/introduction/#fractional-ideals", 
            "text": "", 
            "title": "Fractional ideals"
        }, 
        {
            "location": "/orders/introduction/#types", 
            "text": "", 
            "title": "Types"
        }, 
        {
            "location": "/orders/basics/", 
            "text": "Creation\n\n\nOrder(B::Array{nf_elem, 1}, check::Bool = true) -\n NfOrd\n\n\n\n\n\nReturns the order with \n\\mathbf Z\n-basis \nB\n. If \ncheck\n is set, it is checked whether \nB\n defines an order.\n\n\nOrder(K::AnticNumberField, A::FakeFmpqMat, check::Bool = true) -\n NfOrd\n\n\n\n\n\nReturns the order which has basis matrix \nA\n with respect to the power basis of \nK\n. If \ncheck\n is set, it is checked whether \nA\n defines an order.\n\n\nOrder(A::NfOrdFracIdl) -\n NfOrd\n\n\n\n\n\nReturns the fractional ideal \nA\n as an order of the ambient number field.\n\n\n\n\n  Order(K::RelativeExtension, M::PMat) -\n NfRelOrd\n\n\n\n\n\n\n\nReturns the order which has basis pseudo-matrix \nM\n with respect to the power basis of \nK\n.\n\n\n\n\nEquationOrder(K::AnticNumberField) -\n NfOrd\n\n\n\n\n\nReturns the equation order of the number field \nK\n.\n\n\n\n\nMaximalOrder(K::AnticNumberField) -\n NfOrd\n\n\n\n\n\nReturns the maximal order of \nK\n. \nExample\n\n\njulia\n Qx, x = FlintQQ[\nx\n]\njulia\n K, a = NumberField(x^3 + 2, \na\n)\njulia\n O = MaximalOrder(K)\n\n\n\n\n\n\n\nMaximalOrder(K::NfOrd) -\n NfOrd\n\n\n\n\n\nReturns the maximal order of \nK\n.\n\n\n\n\nExample\n\n\njulia\n \nQx\n,\n \nx\n \n=\n \nPolynomialRing\n(\nFlintQQ\n,\n \nx\n);\n\n\n\njulia\n \nK\n,\n \na\n \n=\n \nNumberField\n(\nx\n^\n2\n \n-\n \n2\n,\n \na\n);\n\n\n\njulia\n \nO\n \n=\n \nEquationOrder\n(\nK\n)\n\n\nOrder\n \nof\n \nNumber\n \nfield\n \nover\n \nRational\n \nField\n \nwith\n \ndefining\n \npolynomial\n \nx\n^\n2\n-\n2\n\n\nwith\n \nZ\n-\nbasis\n \nHecke\n.\nNfOrdElem\n[\n1\n,\n \na\n]\n\n\n\n\n\n\n\n\nBasic properties\n\n\nparent(O::NfOrd) -\n NfOrdSet\n\n\n\n\n\nReturns the parent of \n\\mathcal O\n, that is, the set of orders of the ambient number field.\n\n\nisequation_order(O::NfOrd) -\n Bool\n\n\n\n\n\nReturns whether \n\\mathcal O\n is the equation order of the ambient number field.\n\n\nsignature(O::NfOrd) -\n Tuple{Int, Int}\n\n\n\n\n\nReturns the signature of the ambient number field of \n\\mathcal O\n.\n\n\nnf(O::NfOrd) -\n AnticNumberField\n\n\n\n\n\nReturns the ambient number field of \n\\mathcal O\n.\n\n\ndegree(O::NfOrd) -\n Int\n\n\n\n\n\nReturns the degree of \n\\mathcal O\n.\n\n\nbasis(O::NfOrd) -\n Array{NfOrdElem, 1}\n\n\n\n\n\nReturns the \n\\mathbf Z\n-basis of \n\\mathcal O\n.\n\n\n\n\nbasis(A::NfOrdIdl) -\n Array{NfOrdElem, 1}\n\n\n\n\n\n\n\nReturns the basis of A.\n\n\n\n\nbasis(O::NfOrd, K::AnticNumberField) -\n Array{nf_elem, 1}\n\n\n\n\n\nReturns the \n\\mathbf Z\n-basis elements of \n\\mathcal O\n as elements of the ambient number field.\n\n\nbasis_mat(O::NfOrd) -\n FakeFmpqMat\n\n\n\n\n\nReturns the basis matrix of \n\\mathcal O\n with respect to the power basis of the ambient number field.\n\n\n\n\nbasis_mat(A::NfOrdIdl) -\n fmpz_mat\n\n\n\n\nReturns the basis matrix of \nA\n.\n\n\n\n\n\n\n  basis_mat(O::NfRelOrd{T, S}) -\n Generic.Mat{T}\n\n\n\n\n\n\n\nReturns the basis matrix of \n\\mathcal O\n with respect to the power basis of the ambient number field.\n\n\n\n\n\n\n  basis_mat(a::NfRelOrdIdl{T, S}) -\n Generic.Mat{T}\n\n\n\n\n\n\n\nReturns the basis matrix of \na\n.\n\n\n\n\nbasis_mat_inv(O::NfOrd) -\n FakeFmpqMat\n\n\n\n\n\nReturns the inverse of the basis matrix of \n\\mathcal O\n.\n\n\n\n\nbasis_mat_inv(A::NfOrdIdl) -\n fmpz_mat\n\n\n\n\nReturns the inverse basis matrix of \nA\n.\n\n\n\n\n\n\n  basis_mat_inv(O::NfRelOrd{T, S}) -\n Generic.Mat{T}\n\n\n\n\n\n\n\nReturns the inverse of the basis matrix of \n\\mathcal O\n.\n\n\n\n\n\n\n  basis_mat_inv(a::NfRelOrdIdl{T, S}) -\n Generic.Mat{T}\n\n\n\n\n\n\n\nReturns the inverse of the basis matrix of \na\n.\n\n\n\n\ndiscriminant(O::NfOrd) -\n fmpz\n\n\n\n\n\nReturns the discriminant of \n\\mathcal O\n.\n\n\ngen_index(O::NfOrd) -\n fmpq\n\n\n\n\n\nReturns the generalized index of \n\\mathcal O\n with respect to the equation order of the ambient number field.\n\n\nindex(O::NfOrd) -\n fmpz\n\n\n\n\n\nAssuming that the order \n\\mathcal O\n contains the equation order \n\\mathbf Z[\\alpha]\n of the ambient number field, this function returns the index \n[ \\mathcal O : \\mathbf Z]\n.\n\n\nisindex_divisor(O::NfOrd, d::fmpz) -\n Bool\nisindex_divisor(O::NfOrd, d::Int) -\n Bool\n\n\n\n\n\nReturns whether \nd\n is a divisor of the index of \n\\mathcal O\n. It is assumed that \n\\mathcal O\n contains the equation order of the ambient number field.\n\n\nminkowski_mat(O::NfOrd, abs_tol::Int = 64) -\n arb_mat\n\n\n\n\n\nReturns the Minkowski matrix of \n\\mathcal O\n.  Thus if \n\\mathcal O\n has degree \nd\n, then the result is a matrix in \n\\operatorname{Mat}_{d\\times d}(\\mathbf R)\n. The entries of the matrix are real balls of type \narb\n with radius less then \n2^-abs_tol\n.\n\n\nin(a::nf_elem, O::NfOrd) -\n Bool\n\n\n\n\n\nChecks whether \na\n lies in \n\\mathcal O\n.\n\n\ndenominator(a::nf_elem, O::NfOrd) -\n fmpz\n\n\n\n\n\nReturns the smallest positive integer \nk\n such that \nk \\cdot a\n is contained in \n\\mathcal O\n.\n\n\nnorm_change_const(O::NfOrd) -\n (Float64, Float64)\n\n\n\n\n\nReturns \n(c_1, c_2) \\in \\mathbf R_{>0}^2\n such that for all \nx = \\sum_{i=1}^d x_i \\omega_i \\in \\mathcal O\n we have \nT_2(x) \\leq c_1 \\cdot \\sum_i^d x_i^2\n and \n\\sum_i^d x_i^2 \\leq c_2 \\cdot T_2(x)\n, where \n(\\omega_i)_i\n is the \n\\mathbf Z\n-basis of \n\\mathcal O\n.\n\n\ntrace_matrix(O::NfOrd) -\n fmpz_mat\n\n\n\n\n\nReturns the trace matrix of \n\\mathcal O\n, that is, the matrix \n(\\operatorname{tr}_{K/\\mathbf Q}(b_i \\cdot b_j))_{1 \\leq i, j \\leq d}\n.\n\n\n+(R::NfOrd, S::NfOrd) -\n NfOrd\n\n\n\n\n\nGiven two orders \nR\n, \nS\n of \nK\n, this function returns the smallest order containing both \nR\n and \nS\n. It is assumed that \nR\n, \nS\n contain the ambient equation order and have coprime index.\n\n\npoverorder(O::NfOrd, p::fmpz) -\n NfOrd\npoverorder(O::NfOrd, p::Integer) -\n NfOrd\n\n\n\n\n\nThis function tries to find an order that is locally larger than \n\\mathcal O\n at the prime \np\n: If \np\n divides the index \n[ \\mathcal O_K : \\mathcal O]\n, this function will return an order \nR\n such that \nv_p([ \\mathcal O_K : R]) < v_p([ \\mathcal O_K : \\mathcal O])\n. Otherwise \n\\mathcal O\n is returned.\n\n\npmaximal_overorder(O::NfOrd, p::fmpz) -\n NfOrd\npmaximal_overorder(O::NfOrd, p::Integer) -\n NfOrd\n\n\n\n\n\nThis function finds a \np\n-maximal order \nR\n containing \n\\mathcal O\n. That is, the index \n[ \\mathcal O_K : R]\n is not dividible by \np\n.\n\n\n\n\nElements\n\n\n\n\nCreation\n\n\n(O::NfOrd)(::nf_elem)\n\n\n\n\n\n\n\nBasic properties\n\n\n\n\nparent(a::NfOrdElem) -\n NfOrd\n\n\n\n\n\nReturns the order of which \na\n is an element.\n\n\n\n\nelem_in_nf(a::NfOrdElem) -\n nf_elem\n\n\n\n\n\n\n\nReturns the element \na\n considered as an element of the ambient number field.\n\n\n\n\n\n\nelem_in_basis(a::NfOrdElem) -\n Array{fmpz, 1}\n\n\n\n\n\n\n\nReturns the coefficient vector of \na\n.\n\n\n\n\n\n\n  elem_in_basis(a::NfRelOrdElem{T}) -\n Vector{T}\n\n\n\n\n\n\n\nReturns the coefficient vector of \na\n.\n\n\n\n\n\n\ndiscriminant(B::Array{NfOrdElem, 1}) -\n fmpz\n\n\n\n\n\n\n\nReturns the discriminant of the family \nB\n.\n\n\n\n\n\n\n==(x::NfOrdElem, y::NfOrdElem) -\n Bool\n\n\n\n\n\n\n\nReturns whether \nx\n and \ny\n are equal.\n\n\n\n\n\n\nzero(O::NfOrd) -\n NfOrdElem\n\n\n\n\n\n\n\nReturns the zero element of \n\\mathcal O\n.\n\n\n\n\n\n\none(O::NfOrd) -\n NfOrdElem\n\n\n\n\n\n\n\nReturns the one element of \n\\mathcal O\n.\n\n\n\n\n\n\niszero(a::NfOrd) -\n Bool\n\n\n\n\n\n\n\nTests if \na\n is zero.\n\n\n\n\n\n\nisone(a::NfOrd) -\n Bool\n\n\n\n\n\n\n\nTests if \na\n is one.\n\n\n\n\n\n\nArithmetic\n\n\n\n\n-(x::NfOrdElem) -\n NfOrdElem\n\n\n\n\n\n\n\nReturns the additive inverse of \nx\n.\n\n\n\n\n\n\n+(x::NfOrdElem, y::NfOrdElem) -\n NfOrdElem\n\n\n\n\n\n\n\nReturns \nx + y\n.\n\n\n\n\n\n\n-(x::NfOrdElem, y::NfOrdElem) -\n NfOrdElem\n\n\n\n\n\n\n\nReturns \nx - y\n.\n\n\n\n\n\n\n*(x::NfOrdElem, y::NfOrdElem) -\n NfOrdElem\n\n\n\n\n\n\n\nReturns \nx \\cdot y\n.\n\n\n\n\n\n\n^(x::NfOrdElem, y::Union{fmpz, Int})\n\n\n\n\n\n\n\nReturns \nx^y\n.\n\n\n\n\n\n\nmod(a::NfOrdElem, m::Union{fmpz, Int}) -\n NfOrdElem\n\n\n\n\n\n\n\nReduces the coefficient vector of \na\n modulo \nm\n and returns the corresponding element. The coefficient vector of the result will have entries \nx\n with \n0 \\leq x \\leq m\n.\n\n\n\n\n\n\npowermod(a::NfOrdElem, i::fmpz, m::Integer) -\n NfOrdElem\n\n\n\n\n\n\n\nReturns the element \na^i\n modulo \nm\n.\n\n\n\n\n\n\nMiscallenous\n\n\n\n\nrepresentation_mat(a::NfOrdElem) -\n fmpz_mat\n\n\n\n\n\n\n\nReturns the representation matrix of the element \na\n.\n\n\n\n\n\n\nrepresentation_mat(a::NfOrdElem, K::AnticNumberField) -\n FakeFmpqMat\n\n\n\n\n\n\n\nReturns the representation matrix of the element \na\n considered as an element of the ambient number field \nK\n. It is assumed that \nK\n is the ambient number field of the order of \na\n.\n\n\n\n\n\n\ntrace(a::NfOrdElem) -\n fmpz\n\n\n\n\n\n\n\nReturns the trace of \na\n.\n\n\n\n\n\n\nnorm(a::NfOrdElem) -\n fmpz\n\n\n\n\n\n\n\nReturns the norm of \na\n.\n\n\n\n\n\n\nrand(O::NfOrd, n::Union{Integer, fmpz}) -\n NfOrdElem\n\n\n\n\n\n\n\nComputes a coefficient vector with entries uniformly distributed in \n\\{-n,\\dotsc,-1,0,1,\\dotsc,n\\}\n and returns the corresponding element of the order \n\\mathcal O\n.\n\n\n\n\n\n\nminkowski_map(a::NfOrdElem, abs_tol::Int) -\n Array{arb, 1}\n\n\n\n\n\n\n\nReturns the image of \na\n under the Minkowski embedding. Every entry of the array returned is of type \narb\n with radius less then \n2^-abs_tol\n.\n\n\n\n\n\n\nconjugates_arb(x::NfOrdElem, abs_tol::Int) -\n Array{acb, 1}\n\n\n\n\n\n\n\nCompute the the conjugates of \nx\n as elements of type \nacb\n. Recall that we order the complex conjugates \n\\sigma_{r+1}(x),...,\\sigma_{r+2s}(x)\n such that \n\\sigma_{i}(x) = \\overline{\\sigma_{i + s}(x)}\n for \nr + 2 \\leq i \\leq r + s\n.\n\n\nEvery entry \ny\n of the array returned satisfies \nradius(real(y)) \n 2^-abs_tol\n, \nradius(imag(y)) \n 2^-abs_tol\n respectively.\n\n\n\n\n\n\nconjugates_arb_log(x::NfOrdElem, abs_tol::Int) -\n Array{arb, 1}\n\n\n\n\n\n\n\nReturns the elements \n(\\log(\\lvert \\sigma_1(x) \\rvert),\\dotsc,\\log(\\lvert\\sigma_r(x) \\rvert), \\dotsc,2\\log(\\lvert \\sigma_{r+1}(x) \\rvert),\\dotsc, 2\\log(\\lvert \\sigma_{r+s}(x)\\rvert))\n as elements of type \narb\n radius less then \n2^-abs_tol\n.\n\n\n\n\n\n\nt2(x::NfOrdElem, abs_tol::Int = 32) -\n arb\n\n\n\n\n\n\n\nReturn the \nT_2\n-norm of \nx\n. The radius of the result will be less than \n2^-abs_tol\n.\n\n\n\n\n\n\nIdeals\n\n\n\n\nCreation\n\n\n\n\nideal(O::NfOrd, a::Int) -\n NfOrdIdl\n\n\n\n\n\n\n\nReturns the ideal of \n\\mathcal O\n which is generated by \na\n.\n\n\n\n\n\n\nideal(O::NfOrd, a::fmpz) -\n NfOrdIdl\n\n\n\n\n\n\n\nReturns the ideal of \n\\mathcal O\n which is generated by \na\n.\n\n\n\n\n\n\nideal(O::NfOrd, x::fmpz_mat, check::Bool = false) -\n NfOrdIdl\n\n\n\n\n\n\n\nCreates the ideal of \n\\mathcal O\n with basis matrix \nx\n. If check is set, then it is checked whether \nx\n defines an ideal (expensive).\n\n\n\n\n\n\nideal(O::NfOrd, x::NfOrdElem) -\n NfOrdIdl\n\n\n\n\n\n\n\nCreates the principal ideal \n(x)\n of \n\\mathcal O\n.\n\n\n\n\n\n\nring_of_multipliers(I::NfOrdIdl) -\n NfOrd\n\n\n\n\n\n\n\nComputes the order \n(I : I)\n, which is the set of all \nx \\in K\n with \nxI \\subseteq I\n.\n\n\n\n\n*(O::NfOrd, x::NfOrdElem) -\n NfOrdIdl\n*(x::NfOrdElem, O::NfOrd) -\n NfOrdIdl\n\n\n\n\n\n\n\nReturns the principal ideal \n(x)\n of \n\\mathcal O\n.\n\n\n\n\n\n\nArithmetic\n\n\n\n\n==(x::NfOrdIdl, y::NfOrdIdl)\n\n\n\n\n\n\n\nReturns whether \nx\n and \ny\n are equal.\n\n\n\n\n\n\n+(x::NfOrdIdl, y::NfOrdIdl)\n\n\n\n\n\n\n\nReturns \nx + y\n.\n\n\n\n\n*(x::NfOrdIdl, y::NfOrdIdl)\n\n\n\n\n\n\n\nReturns \nx \\cdot y\n.\n\n\n\n\nintersection(x::NfOrdIdl, y::NfOrdIdl) -\n NfOrdIdl\nlcm(x::NfOrdIdl, y::NfOrdIdl) -\n NfOrdIdl\n\n\n\n\n\n\n\nReturns \nx \\cap y\n.\n\n\n\n\n\n\nMiscaellenous\n\n\n\n\nparent(I::NfOrdIdl) -\n NfOrd\n\n\n\n\n\n\n\nReturns the order of \nI\n.\n\n\n\n\nbasis(O::NfOrd) -\n Array{NfOrdElem, 1}\n\n\n\n\n\nReturns the \n\\mathbf Z\n-basis of \n\\mathcal O\n.\n\n\n\n\nbasis(A::NfOrdIdl) -\n Array{NfOrdElem, 1}\n\n\n\n\n\n\n\nReturns the basis of A.\n\n\n\n\nbasis_mat(O::NfOrd) -\n FakeFmpqMat\n\n\n\n\n\nReturns the basis matrix of \n\\mathcal O\n with respect to the power basis of the ambient number field.\n\n\n\n\nbasis_mat(A::NfOrdIdl) -\n fmpz_mat\n\n\n\n\nReturns the basis matrix of \nA\n.\n\n\n\n\n\n\n  basis_mat(O::NfRelOrd{T, S}) -\n Generic.Mat{T}\n\n\n\n\n\n\n\nReturns the basis matrix of \n\\mathcal O\n with respect to the power basis of the ambient number field.\n\n\n\n\n\n\n  basis_mat(a::NfRelOrdIdl{T, S}) -\n Generic.Mat{T}\n\n\n\n\n\n\n\nReturns the basis matrix of \na\n.\n\n\n\n\nbasis_mat_inv(O::NfOrd) -\n FakeFmpqMat\n\n\n\n\n\nReturns the inverse of the basis matrix of \n\\mathcal O\n.\n\n\n\n\nbasis_mat_inv(A::NfOrdIdl) -\n fmpz_mat\n\n\n\n\nReturns the inverse basis matrix of \nA\n.\n\n\n\n\n\n\n  basis_mat_inv(O::NfRelOrd{T, S}) -\n Generic.Mat{T}\n\n\n\n\n\n\n\nReturns the inverse of the basis matrix of \n\\mathcal O\n.\n\n\n\n\n\n\n  basis_mat_inv(a::NfRelOrdIdl{T, S}) -\n Generic.Mat{T}\n\n\n\n\n\n\n\nReturns the inverse of the basis matrix of \na\n.\n\n\n\n\n\n\nminimum(A::NfOrdIdl) -\n fmpz\n\n\n\n\n\n\n\nReturns the smallest nonnegative element in \nA \\cap \\mathbf Z\n.\n\n\n\n\n\n\nnorm(A::NfOrdIdl) -\n fmpz\n\n\n\n\n\n\n\nReturns the norm of \nA\n, that is, the cardinality of \n\\mathcal O/A\n, where \n\\mathcal O\n is the order of \nA\n.\n\n\n\n\n\n\nnorm(a::NfRelOrdIdl) -\n NfOrdIdl\n\n\n\n\n\n\n\nReturns the norm of \na\n.\n\n\n\n\n\n\nnorm(a::NfRelOrdFracIdl{T, S}) -\n S\n\n\n\n\n\n\n\nReturns the norm of \na\n\n\n\n\n\n\n\n\nin(x::NfOrdElem, y::NfOrdIdl)\nin(x::nf_elem, y::NfOrdIdl)\nin(x::fmpz, y::NfOrdIdl)\n\n\n\n\n\n\n\nReturns whether \nx\n is contained in \ny\n.\n\n\n\n\nidempotents(x::NfOrdIdl, y::NfOrdIdl) -\n NfOrdElem, NfOrdElem\n\n\n\n\n\n\n\nReturns a tuple \n(e, f)\n consisting of elements \ne in x\n, \nf in y\n such that \n1 = e + f\n.\n\n\nIf the ideals are not coprime, an error is raised.\n\n\n\n\n\n\nmod(x::NfOrdElem, I::NfOrdIdl)\n\n\n\n\n\n\n\nReturns the unique element \ny\n of the ambient order of \nx\n with \nx \\equiv y \\bmod I\n and the following property: If \na_1,\\dotsc,a_d \\in \\Z_{\\geq 1}\n are the diagonal entries of the unique HNF basis matrix of \nI\n and \n(b_1,\\dotsc,b_d)\n is the coefficient vector of \ny\n, then \n0 \\leq b_i < a_i\n for \n1 \\leq i \\leq d\n.\n\n\n\n\n\n\npradical(O::NfOrd, p::fmpz) -\n NfOrdIdl\n\n\n\n\n\n\n\nGiven a prime number \np\n, this function returns the \np\n-radical \n\\sqrt{p\\mathcal O}\n of \n\\mathcal O\n, which is just \n\\{ x \\in \\mathcal O \\mid \\exists k \\in \\mathbf Z_{\\geq 0} \\colon x^k \\in p\\mathcal O \\}\n. It is not checked that \np\n is prime.\n\n\n\n\n\n\nFractional ideals\n\n\n\n\nCreation\n\n\nfrac_ideal(::NfOrd, ::fmpz_mat)\nfrac_ideal(::NfOrd, ::fmpz_mat, ::fmpz)\nfrac_ideal(::NfOrd, ::FakeFmpqMat)\nfrac_ideal(::NfOrd, ::NfOrdIdl)\nfrac_ideal(::NfOrd, ::NfOrdIdl, ::fmpz)\nfrac_ideal(::NfOrd, ::nf_elem)\nfrac_ideal(::NfOrd, ::NfOrdElem)\n\n\n\n\n\n\n\nArithmetic\n\n\n\n\n==(x::NfOrdFracIdl, y::NfOrdFracIdl) -\n Bool\n\n\n\n\n\n\n\nReturns whether \nx\n and \ny\n are equal.\n\n\n\n\n\n\nMiscaellenous\n\n\norder(::NfOrdFracIdl)\nbasis_mat(::NfOrdFracIdl)\nbasis_mat_inv(::NfOrdFracIdl)\nbasis(::NfOrdFracIdl)\nnorm(::NfOrdFracIdl)", 
            "title": "Basics"
        }, 
        {
            "location": "/orders/basics/#creation", 
            "text": "Order(B::Array{nf_elem, 1}, check::Bool = true) -  NfOrd  Returns the order with  \\mathbf Z -basis  B . If  check  is set, it is checked whether  B  defines an order.  Order(K::AnticNumberField, A::FakeFmpqMat, check::Bool = true) -  NfOrd  Returns the order which has basis matrix  A  with respect to the power basis of  K . If  check  is set, it is checked whether  A  defines an order.  Order(A::NfOrdFracIdl) -  NfOrd  Returns the fractional ideal  A  as an order of the ambient number field.     Order(K::RelativeExtension, M::PMat) -  NfRelOrd   Returns the order which has basis pseudo-matrix  M  with respect to the power basis of  K .   EquationOrder(K::AnticNumberField) -  NfOrd  Returns the equation order of the number field  K .   MaximalOrder(K::AnticNumberField) -  NfOrd  Returns the maximal order of  K .  Example  julia  Qx, x = FlintQQ[ x ]\njulia  K, a = NumberField(x^3 + 2,  a )\njulia  O = MaximalOrder(K)   MaximalOrder(K::NfOrd) -  NfOrd  Returns the maximal order of  K .", 
            "title": "Creation"
        }, 
        {
            "location": "/orders/basics/#example", 
            "text": "julia   Qx ,   x   =   PolynomialRing ( FlintQQ ,   x );  julia   K ,   a   =   NumberField ( x ^ 2   -   2 ,   a );  julia   O   =   EquationOrder ( K )  Order   of   Number   field   over   Rational   Field   with   defining   polynomial   x ^ 2 - 2  with   Z - basis   Hecke . NfOrdElem [ 1 ,   a ]", 
            "title": "Example"
        }, 
        {
            "location": "/orders/basics/#basic-properties", 
            "text": "parent(O::NfOrd) -  NfOrdSet  Returns the parent of  \\mathcal O , that is, the set of orders of the ambient number field.  isequation_order(O::NfOrd) -  Bool  Returns whether  \\mathcal O  is the equation order of the ambient number field.  signature(O::NfOrd) -  Tuple{Int, Int}  Returns the signature of the ambient number field of  \\mathcal O .  nf(O::NfOrd) -  AnticNumberField  Returns the ambient number field of  \\mathcal O .  degree(O::NfOrd) -  Int  Returns the degree of  \\mathcal O .  basis(O::NfOrd) -  Array{NfOrdElem, 1}  Returns the  \\mathbf Z -basis of  \\mathcal O .   basis(A::NfOrdIdl) -  Array{NfOrdElem, 1}   Returns the basis of A.   basis(O::NfOrd, K::AnticNumberField) -  Array{nf_elem, 1}  Returns the  \\mathbf Z -basis elements of  \\mathcal O  as elements of the ambient number field.  basis_mat(O::NfOrd) -  FakeFmpqMat  Returns the basis matrix of  \\mathcal O  with respect to the power basis of the ambient number field.   basis_mat(A::NfOrdIdl) -  fmpz_mat   Returns the basis matrix of  A .      basis_mat(O::NfRelOrd{T, S}) -  Generic.Mat{T}   Returns the basis matrix of  \\mathcal O  with respect to the power basis of the ambient number field.      basis_mat(a::NfRelOrdIdl{T, S}) -  Generic.Mat{T}   Returns the basis matrix of  a .   basis_mat_inv(O::NfOrd) -  FakeFmpqMat  Returns the inverse of the basis matrix of  \\mathcal O .   basis_mat_inv(A::NfOrdIdl) -  fmpz_mat   Returns the inverse basis matrix of  A .      basis_mat_inv(O::NfRelOrd{T, S}) -  Generic.Mat{T}   Returns the inverse of the basis matrix of  \\mathcal O .      basis_mat_inv(a::NfRelOrdIdl{T, S}) -  Generic.Mat{T}   Returns the inverse of the basis matrix of  a .   discriminant(O::NfOrd) -  fmpz  Returns the discriminant of  \\mathcal O .  gen_index(O::NfOrd) -  fmpq  Returns the generalized index of  \\mathcal O  with respect to the equation order of the ambient number field.  index(O::NfOrd) -  fmpz  Assuming that the order  \\mathcal O  contains the equation order  \\mathbf Z[\\alpha]  of the ambient number field, this function returns the index  [ \\mathcal O : \\mathbf Z] .  isindex_divisor(O::NfOrd, d::fmpz) -  Bool\nisindex_divisor(O::NfOrd, d::Int) -  Bool  Returns whether  d  is a divisor of the index of  \\mathcal O . It is assumed that  \\mathcal O  contains the equation order of the ambient number field.  minkowski_mat(O::NfOrd, abs_tol::Int = 64) -  arb_mat  Returns the Minkowski matrix of  \\mathcal O .  Thus if  \\mathcal O  has degree  d , then the result is a matrix in  \\operatorname{Mat}_{d\\times d}(\\mathbf R) . The entries of the matrix are real balls of type  arb  with radius less then  2^-abs_tol .  in(a::nf_elem, O::NfOrd) -  Bool  Checks whether  a  lies in  \\mathcal O .  denominator(a::nf_elem, O::NfOrd) -  fmpz  Returns the smallest positive integer  k  such that  k \\cdot a  is contained in  \\mathcal O .  norm_change_const(O::NfOrd) -  (Float64, Float64)  Returns  (c_1, c_2) \\in \\mathbf R_{>0}^2  such that for all  x = \\sum_{i=1}^d x_i \\omega_i \\in \\mathcal O  we have  T_2(x) \\leq c_1 \\cdot \\sum_i^d x_i^2  and  \\sum_i^d x_i^2 \\leq c_2 \\cdot T_2(x) , where  (\\omega_i)_i  is the  \\mathbf Z -basis of  \\mathcal O .  trace_matrix(O::NfOrd) -  fmpz_mat  Returns the trace matrix of  \\mathcal O , that is, the matrix  (\\operatorname{tr}_{K/\\mathbf Q}(b_i \\cdot b_j))_{1 \\leq i, j \\leq d} .  +(R::NfOrd, S::NfOrd) -  NfOrd  Given two orders  R ,  S  of  K , this function returns the smallest order containing both  R  and  S . It is assumed that  R ,  S  contain the ambient equation order and have coprime index.  poverorder(O::NfOrd, p::fmpz) -  NfOrd\npoverorder(O::NfOrd, p::Integer) -  NfOrd  This function tries to find an order that is locally larger than  \\mathcal O  at the prime  p : If  p  divides the index  [ \\mathcal O_K : \\mathcal O] , this function will return an order  R  such that  v_p([ \\mathcal O_K : R]) < v_p([ \\mathcal O_K : \\mathcal O]) . Otherwise  \\mathcal O  is returned.  pmaximal_overorder(O::NfOrd, p::fmpz) -  NfOrd\npmaximal_overorder(O::NfOrd, p::Integer) -  NfOrd  This function finds a  p -maximal order  R  containing  \\mathcal O . That is, the index  [ \\mathcal O_K : R]  is not dividible by  p .", 
            "title": "Basic properties"
        }, 
        {
            "location": "/orders/basics/#elements", 
            "text": "", 
            "title": "Elements"
        }, 
        {
            "location": "/orders/basics/#creation_1", 
            "text": "(O::NfOrd)(::nf_elem)", 
            "title": "Creation"
        }, 
        {
            "location": "/orders/basics/#basic-properties_1", 
            "text": "parent(a::NfOrdElem) -  NfOrd  Returns the order of which  a  is an element.   elem_in_nf(a::NfOrdElem) -  nf_elem   Returns the element  a  considered as an element of the ambient number field.    elem_in_basis(a::NfOrdElem) -  Array{fmpz, 1}   Returns the coefficient vector of  a .      elem_in_basis(a::NfRelOrdElem{T}) -  Vector{T}   Returns the coefficient vector of  a .    discriminant(B::Array{NfOrdElem, 1}) -  fmpz   Returns the discriminant of the family  B .    ==(x::NfOrdElem, y::NfOrdElem) -  Bool   Returns whether  x  and  y  are equal.    zero(O::NfOrd) -  NfOrdElem   Returns the zero element of  \\mathcal O .    one(O::NfOrd) -  NfOrdElem   Returns the one element of  \\mathcal O .    iszero(a::NfOrd) -  Bool   Tests if  a  is zero.    isone(a::NfOrd) -  Bool   Tests if  a  is one.", 
            "title": "Basic properties"
        }, 
        {
            "location": "/orders/basics/#arithmetic", 
            "text": "-(x::NfOrdElem) -  NfOrdElem   Returns the additive inverse of  x .    +(x::NfOrdElem, y::NfOrdElem) -  NfOrdElem   Returns  x + y .    -(x::NfOrdElem, y::NfOrdElem) -  NfOrdElem   Returns  x - y .    *(x::NfOrdElem, y::NfOrdElem) -  NfOrdElem   Returns  x \\cdot y .    ^(x::NfOrdElem, y::Union{fmpz, Int})   Returns  x^y .    mod(a::NfOrdElem, m::Union{fmpz, Int}) -  NfOrdElem   Reduces the coefficient vector of  a  modulo  m  and returns the corresponding element. The coefficient vector of the result will have entries  x  with  0 \\leq x \\leq m .    powermod(a::NfOrdElem, i::fmpz, m::Integer) -  NfOrdElem   Returns the element  a^i  modulo  m .", 
            "title": "Arithmetic"
        }, 
        {
            "location": "/orders/basics/#miscallenous", 
            "text": "representation_mat(a::NfOrdElem) -  fmpz_mat   Returns the representation matrix of the element  a .    representation_mat(a::NfOrdElem, K::AnticNumberField) -  FakeFmpqMat   Returns the representation matrix of the element  a  considered as an element of the ambient number field  K . It is assumed that  K  is the ambient number field of the order of  a .    trace(a::NfOrdElem) -  fmpz   Returns the trace of  a .    norm(a::NfOrdElem) -  fmpz   Returns the norm of  a .    rand(O::NfOrd, n::Union{Integer, fmpz}) -  NfOrdElem   Computes a coefficient vector with entries uniformly distributed in  \\{-n,\\dotsc,-1,0,1,\\dotsc,n\\}  and returns the corresponding element of the order  \\mathcal O .    minkowski_map(a::NfOrdElem, abs_tol::Int) -  Array{arb, 1}   Returns the image of  a  under the Minkowski embedding. Every entry of the array returned is of type  arb  with radius less then  2^-abs_tol .    conjugates_arb(x::NfOrdElem, abs_tol::Int) -  Array{acb, 1}   Compute the the conjugates of  x  as elements of type  acb . Recall that we order the complex conjugates  \\sigma_{r+1}(x),...,\\sigma_{r+2s}(x)  such that  \\sigma_{i}(x) = \\overline{\\sigma_{i + s}(x)}  for  r + 2 \\leq i \\leq r + s .  Every entry  y  of the array returned satisfies  radius(real(y))   2^-abs_tol ,  radius(imag(y))   2^-abs_tol  respectively.    conjugates_arb_log(x::NfOrdElem, abs_tol::Int) -  Array{arb, 1}   Returns the elements  (\\log(\\lvert \\sigma_1(x) \\rvert),\\dotsc,\\log(\\lvert\\sigma_r(x) \\rvert), \\dotsc,2\\log(\\lvert \\sigma_{r+1}(x) \\rvert),\\dotsc, 2\\log(\\lvert \\sigma_{r+s}(x)\\rvert))  as elements of type  arb  radius less then  2^-abs_tol .    t2(x::NfOrdElem, abs_tol::Int = 32) -  arb   Return the  T_2 -norm of  x . The radius of the result will be less than  2^-abs_tol .", 
            "title": "Miscallenous"
        }, 
        {
            "location": "/orders/basics/#ideals", 
            "text": "", 
            "title": "Ideals"
        }, 
        {
            "location": "/orders/basics/#creation_2", 
            "text": "ideal(O::NfOrd, a::Int) -  NfOrdIdl   Returns the ideal of  \\mathcal O  which is generated by  a .    ideal(O::NfOrd, a::fmpz) -  NfOrdIdl   Returns the ideal of  \\mathcal O  which is generated by  a .    ideal(O::NfOrd, x::fmpz_mat, check::Bool = false) -  NfOrdIdl   Creates the ideal of  \\mathcal O  with basis matrix  x . If check is set, then it is checked whether  x  defines an ideal (expensive).    ideal(O::NfOrd, x::NfOrdElem) -  NfOrdIdl   Creates the principal ideal  (x)  of  \\mathcal O .    ring_of_multipliers(I::NfOrdIdl) -  NfOrd   Computes the order  (I : I) , which is the set of all  x \\in K  with  xI \\subseteq I .   *(O::NfOrd, x::NfOrdElem) -  NfOrdIdl\n*(x::NfOrdElem, O::NfOrd) -  NfOrdIdl   Returns the principal ideal  (x)  of  \\mathcal O .", 
            "title": "Creation"
        }, 
        {
            "location": "/orders/basics/#arithmetic_1", 
            "text": "==(x::NfOrdIdl, y::NfOrdIdl)   Returns whether  x  and  y  are equal.    +(x::NfOrdIdl, y::NfOrdIdl)   Returns  x + y .   *(x::NfOrdIdl, y::NfOrdIdl)   Returns  x \\cdot y .   intersection(x::NfOrdIdl, y::NfOrdIdl) -  NfOrdIdl\nlcm(x::NfOrdIdl, y::NfOrdIdl) -  NfOrdIdl   Returns  x \\cap y .", 
            "title": "Arithmetic"
        }, 
        {
            "location": "/orders/basics/#miscaellenous", 
            "text": "parent(I::NfOrdIdl) -  NfOrd   Returns the order of  I .   basis(O::NfOrd) -  Array{NfOrdElem, 1}  Returns the  \\mathbf Z -basis of  \\mathcal O .   basis(A::NfOrdIdl) -  Array{NfOrdElem, 1}   Returns the basis of A.   basis_mat(O::NfOrd) -  FakeFmpqMat  Returns the basis matrix of  \\mathcal O  with respect to the power basis of the ambient number field.   basis_mat(A::NfOrdIdl) -  fmpz_mat   Returns the basis matrix of  A .      basis_mat(O::NfRelOrd{T, S}) -  Generic.Mat{T}   Returns the basis matrix of  \\mathcal O  with respect to the power basis of the ambient number field.      basis_mat(a::NfRelOrdIdl{T, S}) -  Generic.Mat{T}   Returns the basis matrix of  a .   basis_mat_inv(O::NfOrd) -  FakeFmpqMat  Returns the inverse of the basis matrix of  \\mathcal O .   basis_mat_inv(A::NfOrdIdl) -  fmpz_mat   Returns the inverse basis matrix of  A .      basis_mat_inv(O::NfRelOrd{T, S}) -  Generic.Mat{T}   Returns the inverse of the basis matrix of  \\mathcal O .      basis_mat_inv(a::NfRelOrdIdl{T, S}) -  Generic.Mat{T}   Returns the inverse of the basis matrix of  a .    minimum(A::NfOrdIdl) -  fmpz   Returns the smallest nonnegative element in  A \\cap \\mathbf Z .    norm(A::NfOrdIdl) -  fmpz   Returns the norm of  A , that is, the cardinality of  \\mathcal O/A , where  \\mathcal O  is the order of  A .    norm(a::NfRelOrdIdl) -  NfOrdIdl   Returns the norm of  a .    norm(a::NfRelOrdFracIdl{T, S}) -  S   Returns the norm of  a     in(x::NfOrdElem, y::NfOrdIdl)\nin(x::nf_elem, y::NfOrdIdl)\nin(x::fmpz, y::NfOrdIdl)   Returns whether  x  is contained in  y .   idempotents(x::NfOrdIdl, y::NfOrdIdl) -  NfOrdElem, NfOrdElem   Returns a tuple  (e, f)  consisting of elements  e in x ,  f in y  such that  1 = e + f .  If the ideals are not coprime, an error is raised.    mod(x::NfOrdElem, I::NfOrdIdl)   Returns the unique element  y  of the ambient order of  x  with  x \\equiv y \\bmod I  and the following property: If  a_1,\\dotsc,a_d \\in \\Z_{\\geq 1}  are the diagonal entries of the unique HNF basis matrix of  I  and  (b_1,\\dotsc,b_d)  is the coefficient vector of  y , then  0 \\leq b_i < a_i  for  1 \\leq i \\leq d .    pradical(O::NfOrd, p::fmpz) -  NfOrdIdl   Given a prime number  p , this function returns the  p -radical  \\sqrt{p\\mathcal O}  of  \\mathcal O , which is just  \\{ x \\in \\mathcal O \\mid \\exists k \\in \\mathbf Z_{\\geq 0} \\colon x^k \\in p\\mathcal O \\} . It is not checked that  p  is prime.", 
            "title": "Miscaellenous"
        }, 
        {
            "location": "/orders/basics/#fractional-ideals", 
            "text": "", 
            "title": "Fractional ideals"
        }, 
        {
            "location": "/orders/basics/#creation_3", 
            "text": "frac_ideal(::NfOrd, ::fmpz_mat)\nfrac_ideal(::NfOrd, ::fmpz_mat, ::fmpz)\nfrac_ideal(::NfOrd, ::FakeFmpqMat)\nfrac_ideal(::NfOrd, ::NfOrdIdl)\nfrac_ideal(::NfOrd, ::NfOrdIdl, ::fmpz)\nfrac_ideal(::NfOrd, ::nf_elem)\nfrac_ideal(::NfOrd, ::NfOrdElem)", 
            "title": "Creation"
        }, 
        {
            "location": "/orders/basics/#arithmetic_2", 
            "text": "==(x::NfOrdFracIdl, y::NfOrdFracIdl) -  Bool   Returns whether  x  and  y  are equal.", 
            "title": "Arithmetic"
        }, 
        {
            "location": "/orders/basics/#miscaellenous_1", 
            "text": "order(::NfOrdFracIdl)\nbasis_mat(::NfOrdFracIdl)\nbasis_mat_inv(::NfOrdFracIdl)\nbasis(::NfOrdFracIdl)\nnorm(::NfOrdFracIdl)", 
            "title": "Miscaellenous"
        }, 
        {
            "location": "/orders/ideals/", 
            "text": "Ideals", 
            "title": "Ideals"
        }, 
        {
            "location": "/orders/ideals/#ideals", 
            "text": "", 
            "title": "Ideals"
        }, 
        {
            "location": "/abelian/introduction/", 
            "text": "Introduction", 
            "title": "Introduction"
        }, 
        {
            "location": "/abelian/introduction/#introduction", 
            "text": "", 
            "title": "Introduction"
        }
    ]
}