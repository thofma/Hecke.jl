<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Sparse linear algebra · Hecke</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Hecke</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Hecke</a></li><li><a class="toctext" href="../number_fields/intro.html">Number Fields</a></li><li><span class="toctext">Orders</span><ul><li><a class="toctext" href="../orders/introduction.html">Introduction</a></li><li><a class="toctext" href="../orders/orders.html">Orders</a></li><li><a class="toctext" href="../orders/elements.html">Elements</a></li><li><a class="toctext" href="../orders/ideals.html">Ideals</a></li><li><a class="toctext" href="../orders/frac_ideals.html">Fractional ideals</a></li></ul></li><li><a class="toctext" href="../abelian/introduction.html">Abelian Groups</a></li><li><a class="toctext" href="../class_fields/intro.html">Class Field Theory</a></li><li class="current"><a class="toctext" href="intro.html">Sparse linear algebra</a><ul class="internal"><li><a class="toctext" href="#Introduction-1">Introduction</a></li><li><a class="toctext" href="#Sparse-rows-1">Sparse rows</a></li><li><a class="toctext" href="#Sparse-matrices-1">Sparse matrices</a></li></ul></li><li><a class="toctext" href="../FacElem.html">Factored Elements</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="intro.html">Sparse linear algebra</a></li></ul><a class="edit-page" href="https://github.com/thofma/Hecke.jl/blob/master/docs/src/sparse/intro.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Sparse linear algebra</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Sparse-linear-algebra-1" href="#Sparse-linear-algebra-1">Sparse linear algebra</a></h1><h2><a class="nav-anchor" id="Introduction-1" href="#Introduction-1">Introduction</a></h2><p>This chapter deals with sparse linear algebra over commutative rings and fields.</p><p>Sparse linear algebra, that is, linear algebra with sparse matrices,  plays an important role in various algorithms in algebraic number theory. For example, it is one of the key ingredients in the computation of class groups and discrete logarithms using index calculus methods.</p><h2><a class="nav-anchor" id="Sparse-rows-1" href="#Sparse-rows-1">Sparse rows</a></h2><p>Building blocks for sparse matrices are sparse rows, which are modelled by objects of type \texttt{SRow}. More precisely, the type is of parametrized form objects of type <code>SRow</code>. More precisely, the type is of parametrized form <code>SRow{T}</code>, where <code>T</code> is the element type of the base ring <span>$R$</span>. For example, <code>SRow{fmpz}</code> is the type for sparse rows over the integers.</p><p>It is important to note that sparse rows do not have a fixed number of columns, that is, they represent elements of <span>$\{ (x_i)_i \in R^{\mathbb{N}} \mid x_i = 0 \text{ for almost all }i\}$</span>. In particular any two sparse rows over the same base ring can be added.</p><h3><a class="nav-anchor" id="Creation-1" href="#Creation-1">Creation</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hecke.sparse_row-Tuple{FlintIntegerRing,Array{Tuple{Int64,fmpz},1}}" href="#Hecke.sparse_row-Tuple{FlintIntegerRing,Array{Tuple{Int64,fmpz},1}}"><code>Hecke.sparse_row</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">sparse_row(R::Ring, J::Vector{Tuple{Int, T}}) -&gt; SRow{T}</code></pre><p>Constructs the sparse row <span>$(a_i)_i$</span> with <span>$a_{i_j} = x_j$</span>, where <span>$J = (i_j, x_j)_j$</span>. The elements <span>$x_i$</span> must belong to the ring <span>$R$</span>.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hecke.sparse_row-Tuple{FlintIntegerRing,Array{Tuple{Int64,Int64},1}}" href="#Hecke.sparse_row-Tuple{FlintIntegerRing,Array{Tuple{Int64,Int64},1}}"><code>Hecke.sparse_row</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">sparse_row(R::Ring, J::Vector{Tuple{Int, T}}) -&gt; SRow{T}</code></pre><p>Constructs the sparse row <span>$(a_i)_i$</span> with <span>$a_{i_j} = x_j$</span>, where <span>$J = (i_j, x_j)_j$</span>. The elements <span>$x_i$</span> must belong to the ring <span>$R$</span>.</p></div><div><pre><code class="language-none">sparse_row(R::Ring, J::Vector{Tuple{Int, Int}}) -&gt; SRow</code></pre><p>Constructs the sparse row <span>$(a_i)_i$</span> over <span>$R$</span> with <span>$a_{i_j} = x_j$</span>, where <span>$J = (i_j, x_j)_j$</span>.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hecke.sparse_row-Tuple{FlintIntegerRing,Array{Int64,1},Array{fmpz,1}}" href="#Hecke.sparse_row-Tuple{FlintIntegerRing,Array{Int64,1},Array{fmpz,1}}"><code>Hecke.sparse_row</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">sparse_row(R::Ring, J::Vector{Int}, V::Vector{T}) -&gt; SRow{T}</code></pre><p>Constructs the sparse row <span>$(a_i)_i$</span> over <span>$R$</span> with <span>$a_{i_j} = x_j$</span>, where <span>$J = (i_j)_j$</span> and <span>$V = (x_j)_j$</span>.</p></div></section><h3><a class="nav-anchor" id="Basic-operations-1" href="#Basic-operations-1">Basic operations</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:==-Tuple{SRow{fmpz},SRow{fmpz}}" href="#Base.:==-Tuple{SRow{fmpz},SRow{fmpz}}"><code>Base.:==</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">==(x::SRow, y::SRow)</code></pre><p>Checks whether <span>$x$</span> and <span>$y$</span> are the same sparse row, that is, whether <span>$x$</span> and <span>$y$</span> have the same non-zero entries.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:+-Tuple{SRow{fmpz},SRow{fmpz}}" href="#Base.:+-Tuple{SRow{fmpz},SRow{fmpz}}"><code>Base.:+</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">+(A::SRow, B::SRow) -&gt; SRow</code></pre><p>Returns the sum of <span>$A$</span> and <span>$B$</span>.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.getindex-Tuple{SRow{fmpz},Int64}" href="#Base.getindex-Tuple{SRow{fmpz},Int64}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">getindex(A::SRow, j::Int) -&gt; RingElem</code></pre><p>Given a sparse row <span>$(a_i)_{i}$</span> and an index <span>$j$</span> return <span>$a_j$</span>.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:*-Tuple{fmpz,SRow{fmpz}}" href="#Base.:*-Tuple{fmpz,SRow{fmpz}}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">*(b::T, A::SRow{T}) -&gt; SRow</code></pre><p>Return the sparse row obtained by multiplying all elements of <span>$A$</span> by <span>$b$</span>.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.div-Tuple{SRow{fmpz},fmpz}" href="#Base.div-Tuple{SRow{fmpz},fmpz}"><code>Base.div</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">div(A::SRow{T}, b::T) -&gt; SRow</code></pre><p>Return the sparse row obtained by dividing all elements of <span>$A$</span> by <span>$b$</span> using <code>div</code>.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractAlgebra.Generic.divexact-Tuple{SRow{fmpz},fmpz}" href="#AbstractAlgebra.Generic.divexact-Tuple{SRow{fmpz},fmpz}"><code>AbstractAlgebra.Generic.divexact</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">divexact(A::SRow{T}, b::T) -&gt; SRow</code></pre><p>Return the sparse row obtained by dividing all elements of <span>$A$</span> by <span>$b$</span> using <code>divexact</code>.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hecke.add_scaled_row-Tuple{SRow{fmpz},SRow{fmpz},fmpz}" href="#Hecke.add_scaled_row-Tuple{SRow{fmpz},SRow{fmpz},fmpz}"><code>Hecke.add_scaled_row</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">add_scaled_row(A::SRow{T}, B::SRow{T}, c::T) -&gt; SRow{T}</code></pre><p>Returns the row <span>$c A + B$</span>.</p></div></section><h3><a class="nav-anchor" id="Change-of-base-ring-1" href="#Change-of-base-ring-1">Change of base ring</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hecke.change_ring-Tuple{SRow{fmpz},FlintIntegerRing}" href="#Hecke.change_ring-Tuple{SRow{fmpz},FlintIntegerRing}"><code>Hecke.change_ring</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">change_ring(A::SRow, R::Ring) -&gt; SRow</code></pre><p>Create a new sparse row by coercing all elements into the ring <span>$R$</span>.</p></div></section><h3><a class="nav-anchor" id="Maximum,-minimum-and-2-norm-1" href="#Maximum,-minimum-and-2-norm-1">Maximum, minimum and 2-norm</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.maximum-Tuple{SRow{fmpz}}" href="#Base.maximum-Tuple{SRow{fmpz}}"><code>Base.maximum</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">maximum(A::SRow{T}) -&gt; T</code></pre><p>Returns the largest entry of <span>$A$</span>.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.minimum-Tuple{SRow{fmpz}}" href="#Base.minimum-Tuple{SRow{fmpz}}"><code>Base.minimum</code></a> — <span class="docstring-category">Method</span>.</div><div><hr/><pre><code class="language-none">minimum(A::NfAbsOrdIdl) -&gt; fmpz</code></pre><blockquote><p>Returns the smallest nonnegative element in <span>$A \cap \mathbf Z$</span>.</p></blockquote></div><div><pre><code class="language-none">minimum(A::SRow{T}) -&gt; T</code></pre><p>Returns the smallest entry of <span>$A$</span>.</p></div><div><hr/><pre><code class="language-none">  minimum(A::NfRelOrdIdl) -&gt; NfOrdIdl
  minimum(A::NfRelOrdIdl) -&gt; NfRelOrdIdl</code></pre><blockquote><p>Returns the ideal <span>$A \cap O$</span> where <span>$O$</span> is the maximal order of the coefficient ideals of <span>$A$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hecke.norm2-Tuple{SRow{fmpz}}" href="#Hecke.norm2-Tuple{SRow{fmpz}}"><code>Hecke.norm2</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">norm2(A::SRow{T} -&gt; T</code></pre><p>Returns <span>$A \cdot A^t$</span>.</p></div></section><h3><a class="nav-anchor" id="Functionality-for-integral-sparse-rows-1" href="#Functionality-for-integral-sparse-rows-1">Functionality for integral sparse rows</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nemo.lift-Tuple{SRow{Nemo.nmod}}" href="#Nemo.lift-Tuple{SRow{Nemo.nmod}}"><code>Nemo.lift</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">lift(A::SRow{nmod}) -&gt; SRow{fmpz}</code></pre><p>Return the sparse row obtained by lifting all entries in <span>$A$</span>.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hecke.mod!-Tuple{SRow{fmpz},fmpz}" href="#Hecke.mod!-Tuple{SRow{fmpz},fmpz}"><code>Hecke.mod!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">mod!(A::SRow{fmpz}, n::fmpz) -&gt; SRow{fmpz}</code></pre><p>Inplace reduction of all entries of <span>$A$</span> modulo <span>$n$</span> to the positive residue system.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hecke.mod_sym!-Tuple{SRow{fmpz},fmpz}" href="#Hecke.mod_sym!-Tuple{SRow{fmpz},fmpz}"><code>Hecke.mod_sym!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">mod_sym!(A::SRow{fmpz}, n::fmpz) -&gt; SRow{fmpz}</code></pre><p>Inplace reduction of all entries of <span>$A$</span> modulo <span>$n$</span> to the symmetric residue system.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.maximum-Tuple{typeof(abs),SRow{fmpz}}" href="#Base.maximum-Tuple{typeof(abs),SRow{fmpz}}"><code>Base.maximum</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">maximum(abs, A::SRow{fmpz}) -&gt; fmpz</code></pre><p>Returns the largest, in absolute value, entry of <span>$A$</span>.</p></div></section><h2><a class="nav-anchor" id="Sparse-matrices-1" href="#Sparse-matrices-1">Sparse matrices</a></h2><p>Let <span>$R$</span> be a commutative ring. Sparse matrices with base ring <span>$R$</span> are modlled by objects of type <code>SMat</code>. More precisely, the type is of parametrized form <code>SRow{T}</code>, where <code>T</code> is the element type of the base ring. For example, <code>SMat{fmpz}</code> is the type for sparse matrices over the integers.</p><p>In constrast to sparse rows, sparse matrices have a fixed number of rows and columns, that is, they represent elements of the matrices space <span>$\mathrm{Mat}_{n\times m}(R)$</span>. Internally, sparse matrices are implemented as an array of sparse rows.  As a consequence, Unlike their dense counterparts, sparse matrices have a mutable number of rows and it is very performant to add additional rows.</p><h3><a class="nav-anchor" id="Construction-1" href="#Construction-1">Construction</a></h3><footer><hr/><a class="previous" href="../class_fields/intro.html"><span class="direction">Previous</span><span class="title">Class Field Theory</span></a><a class="next" href="../FacElem.html"><span class="direction">Next</span><span class="title">Factored Elements</span></a></footer></article></body></html>
