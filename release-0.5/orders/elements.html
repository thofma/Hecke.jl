<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Elements · Hecke</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Hecke</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Hecke</a></li><li><a class="toctext" href="../number_fields/intro.html">Number Fields</a></li><li><span class="toctext">Orders</span><ul><li><a class="toctext" href="introduction.html">Introduction</a></li><li><a class="toctext" href="orders.html">Orders</a></li><li class="current"><a class="toctext" href="elements.html">Elements</a><ul class="internal"><li><a class="toctext" href="#Creation-1">Creation</a></li><li><a class="toctext" href="#Basic-properties-1">Basic properties</a></li><li><a class="toctext" href="#Arithmetic-1">Arithmetic</a></li><li><a class="toctext" href="#Miscallenous-1">Miscallenous</a></li></ul></li><li><a class="toctext" href="ideals.html">Ideals</a></li><li><a class="toctext" href="frac_ideals.html">Fractional ideals</a></li></ul></li><li><a class="toctext" href="../abelian/introduction.html">Abelian Groups</a></li><li><a class="toctext" href="../class_fields/intro.html">Class Field Theory</a></li><li><a class="toctext" href="../sparse/intro.html">Sparse linear algebra</a></li><li><a class="toctext" href="../FacElem.html">Factored Elements</a></li></ul></nav><article id="docs"><header><nav><ul><li>Orders</li><li><a href="elements.html">Elements</a></li></ul><a class="edit-page" href="https://github.com/thofma/Hecke.jl/blob/master/docs/src/orders/elements.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Elements</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Elements-1" href="#Elements-1">Elements</a></h1><p>Elements in orders have two representations: they can be viewed as  elements in the <span>$Z^n$</span> giving the coefficients wrt to the order basis where they are elements in. On the other hand, as every order is in a field, they also have a representation as number field elements. Since, asymptotically, operations are more efficient in the  field (due to fast polynomial arithmetic) than in the order, the primary representation is that as a field element.</p><h2><a class="nav-anchor" id="Creation-1" href="#Creation-1">Creation</a></h2><p>Elements are constructed either as linear combinations of basis elements or via explicit coercion. Elements will be of type <code>NfOrdElem</code>,  the type if actually parametrized by the type of the surrounding field and the type of the field elements. E.g. the type of any element in any order of an absolute simple field will be <code>NfAbsOrdElem{AnticNumberField,nf_elem}</code></p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hecke.NfAbsOrd" href="#Hecke.NfAbsOrd"><code>Hecke.NfAbsOrd</code></a> — <span class="docstring-category">Type</span>.</div><div><hr/><pre><code class="language-none">  (O::NfOrd)(a::Union{fmpz, Integer}) -&gt; NfAbsOrdElem</code></pre><blockquote><p>Given an element <span>$a$</span> of type <code>fmpz</code> or <code>Integer</code>, this function coerces the element into <span>$\mathcal O$</span>. It will be checked that <span>$a$</span> is contained in <span>$\mathcal O$</span> if and only if <code>check</code> is <code>true</code>.</p></blockquote></div><div><hr/><pre><code class="language-none">  (O::NfOrd)(arr::Array{fmpz, 1})</code></pre><blockquote><p>Returns the element of <span>$\mathcal O$</span> with coefficient vector <code>arr</code>.</p></blockquote></div><div><hr/><pre><code class="language-none">  (O::NfOrd)() -&gt; NfAbsOrdElem</code></pre><blockquote><p>This function constructs a new element of <span>$\mathcal O$</span> which is set to <span>$0$</span>.</p></blockquote></div></section><h2><a class="nav-anchor" id="Basic-properties-1" href="#Basic-properties-1">Basic properties</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.parent-Tuple{NfAbsOrdElem{AnticNumberField,nf_elem}}" href="#Base.parent-Tuple{NfAbsOrdElem{AnticNumberField,nf_elem}}"><code>Base.parent</code></a> — <span class="docstring-category">Method</span>.</div><div><hr/><pre><code class="language-none">parent(a::NfAbsOrdElem) -&gt; NfOrd</code></pre><p>Returns the order of which <span>$a$</span> is an element.</p></div><div><pre><code class="language-none">parent(g::perm{T}) where T = PermGroup</code></pre><blockquote><p>Return the parent of the permutation <code>g</code>.</p></blockquote><pre><code class="language-julia-repl">julia&gt; G = PermutationGroup(5); g = perm([3,4,5,2,1])
(1,3,5)(2,4)

julia&gt; parent(g) == G
true</code></pre></div><div><pre><code class="language-none">parent(a::AbstractAlgebra.MatElem{T}, cached::Bool = true) where T &lt;: RingElement</code></pre><blockquote><p>Return the parent object of the given matrix.</p></blockquote></div><div><pre><code class="language-none">parent(a::AbstractAlgebra.MatAlgElem{T}, cached::Bool = true) where T &lt;: RingElement</code></pre><blockquote><p>Return the parent object of the given matrix.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hecke.elem_in_nf-Tuple{NfAbsOrdElem{AnticNumberField,nf_elem}}" href="#Hecke.elem_in_nf-Tuple{NfAbsOrdElem{AnticNumberField,nf_elem}}"><code>Hecke.elem_in_nf</code></a> — <span class="docstring-category">Method</span>.</div><div><hr/><pre><code class="language-none">elem_in_nf(a::NfAbsOrdElem) -&gt; nf_elem</code></pre><blockquote><p>Returns the element <span>$a$</span> considered as an element of the ambient number field.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hecke.elem_in_basis-Tuple{NfAbsOrdElem{AnticNumberField,nf_elem}}" href="#Hecke.elem_in_basis-Tuple{NfAbsOrdElem{AnticNumberField,nf_elem}}"><code>Hecke.elem_in_basis</code></a> — <span class="docstring-category">Method</span>.</div><div><hr/><pre><code class="language-none">elem_in_basis(a::NfAbsOrdElem) -&gt; Array{fmpz, 1}</code></pre><blockquote><p>Returns the coefficient vector of <span>$a$</span>.</p></blockquote></div><div><hr/><pre><code class="language-none">  elem_in_basis(a::NfRelOrdElem{T}) -&gt; Vector{T}</code></pre><blockquote><p>Returns the coefficient vector of <span>$a$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractAlgebra.Generic.discriminant-Tuple{Array{NfAbsOrdElem{AnticNumberField,nf_elem},1}}" href="#AbstractAlgebra.Generic.discriminant-Tuple{Array{NfAbsOrdElem{AnticNumberField,nf_elem},1}}"><code>AbstractAlgebra.Generic.discriminant</code></a> — <span class="docstring-category">Method</span>.</div><div><hr/><pre><code class="language-none">discriminant(B::Array{NfAbsOrdElem, 1}) -&gt; fmpz</code></pre><blockquote><p>Returns the discriminant of the family <span>$B$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:==-Tuple{NfAbsOrdElem{AnticNumberField,nf_elem},NfAbsOrdElem{AnticNumberField,nf_elem}}" href="#Base.:==-Tuple{NfAbsOrdElem{AnticNumberField,nf_elem},NfAbsOrdElem{AnticNumberField,nf_elem}}"><code>Base.:==</code></a> — <span class="docstring-category">Method</span>.</div><div><hr/><pre><code class="language-none">==(x::NfAbsOrdElem, y::NfAbsOrdElem) -&gt; Bool</code></pre><blockquote><p>Returns whether <span>$x$</span> and <span>$y$</span> are equal.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.zero-Tuple{NfAbsOrd{AnticNumberField,nf_elem}}" href="#Base.zero-Tuple{NfAbsOrd{AnticNumberField,nf_elem}}"><code>Base.zero</code></a> — <span class="docstring-category">Method</span>.</div><div><hr/><pre><code class="language-none">zero(O::NfOrd) -&gt; NfAbsOrdElem</code></pre><blockquote><p>Returns the zero element of <span>$\mathcal O$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.one-Tuple{NfAbsOrd{AnticNumberField,nf_elem}}" href="#Base.one-Tuple{NfAbsOrd{AnticNumberField,nf_elem}}"><code>Base.one</code></a> — <span class="docstring-category">Method</span>.</div><div><hr/><pre><code class="language-none">one(O::NfOrd) -&gt; NfAbsOrdElem</code></pre><blockquote><p>Returns the one element of <span>$\mathcal O$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.iszero-Tuple{NfAbsOrdElem{AnticNumberField,nf_elem}}" href="#Base.iszero-Tuple{NfAbsOrdElem{AnticNumberField,nf_elem}}"><code>Base.iszero</code></a> — <span class="docstring-category">Method</span>.</div><div><hr/><pre><code class="language-none">iszero(a::NfOrd) -&gt; Bool</code></pre><blockquote><p>Tests if <span>$a$</span> is zero.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isone-Tuple{NfAbsOrdElem{AnticNumberField,nf_elem}}" href="#Base.isone-Tuple{NfAbsOrdElem{AnticNumberField,nf_elem}}"><code>Base.isone</code></a> — <span class="docstring-category">Method</span>.</div><div><hr/><pre><code class="language-none">isone(a::NfOrd) -&gt; Bool</code></pre><blockquote><p>Tests if <span>$a$</span> is one.</p></blockquote></div></section><h2><a class="nav-anchor" id="Arithmetic-1" href="#Arithmetic-1">Arithmetic</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:--Tuple{NfAbsOrdElem{AnticNumberField,nf_elem}}" href="#Base.:--Tuple{NfAbsOrdElem{AnticNumberField,nf_elem}}"><code>Base.:-</code></a> — <span class="docstring-category">Method</span>.</div><div><hr/><pre><code class="language-none">-(x::NfAbsOrdElem) -&gt; NfAbsOrdElem</code></pre><blockquote><p>Returns the additive inverse of <span>$x$</span>.</p></blockquote></div><div><pre><code class="language-none">-(A::SMat, B::SMat) -&gt; SMat</code></pre><p>Return the difference <span>$A - B$</span>.</p></div><div><pre><code class="language-none">-(A::SRow, B::SRow) -&gt; SRow</code></pre><p>Returns the difference of <span>$A$</span> and <span>$B$</span>.</p></div><div><pre><code class="language-none">-(a::AbstractAlgebra.ResElem{T}, b::AbstractAlgebra.ResElem{T}) where {T &lt;: RingElement}</code></pre><blockquote><p>Return <span>$a - b$</span>.</p></blockquote></div><div><pre><code class="language-none">-(a::AbstractAlgebra.ResElem{T}, b::T) where {T &lt;: RingElem}</code></pre><blockquote><p>Return <span>$a - b$</span>.</p></blockquote></div><div><pre><code class="language-none">-(a::T, b::AbstractAlgebra.ResElem{T}) where {T &lt;: RingElem}</code></pre><blockquote><p>Return <span>$a - b$</span>.</p></blockquote></div><div><pre><code class="language-none">-(a::AbstractAlgebra.ResFieldElem{T}, b::AbstractAlgebra.ResFieldElem{T}) where {T &lt;: RingElement}</code></pre><blockquote><p>Return <span>$a - b$</span>.</p></blockquote></div><div><pre><code class="language-none">-(a::AbstractAlgebra.ResFieldElem{T}, b::T) where {T &lt;: RingElem}</code></pre><blockquote><p>Return <span>$a - b$</span>.</p></blockquote></div><div><pre><code class="language-none">-(a::T, b::AbstractAlgebra.ResFieldElem{T}) where {T &lt;: RingElem}</code></pre><blockquote><p>Return <span>$a - b$</span>.</p></blockquote></div><div><pre><code class="language-none">-(a::AbstractAlgebra.PolyElem{T}, b::AbstractAlgebra.PolyElem{T}) where {T &lt;: RingElement}</code></pre><blockquote><p>Return <span>$a - b$</span>.</p></blockquote></div><div><pre><code class="language-none">-(a::AbstractAlgebra.NCPolyElem{T}, b::AbstractAlgebra.NCPolyElem{T}) where {T &lt;: NCRingElem}</code></pre><blockquote><p>Return <span>$a - b$</span>.</p></blockquote></div><div><pre><code class="language-none">-(a::AbstractAlgebra.RelSeriesElem{T}, b::AbstractAlgebra.RelSeriesElem{T}) where {T &lt;: RingElement}</code></pre><blockquote><p>Return <span>$a - b$</span>.</p></blockquote></div><div><pre><code class="language-none">-(a::AbstractAlgebra.AbsSeriesElem{T}, b::AbstractAlgebra.AbsSeriesElem{T}) where {T &lt;: RingElement}</code></pre><blockquote><p>Return <span>$a - b$</span>.</p></blockquote></div><div><pre><code class="language-none">-(a::Generic.LaurentSeriesElem{T}, b::Generic.LaurentSeriesElem{T}) where {T &lt;: RingElement}</code></pre><blockquote><p>Return <span>$a - b$</span>.</p></blockquote></div><div><pre><code class="language-none">-(x::Generic.MatrixElem{T}, y::Generic.MatrixElem{T}) where {T &lt;: RingElement}</code></pre><blockquote><p>Return <span>$a - b$</span>.</p></blockquote></div><div><pre><code class="language-none">-(x::T, y::Generic.MatrixElem{T}) where {T &lt;: RingElem}</code></pre><blockquote><p>Return <span>$S(x) - y$</span> where <span>$S$</span> is the parent of <span>$y$</span>.</p></blockquote></div><div><pre><code class="language-none">-(x::Generic.MatrixElem{T}, y::T) where {T &lt;: RingElem}</code></pre><blockquote><p>Return <span>$x - S(y)$</span>, where <span>$S$</span> is the parent of <span>$a$</span>.</p></blockquote></div><div><pre><code class="language-none">-(a::AbstractAlgebra.FracElem{T}, b::AbstractAlgebra.FracElem{T}) where {T &lt;: RingElem}</code></pre><blockquote><p>Return <span>$a - b$</span>.</p></blockquote></div><div><pre><code class="language-none">-(a::AbstractAlgebra.FracElem{T}, b::T) where {T &lt;: RingElem}</code></pre><blockquote><p>Return <span>$a - b$</span>.</p></blockquote></div><div><pre><code class="language-none">-(a::T, b::AbstractAlgebra.FracElem{T}) where {T &lt;: RingElem}</code></pre><blockquote><p>Return <span>$a - b$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:+-Tuple{NfAbsOrdElem{AnticNumberField,nf_elem},NfAbsOrdElem{AnticNumberField,nf_elem}}" href="#Base.:+-Tuple{NfAbsOrdElem{AnticNumberField,nf_elem},NfAbsOrdElem{AnticNumberField,nf_elem}}"><code>Base.:+</code></a> — <span class="docstring-category">Method</span>.</div><div><hr/><pre><code class="language-none">+(x::NfAbsOrdElem, y::NfAbsOrdElem) -&gt; NfAbsOrdElem</code></pre><blockquote><p>Returns <span>$x + y$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:--Tuple{NfAbsOrdElem{AnticNumberField,nf_elem},NfAbsOrdElem{AnticNumberField,nf_elem}}" href="#Base.:--Tuple{NfAbsOrdElem{AnticNumberField,nf_elem},NfAbsOrdElem{AnticNumberField,nf_elem}}"><code>Base.:-</code></a> — <span class="docstring-category">Method</span>.</div><div><hr/><pre><code class="language-none">-(x::NfAbsOrdElem, y::NfAbsOrdElem) -&gt; NfAbsOrdElem</code></pre><blockquote><p>Returns <span>$x - y$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:*-Tuple{NfAbsOrdElem{AnticNumberField,nf_elem},NfAbsOrdElem{AnticNumberField,nf_elem}}" href="#Base.:*-Tuple{NfAbsOrdElem{AnticNumberField,nf_elem},NfAbsOrdElem{AnticNumberField,nf_elem}}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span>.</div><div><hr/><pre><code class="language-none">*(x::NfAbsOrdElem, y::NfAbsOrdElem) -&gt; NfAbsOrdElem</code></pre><blockquote><p>Returns <span>$x \cdot y$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:^-Tuple{NfAbsOrdElem{AnticNumberField,nf_elem},Int64}" href="#Base.:^-Tuple{NfAbsOrdElem{AnticNumberField,nf_elem},Int64}"><code>Base.:^</code></a> — <span class="docstring-category">Method</span>.</div><div><hr/><pre><code class="language-none">^(x::NfAbsOrdElem, y::Union{fmpz, Int})</code></pre><blockquote><p>Returns <span>$x^y$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.mod-Tuple{NfAbsOrdElem{AnticNumberField,nf_elem},Int64}" href="#Base.mod-Tuple{NfAbsOrdElem{AnticNumberField,nf_elem},Int64}"><code>Base.mod</code></a> — <span class="docstring-category">Method</span>.</div><div><hr/><pre><code class="language-none">mod(a::NfAbsOrdElem, m::Union{fmpz, Int}) -&gt; NfAbsOrdElem</code></pre><blockquote><p>Reduces the coefficient vector of <span>$a$</span> modulo <span>$m$</span> and returns the corresponding element. The coefficient vector of the result will have entries <span>$x$</span> with <span>$0 \leq x \leq m$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.powermod-Tuple{NfAbsOrdElem{AnticNumberField,nf_elem},fmpz,Int64}" href="#Base.powermod-Tuple{NfAbsOrdElem{AnticNumberField,nf_elem},fmpz,Int64}"><code>Base.powermod</code></a> — <span class="docstring-category">Method</span>.</div><div><hr/><pre><code class="language-none">powermod(a::NfAbsOrdElem, i::fmpz, m::Integer) -&gt; NfAbsOrdElem</code></pre><blockquote><p>Returns the element <span>$a^i$</span> modulo <span>$m$</span>.</p></blockquote></div></section><h2><a class="nav-anchor" id="Miscallenous-1" href="#Miscallenous-1">Miscallenous</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nemo.representation_matrix-Tuple{NfAbsOrdElem{AnticNumberField,nf_elem}}" href="#Nemo.representation_matrix-Tuple{NfAbsOrdElem{AnticNumberField,nf_elem}}"><code>Nemo.representation_matrix</code></a> — <span class="docstring-category">Method</span>.</div><div><hr/><pre><code class="language-none">representation_matrix(a::NfAbsOrdElem) -&gt; fmpz_mat</code></pre><blockquote><p>Returns the representation matrix of the element <span>$a$</span>.</p></blockquote></div><div><hr/><pre><code class="language-none">representation_matrix(a::NfAbsOrdElem, K::AnticNumberField) -&gt; FakeFmpqMat</code></pre><blockquote><p>Returns the representation matrix of the element <span>$a$</span> considered as an element of the ambient number field <span>$K$</span>. It is assumed that <span>$K$</span> is the ambient number field of the order of <span>$a$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nemo.representation_matrix-Tuple{NfAbsOrdElem{AnticNumberField,nf_elem},AnticNumberField}" href="#Nemo.representation_matrix-Tuple{NfAbsOrdElem{AnticNumberField,nf_elem},AnticNumberField}"><code>Nemo.representation_matrix</code></a> — <span class="docstring-category">Method</span>.</div><div><hr/><pre><code class="language-none">representation_matrix(a::NfAbsOrdElem, K::AnticNumberField) -&gt; FakeFmpqMat</code></pre><blockquote><p>Returns the representation matrix of the element <span>$a$</span> considered as an element of the ambient number field <span>$K$</span>. It is assumed that <span>$K$</span> is the ambient number field of the order of <span>$a$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.tr-Tuple{NfAbsOrdElem{AnticNumberField,nf_elem}}" href="#LinearAlgebra.tr-Tuple{NfAbsOrdElem{AnticNumberField,nf_elem}}"><code>LinearAlgebra.tr</code></a> — <span class="docstring-category">Method</span>.</div><div><hr/><pre><code class="language-none">tr(a::NfAbsOrdElem) -&gt; fmpz</code></pre><blockquote><p>Returns the trace of <span>$a$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.norm-Tuple{NfAbsOrdElem{AnticNumberField,nf_elem}}" href="#LinearAlgebra.norm-Tuple{NfAbsOrdElem{AnticNumberField,nf_elem}}"><code>LinearAlgebra.norm</code></a> — <span class="docstring-category">Method</span>.</div><div><hr/><pre><code class="language-none">norm(a::NfAbsOrdElem) -&gt; fmpz</code></pre><blockquote><p>Returns the norm of <span>$a$</span>.</p></blockquote></div><div><hr/><pre><code class="language-none">norm(A::NfAbsOrdIdl) -&gt; fmpz</code></pre><blockquote><p>Returns the norm of <span>$A$</span>, that is, the cardinality of <span>$\mathcal O/A$</span>, where <span>$\mathcal O$</span> is the order of <span>$A$</span>.</p></blockquote></div><div><hr/><pre><code class="language-none">norm(a::NfRelOrdIdl) -&gt; NfOrdIdl</code></pre><blockquote><p>Returns the norm of <span>$a$</span>.</p></blockquote></div><div><hr/><pre><code class="language-none">norm(a::NfRelOrdFracIdl{T, S}) -&gt; S</code></pre><blockquote><p>Returns the norm of <span>$a$</span></p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.rand-Tuple{NfAbsOrd{AnticNumberField,nf_elem},Int64}" href="#Base.rand-Tuple{NfAbsOrd{AnticNumberField,nf_elem},Int64}"><code>Base.rand</code></a> — <span class="docstring-category">Method</span>.</div><div><hr/><pre><code class="language-none">rand(O::NfOrd, n::Union{Integer, fmpz}) -&gt; NfAbsOrdElem</code></pre><blockquote><p>Computes a coefficient vector with entries uniformly distributed in <span>$\{-n,\dotsc,-1,0,1,\dotsc,n\}$</span> and returns the corresponding element of the order <span>$\mathcal O$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hecke.minkowski_map-Tuple{NfAbsOrdElem{AnticNumberField,nf_elem},Int64}" href="#Hecke.minkowski_map-Tuple{NfAbsOrdElem{AnticNumberField,nf_elem},Int64}"><code>Hecke.minkowski_map</code></a> — <span class="docstring-category">Method</span>.</div><div><hr/><pre><code class="language-none">minkowski_map(a::NfAbsOrdElem, abs_tol::Int) -&gt; Array{arb, 1}</code></pre><blockquote><p>Returns the image of <span>$a$</span> under the Minkowski embedding. Every entry of the array returned is of type <code>arb</code> with radius less then <code>2^-abs_tol</code>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hecke.conjugates_arb-Tuple{NfAbsOrdElem{AnticNumberField,nf_elem},Int64}" href="#Hecke.conjugates_arb-Tuple{NfAbsOrdElem{AnticNumberField,nf_elem},Int64}"><code>Hecke.conjugates_arb</code></a> — <span class="docstring-category">Method</span>.</div><div><hr/><pre><code class="language-none">conjugates_arb(x::NfAbsOrdElem, abs_tol::Int) -&gt; Array{acb, 1}</code></pre><blockquote><p>Compute the the conjugates of <code>x</code> as elements of type <code>acb</code>. Recall that we order the complex conjugates <span>$\sigma_{r+1}(x),...,\sigma_{r+2s}(x)$</span> such that <span>$\sigma_{i}(x) = \overline{\sigma_{i + s}(x)}$</span> for <span>$r + 2 \leq i \leq r + s$</span>.</p><p>Every entry <code>y</code> of the array returned satisfies <code>radius(real(y)) &lt; 2^-abs_tol</code>, <code>radius(imag(y)) &lt; 2^-abs_tol</code> respectively.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hecke.conjugates_arb_log-Tuple{NfAbsOrdElem{AnticNumberField,nf_elem},Int64}" href="#Hecke.conjugates_arb_log-Tuple{NfAbsOrdElem{AnticNumberField,nf_elem},Int64}"><code>Hecke.conjugates_arb_log</code></a> — <span class="docstring-category">Method</span>.</div><div><hr/><pre><code class="language-none">conjugates_arb_log(x::NfAbsOrdElem, abs_tol::Int) -&gt; Array{arb, 1}</code></pre><blockquote><p>Returns the elements <span>$(\log(\lvert \sigma_1(x) \rvert),\dotsc,\log(\lvert\sigma_r(x) \rvert), \dotsc,2\log(\lvert \sigma_{r+1}(x) \rvert),\dotsc, 2\log(\lvert \sigma_{r+s}(x)\rvert))$</span> as elements of type <code>arb</code> radius less then <code>2^-abs_tol</code>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hecke.t2-Tuple{NfAbsOrdElem{AnticNumberField,nf_elem},Int64}" href="#Hecke.t2-Tuple{NfAbsOrdElem{AnticNumberField,nf_elem},Int64}"><code>Hecke.t2</code></a> — <span class="docstring-category">Method</span>.</div><div><hr/><pre><code class="language-none">t2(x::NfAbsOrdElem, abs_tol::Int = 32) -&gt; arb</code></pre><blockquote><p>Return the <span>$T_2$</span>-norm of <span>$x$</span>. The radius of the result will be less than <code>2^-abs_tol</code>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractAlgebra.Generic.minpoly-Tuple{NfAbsOrdElem{AnticNumberField,nf_elem}}" href="#AbstractAlgebra.Generic.minpoly-Tuple{NfAbsOrdElem{AnticNumberField,nf_elem}}"><code>AbstractAlgebra.Generic.minpoly</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">minpoly(a::NfAbsOrdElem) -&gt; fmpz_poly

minpoly(a::NfAbsOrdElem, FlintZZ) -&gt; fmpz_poly</code></pre><blockquote><p>The minimal polynomial of <span>$a$</span>.    </p></blockquote></div><div><pre><code class="language-none">minpoly(S::Ring, M::MatElem{T}, charpoly_only::Bool = false) where {T &lt;: RingElement}</code></pre><blockquote><p>Returns the minimal polynomial <span>$p$</span> of the matrix <span>$M$</span>. The polynomial ring <span>$S$</span> of the resulting polynomial must be supplied and the matrix must be square.</p></blockquote></div><div><pre><code class="language-none">minpoly(S::Ring, M::MatAlgElem{T}, charpoly_only::Bool = false) where {T &lt;: RingElement}</code></pre><blockquote><p>Returns the minimal polynomial <span>$p$</span> of the matrix <span>$M$</span>. The polynomial ring <span>$S$</span> of the resulting polynomial must be supplied and the matrix must be square.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractAlgebra.Generic.charpoly-Tuple{NfAbsOrdElem{AnticNumberField,nf_elem}}" href="#AbstractAlgebra.Generic.charpoly-Tuple{NfAbsOrdElem{AnticNumberField,nf_elem}}"><code>AbstractAlgebra.Generic.charpoly</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">charpoly(a::NfAbsOrdElem) -&gt; fmpz_poly

charpoly(a::NfAbsOrdElem, FlintZZ) -&gt; fmpz_poly</code></pre><blockquote><p>The characteristic polynomial of <span>$a$</span>.    </p></blockquote></div><div><pre><code class="language-none">charpoly(V::Ring, Y::Generic.MatrixElem{T}) where {T &lt;: RingElement}</code></pre><blockquote><p>Returns the characteristic polynomial <span>$p$</span> of the matrix <span>$M$</span>. The polynomial ring <span>$R$</span> of the resulting polynomial must be supplied and the matrix is assumed to be square.</p></blockquote></div></section><footer><hr/><a class="previous" href="orders.html"><span class="direction">Previous</span><span class="title">Orders</span></a><a class="next" href="ideals.html"><span class="direction">Next</span><span class="title">Ideals</span></a></footer></article></body></html>
