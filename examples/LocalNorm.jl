import Oscar: blocks, stabilizer, galois_group
import Oscar.GaloisGrp: GaloisCtx

"""
S the GaloisCtx of K, a number field and A an element of K
return the block system defining the subfield generated by A.
"""
function blocks(S::GaloisCtx, A::AbsSimpleNumFieldElem)
  return Oscar.SubfieldLattice_Module.block_system(S, A)
end

"""
The subgroup of the Galois group fixing A
"""
function stabilizer(S::GaloisCtx, A::AbsSimpleNumFieldElem)
#  H = Oscar.GaloisGrp.action_on_block_system(S.G, blocks(S, A))
#  U = sub(S.G, vcat(gens(kernel(H)[1]), gens(stabilizer(S.G, 1)[1])))
#  return U
   return stabilizer(S.G, blocks(S, A)[1], on_sets)
end

""" 
The projection from the Galois group onto the Galois group of the
subfield defined by A, as well as a map giving the relative galois group:

Let B be the block containing 1 of the subfield generated by A, then
the map is the restriction of the stabilizer of B to B, re-numbered so that
effectively B = [1,2,...,n]
"""
function galois_group(S::GaloisCtx, A::AbsSimpleNumFieldElem)
  B = blocks(S, A)
  U = stabilizer(S.G, B[1], on_sets)[1]
  H = action_homomorphism(U, B[1])
  return right_coset_action(S.G, U), H
end

function galois_group_non_normal(A::ClassField, ::QQField)
  k = number_field(A)
  ka, mka = absolute_simple_field(k)
  G, S = galois_group(ka)
  z = galois_group(S, preimage(mka, k(gen(base_field(A)))))
end
#=
   B
   |   so A is abelian over l (base_field(A))
   |      L is the normal closure (over Q) of l 
   AL     B is the normal closure (over Q) of A
  /|
 / |   Let G be the Galois group of B/Q
A  L   Fix(G, A) = stabilizer(G, 1)
| /    Fix(G, l) = stabilizer(G, block(gen(l)))
|/     Fix(G, L) = core(Fix(G, l)) (see comment below)
l      Fix(G, AL) = Fix(G, A) cap Fix(G, L)
|      We want "A to be normal over l" which here means
|        AL == B <-> Fix(G, AL) == {1}
Q      Ideally we want "A to be central" which we translate into
         AL == B & Fix(G, L) <= center(G)
       (We also want Gal(AL/L) == Gal(A/l) but this we can get via
       coprime conductors)
=#      
function stays_normal(A::ClassField)
  k = number_field(A)
  ka, mka = absolute_simple_field(k)
  g, s = galois_group(ka)
  b = blocks(s, preimage(mka, k(gen(base_field(A)))))
  #want the group fixing the normal closure of the base_field of A
  #the base_field itself corresponds to the stabilizer of the 1st block
  #the conjugate fields correspond to the stabilizers of the other blocks
  #but, as the operation on the blocks is transitive, the stabilizers
  #are conjugate. The intersection of the stabilizers is the core of
  #the 1st (and any other)
  #other approach: stabilizer of 1st block is fixed group of base_field
  #the normal closure is the smallest normal subfield corresponding
  #to the largest normal subgroup in it, thus the core
  s = core(g, stabilizer(g, b[1], on_sets)[1])[1]
  #if A and normal_closure(base_field(k)) are coprime, then ==
  #should be there
  #A/base_field stays normal if stab(1) cap s = {1}
  t = stabilizer(g, 1)[1]
  return order(intersect(t, s)[1]) == 1  
end

function is_central(A::ClassField)
  k = number_field(A)
  ka, mka = absolute_simple_field(k)
  g, s = galois_group(ka)
  b = blocks(s, preimage(mka, k(gen(base_field(A)))))
  s = core(g, stabilizer(g, b[1], on_sets)[1])[1]
  t = stabilizer(g, 1)[1]
  return issubset(s, center(g)[1]) && order(intersect(t, s)[1]) == 1  
end


function galois_group_non_normal2(A::ClassField, ::QQField)
  k = number_field(A)
  ka, mka = absolute_simple_field(k)
  au = automorphism_list(k)
  G, S = galois_group(ka)

  Qt = parent(defining_polynomial(ka))
  gn = mka(gen(ka))
  si = [Qt(preimage(mka, x(gn))) for x = au]

  #g is the galois group over Q, we now want the subgroup A/k
  #the group of the base field
  r = roots(S, 2)
  @show length(r)
  @show length(r), G
  s, ms = sub(G, [G([findfirst(isequal(y(x)), r) for x = r]) for y = si])
  o = orbits(s)
  @assert all(x->length(o[1]) == length(x), o)
  @show o, [x.seeds for x = o]
  q = Oscar.GaloisGrp.action_on_block_system(G, [x.seeds for x = o])  
  #the small_knot is correct, hopefully, if
  # kernel(q) == image(ms) 
  return ms, q
end
