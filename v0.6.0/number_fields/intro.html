<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Number Fields · Hecke</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><script data-outdated-warner="">function maybeAddWarning () {
    const head = document.getElementsByTagName('head')[0];

    // Add a noindex meta tag (unless one exists) so that search engines don't index this version of the docs.
    if (document.body.querySelector('meta[name="robots"]') === null) {
        const meta = document.createElement('meta');
        meta.name = 'robots';
        meta.content = 'noindex';

        head.appendChild(meta);
    };

    // Add a stylesheet to avoid inline styling
    const style = document.createElement('style');
    style.type = 'text/css';
    style.appendChild(document.createTextNode('.outdated-warning-overlay {  position: fixed;  top: 0;  left: 0;  right: 0;  box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);  z-index: 999;  background-color: #ffaba7;  color: rgba(0, 0, 0, 0.7);  border-bottom: 3px solid #da0b00;  padding: 10px 35px;  text-align: center;  font-size: 15px; }  .outdated-warning-overlay .outdated-warning-closer {    position: absolute;    top: calc(50% - 10px);    right: 18px;    cursor: pointer;    width: 12px; }  .outdated-warning-overlay a {    color: #2e63b8; }    .outdated-warning-overlay a:hover {      color: #363636; }'));
    head.appendChild(style);

    const div = document.createElement('div');
    div.classList.add('outdated-warning-overlay');
    const closer = document.createElement('div');
    closer.classList.add('outdated-warning-closer');

    // Icon by font-awesome (license: https://fontawesome.com/license, link: https://fontawesome.com/icons/times?style=solid)
    closer.innerHTML = '<svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="times" class="svg-inline--fa fa-times fa-w-11" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 352 512"><path fill="currentColor" d="M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z"></path></svg>';
    closer.addEventListener('click', function () {
        document.body.removeChild(div);
    });
    let href = '/stable';
    if (window.documenterBaseURL) {
        href = window.documenterBaseURL + '/../stable';
    }
    div.innerHTML = 'This documentation is not for the latest version. <br> <a href="' + href + '" target="_self">Go to the latest documentation</a>.';
    div.appendChild(closer);
    document.body.appendChild(div);
};

if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', maybeAddWarning);
} else {
    maybeAddWarning();
};
</script>
</head><body><nav class="toc"><h1>Hecke</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Hecke</a></li><li class="current"><a class="toctext" href="intro.html">Number Fields</a><ul class="internal"><li><a class="toctext" href="#NumberFieldsLink-1">Introduction</a></li><li><a class="toctext" href="#Absolute-Simple-Fields-1">Absolute Simple Fields</a></li><li><a class="toctext" href="#Absolute-Non-Simple-Fields-1">Absolute Non-Simple Fields</a></li><li><a class="toctext" href="#Simple-Relative-Fields-1">Simple Relative Fields</a></li><li><a class="toctext" href="#Non-Simple-Relative-Fields-1">Non-Simple Relative Fields</a></li><li><a class="toctext" href="#Implicit-Relative-Extensions-1">Implicit Relative Extensions</a></li><li><a class="toctext" href="#Invariants-1">Invariants</a></li><li><a class="toctext" href="#Elements-1">Elements</a></li></ul></li><li><span class="toctext">Orders</span><ul><li><a class="toctext" href="../orders/introduction.html">Introduction</a></li><li><a class="toctext" href="../orders/orders.html">Orders</a></li><li><a class="toctext" href="../orders/elements.html">Elements</a></li><li><a class="toctext" href="../orders/ideals.html">Ideals</a></li><li><a class="toctext" href="../orders/frac_ideals.html">Fractional ideals</a></li></ul></li><li><a class="toctext" href="../abelian/introduction.html">Abelian Groups</a></li><li><a class="toctext" href="../class_fields/intro.html">Class Field Theory</a></li><li><a class="toctext" href="../sparse/intro.html">Sparse linear algebra</a></li><li><a class="toctext" href="../FacElem.html">Factored Elements</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="intro.html">Number Fields</a></li></ul><a class="edit-page" href="https://github.com/thofma/Hecke.jl/blob/master/docs/src/number_fields/intro.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Number Fields</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Number-Fields-1" href="#Number-Fields-1">Number Fields</a></h1><h2><a class="nav-anchor" id="NumberFieldsLink-1" href="#NumberFieldsLink-1">Introduction</a></h2><p>This chapter deals with number fields. Number fields, in Hecke, come in several different types:</p><ul><li><code>AnticNumberField</code>: a finite simple extension of the rational numbers <span>$Q$</span></li><li><code>NfAbsNS</code>: a finite extension of <span>$Q$</span> given by several polynomials.</li></ul><p>We will refer to this as a non-simple field - even though mathematically  we can find a primitive elements.</p><ul><li><code>NfRel</code>: a finite simple extension of a number field. This is   actually parametried by the (element) type of the coefficient field.  The complete type of an extension of an absolute field (<code>AnticNumberField</code>)  is <code>NfRel{nf_elem}</code>. The next extension thus will be  <code>NfRel{NfRelElem{nf_elem}}</code>.</li><li><code>NfRel_ns</code>: extensions of number fields given by several polynomials.  This too will be refered to as a non-simple field.</li></ul><p>The simple types <code>AnticNumberField</code> and <code>NfRel</code> are also calle simple fields in the rest of this document, <code>NfRel</code> and <code>NfRel_ns</code> are referred to as relative extensions while <code>AnticNumberField</code> and <code>NfAbsNS</code> are called absolute.</p><p>Internally, simple fields are essentially just (univariate) polynomial quotients in a dense representation, while non-simple fields are multivariate quotient rings, thus have a sparse presentation. In general, simple fields allow much faster arithmetic, while  the non-simple fields give easy access to large degree fields.</p><h2><a class="nav-anchor" id="Absolute-Simple-Fields-1" href="#Absolute-Simple-Fields-1">Absolute Simple Fields</a></h2><p>The most basic number field type is that of <code>AnticNumberField</code>. Internally this is essentially represented as a unvariate quotient with the arithmetic provided by the antic-c-library and implemented in Nemo.</p><h3><a class="nav-anchor" id="Creation-1" href="#Creation-1">Creation</a></h3><p>Number fields are mostly created using <code>NumberField</code>, but also using <code>number_field</code>.</p><p>Many of the constructors have arguments of type <code>Symbol</code> or <code>AbstractString</code>, if used, they define the appearance in printing, and printing only. The named parameter <code>check</code> can be <code>true</code> or <code>false, the default being</code>true`. This parameter controlls is the polynomial defining the number field is tested for irreducibility or not. Given that this can be potentially  very time consuiming if the degree if large, one can omit this test. Note however, that the behaviour of Hecke is undefined if a reducible polynomial is used to define a <em>field</em>.</p><p>The named boolean parameter <code>cached</code> is inherited from the underlying Nemo system. Two number fields defined using the same polynomial from the identical polynomial ring and the same (identical) symbol/ string will be identical if <code>cached == true</code> and different if <code>cached == false</code>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nemo.NumberField-Tuple{fmpq_poly}" href="#Nemo.NumberField-Tuple{fmpq_poly}"><code>Nemo.NumberField</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">NumberField(f::fmpq_poly; cached::Bool = true, check::Bool = true)</code></pre><blockquote><p>The number field Q[x]/f generated by f.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hecke.cyclotomic_field-Tuple{Int64}" href="#Hecke.cyclotomic_field-Tuple{Int64}"><code>Hecke.cyclotomic_field</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">cyclotomic_field(n::Int) -&gt; AnticNumberField, nf_elem</code></pre><p>The <span>$n$</span>-th cyclotomic field defined by the <span>$n$</span>-the cyclotomic polynomial.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hecke.wildanger_field-Tuple{Int64,fmpz}" href="#Hecke.wildanger_field-Tuple{Int64,fmpz}"><code>Hecke.wildanger_field</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">wildanger_field(n::Int, B::fmpz) -&gt; AnticNumberField, nf_elem
wildanger_field(n::Int, B::Integer) -&gt; AnticNumberField, nf_elem</code></pre><p>Returns the field with defining polynomial <span>$x^n + \sum_{i=0}^{n-1} (-1)^{n-i}Bx^i$</span>. These fields tend to have non-trivial class groups.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hecke.pure_extension-Tuple{Int64,Integer}" href="#Hecke.pure_extension-Tuple{Int64,Integer}"><code>Hecke.pure_extension</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">pure_extension(n::Int, gen::Integer; cached::Bool = true, check::Bool = true) -&gt; AnticNumberField, nf_elem
pure_extension(n::Int, gen::fmpz; cached::Bool = true, check::Bool = true) -&gt; AnticNumberField, nf_elem</code></pre><p>The number field with defining polynomial <span>$x^n-gen$</span>.</p></div></section><h3><a class="nav-anchor" id="Example-1" href="#Example-1">Example</a></h3><pre><code class="language-julia-repl">
julia&gt; Qx, x = PolynomialRing(FlintQQ, &quot;x&quot;);

julia&gt; K, a = NumberField(x^2 - 10, &quot;a&quot;);</code></pre><h2><a class="nav-anchor" id="Absolute-Non-Simple-Fields-1" href="#Absolute-Non-Simple-Fields-1">Absolute Non-Simple Fields</a></h2><h3><a class="nav-anchor" id="Creation-2" href="#Creation-2">Creation</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nemo.NumberField" href="#Nemo.NumberField"><code>Nemo.NumberField</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">number_field(f::Array{fmpq_poly, 1}, s::String=&quot;_\$&quot;) -&gt; NfAbsNS</code></pre><blockquote><p>Let <span>$f = (f_1, \ldots, f_n)$</span> be univariate rational polynomials, then we construct </p></blockquote><div>\[K = Q[t_1, \ldots, t_n]/\langle f_1(t_1), \ldots, f_n(t_n)\rangle\]</div><blockquote><p>The ideal bust be maximal, however, this is not tested.</p></blockquote></div></section><h3><a class="nav-anchor" id="Example-2" href="#Example-2">Example</a></h3><pre><code class="language-julia-repl">
julia&gt; Qx, x = PolynomialRing(FlintQQ, &quot;x&quot;);

julia&gt; K, g = number_field([x^2-2, x^2-3, x^2-5])
(Non-simple number field with defining polynomials fmpq_mpoly[_$1^2 - 2, _$2^2 - 3, _$3^2 - 5], NfAbsNSElem[_$1, _$2, _$3])

julia&gt; g[1]^2
2

julia&gt; minpoly(g[1] + g[2])
x^4-10*x^2+1</code></pre><h3><a class="nav-anchor" id="Conversion-1" href="#Conversion-1">Conversion</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hecke.simple_extension-Tuple{NfAbsNS}" href="#Hecke.simple_extension-Tuple{NfAbsNS}"><code>Hecke.simple_extension</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">simple_extension(K::NfAbsNS) -&gt; AnticNumberField, Map</code></pre><blockquote><p>For a non-simple extension <span>$K$</span> of <span>$Q$</span>, find a primitive element and thus an isomorphic simple extension of <span>$Q$</span>. The map realises this isomorphism.</p></blockquote></div></section><h2><a class="nav-anchor" id="Simple-Relative-Fields-1" href="#Simple-Relative-Fields-1">Simple Relative Fields</a></h2><h3><a class="nav-anchor" id="Creation-3" href="#Creation-3">Creation</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nemo.NumberField-Tuple{AbstractAlgebra.Generic.Poly}" href="#Nemo.NumberField-Tuple{AbstractAlgebra.Generic.Poly}"><code>Nemo.NumberField</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">NumberField(f::Generic.Poly{T}, s::String; cached::Bool = false, check::Bool = false) where T</code></pre><blockquote><p>Given an irreducible polynomial <span>$f$</span> over some number field <span>$K$</span>, create the field <span>$K[t]/f$</span>. <span>$f$</span> must be irreducible - although this is not tested.</p></blockquote></div><div><pre><code class="language-none">NumberField(f::Generic.Poly{T}; cached::Bool = false, check::Bool = false) where T</code></pre><blockquote><p>Given an irreducible polynomial <span>$f$</span> over some number field <span>$K$</span>, create the field <span>$K[t]/f$</span>. <span>$f$</span> must be irreducible - although this is not tested.</p></blockquote></div><div><pre><code class="language-none">number_field(f::Array{Generic.Poly{T}, 1}, s::String=&quot;_\$&quot;) where T -&gt; NfRel_ns</code></pre><blockquote><p>Given polynomials <span>$f = (f_1, \ldots, f_n)$</span> over some number field <span>$k$</span>, construct <span>$K = k[t_1, \ldots, t_n]/\langle f_1(t_1), \ldots, f_n(t_n)\rangle$</span> The ideal in the quotient must be maximal - although this is not tested.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nemo.NumberField-Tuple{AbstractAlgebra.Generic.Poly,String}" href="#Nemo.NumberField-Tuple{AbstractAlgebra.Generic.Poly,String}"><code>Nemo.NumberField</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">NumberField(f::Generic.Poly{T}, s::String; cached::Bool = false, check::Bool = false) where T</code></pre><blockquote><p>Given an irreducible polynomial <span>$f$</span> over some number field <span>$K$</span>, create the field <span>$K[t]/f$</span>. <span>$f$</span> must be irreducible - although this is not tested.</p></blockquote></div></section><h3><a class="nav-anchor" id="Conversion-2" href="#Conversion-2">Conversion</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hecke.absolute_field-Tuple{Hecke.NfRel{nf_elem}}" href="#Hecke.absolute_field-Tuple{Hecke.NfRel{nf_elem}}"><code>Hecke.absolute_field</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">absolute_field(K::NfRel{nf_elem}, cached::Bool = false) -&gt; AnticNumberField, Map, Map</code></pre><blockquote><p>Given an extension <span>$K/k/Q$</span>, find an isomorphic extensino of <span>$Q$</span>.</p></blockquote></div><div><pre><code class="language-none">absolute_field(K::NfRel{NfRelElem}, cached::Bool = false) -&gt; NfRel, Map, Map</code></pre><blockquote><p>Given an extension <span>$E/K/k$</span>, find an isomorphic extension of <span>$k$</span>. In a tower, only the top-most steps are collapsed.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hecke.absolute_field-Tuple{Hecke.NfRel{Hecke.NfRelElem}}" href="#Hecke.absolute_field-Tuple{Hecke.NfRel{Hecke.NfRelElem}}"><code>Hecke.absolute_field</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">absolute_field(K::NfRel{NfRelElem}, cached::Bool = false) -&gt; NfRel, Map, Map</code></pre><blockquote><p>Given an extension <span>$E/K/k$</span>, find an isomorphic extension of <span>$k$</span>. In a tower, only the top-most steps are collapsed.</p></blockquote></div></section><h2><a class="nav-anchor" id="Non-Simple-Relative-Fields-1" href="#Non-Simple-Relative-Fields-1">Non-Simple Relative Fields</a></h2><h3><a class="nav-anchor" id="Creation-4" href="#Creation-4">Creation</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nemo.NumberField-Union{Tuple{Array{Poly{T},1}}, Tuple{T}, Tuple{Array{Poly{T},1},String}} where T" href="#Nemo.NumberField-Union{Tuple{Array{Poly{T},1}}, Tuple{T}, Tuple{Array{Poly{T},1},String}} where T"><code>Nemo.NumberField</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">number_field(f::Array{Generic.Poly{T}, 1}, s::String=&quot;_\$&quot;) where T -&gt; NfRel_ns</code></pre><blockquote><p>Given polynomials <span>$f = (f_1, \ldots, f_n)$</span> over some number field <span>$k$</span>, construct <span>$K = k[t_1, \ldots, t_n]/\langle f_1(t_1), \ldots, f_n(t_n)\rangle$</span> The ideal in the quotient must be maximal - although this is not tested.</p></blockquote></div></section><h3><a class="nav-anchor" id="Conversion-3" href="#Conversion-3">Conversion</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hecke.simple_extension-Tuple{NfRel_ns}" href="#Hecke.simple_extension-Tuple{NfRel_ns}"><code>Hecke.simple_extension</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">simple_extension(K::NfRel_ns{nf_elem}) -&gt; NfRel, Map</code></pre><blockquote><p>Compute a simple field L as an extension of the base field of K and an isomorphism between L and K </p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hecke.simple_extension-Tuple{NfRel_ns{nf_elem},FlintRationalField}" href="#Hecke.simple_extension-Tuple{NfRel_ns{nf_elem},FlintRationalField}"><code>Hecke.simple_extension</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">simple_extension(K::NfRel_ns{nf_elem}, FlintQQ) -&gt; AnticNumberField, Map, Map

absolute_field(K::NfRel_ns{nf_elem}) -&gt; AnticNumberField, Map, Map</code></pre><blockquote><p>Compute an isomorphic field as an extension of <span>$Q$</span> together with the isomorphism  (1st map) and the embedding of the base field (2nd map).</p></blockquote></div></section><h2><a class="nav-anchor" id="Implicit-Relative-Extensions-1" href="#Implicit-Relative-Extensions-1">Implicit Relative Extensions</a></h2><p>Given two absolute fields <span>$K$</span> and <span>$k$</span> as well as an embedding <span>$\phi:k \to K$</span> we can regard <span>$K$</span> as an extension on <span>$k$</span>, hence invariante of <span>$K$</span> can be investigated relative to <span>$k$</span> rathern than over <span>$Q$</span>. Here we list functions achieving this without actually computing <span>$K$</span> as an extension of <span>$k$</span>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.minimum-Union{Tuple{T}, Tuple{T,NfAbsOrdIdl{AnticNumberField,nf_elem}}} where T&lt;:(Map{AnticNumberField,AnticNumberField,S,T} where T where S)" href="#Base.minimum-Union{Tuple{T}, Tuple{T,NfAbsOrdIdl{AnticNumberField,nf_elem}}} where T&lt;:(Map{AnticNumberField,AnticNumberField,S,T} where T where S)"><code>Base.minimum</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">minimum(m::T, I::NfOrdIdl) where T &lt;: Map{AnticNumberField, AnticNumberField} -&gt; NfOrdIdl</code></pre><blockquote><p>Given an embedding <span>$m:k\to K$</span> of number fields and an integral ideal in <span>$K$</span>, find the  intersect <span>$I \cap \Z_k$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.norm-Union{Tuple{T}, Tuple{T,NfAbsOrdIdl{AnticNumberField,nf_elem}}} where T&lt;:(Map{AnticNumberField,AnticNumberField,S,T} where T where S)" href="#LinearAlgebra.norm-Union{Tuple{T}, Tuple{T,NfAbsOrdIdl{AnticNumberField,nf_elem}}} where T&lt;:(Map{AnticNumberField,AnticNumberField,S,T} where T where S)"><code>LinearAlgebra.norm</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">norm(m::T, I::NfOrdIdl) where T &lt;: Map{AnticNumberField, AnticNumberField} -&gt; NfOrdIdl</code></pre><blockquote><p>Given an embedding <span>$m:k\to K$</span> of number fields and an integral ideal in <span>$K$</span>, find the norm <span>$N_{K/k}(I)$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.norm-Union{Tuple{T}, Tuple{T,nf_elem}} where T&lt;:(Map{AnticNumberField,AnticNumberField,S,T} where T where S)" href="#LinearAlgebra.norm-Union{Tuple{T}, Tuple{T,nf_elem}} where T&lt;:(Map{AnticNumberField,AnticNumberField,S,T} where T where S)"><code>LinearAlgebra.norm</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">norm(m::T, a::nf_elem) where T &lt;: Map{AnticNumberField, AnticNumberField} -&gt; nf_elem</code></pre><blockquote><p>Given an embedding <span>$m:k\to K$</span> of number fields and an element in <span>$K$</span>, find the norm <span>$N_{K/k}(a)$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractAlgebra.Generic.discriminant-Tuple{Map,NfAbsOrd{AnticNumberField,nf_elem}}" href="#AbstractAlgebra.Generic.discriminant-Tuple{Map,NfAbsOrd{AnticNumberField,nf_elem}}"><code>AbstractAlgebra.Generic.discriminant</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">discriminant(m::Map, R::NfOrd) -&gt; NfOrdIdl</code></pre><blockquote><p>The discriminant ideal of <span>$R$</span> over the maximal order of the domain of the map <span>$m$</span>,  that is, the ideal generated by all norms of differents of elements in <span>$R$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hecke.NfAbsOrdIdlSet" href="#Hecke.NfAbsOrdIdlSet"><code>Hecke.NfAbsOrdIdlSet</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">(::NfAbsOrdIdlSet)(m::Map, I::NfOrdIdl) -&gt; NfOrdIdl</code></pre><blockquote><p>Given an embedding <span>$m:k\to K$</span> of number fields and an ideal <span>$I$</span> in <span>$k$</span>, find the ideal above <span>$I$</span> in <span>$K$</span>.</p></blockquote></div></section><h2><a class="nav-anchor" id="Invariants-1" href="#Invariants-1">Invariants</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractAlgebra.Generic.degree-Tuple{AnticNumberField}" href="#AbstractAlgebra.Generic.degree-Tuple{AnticNumberField}"><code>AbstractAlgebra.Generic.degree</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">degree(a::AnticNumberField)</code></pre><blockquote><p>Return the degree of the given number field, i.e. the degree of its defining polynomial.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hecke.basis-Tuple{AnticNumberField}" href="#Hecke.basis-Tuple{AnticNumberField}"><code>Hecke.basis</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">basis(K::AnticNumberField) -&gt; Vector{nf_elem}</code></pre><p>Returns the power basis of <span>$K$</span>, that is, the elements <span>$1,a,\dotsc,a^{d - 1}$</span>, where <span>$d$</span> is the degree of <span>$K$</span>.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractAlgebra.Generic.discriminant-Tuple{AnticNumberField}" href="#AbstractAlgebra.Generic.discriminant-Tuple{AnticNumberField}"><code>AbstractAlgebra.Generic.discriminant</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">discriminant(K::AnticNumberField) -&gt; fmpq
discriminant(K::NfRel) -&gt;</code></pre><blockquote><p>The discriminant of the defining polynomial of <span>$K$</span> {\bf not} the discriminant  of the maximal order.</p></blockquote></div></section><h2><a class="nav-anchor" id="Elements-1" href="#Elements-1">Elements</a></h2><h3><a class="nav-anchor" id="Creation-5" href="#Creation-5">Creation</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nemo.AnticNumberField" href="#Nemo.AnticNumberField"><code>Nemo.AnticNumberField</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">(a::AnticNumberField)()</code></pre><blockquote><p>Return an empty (0) element.    </p></blockquote></div><div><pre><code class="language-none">(a::AnticNumberField)(c::Int)</code></pre><blockquote><p>Return <span>$c$</span> as an element in <span>$a$</span>.</p></blockquote></div></section><h3><a class="nav-anchor" id="Invariants-2" href="#Invariants-2">Invariants</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.norm-Tuple{nf_elem}" href="#LinearAlgebra.norm-Tuple{nf_elem}"><code>LinearAlgebra.norm</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">norm(a::nf_elem)</code></pre><blockquote><p>Return the absolute norm of <span>$a$</span>. The result will be a rational number.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractAlgebra.Generic.minpoly-Tuple{nf_elem}" href="#AbstractAlgebra.Generic.minpoly-Tuple{nf_elem}"><code>AbstractAlgebra.Generic.minpoly</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">minpoly(S::Ring, M::MatElem{T}, charpoly_only::Bool = false) where {T &lt;: FieldElement}</code></pre><blockquote><p>Returns the minimal polynomial <span>$p$</span> of the matrix <span>$M$</span>. The polynomial ring <span>$S$</span> of the resulting polynomial must be supplied and the matrix must be square.</p></blockquote></div><div><pre><code class="language-none">minpoly(S::Ring, M::MatElem{T}, charpoly_only::Bool = false) where {T &lt;: RingElement}</code></pre><blockquote><p>Returns the minimal polynomial <span>$p$</span> of the matrix <span>$M$</span>. The polynomial ring <span>$S$</span> of the resulting polynomial must be supplied and the matrix must be square.</p></blockquote></div><div><pre><code class="language-none">minpoly(S::Ring, M::MatAlgElem{T}, charpoly_only::Bool = false) where {T &lt;: RingElement}</code></pre><blockquote><p>Returns the minimal polynomial <span>$p$</span> of the matrix <span>$M$</span>. The polynomial ring <span>$S$</span> of the resulting polynomial must be supplied and the matrix must be square.</p></blockquote></div><div><hr/><pre><code class="language-none">minpoly(a::nf_elem) -&gt; fmpq_poly</code></pre><blockquote><p>The minimal polynomial of a.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractAlgebra.Generic.charpoly-Tuple{nf_elem}" href="#AbstractAlgebra.Generic.charpoly-Tuple{nf_elem}"><code>AbstractAlgebra.Generic.charpoly</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">charpoly(V::Ring, Y::Generic.MatrixElem{T}) where {T &lt;: RingElement}</code></pre><blockquote><p>Returns the characteristic polynomial <span>$p$</span> of the matrix <span>$M$</span>. The polynomial ring <span>$R$</span> of the resulting polynomial must be supplied and the matrix is assumed to be square.</p></blockquote></div><div><hr/><pre><code class="language-none">charpoly(a::nf_elem) -&gt; fmpq_poly</code></pre><p>The characteristic polynomial of a.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.denominator-Tuple{nf_elem}" href="#Base.denominator-Tuple{nf_elem}"><code>Base.denominator</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">denominator(a::nf_elem)</code></pre><blockquote><p>Return the denominator of the polynomial representation of the given number field element.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.numerator-Tuple{nf_elem}" href="#Base.numerator-Tuple{nf_elem}"><code>Base.numerator</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">numerator(a::nf_elem) -&gt; nf_elem</code></pre><blockquote><p>For an element <span>$a\in K = Q[t]/f$</span> write <span>$a$</span> as <span>$b/d$</span> with <span>$b\in Z[t]$</span>, <span>$\deg(a) = \deg(b)$</span> and <span>$d&gt;0$</span> minimal in <span>$Z$</span>. This function returns <span>$b$</span>.</p></blockquote></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractAlgebra.Generic.isunit-Tuple{nf_elem}" href="#AbstractAlgebra.Generic.isunit-Tuple{nf_elem}"><code>AbstractAlgebra.Generic.isunit</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">isunit(a::nf_elem)</code></pre><blockquote><p>Return <code>true</code> if the given number field element is invertible, i.e. nonzero, otherwise return <code>false</code>.</p></blockquote></div></section><footer><hr/><a class="previous" href="../index.html"><span class="direction">Previous</span><span class="title">Hecke</span></a><a class="next" href="../orders/introduction.html"><span class="direction">Next</span><span class="title">Introduction</span></a></footer></article></body></html>
