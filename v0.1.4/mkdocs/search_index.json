{
    "docs": [
        {
            "location": "/", 
            "text": "Hecke\n\n\nBuilds\n\n\n\n\n\n\nAbout\n\n\nHecke is a software package for algebraic number theory maintained by Claus Fieker and Tommy Hofmann. It is written in \njulia\n and is based on the computer algebra package \nNemo\n.\n\n\n\n\nhttps://github.com/thofma/Hecke.jl\n (Source code)\n\n\nhttp://thofma.github.io/Hecke.jl/latest/\n (Online documentation)\n\n\n\n\nSo far, Hecke provides the following features:\n\n\n\n\nOrders (including element and ideal arithmetic) in number fields\n\n\nComputation of maximal orders\n\n\nVerified residue computations of Dedekind zeta functions\n\n\nFactor base creation and relations search in number fields\n\n\nLattice enumeration\n\n\nSparse linear algebra\n\n\n\n\n\n\nInstallation\n\n\nTo use Hecke, a julia version of 0.4 or higher is necessary (the latest stable julia version will do). Please see \nhttp://julialang.org/downloads\n for instructions on how to obtain julia for your system. Once a suitable julia version is installed, use the following steps at the julia prompt to install Hecke:\n\n\njulia\n \nPkg\n.\nclone\n(\nhttps://github.com/nemocas/Nemo.jl\n)\n\n\njulia\n \nPkg\n.\nclone\n(\nhttps://github.com/thofma/Hecke.jl\n)\n\n\njulia\n \nPkg\n.\nbuild\n(\nHecke\n)\n\n\n\n\n\n\n\n\nQuick start\n\n\nHere is a quick example of using Hecke:\n\n\njulia\n \nusing\n \nHecke\n\n\n...\n\n\n\nWelcome\n \nto\n \n\n  \n_\n    \n_\n           \n_\n        \n \n|\n \n|\n  \n|\n \n|\n         \n|\n \n|\n       \n \n|\n \n|\n__\n|\n \n|\n \n___\n  \n___\n|\n \n|\n \n_____\n \n \n|\n  \n__\n  \n|/\n \n_\n \\\n/\n \n__\n|\n \n|/\n \n/\n \n_\n \\\n \n|\n \n|\n  \n|\n \n|\n  \n__\n/\n \n(\n__\n|\n   \n  \n__\n/\n\n \n|\n_\n|\n  \n|\n_\n|\n\\\n___\n|\n\\\n___\n|\n_\n|\n\\\n_\n\\\n___\n|\n\n\n\nVersion\n \n0.1\n-\ndev\n \n...\n \n \n...\n \nwhich\n \ncomes\n \nwith\n \nabsolutely\n \nno\n \nwarrant\n \nwhatsoever\n\n\n(\nc\n)\n \n2015\n \nby\n \nClaus\n \nFieker\n \nand\n \nTommy\n \nHofmann\n\n\n\njulia\n \nQx\n,\n \nx\n \n=\n \nPolynomialRing\n(\nQQ\n,\n \nx\n);\n\n\njulia\n \nf\n \n=\n \nx\n^\n3\n \n+\n \n2\n;\n\n\njulia\n \nK\n,\n \na\n \n=\n \nNumberField\n(\nf\n,\n \na\n);\n\n\njulia\n \nO\n \n=\n \nMaximalOrder\n(\nK\n);\n\n\njulia\n \nO\n\n\nMaximal\n \norder\n \nof\n \nNumber\n \nfield\n \nover\n \nRational\n \nField\n \nwith\n \ndefining\n \npolynomial\n \nx\n^\n3\n \n+\n \n2\n \n\nwith\n \nbasis\n \n[\n1\n,\na\n,\na\n^\n2\n]\n\n\n\n\n\n\n\n\nDocumentation\n\n\nThe online documentation can be found here: [http://hecke.readthedocs.org/en/latest/]\n\n\nThe documentation of the single functions can also be accessed at the julia prompt. Here is an example:\n\n\nhelp?\n signature\nsearch: signature\n\n  ----------------------------------------------------------------------------\n\n  signature(O::NfMaximalOrder) -\n Tuple{Int, Int}\n\n  |  Returns the signature of the ambient number field of \\mathcal O.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/#hecke", 
            "text": "Builds", 
            "title": "Hecke"
        }, 
        {
            "location": "/#about", 
            "text": "Hecke is a software package for algebraic number theory maintained by Claus Fieker and Tommy Hofmann. It is written in  julia  and is based on the computer algebra package  Nemo .   https://github.com/thofma/Hecke.jl  (Source code)  http://thofma.github.io/Hecke.jl/latest/  (Online documentation)   So far, Hecke provides the following features:   Orders (including element and ideal arithmetic) in number fields  Computation of maximal orders  Verified residue computations of Dedekind zeta functions  Factor base creation and relations search in number fields  Lattice enumeration  Sparse linear algebra", 
            "title": "About"
        }, 
        {
            "location": "/#installation", 
            "text": "To use Hecke, a julia version of 0.4 or higher is necessary (the latest stable julia version will do). Please see  http://julialang.org/downloads  for instructions on how to obtain julia for your system. Once a suitable julia version is installed, use the following steps at the julia prompt to install Hecke:  julia   Pkg . clone ( https://github.com/nemocas/Nemo.jl )  julia   Pkg . clone ( https://github.com/thofma/Hecke.jl )  julia   Pkg . build ( Hecke )", 
            "title": "Installation"
        }, 
        {
            "location": "/#quick-start", 
            "text": "Here is a quick example of using Hecke:  julia   using   Hecke  ...  Welcome   to  \n\n   _      _             _         \n  |   |    |   |           |   |        \n  |   | __ |   |   ___    ___ |   |   _____  \n  |    __    |/   _  \\ /   __ |   |/   /   _  \\\n  |   |    |   |    __ /   ( __ |        __ / \n  | _ |    | _ | \\ ___ | \\ ___ | _ | \\ _ \\ ___ |  Version   0.1 - dev   ...  \n  ...   which   comes   with   absolutely   no   warrant   whatsoever  ( c )   2015   by   Claus   Fieker   and   Tommy   Hofmann  julia   Qx ,   x   =   PolynomialRing ( QQ ,   x );  julia   f   =   x ^ 3   +   2 ;  julia   K ,   a   =   NumberField ( f ,   a );  julia   O   =   MaximalOrder ( K );  julia   O  Maximal   order   of   Number   field   over   Rational   Field   with   defining   polynomial   x ^ 3   +   2   with   basis   [ 1 , a , a ^ 2 ]", 
            "title": "Quick start"
        }, 
        {
            "location": "/#documentation", 
            "text": "The online documentation can be found here: [http://hecke.readthedocs.org/en/latest/]  The documentation of the single functions can also be accessed at the julia prompt. Here is an example:  help?  signature\nsearch: signature\n\n  ----------------------------------------------------------------------------\n\n  signature(O::NfMaximalOrder) -  Tuple{Int, Int}\n\n  |  Returns the signature of the ambient number field of \\mathcal O.", 
            "title": "Documentation"
        }, 
        {
            "location": "/numberfields/introduction/", 
            "text": "Introduction", 
            "title": "Introduction"
        }, 
        {
            "location": "/numberfields/introduction/#introduction", 
            "text": "", 
            "title": "Introduction"
        }, 
        {
            "location": "/numberfields/orders/", 
            "text": "Creation\n\n\nOrder(B::Array{nf_elem, 1}, check::Bool = true) -\n NfOrd\n\n\n\n\n\n\n\nReturns the order with \n\\mathbf Z\n-basis \nB\n. If \ncheck\n is set, it is checked whether \nB\n defines an order.\n\n\n\n\nOrder(K::AnticNumberField, A::FakeFmpqMat, check::Bool = true) -\n NfOrd\n\n\n\n\n\n\n\nReturns the order which has basis matrix \nA\n with respect to the power basis of \nK\n. If \ncheck\n is set, it is checked whether \nA\n defines an order.\n\n\n\n\nEquationOrder(K::AnticNumberField) -\n NfOrd\n\n\n\n\n\n\n\nReturns the equation of the number field \nK\n.\n\n\n\n\n\n\nExample\n\n\njulia\n \nQx\n,\n \nx\n \n=\n \nPolynomialRing\n(\nQQ\n,\n \nx\n);\n\n\n\njulia\n \nK\n,\n \na\n \n=\n \nNumberField\n(\nx\n^\n2\n \n-\n \n2\n,\n \na\n);\n\n\n\njulia\n \nO\n \n=\n \nEquationOrder\n(\nK\n)\n\n\nOrder\n \nof\n \nNumber\n \nfield\n \nover\n \nRational\n \nField\n \nwith\n \ndefining\n \npolynomial\n \nx\n^\n2\n \n-\n \n2\n\n\nwith\n \nZ\n-\nbasis\n \n[\n1\n,\na\n]\n\n\n\n\n\n\n\n\nNote\n\n\nInternally there is a difference between arbitary orders and maximal orders.     An order will be treated as a maximal order, that is, as the ring of integers,     if it was computed in the following way.\n\n\n\n\n\n\nmaximal_order(K::AnticNumberField) -\n NfMaxOrd\nring_of_integers(K::AnticNumberField) -\n NfMaxOrd\n\n\n\n\n\n\n\nReturns the maximal order of \nK\n.\n\n\n\n\n\n\nmaximal_order(K::AnticNumberField, primes::Array{fmpz, 1}) -\n NfMaxOrd\nmaximal_order(K::AnticNumberField, primes::Array{Integer, 1}) -\n NfMaxOrd\nring_of_integers(K::AnticNumberField, primes::Array{fmpz, 1}) -\n NfMaxOrd\nring_of_integers(K::AnticNumberField, primes::Array{Integer, 1}) -\n NfMaxOrd\n\n\n\n\n\n\n\nAssuming that \nprimes\n contains all the prime numbers at which the equation order \n\\mathbf{Z}[\\alpha]\n of \nK = \\mathbf{Q}(\\alpha)\n is not maximal (e.g. \nprimes\n may contain all prime divisors of the discriminant of \n\\mathbf Z[\\alpha]\n), this function returns the maximal order of \nK\n.\n\n\n\n\n\n\nmake_maximal(O::NfOrd) -\n NfMaxOrd\n\n\n\n\n\n\n\nAssuming that \n\\mathcal O\n is an order, this function returns the same order as a maximal order.\n\n\n\n\njulia\n \nQx\n,\n \nx\n \n=\n \nPolynomialRing\n(\nQQ\n,\n \nx\n);\n\n\n\njulia\n \nK\n,\n \na\n \n=\n \nNumberField\n(\nx\n^\n2\n \n-\n \n2\n,\n \na\n);\n\n\n\njulia\n \nR\n \n=\n \nEquationOrder\n(\nK\n)\n\n\nOrder\n \nof\n \nNumber\n \nfield\n \nover\n \nRational\n \nField\n \nwith\n \ndefining\n \npolynomial\n \nx\n^\n2\n \n-\n \n2\n\n\nwith\n \nZ\n-\nbasis\n \n[\n1\n,\na\n]\n\n\n\njulia\n \nS\n \n=\n \nmake_maximal\n(\nR\n)\n\n\nMaximal\n \norder\n \nof\n \nNumber\n \nfield\n \nover\n \nRational\n \nField\n \nwith\n \ndefining\n \npolynomial\n \nx\n^\n2\n \n-\n \n2\n\n\nwith\n \nbasis\n \n[\n1\n,\na\n]\n\n\n\njulia\n \nT\n \n=\n \nmaximal_order\n(\nK\n)\n\n\nMaximal\n \norder\n \nof\n \nNumber\n \nfield\n \nover\n \nRational\n \nField\n \nwith\n \ndefining\n \npolynomial\n \nx\n^\n2\n \n-\n \n2\n\n\nwith\n \nbasis\n \n[\n1\n,\na\n]\n\n\n\njulia\n \nbasis_mat\n(\nS\n)\n \n==\n \nbasis_mat\n(\nT\n)\n\n\ntrue\n\n\n\n\n\n\n\n\nBasic properties\n\n\nsignature(O::NfOrd) -\n Tuple{Int, Int}\n\n\n\n\n\n\n\nReturns the signature of the ambient number field of \n\\mathcal O\n.\n\n\n\n\ndegree(O::NfOrd) -\n Int\n\n\n\n\n\n\n\nReturns the degree of \n\\mathcal O\n.\n\n\n\n\nnorm_change_const(O::NfOrd) -\n (Float64, Float64)\n\n\n\n\n\n\n\nReturns \n(c_1, c_2) \\in \\mathbf R_{>0}^2\n such that for all \nx = \\sum_{i=1}^d x_i \\omega_i \\in \\mathcal O\n we have \nT_2(x) \\leq c_1 \\cdot \\sum_i^d x_i^2\n and \n\\sum_i^d x_i^2 \\leq c_2 \\cdot T_2(x)\n, where \n(\\omega_i)_i\n is the \n\\mathbf Z\n-basis of \n\\mathcal O\n.\n\n\n\n\nisequationorder(O::NfOrd) -\n Bool\n\n\n\n\n\n\n\nReturns whether \n\\mathcal O\n is the equation order.\n\n\n\n\nnf(O::NfOrd) -\n AnticNumberField\n\n\n\n\n\n\n\nReturns the ambient number field of \n\\mathcal O\n.\n\n\n\n\nbasis(O::NfOrd) -\n Array{NfOrdElem, 1}\n\n\n\n\n\n\n\nReturns the \n\\mathbf Z\n-basis of \n\\mathcal O\n.\n\n\n\n\nbasis_mat(O::NfOrd) -\n FakeFmpqMat\n\n\n\n\n\n\n\nReturns the basis matrix of \n\\mathcal O\n with respect to the power basis of the ambient number field.\n\n\n\n\nbasis_mat_inv(O::NfOrd) -\n FakeFmpqMat\n\n\n\n\n\n\n\nReturns the inverse of the basis matrix of \n\\mathcal O\n.\n\n\n\n\ndiscriminant(O::NfOrd) -\n fmpz\n\n\n\n\n\n\n\nReturns the discriminant of \n\\mathcal O\n.\n\n\n\n\ngen_index(O::NfOrd) -\n fmpq\n\n\n\n\n\n\n\nGeneralized index of \n\\mathcal O\n with respect to the ambient equation order \n\\mathbf Z[\\alpha]\n.\n\n\n\n\nindex(O::NfOrd) -\n fmpz\n\n\n\n\n\n\n\nAssuming that the order \n\\mathcal O\n contains the ambient equation order \n\\mathbf Z[\\alpha]\n, this function returns the index \n[ \\mathcal O : \\mathbf ZZ]\n.\n\n\n\n\nis_index_divisor(O::NfOrd, d::fmpz) -\n Bool\nis_index_divisor(O::NfOrd, d::Int) -\n Bool\n\n\n\n\n\n\n\nReturns whether \nd\n is a divisor of the index of \n\\mathcal O\n.\n\n\n\n\nminkowski_mat(O::NfOrd, abs_tol::Int = 64) -\n arb_mat\n\n\n\n\n\n\n\nReturns the Minkowski matrix of \n\\mathcal O\n. Thus if \n\\mathcal O\n has degree \nd\n, then the result is a matrix in \n\\operatorname{Mat}_{d\\times d}(\\mathbf R)\n. The entries of the matrix are real balls of type \narb\n with radius less then \n2^-abs_tol\n.\n\n\n\n\nin(a::nf_elem, O::NfOrd) -\n Bool\n\n\n\n\n\n\n\nChecks whether \na\n lies in \n\\mathcal O\n.\n\n\n\n\nden(a::nf_elem, O::NfOrd) -\n fmpz\n\n\n\n\n\n\n\nReturns the smallest positive integer \nk\n such that \nk \\cdot a\n lies in O.\n\n\n\n\n+(R::NfOrd, S::NfOrd) -\n NfOrd\n\n\n\n\n\n\n\nGiven two orders \nR\n, \nS\n of \nK\n, this function returns the smallest order containing both \nR\n and \nS\n. It is assumed that \nR\n, \nS\n contain the ambient equation order and have coprime index.\n\n\n\n\npoverorder(O::NfOrd, p::fmpz) -\n NfOrd\npoverorder(O::NfOrd, p::Integer) -\n NfOrd\n\n\n\n\n\n\n\nThis function tries to find an order that is locally larger than \n\\mathcal O\n at the prime \np\n: If \np\n divides the index \n[ \\mathcal O_K : \\mathcal O]\n, this function will return an order \n\\tilde{\\mathcal O}\n such that \nv_p([ \\mathcal O_K : \\tilde{\\mathcal O}]) < v_p([ \\mathcal O_K : \\mathcal O])\n. Otherwise \n\\mathcal O\n is returned.\n\n\n\n\npmaximal_overorder(O::NfOrd, p::fmpz) -\n NfOrd\npmaximal_overorder(O::NfOrd, p::Integer) -\n NfOrd\n\n\n\n\n\n\n\nThis function finds a \np\n-maximal order \n\\tilde{\\mathcal O}\n containing \n\\mathcal O\n. That is, the index \n[ \\mathcal O_K : \\tilde{\\mathcal O}]\n is not dividible by \np\n.\n\n\n\n\n\n\nElements\n\n\n\n\nCreation\n\n\n\n\n  call(O::NfOrd, a::nf_elem, check::Bool = true) -\n NfOrdElem\n\n\n\n\n\n\n\nGiven an element \na\n of the ambient number field of \n\\mathcal O\n, this function coerces the element into \n\\mathcal O\n. It will be checked that \na\n is contained in \n\\mathcal O\n if and only if \ncheck\n is \ntrue\n.\n\n\n\n\n\n\n  call(O::NfOrd, a::Union{fmpz, Integer}) -\n NfOrdElem\n\n\n\n\n\n\n\nGiven an element \na\n of type \nfmpz\n or \nInteger\n, this function coerces the element into \n\\mathcal O\n. It will be checked that \na\n is contained in \n\\mathcal O\n if and only if \ncheck\n is \ntrue\n.\n\n\n\n\n\n\n  call(O::NfOrd, arr::Array{fmpz, 1})\n\n\n\n\n\n\n\nReturns the element of \n\\mathcal O\n with coefficient vector \narr\n.\n\n\n\n\n\n\n  call{T \n: Integer}(O::NfOrd, arr::Array{T, 1})\n\n\n\n\n\n\n\nReturns the element of \n\\mathcal O\n with coefficient vector \narr\n.\n\n\n\n\n\n\n  call(O::NfOrd) -\n NfOrdElem\n\n\n\n\n\n\n\nThis function constructs a new element of \n\\mathcal O\n which is set to \n0\n.\n\n\n\n\n\n\nBasic properties\n\n\n\n\nparent(a::NfOrdElem) -\n NfOrd\n\n\n\n\n\n\n\nReturns the order of which \na\n is an element.\n\n\n\n\n\n\nelem_in_nf(a::NfOrdElem) -\n nf_elem\n\n\n\n\n\n\n\nReturns the element \na\n considered as an element of the ambient number field.\n\n\n\n\n\n\nelem_in_basis(a::NfOrdElem) -\n Array{fmpz, 1}\n\n\n\n\n\n\n\nReturns the coefficient vector of \na\n.\n\n\n\n\n\n\ndiscriminant(B::Array{NfOrdElem, 1}) -\n fmpz\n\n\n\n\n\n\n\nReturns the discriminant of the family \nB\n.\n\n\n\n\n\n\n==(x::NfOrdElem, y::NfOrdElem) -\n Bool\n\n\n\n\n\n\n\nReturns whether \nx\n and \ny\n are equal.\n\n\n\n\n\n\nzero(O::NfOrd) -\n NfOrdElem\n\n\n\n\n\n\n\nReturns the zero element of \n\\mathcal O\n.\n\n\n\n\n\n\none(O::NfOrd) -\n NfOrdElem\n\n\n\n\n\n\n\nReturns the zero element of \n\\mathcal O\n.\n\n\n\n\n\n\niszero(a::NfOrd) -\n Bool\n\n\n\n\n\n\n\nTests if \na\n is one.\n\n\n\n\n\n\nisone(a::NfOrd) -\n Bool\n\n\n\n\n\n\n\nTests if \na\n is one.\n\n\n\n\n\n\nArithmetic\n\n\n\n\n-(x::NfOrdElem) -\n NfOrdElem\n\n\n\n\n\n\n\nReturns the additive inverse of \nx\n.\n\n\n\n\n\n\n+(x::NfOrdElem, y::NfOrdElem) -\n NfOrdElem\n\n\n\n\n\n\n\nReturns \nx + y\n.\n\n\n\n\n\n\n-(x::NfOrdElem, y::NfOrdElem) -\n NfOrdElem\n\n\n\n\n\n\n\nReturns \nx - y\n.\n\n\n\n\n\n\n*(x::NfOrdElem, y::NfOrdElem) -\n NfOrdElem\n\n\n\n\n\n\n\nReturns \nx \\cdot y\n.\n\n\n\n\n\n\n^(x::NfOrdElem, y::Union{fmpz, Int})\n\n\n\n\n\n\n\nReturns \nx^y\n.\n\n\n\n\n\n\nmod(a::NfOrdElem, m::Union{fmpz, Int}) -\n NfOrdElem\n\n\n\n\n\n\n\nReduces the coefficient vector of \na\n modulo \nm\n and returns the corresponding element. The coefficient vector of the result will have entries \nx\n with  \n0 \\leq x \\leq m\n.\n\n\n\n\n\n\npowermod(a::NfOrdElem, i::fmpz, m::Integer) -\n NfOrdElem\n\n\n\n\n\n\n\nReturns the element \na^i\n modulo \nm\n.\n\n\n\n\n\n\nMiscallenous\n\n\n\n\nrepresentation_mat(a::NfOrdElem) -\n fmpz_mat\n\n\n\n\n\n\n\nReturns the representation matrix of the element \na\n.\n\n\n\n\n\n\nrepresentation_mat(a::NfOrdElem, K::AnticNumberField) -\n FakeFmpqMat\n\n\n\n\n\n\n\nReturns the representation matrix of the element \na\n considered as an element of the ambient number field \nK\n. It is assumed that \nK\n is the ambient number field of the order of \na\n.\n\n\n\n\n\n\ntrace(a::NfOrdElem) -\n fmpz\n\n\n\n\n\n\n\nReturns the trace of \na\n.\n\n\n\n\n\n\nnorm(a::NfOrdElem) -\n fmpz\n\n\n\n\n\n\n\nReturns the norm of \na\n.\n\n\n\n\n\n\nrand(O::NfOrd, n::Union{Integer, fmpz}) -\n NfOrdElem\n\n\n\n\n\n\n\nComputes a coefficient vector with entries uniformly distributed in \n\\{-n,\\dotsc,-1,0,1,\\dotsc,n\\}\n and returns the corresponding element of the order \n\\mathcal O\n.\n\n\n\n\n\n\nminkowski_map(a::NfOrdElem, abs_tol::Int) -\n Array{arb, 1}\n\n\n\n\n\n\n\nReturns the image of \na\n under the Minkowski embedding. Every entry of the array returned is of type \narb\n with radius less then \n2^-abs_tol\n.\n\n\n\n\n\n\nconjugates_arb(x::NfOrdElem, abs_tol::Int) -\n Array{acb, 1}\n\n\n\n\n\n\n\nCompute the the conjugates of \nx\n as elements of type \nacb\n. Recall that we order the complex conjugates \n\\sigma_{r+1}(x),...,\\sigma_{r+2s}(x)\n such that \n\\sigma_{i}(x) = \\overline{\\sigma_{i + s}(x)}\n for \nr + 1 \\leq i \\leq r + s\n.\n\n\nEvery entry \ny\n of the array returned satisfies \nradius(real(y)) \n 2^-abs_tol\n, \nradius(imag(y)) \n 2^-abs_tol\n respectively.\n\n\n\n\n\n\nconjugates_arb_log(x::NfOrdElem, abs_tol::Int) -\n Array{arb, 1}\n\n\n\n\n\n\n\nReturns the elements \n(\\log(\\lvert \\sigma_1(x) \\rvert),\\dotsc,\\log(\\lvert\\sigma_r(x) \\rvert), \\dotsc,2\\log(\\lvert \\sigma_{r+1}(x) \\rvert),\\dotsc, 2\\log(\\lvert \\sigma_{r+s}(x)\\rvert))\n as elements of type \narb\n radius less then \n2^-abs_tol\n.\n\n\n\n\n\n\nt2(x::NfOrdElem, abs_tol::Int = 32) -\n arb\n\n\n\n\n\n\n\nReturn the \nT_2\n-norm of \nx\n. The radius of the result will be less than \n2^-abs_tol\n.\n\n\n\n\n\n\nIdeals\n\n\n\n\nCreation\n\n\n\n\nideal(O::NfOrd, a::Int) -\n NfOrdIdl\n\n\n\n\n\n\n\nReturns the ideal of \n\\mathcal O\n which is generated by \na\n.\n\n\n\n\n\n\nideal(O::NfOrd, a::fmpz) -\n NfOrdIdl\n\n\n\n\n\n\n\nReturns the ideal of \n\\mathcal O\n which is generated by \na\n.\n\n\n\n\n\n\nideal(O::NfOrd, A::fmpz_mat) -\n NfOrdIdl\n\n\n\n\n\n\n\nAssuming that \nA\n is a \nd \\times d\n nonsingular integer matrix, this function returns the ideal \nI\n given by \nI = \\bigoplus \\mathbf Z \\alpha_i\n, where \n(\\alpha_1,\\dotsc,\\alpha_d) = (\\omega_1,\\dotsc,\\omega_d) A^t\n.\n\n\n\n\n\n\nideal(O::NfOrd, a::NfOrdElem) -\n NfOrdIdl\n\n\n\n\n\n\n\nReturns the ideal of \n\\mathcal O\n which is generated by \na\n.\n\n\n\n\n\n\nring_of_multipliers(I::NfOrdIdl) -\n NfOrdGen\n\n\n\n\n\n\n\nComputes the order \n(I : I)\n, which is the set of all \nx \\in K\n with \nxI \\subseteq I\n.\n\n\n\n\n*(O::NfOrd, x::NfOrdElem) -\n NfOrdIdl\n*(x::NfOrdElem, O::NfOrd) -\n NfOrdIdl\n\n\n\n\n\n\n\nReturns the principal ideal \n(x)\n of \n\\mathcal O\n.\n\n\n\n\n\n\nArithmetic\n\n\n\n\n==(x::NfOrdIdl, y::NfOrdIdl)\n\n\n\n\n\n\n\nReturns whether \nx\n and \ny\n are equal.\n\n\n\n\n\n\n+(x::NfOrdIdl, y::NfOrdIdl)\n\n\n\n\n\n\n\nReturns \nx + y\n.\n\n\n\n\n*(x::NfOrdIdl, y::NfOrdIdl)\n\n\n\n\n\n\n\nReturns \nx \\cdot y\n.\n\n\n\n\nintersection(x::NfOrdIdl, y::NfOrdIdl) -\n NfOrdIdl\nlcm(x::NfOrdIdl, y::NfOrdIdl) -\n NfOrdIdl\n\n\n\n\n\n\n\nReturns \nx \\cap y\n.\n\n\n\n\n\n\nMiscaellenous\n\n\n\n\nparent(I::NfOrdIdl) -\n NfOrd\n\n\n\n\n\n\n\nReturns the order of \nI\n.\n\n\n\n\n\n\nbasis(I::NfOrdIdl) -\n Array{NfOrdElem, 1}\n\n\n\n\n\n\n\nReturns the \n\\mathbf Z\n-basis of \nI\n.\n\n\n\n\n\n\nbasis_mat(I::NfOrdIdl) -\n fmpz_mat\n\n\n\n\n\n\n\nReturns the basis matrix of \nI\n with respect to the basis of the order.\n\n\n\n\n\n\nminimum(I::NfOrdIdl) -\n fmpz\n\n\n\n\n\n\n\nReturns the minimum of \nI\n, that is, the minimum of \nI \\cap \\mathbf Z_{\\geq 0}\n, where \n\\mathcal O\n is the order of \nI\n.\n\n\n\n\n\n\nnorm(I::NfOrdIdl) -\n fmpz\n\n\n\n\n\n\n\nReturns the norm of \nI\n, that is, the cardinality of \n\\mathcal O/I\n, where \n\\mathcal O\n is the order of \nI\n.\n\n\n\n\n\n\nin(x::NfOrdElem, y::NfOrdIdl)\n\n\n\n\n\n\n\nReturns whether \nx\n is contained in \ny\n.\n\n\n\n\nidempotents(x::NfOrdIdl, y::NfOrdIdl) -\n NfOrdElem, NfOrdElem\n\n\n\n\n\n\n\nReturns a tuple \n(e, f)\n consisting of elements \ne in x\n, \nf in y\n such that \n1 = e + f\n.\n\n\nIf the ideals are not coprime, an error is raised.\n\n\n\n\n\n\nmod(x::NfOrdElem, I::NfOrdIdl)\n\n\n\n\n\n\n\nReturns the unique element \ny\n of the ambient order of \nx\n with \nx \\equiv y \\bmod I\n and the following property: If \na_1,\\dotsc,a_d \\in \\Z_{\\geq 1}\n are the diagonal entries of the unique HNF basis matrix of \nI\n and \n(b_1,\\dotsc,b_d)\n is the coefficient vector of \ny\n, then \n0 \\leq b_i < a_i\n for \n1 \\leq i \\leq d\n.\n\n\n\n\n\n\npradical(O::NfOrd, p::fmpz) -\n NfOrdIdl\n\n\n\n\n\n\n\nGiven a prime number \np\n, this function returns the \np\n-radical \n\\sqrt{p\\mathcal O}\n of \n\\mathcal O\n, which is  just \n\\{ x \\in \\mathcal O \\mid \\exists k \\in \\mathbf Z_{\\geq 0} \\colon x^k \\in p\\mathcal O \\}\n. It is not checked that \np\n is prime.\n\n\n\n\n\n\nFractional ideals\n\n\n\n\nCreation\n\n\n\n\nfrac_ideal(O::NfOrd, A::fmpz_mat, b::fmpz) -\n NfOrdFracIdl\n\n\n\n\n\n\n\nCreates the fractional ideal of \n\\mathcal O\n with basis matrix \nA/b\n.\n\n\n\n\n\n\nfrac_ideal(O::NfOrd, A::FakeFmpqMat) -\n NfOrdFracIdl\n\n\n\n\n\n\n\nCreates the fractional ideal of \n\\mathcal O\n with basis matrix \nA\n.\n\n\n\n\n\n\nfrac_ideal(O::NfOrd, I::NfOrdIdl) -\n NfOrdFracIdl\n\n\n\n\n\n\n\nTurns the ideal \nI\n into a fractional ideal of \n\\mathcal O\n.\n\n\n\n\n\n\nfrac_ideal(O::NfOrd, I::NfOrdIdl, b::fmpz) -\n NfOrdFracIdl\n\n\n\n\n\n\n\nCreates the fractional ideal \nI/b\n of \n\\mathcal O\n.\n\n\n\n\n\n\nfrac_ideal(O::NfOrd, a::nf_elem) -\n NfOrdFracIdl\n\n\n\n\n\n\n\nCreates the principal fractional ideal \n(a)\n of \n\\mathcal O\n.\n\n\n\n\n\n\nfrac_ideal(O::NfOrd, a::NfOrdElem) -\n NfOrdFracIdl\n\n\n\n\n\n\n\nCreates the principal fractional ideal \n(a)\n of \n\\mathcal O\n.\n\n\n\n\n\n\nArithmetic\n\n\n\n\n==(x::NfOrdFracIdl, y::NfOrdFracIdl) -\n Bool\n\n\n\n\n\n\n\nReturns whether \nx\n and \ny\n are equal.\n\n\n\n\n\n\nMiscaellenous\n\n\n\n\nbasis_mat(I::NfOrdFracIdl) -\n FakeFmpqMat\n\n\n\n\n\n\n\nReturns the basis matrix of \nI\n with respect to the basis of the order.\n\n\n\n\n\n\nbasis_mat_inv(I::NfOrdFracIdl) -\n FakeFmpqMat\n\n\n\n\n\n\n\nReturns the inverse of the basis matrix of \nI\n.\n\n\n\n\n\n\nbasis(I::NfOrdFracIdl) -\n Array{nf_elem, 1}\n\n\n\n\n\n\n\nReturns the \n\\mathbf Z\n-basis of \nI\n.\n\n\n\n\n\n\nnorm(I::NfOrdFracIdl) -\n fmpq\n\n\n\n\n\n\n\nReturns the norm of \nI", 
            "title": "Orders"
        }, 
        {
            "location": "/numberfields/orders/#creation", 
            "text": "Order(B::Array{nf_elem, 1}, check::Bool = true) -  NfOrd   Returns the order with  \\mathbf Z -basis  B . If  check  is set, it is checked whether  B  defines an order.   Order(K::AnticNumberField, A::FakeFmpqMat, check::Bool = true) -  NfOrd   Returns the order which has basis matrix  A  with respect to the power basis of  K . If  check  is set, it is checked whether  A  defines an order.   EquationOrder(K::AnticNumberField) -  NfOrd   Returns the equation of the number field  K .", 
            "title": "Creation"
        }, 
        {
            "location": "/numberfields/orders/#example", 
            "text": "julia   Qx ,   x   =   PolynomialRing ( QQ ,   x );  julia   K ,   a   =   NumberField ( x ^ 2   -   2 ,   a );  julia   O   =   EquationOrder ( K )  Order   of   Number   field   over   Rational   Field   with   defining   polynomial   x ^ 2   -   2  with   Z - basis   [ 1 , a ]    Note  Internally there is a difference between arbitary orders and maximal orders.     An order will be treated as a maximal order, that is, as the ring of integers,     if it was computed in the following way.    maximal_order(K::AnticNumberField) -  NfMaxOrd\nring_of_integers(K::AnticNumberField) -  NfMaxOrd   Returns the maximal order of  K .    maximal_order(K::AnticNumberField, primes::Array{fmpz, 1}) -  NfMaxOrd\nmaximal_order(K::AnticNumberField, primes::Array{Integer, 1}) -  NfMaxOrd\nring_of_integers(K::AnticNumberField, primes::Array{fmpz, 1}) -  NfMaxOrd\nring_of_integers(K::AnticNumberField, primes::Array{Integer, 1}) -  NfMaxOrd   Assuming that  primes  contains all the prime numbers at which the equation order  \\mathbf{Z}[\\alpha]  of  K = \\mathbf{Q}(\\alpha)  is not maximal (e.g.  primes  may contain all prime divisors of the discriminant of  \\mathbf Z[\\alpha] ), this function returns the maximal order of  K .    make_maximal(O::NfOrd) -  NfMaxOrd   Assuming that  \\mathcal O  is an order, this function returns the same order as a maximal order.   julia   Qx ,   x   =   PolynomialRing ( QQ ,   x );  julia   K ,   a   =   NumberField ( x ^ 2   -   2 ,   a );  julia   R   =   EquationOrder ( K )  Order   of   Number   field   over   Rational   Field   with   defining   polynomial   x ^ 2   -   2  with   Z - basis   [ 1 , a ]  julia   S   =   make_maximal ( R )  Maximal   order   of   Number   field   over   Rational   Field   with   defining   polynomial   x ^ 2   -   2  with   basis   [ 1 , a ]  julia   T   =   maximal_order ( K )  Maximal   order   of   Number   field   over   Rational   Field   with   defining   polynomial   x ^ 2   -   2  with   basis   [ 1 , a ]  julia   basis_mat ( S )   ==   basis_mat ( T )  true", 
            "title": "Example"
        }, 
        {
            "location": "/numberfields/orders/#basic-properties", 
            "text": "signature(O::NfOrd) -  Tuple{Int, Int}   Returns the signature of the ambient number field of  \\mathcal O .   degree(O::NfOrd) -  Int   Returns the degree of  \\mathcal O .   norm_change_const(O::NfOrd) -  (Float64, Float64)   Returns  (c_1, c_2) \\in \\mathbf R_{>0}^2  such that for all  x = \\sum_{i=1}^d x_i \\omega_i \\in \\mathcal O  we have  T_2(x) \\leq c_1 \\cdot \\sum_i^d x_i^2  and  \\sum_i^d x_i^2 \\leq c_2 \\cdot T_2(x) , where  (\\omega_i)_i  is the  \\mathbf Z -basis of  \\mathcal O .   isequationorder(O::NfOrd) -  Bool   Returns whether  \\mathcal O  is the equation order.   nf(O::NfOrd) -  AnticNumberField   Returns the ambient number field of  \\mathcal O .   basis(O::NfOrd) -  Array{NfOrdElem, 1}   Returns the  \\mathbf Z -basis of  \\mathcal O .   basis_mat(O::NfOrd) -  FakeFmpqMat   Returns the basis matrix of  \\mathcal O  with respect to the power basis of the ambient number field.   basis_mat_inv(O::NfOrd) -  FakeFmpqMat   Returns the inverse of the basis matrix of  \\mathcal O .   discriminant(O::NfOrd) -  fmpz   Returns the discriminant of  \\mathcal O .   gen_index(O::NfOrd) -  fmpq   Generalized index of  \\mathcal O  with respect to the ambient equation order  \\mathbf Z[\\alpha] .   index(O::NfOrd) -  fmpz   Assuming that the order  \\mathcal O  contains the ambient equation order  \\mathbf Z[\\alpha] , this function returns the index  [ \\mathcal O : \\mathbf ZZ] .   is_index_divisor(O::NfOrd, d::fmpz) -  Bool\nis_index_divisor(O::NfOrd, d::Int) -  Bool   Returns whether  d  is a divisor of the index of  \\mathcal O .   minkowski_mat(O::NfOrd, abs_tol::Int = 64) -  arb_mat   Returns the Minkowski matrix of  \\mathcal O . Thus if  \\mathcal O  has degree  d , then the result is a matrix in  \\operatorname{Mat}_{d\\times d}(\\mathbf R) . The entries of the matrix are real balls of type  arb  with radius less then  2^-abs_tol .   in(a::nf_elem, O::NfOrd) -  Bool   Checks whether  a  lies in  \\mathcal O .   den(a::nf_elem, O::NfOrd) -  fmpz   Returns the smallest positive integer  k  such that  k \\cdot a  lies in O.   +(R::NfOrd, S::NfOrd) -  NfOrd   Given two orders  R ,  S  of  K , this function returns the smallest order containing both  R  and  S . It is assumed that  R ,  S  contain the ambient equation order and have coprime index.   poverorder(O::NfOrd, p::fmpz) -  NfOrd\npoverorder(O::NfOrd, p::Integer) -  NfOrd   This function tries to find an order that is locally larger than  \\mathcal O  at the prime  p : If  p  divides the index  [ \\mathcal O_K : \\mathcal O] , this function will return an order  \\tilde{\\mathcal O}  such that  v_p([ \\mathcal O_K : \\tilde{\\mathcal O}]) < v_p([ \\mathcal O_K : \\mathcal O]) . Otherwise  \\mathcal O  is returned.   pmaximal_overorder(O::NfOrd, p::fmpz) -  NfOrd\npmaximal_overorder(O::NfOrd, p::Integer) -  NfOrd   This function finds a  p -maximal order  \\tilde{\\mathcal O}  containing  \\mathcal O . That is, the index  [ \\mathcal O_K : \\tilde{\\mathcal O}]  is not dividible by  p .", 
            "title": "Basic properties"
        }, 
        {
            "location": "/numberfields/orders/#elements", 
            "text": "", 
            "title": "Elements"
        }, 
        {
            "location": "/numberfields/orders/#creation_1", 
            "text": "call(O::NfOrd, a::nf_elem, check::Bool = true) -  NfOrdElem   Given an element  a  of the ambient number field of  \\mathcal O , this function coerces the element into  \\mathcal O . It will be checked that  a  is contained in  \\mathcal O  if and only if  check  is  true .      call(O::NfOrd, a::Union{fmpz, Integer}) -  NfOrdElem   Given an element  a  of type  fmpz  or  Integer , this function coerces the element into  \\mathcal O . It will be checked that  a  is contained in  \\mathcal O  if and only if  check  is  true .      call(O::NfOrd, arr::Array{fmpz, 1})   Returns the element of  \\mathcal O  with coefficient vector  arr .      call{T  : Integer}(O::NfOrd, arr::Array{T, 1})   Returns the element of  \\mathcal O  with coefficient vector  arr .      call(O::NfOrd) -  NfOrdElem   This function constructs a new element of  \\mathcal O  which is set to  0 .", 
            "title": "Creation"
        }, 
        {
            "location": "/numberfields/orders/#basic-properties_1", 
            "text": "parent(a::NfOrdElem) -  NfOrd   Returns the order of which  a  is an element.    elem_in_nf(a::NfOrdElem) -  nf_elem   Returns the element  a  considered as an element of the ambient number field.    elem_in_basis(a::NfOrdElem) -  Array{fmpz, 1}   Returns the coefficient vector of  a .    discriminant(B::Array{NfOrdElem, 1}) -  fmpz   Returns the discriminant of the family  B .    ==(x::NfOrdElem, y::NfOrdElem) -  Bool   Returns whether  x  and  y  are equal.    zero(O::NfOrd) -  NfOrdElem   Returns the zero element of  \\mathcal O .    one(O::NfOrd) -  NfOrdElem   Returns the zero element of  \\mathcal O .    iszero(a::NfOrd) -  Bool   Tests if  a  is one.    isone(a::NfOrd) -  Bool   Tests if  a  is one.", 
            "title": "Basic properties"
        }, 
        {
            "location": "/numberfields/orders/#arithmetic", 
            "text": "-(x::NfOrdElem) -  NfOrdElem   Returns the additive inverse of  x .    +(x::NfOrdElem, y::NfOrdElem) -  NfOrdElem   Returns  x + y .    -(x::NfOrdElem, y::NfOrdElem) -  NfOrdElem   Returns  x - y .    *(x::NfOrdElem, y::NfOrdElem) -  NfOrdElem   Returns  x \\cdot y .    ^(x::NfOrdElem, y::Union{fmpz, Int})   Returns  x^y .    mod(a::NfOrdElem, m::Union{fmpz, Int}) -  NfOrdElem   Reduces the coefficient vector of  a  modulo  m  and returns the corresponding element. The coefficient vector of the result will have entries  x  with   0 \\leq x \\leq m .    powermod(a::NfOrdElem, i::fmpz, m::Integer) -  NfOrdElem   Returns the element  a^i  modulo  m .", 
            "title": "Arithmetic"
        }, 
        {
            "location": "/numberfields/orders/#miscallenous", 
            "text": "representation_mat(a::NfOrdElem) -  fmpz_mat   Returns the representation matrix of the element  a .    representation_mat(a::NfOrdElem, K::AnticNumberField) -  FakeFmpqMat   Returns the representation matrix of the element  a  considered as an element of the ambient number field  K . It is assumed that  K  is the ambient number field of the order of  a .    trace(a::NfOrdElem) -  fmpz   Returns the trace of  a .    norm(a::NfOrdElem) -  fmpz   Returns the norm of  a .    rand(O::NfOrd, n::Union{Integer, fmpz}) -  NfOrdElem   Computes a coefficient vector with entries uniformly distributed in  \\{-n,\\dotsc,-1,0,1,\\dotsc,n\\}  and returns the corresponding element of the order  \\mathcal O .    minkowski_map(a::NfOrdElem, abs_tol::Int) -  Array{arb, 1}   Returns the image of  a  under the Minkowski embedding. Every entry of the array returned is of type  arb  with radius less then  2^-abs_tol .    conjugates_arb(x::NfOrdElem, abs_tol::Int) -  Array{acb, 1}   Compute the the conjugates of  x  as elements of type  acb . Recall that we order the complex conjugates  \\sigma_{r+1}(x),...,\\sigma_{r+2s}(x)  such that  \\sigma_{i}(x) = \\overline{\\sigma_{i + s}(x)}  for  r + 1 \\leq i \\leq r + s .  Every entry  y  of the array returned satisfies  radius(real(y))   2^-abs_tol ,  radius(imag(y))   2^-abs_tol  respectively.    conjugates_arb_log(x::NfOrdElem, abs_tol::Int) -  Array{arb, 1}   Returns the elements  (\\log(\\lvert \\sigma_1(x) \\rvert),\\dotsc,\\log(\\lvert\\sigma_r(x) \\rvert), \\dotsc,2\\log(\\lvert \\sigma_{r+1}(x) \\rvert),\\dotsc, 2\\log(\\lvert \\sigma_{r+s}(x)\\rvert))  as elements of type  arb  radius less then  2^-abs_tol .    t2(x::NfOrdElem, abs_tol::Int = 32) -  arb   Return the  T_2 -norm of  x . The radius of the result will be less than  2^-abs_tol .", 
            "title": "Miscallenous"
        }, 
        {
            "location": "/numberfields/orders/#ideals", 
            "text": "", 
            "title": "Ideals"
        }, 
        {
            "location": "/numberfields/orders/#creation_2", 
            "text": "ideal(O::NfOrd, a::Int) -  NfOrdIdl   Returns the ideal of  \\mathcal O  which is generated by  a .    ideal(O::NfOrd, a::fmpz) -  NfOrdIdl   Returns the ideal of  \\mathcal O  which is generated by  a .    ideal(O::NfOrd, A::fmpz_mat) -  NfOrdIdl   Assuming that  A  is a  d \\times d  nonsingular integer matrix, this function returns the ideal  I  given by  I = \\bigoplus \\mathbf Z \\alpha_i , where  (\\alpha_1,\\dotsc,\\alpha_d) = (\\omega_1,\\dotsc,\\omega_d) A^t .    ideal(O::NfOrd, a::NfOrdElem) -  NfOrdIdl   Returns the ideal of  \\mathcal O  which is generated by  a .    ring_of_multipliers(I::NfOrdIdl) -  NfOrdGen   Computes the order  (I : I) , which is the set of all  x \\in K  with  xI \\subseteq I .   *(O::NfOrd, x::NfOrdElem) -  NfOrdIdl\n*(x::NfOrdElem, O::NfOrd) -  NfOrdIdl   Returns the principal ideal  (x)  of  \\mathcal O .", 
            "title": "Creation"
        }, 
        {
            "location": "/numberfields/orders/#arithmetic_1", 
            "text": "==(x::NfOrdIdl, y::NfOrdIdl)   Returns whether  x  and  y  are equal.    +(x::NfOrdIdl, y::NfOrdIdl)   Returns  x + y .   *(x::NfOrdIdl, y::NfOrdIdl)   Returns  x \\cdot y .   intersection(x::NfOrdIdl, y::NfOrdIdl) -  NfOrdIdl\nlcm(x::NfOrdIdl, y::NfOrdIdl) -  NfOrdIdl   Returns  x \\cap y .", 
            "title": "Arithmetic"
        }, 
        {
            "location": "/numberfields/orders/#miscaellenous", 
            "text": "parent(I::NfOrdIdl) -  NfOrd   Returns the order of  I .    basis(I::NfOrdIdl) -  Array{NfOrdElem, 1}   Returns the  \\mathbf Z -basis of  I .    basis_mat(I::NfOrdIdl) -  fmpz_mat   Returns the basis matrix of  I  with respect to the basis of the order.    minimum(I::NfOrdIdl) -  fmpz   Returns the minimum of  I , that is, the minimum of  I \\cap \\mathbf Z_{\\geq 0} , where  \\mathcal O  is the order of  I .    norm(I::NfOrdIdl) -  fmpz   Returns the norm of  I , that is, the cardinality of  \\mathcal O/I , where  \\mathcal O  is the order of  I .    in(x::NfOrdElem, y::NfOrdIdl)   Returns whether  x  is contained in  y .   idempotents(x::NfOrdIdl, y::NfOrdIdl) -  NfOrdElem, NfOrdElem   Returns a tuple  (e, f)  consisting of elements  e in x ,  f in y  such that  1 = e + f .  If the ideals are not coprime, an error is raised.    mod(x::NfOrdElem, I::NfOrdIdl)   Returns the unique element  y  of the ambient order of  x  with  x \\equiv y \\bmod I  and the following property: If  a_1,\\dotsc,a_d \\in \\Z_{\\geq 1}  are the diagonal entries of the unique HNF basis matrix of  I  and  (b_1,\\dotsc,b_d)  is the coefficient vector of  y , then  0 \\leq b_i < a_i  for  1 \\leq i \\leq d .    pradical(O::NfOrd, p::fmpz) -  NfOrdIdl   Given a prime number  p , this function returns the  p -radical  \\sqrt{p\\mathcal O}  of  \\mathcal O , which is  just  \\{ x \\in \\mathcal O \\mid \\exists k \\in \\mathbf Z_{\\geq 0} \\colon x^k \\in p\\mathcal O \\} . It is not checked that  p  is prime.", 
            "title": "Miscaellenous"
        }, 
        {
            "location": "/numberfields/orders/#fractional-ideals", 
            "text": "", 
            "title": "Fractional ideals"
        }, 
        {
            "location": "/numberfields/orders/#creation_3", 
            "text": "frac_ideal(O::NfOrd, A::fmpz_mat, b::fmpz) -  NfOrdFracIdl   Creates the fractional ideal of  \\mathcal O  with basis matrix  A/b .    frac_ideal(O::NfOrd, A::FakeFmpqMat) -  NfOrdFracIdl   Creates the fractional ideal of  \\mathcal O  with basis matrix  A .    frac_ideal(O::NfOrd, I::NfOrdIdl) -  NfOrdFracIdl   Turns the ideal  I  into a fractional ideal of  \\mathcal O .    frac_ideal(O::NfOrd, I::NfOrdIdl, b::fmpz) -  NfOrdFracIdl   Creates the fractional ideal  I/b  of  \\mathcal O .    frac_ideal(O::NfOrd, a::nf_elem) -  NfOrdFracIdl   Creates the principal fractional ideal  (a)  of  \\mathcal O .    frac_ideal(O::NfOrd, a::NfOrdElem) -  NfOrdFracIdl   Creates the principal fractional ideal  (a)  of  \\mathcal O .", 
            "title": "Creation"
        }, 
        {
            "location": "/numberfields/orders/#arithmetic_2", 
            "text": "==(x::NfOrdFracIdl, y::NfOrdFracIdl) -  Bool   Returns whether  x  and  y  are equal.", 
            "title": "Arithmetic"
        }, 
        {
            "location": "/numberfields/orders/#miscaellenous_1", 
            "text": "basis_mat(I::NfOrdFracIdl) -  FakeFmpqMat   Returns the basis matrix of  I  with respect to the basis of the order.    basis_mat_inv(I::NfOrdFracIdl) -  FakeFmpqMat   Returns the inverse of the basis matrix of  I .    basis(I::NfOrdFracIdl) -  Array{nf_elem, 1}   Returns the  \\mathbf Z -basis of  I .    norm(I::NfOrdFracIdl) -  fmpq   Returns the norm of  I", 
            "title": "Miscaellenous"
        }, 
        {
            "location": "/numberfields/maximalorders/", 
            "text": "Ideals\n\n\n\n\ninv(A::NfMaxOrdIdl) -\n NfMaxOrdFracIdl\n\n\n\n\n\n\n\nComputes the inverse of A, that is, the fractional ideal \nB\n such that \nAB = \\mathcal O_K\n.\n\n\n\n\n\n\nvaluation(a::nf_elem, p::NfMaxOrdIdl) -\n fmpz\nvaluation(a::NfOrdElem, p::NfMaxOrdIdl) -\n fmpz\nvaluation(a::fmpz, p::NfMaxOrdIdl) -\n fmpz\n\n\n\n\n\n\n\nComputes the \n\\mathfrak p\n-adic valuation of \na\n, that is, the largest \ni\n such that \na\n is contained in \n\\mathfrak p^i\n.\n\n\n\n\n\n\nvaluation(A::NfMaxOrdIdl, p::NfMaxOrdIdl) -\n fmpz\n\n\n\n\n\n\n\nComputes the \n\\mathfrak p\n-adic valuation of \nA\n, that is, the largest \ni\n such that \nA\n is contained in \n\\mathfrak p^i\n.\n\n\n\n\n\n\nisramified(O::NfMaxOrd, p::Int) -\n Bool\n\n\n\n\n\n\n\nReturns whether the integer \np\n is ramified in \n\\mathcal O\n. It is assumed that \np\n is prime.\n\n\n\n\n\n\nprime_decomposition(O::NfMaxOrd,\n                    p::Integer,\n                    degree_limit::Int = 0,\n                    lower_limit::Int = 0) -\n Array{Tuple{NfMaxOrdIdl, Int}, 1}\n\n\n\n\n\n\n\nReturns an array of tuples \n(\\mathfrak p_i,e_i)\n such that \np \\mathcal O\n is the product of the \n\\mathfrak p_i^{e_i}\n and \n\\mathfrak p_i \\neq \\mathfrak p_j\n for \ni \\neq j\n.\n\n\nIf \ndegree_limit\n is a nonzero integer \nk > 0\n, then only those prime ideals \n\\mathfrak p\n with \n\\deg(\\mathfrak p) \\leq k\n will be returned. Similarly if \n\\lower_limit\n is a nonzero integer \nl > 0\n, then only those prime ideals \n\\mathfrak p\n with \nl \\leq \\deg(\\mathfrak p)\n will be returned. Note that in this case it may happen that \np\\mathcal O\n is not the product of the \n\\mathfrak p_i^{e_i}\n.\n\n\n\n\n\n\nprime_ideals_up_to\n(\nO\n:\n:NfMaxOrd\n,\n\n                   \nB\n:\n:Int\n;\n\n                   \ndegree_limit\n:\n:Int\n \n=\n \n0\n)\n \n-\n \nArray\n{\nNfMaxOrdIdl\n,\n \n1\n}\n\n\n\n\n\n\n\n\nComputes the prime ideals \n\\mathcal O\n with norm up to \nB\n.\n\n\nIf \ndegree_limit\n is a nonzero integer \nk\n, then prime ideals \n\\mathfrak p\n with \n\\deg(\\mathfrak p) > k\n will be discarded.\n\n\n\n\n\n\nfactor(A::NfMaxOrdIdl) -\n Dict{NfMaxOrdIdl, Int}\n\n\n\n\n\n\n\nComputes the prime ideal factorization \nA\n as a dictionary, the keys being the prime ideal divisors: If \nlp = factor_dict(A)\n, then \nkeys(lp)\n are the prime ideal divisors of A and \nlp[P]\n is the \nP\n-adic valuation of \nA\n for all \nP\n in \nkeys(lp)\n.\n\n\n\n\n\n\ndivexact(A::NfMaxOrdIdl, y::fmpz) -\n NfMaxOrdIdl\n\n\n\n\n\n\n\nReturns \nA/y\n assuming that \nA/y\n is again an integral ideal.\n\n\n\n\n\n\ndivexact(A::NfMaxOrdIdl, B::NfMaxOrdIdl) -\n NfMaxOrdIdl\n\n\n\n\n\n\n\nReturns \nAB^{-1}\n assuming that \nAB^{-1}\n is again an integral ideal.\n\n\n\n\n\n\nFractional ideals\n\n\n\n\n*(I::NfMaxOrdFracIdl, J::NfMaxOrdFracIdl) -\n NfMaxOrdFracIdl\n\n\n\n\n\n\n\nReturns \nIJ\n.\n\n\n\n\n\n\ninv(A::NfMaxOrdFracIdl) -\n NfMaxOrdFracIdl\n\n\n\n\n\n\n\nReturns the fractional ideal \nB\n such that \nAB = \\mathcal O\n.\n\n\n\n\n\n\nClass and unit group\n\n\n\n\nunit_rank(O::NfOrd) -\n Int\n\n\n\n\n\n\n\nReturns the unit rank of \n\\mathcal O\n, that is, the rank of the unit group \n\\mathcal O^\\times\n.\n\n\n\n\n\n\nis_unit(x::NfOrdElem) -\n Bool\n\n\n\n\n\n\n\nReturns whether \nx\n is invertible or not.\n\n\n\n\n\n\nis_torsion_unit(x::NfOrdElem, checkisunit::Bool = false) -\n Bool\n\n\n\n\n\n\n\nReturns whether \nx\n is a torsion unit, that is, whether there exists \nn\n such that \nx^n = 1\n.\n\n\nIf \ncheckisunit\n is \ntrue\n, it is first checked whether \nx\n is a unit of the maximal order of the number field \nx\n is lying in.\n\n\n\n\n\n\ntorsion_units(O::NfOrd) -\n Array{NfOrdElem, 1}\n\n\n\n\n\n\n\nGiven an order \nO\n, compute the torsion units of \nO\n.\n\n\n\n\n\n\ntorsion_units(O::NfOrd) -\n NfOrdElem\n\n\n\n\n\n\n\nGiven an order \nO\n, compute a generator of the torsion units of \nO\n.\n\n\n\n\n\n\nunit_group(O::NfMaxOrd) -\n Map\n\n\n\n\n\n\n\nReturns an isomorphism map \nf \\colon A \\to \\mathcal O^\\times\n. Let \nA = domain(f)\n. Then a set of fundamental units of \n\\mathcal O\n can be obtained via \n[ f(A[i]) for i in 1:unit_rank(O) ]\n.\n\n\n\n\n\n\nResidue rings\n\n\n\n\nResidue fields", 
            "title": "Maximal Orders"
        }, 
        {
            "location": "/numberfields/maximalorders/#ideals", 
            "text": "inv(A::NfMaxOrdIdl) -  NfMaxOrdFracIdl   Computes the inverse of A, that is, the fractional ideal  B  such that  AB = \\mathcal O_K .    valuation(a::nf_elem, p::NfMaxOrdIdl) -  fmpz\nvaluation(a::NfOrdElem, p::NfMaxOrdIdl) -  fmpz\nvaluation(a::fmpz, p::NfMaxOrdIdl) -  fmpz   Computes the  \\mathfrak p -adic valuation of  a , that is, the largest  i  such that  a  is contained in  \\mathfrak p^i .    valuation(A::NfMaxOrdIdl, p::NfMaxOrdIdl) -  fmpz   Computes the  \\mathfrak p -adic valuation of  A , that is, the largest  i  such that  A  is contained in  \\mathfrak p^i .    isramified(O::NfMaxOrd, p::Int) -  Bool   Returns whether the integer  p  is ramified in  \\mathcal O . It is assumed that  p  is prime.    prime_decomposition(O::NfMaxOrd,\n                    p::Integer,\n                    degree_limit::Int = 0,\n                    lower_limit::Int = 0) -  Array{Tuple{NfMaxOrdIdl, Int}, 1}   Returns an array of tuples  (\\mathfrak p_i,e_i)  such that  p \\mathcal O  is the product of the  \\mathfrak p_i^{e_i}  and  \\mathfrak p_i \\neq \\mathfrak p_j  for  i \\neq j .  If  degree_limit  is a nonzero integer  k > 0 , then only those prime ideals  \\mathfrak p  with  \\deg(\\mathfrak p) \\leq k  will be returned. Similarly if  \\lower_limit  is a nonzero integer  l > 0 , then only those prime ideals  \\mathfrak p  with  l \\leq \\deg(\\mathfrak p)  will be returned. Note that in this case it may happen that  p\\mathcal O  is not the product of the  \\mathfrak p_i^{e_i} .    prime_ideals_up_to ( O : :NfMaxOrd , \n                    B : :Int ; \n                    degree_limit : :Int   =   0 )   -   Array { NfMaxOrdIdl ,   1 }    Computes the prime ideals  \\mathcal O  with norm up to  B .  If  degree_limit  is a nonzero integer  k , then prime ideals  \\mathfrak p  with  \\deg(\\mathfrak p) > k  will be discarded.    factor(A::NfMaxOrdIdl) -  Dict{NfMaxOrdIdl, Int}   Computes the prime ideal factorization  A  as a dictionary, the keys being the prime ideal divisors: If  lp = factor_dict(A) , then  keys(lp)  are the prime ideal divisors of A and  lp[P]  is the  P -adic valuation of  A  for all  P  in  keys(lp) .    divexact(A::NfMaxOrdIdl, y::fmpz) -  NfMaxOrdIdl   Returns  A/y  assuming that  A/y  is again an integral ideal.    divexact(A::NfMaxOrdIdl, B::NfMaxOrdIdl) -  NfMaxOrdIdl   Returns  AB^{-1}  assuming that  AB^{-1}  is again an integral ideal.", 
            "title": "Ideals"
        }, 
        {
            "location": "/numberfields/maximalorders/#fractional-ideals", 
            "text": "*(I::NfMaxOrdFracIdl, J::NfMaxOrdFracIdl) -  NfMaxOrdFracIdl   Returns  IJ .    inv(A::NfMaxOrdFracIdl) -  NfMaxOrdFracIdl   Returns the fractional ideal  B  such that  AB = \\mathcal O .", 
            "title": "Fractional ideals"
        }, 
        {
            "location": "/numberfields/maximalorders/#class-and-unit-group", 
            "text": "unit_rank(O::NfOrd) -  Int   Returns the unit rank of  \\mathcal O , that is, the rank of the unit group  \\mathcal O^\\times .    is_unit(x::NfOrdElem) -  Bool   Returns whether  x  is invertible or not.    is_torsion_unit(x::NfOrdElem, checkisunit::Bool = false) -  Bool   Returns whether  x  is a torsion unit, that is, whether there exists  n  such that  x^n = 1 .  If  checkisunit  is  true , it is first checked whether  x  is a unit of the maximal order of the number field  x  is lying in.    torsion_units(O::NfOrd) -  Array{NfOrdElem, 1}   Given an order  O , compute the torsion units of  O .    torsion_units(O::NfOrd) -  NfOrdElem   Given an order  O , compute a generator of the torsion units of  O .    unit_group(O::NfMaxOrd) -  Map   Returns an isomorphism map  f \\colon A \\to \\mathcal O^\\times . Let  A = domain(f) . Then a set of fundamental units of  \\mathcal O  can be obtained via  [ f(A[i]) for i in 1:unit_rank(O) ] .", 
            "title": "Class and unit group"
        }, 
        {
            "location": "/numberfields/maximalorders/#residue-rings", 
            "text": "", 
            "title": "Residue rings"
        }, 
        {
            "location": "/numberfields/maximalorders/#residue-fields", 
            "text": "", 
            "title": "Residue fields"
        }
    ]
}